<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之三：Nsight Eclipse Edition基础</title>
    <url>/folder/2019/11/08/2017-10-01-tx-3/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p>&#160;&#160;&#160;&#160;Nsight Eclipse Edition是专为NVIDIA定制的Eclipse开发环境，主要区别是在菜单中加入了CUDA工程的建立、CUDAToolKit和NVIDIA的NVCC编译器等开发工具，方便开发者开发基于CUDA强大计算能力的各种工程项目。<br>&#160;&#160;&#160;&#160;根据上个教程安装完JetPcak3.0的各个功能模块之后，就可以在桌面的搜索框找出Nsight Eclipse Edition这个软件：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603170714026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&#160;&#160;&#160;&#160;本次教程以CUDA自带例程oceanFFT为例，介绍Nsight Eclips Edition的简单使用。</p>
<p>1.双击Nsight软件，弹出对话框，选择工作空间，即工作文件存放路径。确定后点击OK：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222057914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>2.File-&gt;New-&gt;CUDA C/C++ Project，新建CUDA工程：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222149954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>3.Project name：命名工程名称，Project type：提取CUDA例程，选定后点击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222210845?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>4.选取CUDA例程，这里我们选择oceanFFT，选定后点击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222405743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>5.基础设置默认即可，当然，对于TX1的PTX和GPU，标准的选择还是5.3，而不是2.0，选定后点击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222424384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500" /></div>
<p></p>

<p>6.选择链接，点击Management，创建新的链接，链接内容如第7步所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222443915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>7.输入IP和用户名，通过SSH登陆，填完后点击Finish：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222504197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500" /></div>
<p></p>

<p>8.选择Project Path、Toolkit和CPU类型，选定后点击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222524428?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>9.编译版本默认即可，选定后点击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222544772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>10.工程文件：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222611007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500" /></div>
<p></p>

<p>11.Ctrl+B,构建：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603222627492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>12.在TX1上找到相应目录，运行相应二进制文件，运行效果如下：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170603224024916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍Nsight进阶开发。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>Nsight</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之二：刷机与开发前准备</title>
    <url>/folder/2019/11/08/2017-10-01-tx-2/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">1.  JetPack3.0下载与安装</font></strong></p>
<p>本人PC端使用虚拟机安装Ubuntu14.04系统进行开发，需要有效联网。</p>
<p>1.首先在自己的home目录下创建Jetson文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir ~/Jetson</span><br><span class="line">$ cd ~/Jetson</span><br></pre></td></tr></table></figure>

<p>2.下载可执行文件到新建的Jetson文件夹下：<br><a href="https://developer.nvidia.com/embedded/downloads" target="_blank" rel="noopener">https://developer.nvidia.com/embedded/downloads</a></p>
<p>3.在虚拟机上运行安装脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x  ./JetPack-L4T-&lt;version&gt;-linux-x64.run</span><br><span class="line">$ ./JetPack-L4T-&lt;version&gt;-linux-x64.run</span><br></pre></td></tr></table></figure>

<p>之后出现如下图所示，单击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514162457089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>之后会显示安装路径，单击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514163056458?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>4.接下来是开发板选型，这里我选TX1，单击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514163208366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>5.输入root用户密码：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514163407807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>6.联网获取安装包信息，此处必须联网，否则出不来安装信息，选完安装信息之后单击Next（ps：一般默认即可，只安装Jetpack不刷机的话就把下面的Target-Jetson TX1的Action一栏全部改为no action；由于我的已经安装完毕，所以Action一栏都是no action）：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514164423772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>7.接受所选组件的许可协议，全部同意并单击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514164513150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>8.报错的话就按提示安装依赖库后再进行Jetpack安装：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514165036562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>9.安装完成后如下图所示，单机Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514165440464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>10.点击Finish即可完成安装，最好不要勾选移除安装包：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514165617027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p><strong><font color="black" size=5 face="仿宋">2.  刷机</font></strong><br>&#160;&#160;&#160;&#160;刷机过程需要重复上述1-5步，并且在第6步中Target-Jetson TX1的Action一栏改为需要的各个软件安装版本。所以刷机从第6步开始介绍.<br>6.联网获取安装包信息，此处必须联网，否则出不来安装信息，选完安装信息之后单击Next（一般默认即可）：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514170240735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>7.接受所选组件的许可协议，全部同意并单击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514164513150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>
8.该组件管理器将继续安装。一旦主机的安装步骤完成后，单击下一步按钮继续安装目标组件。
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514165440464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>9.a.如果在6中取消选择Flash OS的组件管理器（即不烧写系统，只烧写某些组件），将需要输入IP地址，用户名和密码来建立ssh连接到目标设备：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514171202482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>9.b.如果在6中选择Flash OS的组件管理器，需要选择适合的特定环境中的网络布局：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514171121200?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>
10.a.如果选择了通过路由器/交换机设备访问互联网的布局，你会被要求选择哪个接口用于上网。
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514171519491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>10.b.如果您选择的设备通过主机IP获得通过指定DHCP服务器主机和访问互联网上的布局，您必须选择哪个接口是用于上网，并且将被用于目标接口。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514171554051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>11.烧写确认，单击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514173025649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>12.之后会弹出POST窗口来引导你开启USB强制恢复模式：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170521110312924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&#160;&#160;&#160;&#160;TX1与主机使用usb连接，开启USB强制恢复模式（关机情况下，按一下POWER键，再长按REC键的同时点按RESET键，两秒后松开REC键）此时虚拟机会弹出NVIDIA设备：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514172001604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>可以lsusb确认一下：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514172036136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="200" /></div>
<p></p>

<p>13.在POST窗口中回车，开始安装：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514172117995?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>14.系统安装完成后板子会重启。如果TX1重启后出现了Ubuntu的GUI界面，说明系统已经安装完成。重启完之后POST窗口会提示你输入IP地址，这里如果输入正确，等待十分钟左右就会进入下一个界面；如果失败，最好查看一下TX1现在的IP。接下来就需要安装CUDA、OpenCV等组件。在按Enter继续安装之前，需要确保TX1已经连网外网，如果校园网需要登录网关这样的，先将网关登录好再继续，因为安装组件的时候，需要安装一些依赖库，需要有外网的情况下才能进行。按Enter继续后，会出现提示信息，确定TX1的IP地址，手动输入TX1的IP地址后，按回车继续，稍等一会儿，会出现如下对话框（和9a里的一样，如果执行的9a而不是9b，这里就不会再出现确认信息）：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514171202482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>15.一路NEXT，再次进入POST界面，此时使用SSH远程服务，无需下载线。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514172710005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>16.安装完之后，程序自动关闭POST，回到如下界面，点击FINISH完成安装。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514172808920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p><strong><font color="black" size=5 face="仿宋">3.  测试</font></strong><br>Jetpack自动编译所有例程，CUDA例程可以在以下目录中找到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;JetPack_Install_Dir&gt; / NVIDIA_CUDA- &lt;版本&gt; _samples</span><br></pre></td></tr></table></figure>
<p>可以通过重新编译运行示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SMS=53 EXTRA_LDFLAGS=--unresolved-symbols=ignore-in-shared-libs TARGET_ARCH=aarch64 make</span><br></pre></td></tr></table></figure>
<p>运行：<br>CUDA的例程编译后的二进制文件目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/home/ubuntu/NVIDIA_CUDA-&lt;version&gt;_Samples/bin/aarch64/linux/release/</span><br></pre></td></tr></table></figure>
<p>命令行运行或双击运行：<br>例如，当您运行oceanFFT样品，将显示如下画面。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170514174244191?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>


<p><strong><font color="black" size=5 face="仿宋">4.  开发前准备工作</font></strong></p>
<p><strong>更新源：</strong></p>
<p>&#160;&#160;&#160;&#160;因为默认源会找不到我们下述要用的一些依赖库和安装包，所以需要加入国内源，本例中采用的是中科大的源。值得注意的是，如果你之后回头来刷固件，一定还要把源换回来，否则有可能会安装失败。所以我们先做一下备份：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>在sources.list中将被#注释掉的源全部打开，随后在底部添加新的源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports trusty main universe restricted multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports trusty-security main universe restricted multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports trusty-updates main universe restricted multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty main universe restricted multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty-security main universe restricted multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty-updates main universe restricted multiverse</span><br></pre></td></tr></table></figure>

<p>保存文件后，进行更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>

<p><strong>浏览器安装：</strong></p>
<p>&#160;&#160;&#160;&#160;<font color="red">直接能上外网的请忽略此步骤。</font></p>
<p>&#160;&#160;&#160;&#160;由于身在校内，且实验室网络连接都是交换机模式，每一台设备连接外网时都需要登陆，所以就涉及到浏览器的安装。当然，大家也可以直接用PYTHON写个登陆脚本也是可以的。</p>
<p>&#160;&#160;&#160;&#160;NVIDIA Jetson TX1自带系统没有浏览器是个很尴尬的事情。我们尝试了两款浏览器，分别是Epiphany和Firefox。前者相对稳定，但是用一段时间之后就再也不能跳转至校园网登陆界面；后者经常闪退，但是至少还给我输入账号密码的机会。最后我们选择的是Firefox。</p>
<p>&#160;&#160;&#160;&#160;安装浏览器也需要联网，so，还得先用WiFi连接一下个人热点。</p>
<p>安装Epiphany：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install epiphany-browser</span><br></pre></td></tr></table></figure>

<p>安装Firefox：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install firefox-browser</span><br></pre></td></tr></table></figure>

<p><strong>输入法安装：</strong></p>
<p>&#160;&#160;&#160;&#160;命令行操作一般不需要使用输入法，但是如果我们想在GUI上进行一些操作，比如上网查资料等，输入法还是得有的。</p>
<p>安装google输入法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ibus-googlepinyin</span><br><span class="line">sudo reboot now</span><br></pre></td></tr></table></figure>

<p>&#160;&#160;&#160;&#160;安装完后重启系统，随后在GUI界面右上角找到文本输入设置(Text Entry Settings)，在里面将自己新下载的google输入法添加进去即可，操作和WINDOWS下添加输入法一样，故不在此赘述。</p>
<p><strong>lrzsz安装：</strong></p>
<p>&#160;&#160;&#160;&#160;NVIDIA Jetson TX1的SSH服务（端口号：22）已经配好，所以我们可以直接使用Xshell或者其他支持SSH远程登陆的客户端软件通过SSH服务来连接TX1，从而方便多人在WINDOWS上远程操控TX1。当然，Xshell是不支持图形界面的，如果想远程登录图形界面，可以配置一下vncserver，但是会消耗资源，个人不建议使用。</p>
<p>&#160;&#160;&#160;&#160;远程登录难免涉及到文件传输，文件传输有两种方法，大文件最好用FTP来传输，推荐使用File Zilla；小文件Xshell自己就可以搞定，需要在TX1上安装lrzsz。</p>
<p>安装lrzsz：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install lrzsz</span><br></pre></td></tr></table></figure>

<p>sz发送TX1文件到本地：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sz filename</span><br></pre></td></tr></table></figure>

<p>rz发送本地文件到服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure>

<p>&#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍如何使用Nsight进行程序开发。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>刷机</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之一：开箱测试</title>
    <url>/folder/2019/11/08/2017-10-01-tx-1/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">1. 概述</font></strong></p>
<p>&#160;&#160;&#160;&#160;NVIDIA的Jetson TX1是嵌入式系统级模块（SoM），具有四核ARM Cortex-A57，4GB LPDDR4和集成的256核Maxwell GPU。 </p>
<p>&#160;&#160;&#160;&#160;对于部署计算机视觉和深度学习而言非常有用，Jetson TX1运行Linux(定制Ubuntu)，并提供1TFLOPS的FP16计算性能，功耗为10瓦。</p>
<p>&#160;&#160;&#160;&#160;Jetson TX1可作为模块，开发套件和兼容的生态系统产品。更多详细信息可以登录<a href="http://www.nvidia.cn/object/embedded-systems-dev-kits-modules-cn.html" target="_blank" rel="noopener">NVIDIA官网（此处有链接）</a>进行了解，也可通过<a href="http://elinux.org/Jetson_TX1" target="_blank" rel="noopener">Wikipedia（此处有链接）</a>进行TX1模组参数的快速预览。</p>
<p></p>
<div align=center>
<img src="http://img.blog.csdn.net/20170507174659130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" />
</div>
<p></p>

<hr>
<p><strong><font color="black" size=5 face="仿宋">2. 基本参数</font></strong></p>
<p><strong>处理组件：</strong></p>
<ul>
<li>四核ARM Cortex-A57</li>
<li>256核Maxwell GPU</li>
<li>4GB LPDDR4</li>
<li>16GB eMMC</li>
<li>H.264 / H.265编码器和解码器</li>
<li>双ISP（图像服务处理器）</li>
</ul>
<p><strong>端口和外设：</strong></p>
<ul>
<li>HDMI 2.0</li>
<li>802.11ac WiFi，蓝牙4.0</li>
<li>USB3，USB2</li>
<li>千兆以太网</li>
<li>12路MIPI CSI 2.0</li>
<li>4车道PCIe gen 2.0</li>
<li>SATA，2x SD卡</li>
<li>3x UART，3x SPI，4x I2C</li>
</ul>
<p><strong>构成因素：</strong></p>
<ul>
<li>400针Samtec板对板连接器</li>
<li>尺寸：50x87mm  （1.96“x 3.42”）</li>
<li>质量：45克</li>
<li>热转印板（TTP），-25C至85C工作温度</li>
<li>5.5-19.6VDC输入功率（消耗10-15W，典型负载下）</li>
</ul>
<p><strong>软件支持：</strong></p>
<ul>
<li>JetPack 2.3</li>
<li>Linux4Tegra R24.2 (L4T) for ARM (Ubuntu 16.04 aarch64)</li>
<li>CUDA Toolkit 8</li>
<li>cuDNN v5.1</li>
<li>TensorRT 1.0</li>
<li>VisionWorks 1.5</li>
<li>OpenCV4Tegra 2.4.13</li>
<li>OpenGL 4.4</li>
<li>OpenGL ES 3.1</li>
<li>Vulkan</li>
<li>V4L2 media controller support</li>
<li>gstreamer / OpenMAX</li>
<li>Tegra System Profiler (TSP)</li>
<li>Tegra Graphics Debugger</li>
<li>PerfKit 4.5.1</li>
</ul>
<p><strong><font color="black" size=5 face="仿宋">3. 开箱测试</font></strong></p>
<p>&#160;&#160;&#160;&#160;小五千大洋买回来的宝贝，拿到手还有点小激动（图片来自我的partner：Jack Cui）：</p>
<p></p>
<div align=center>
<img src="http://img.blog.csdn.net/20170507192357194?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" />
</div>
<p></p>

<p>&#160;&#160;&#160;&#160;包装很高大上，下面来介绍一下开发套件的内容：TX1开发套件（含TX1模组）、一个19V电源适配器（尴尬的是没有插座线）、两个天线（用于TX1模组的WiFi和蓝牙）、Micro USB线和USB-OTG线。</p>
<p></p>
<div align=center>
<img src="http://img.blog.csdn.net/20170507192426987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" />
</div>
<p></p>

<p>&#160;&#160;&#160;&#160;光有上面这些开发套件包含的东西是不能正常使用的，你还需要下面这些设备：</p>
<ul>
<li>电源适配器插头：</li>
</ul>
<p></p>
<div align=center>
<img src="http://img.blog.csdn.net/20170507192456925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" />
</div>
<p></p>

<ul>
<li>2K显示屏：（开发套件原装系统默认分辨率为2K）。</li>
</ul>
<p>&#160;&#160;&#160;&#160;这里有点尴尬，除非你能保证你可以在没有显示器的情况下就能输入命令行修改分辨率（想办法调出命令行然后输入：xrandr -s 1208x720），否则还是找一块2K显示屏来吧。</p>
<p></p>
<div align=center>
<img src="http://img.blog.csdn.net/20170507175904716?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="400" height="400" />
</div>
<p></p>

<ul>
<li>鼠键套装：</li>
</ul>
<p></p>
<div align=center>
<img src="http://img.blog.csdn.net/20170507180214767?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" />
</div>
<p></p>

<p><strong><font color="black" size=5 face="仿宋">4.调出桌面：</font></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/NVIDIA-INSTALL</span><br><span class="line">sudo ./install.sh</span><br><span class="line">sudo reboot now</span><br></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;重启电脑之后，我们就可以看到ubuntu系统的桌面了。Jetson TX1出厂时默认的系统以及各依赖工具版本比较老旧，所以我们需要进行刷机来部署最新版本的JetPack。</p>
<p>&#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍如何进行刷机。<br>&#160;&#160;&#160;&#160;下周日更新。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 3 搭建Python开发环境 码代码 美如画</title>
    <url>/folder/2019/11/08/2017-10-01-py-7/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：Sublime Text 3 Build 3143</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的 Vim ，浮肿沉重的 Eclipse ， VS ，即便体积轻巧迅速启动的 Editplus 、 Notepad++ ，在 Sublime Text 面前也略显失色，无疑这款性感无比的编辑器是 Coding 和 Writing 最佳的选择，没有之一。</p>
<p>&emsp;&emsp;Sublime Text 3 的功能实在是太强大了，搭配各种 package ，码代码、美如画。对于 Sublime Text 3 的介绍网上一大堆，博主就不再这里赘述了。本篇博文主要是记录一下博主如何在 Sublime Text 3 下优雅的编写、编译、运行 python 代码。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;WordZzzz使用的版本是 Sublime Text Build 3143 ，大家自行下载后直接安装即可，安装完之后需要 License 来激活我们的软件。</p>
<p>&emsp;&emsp;直接将下面的 License 复制过去就好，亲测可用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">—– BEGIN LICENSE —– </span><br><span class="line">TwitterInc </span><br><span class="line">200 User License </span><br><span class="line">EA7E-890007 </span><br><span class="line">1D77F72E 390CDD93 4DCBA022 FAF60790 </span><br><span class="line">61AA12C0 A37081C5 D0316412 4584D136 </span><br><span class="line">94D7F7D4 95BC8C1C 527DA828 560BB037 </span><br><span class="line">D1EDDD8C AE7B379F 50C9D69D B35179EF </span><br><span class="line">2FE898C4 8E4277A8 555CE714 E1FB0E43 </span><br><span class="line">D5D52613 C3D12E98 BC49967F 7652EED2 </span><br><span class="line">9D2D2E61 67610860 6D338B72 5CF95C69 </span><br><span class="line">E36B85CC 84991F19 7575D828 470A92AB </span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h3><p>&emsp;&emsp;按 Ctrl+` 调出 console ，粘贴以下代码到底部命令行并回车：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;重启 Sublime Text 3。如果在 Perferences-&gt;package settings 中看到 package control 这一项，则安装成功。按下 Ctrl+Shift+P 调出命令面板输入 install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</p>
<p>&emsp;&emsp;下面介绍几个比较实用的 package 。</p>
<h3 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h3><p>&emsp;&emsp;SideBarEnhancements 扩展了侧边栏中菜单选项的数量，从而提升你的工作效率。诸如 “New file” 和 “Duplicate” 这样的选项对于 ST3 来说实在是太重要了，而且仅凭 “Delete” 这一个功能就让这个插件值得下载。这个功能将你会在你删除文件的时候把它放入回收站。虽然这个功能乍一看没什么用，但是当你没有使用这样的功能而彻底删除了一个文件的时候，除非你用了版本管理软件，否则你将很难恢复这个文件。</p>
<h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>&emsp;&emsp;Anaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，例如：</p>
<ul>
<li>Autocompletion 自动完成，该选项默认开启，同时提供多种配置选项。</li>
<li>Code linting 使用支持 pep8 标准的 PyLint 或者 PyFlakes。</li>
<li>McCabe code complexity checker 让你可以在特定的文件中使用 McCabe complexity checker. </li>
<li>Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。</li>
<li>Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。</li>
<li>Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下)</li>
</ul>
<p>&emsp;&emsp;但是，刚安装完之后，打开一个 python 文档，所有代码都会被白色细线框中，如图所示；</p>
<p>&emsp;&emsp;强迫症的我看着好难受，决心要搞一搞这东西。后来发现在 Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – Default 下修改 linting behaviour 选项即可，我这里改成了只有在保存的时候linting工作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    Sets the linting behaviour for anaconda:</span><br><span class="line"></span><br><span class="line">    &quot;always&quot; - Linting works always even while you are writing (in the background)</span><br><span class="line">    &quot;load-save&quot; - Linting works in file load and save only</span><br><span class="line">    &quot;save-only&quot; - Linting works in file save only</span><br><span class="line">*/</span><br><span class="line">&quot;anaconda_linting_behaviour&quot;: &quot;save-only&quot;,</span><br></pre></td></tr></table></figure>

<h3 id="SublimeREPL"><a href="#SublimeREPL" class="headerlink" title="SublimeREPL"></a>SublimeREPL</h3><p>&emsp;&emsp;这可能是对程序员来说最有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ，Python，Ruby， Scala 和 Haskell 等等）。</p>
<p>&emsp;&emsp;在 Sublime &gt; Tools &gt; SublimeREPL 下我们可以看到 SublimeREPL 支持运行的所有语言。</p>
<p>&emsp;&emsp;下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Default.sublime-commands 文件，从中我们可以看到 SublimeREPL 所支持的 python 的各种运行方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - PDB current file&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python_pdb&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python_run&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;command&quot;: &quot;python_virtualenv_repl&quot;,</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - virtualenv&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - IPython&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python_ipython&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来配置快捷键，打开 Sublime &gt; Preferences &gt; Key Building ，在右侧栏（ User 部分）添加下面的代码。下面的代码用 F5 来执行当前 Python 脚本，用 F4 来实现切换至 Python 命令行窗口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;&quot;keys&quot;:[&quot;f5&quot;],</span><br><span class="line">	&quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,</span><br><span class="line">	&quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">	&#123;&quot;id&quot;: &quot;repl_python_run&quot;,</span><br><span class="line">	&quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;</span><br><span class="line">	,</span><br><span class="line">	&#123;&quot;keys&quot;:[&quot;f4&quot;],</span><br><span class="line">	&quot;caption&quot;: &quot;SublimeREPL: Python&quot;,</span><br><span class="line">	&quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">	&#123;&quot;id&quot;: &quot;repl_python&quot;,</span><br><span class="line">	&quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，如果你电脑里面安装了两个版本的 Python ，而你想指定使用某个版本，则需要修改下面的代码。下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Main.sublime-menu 文件，主要修改 “cmd” 后面跟着的 python 命令。比如我电脑里 python2.7 的执行程序命名是 python.exe ，而 python3.6 的执行程序命名为 python3.exe ，我想要使用 python3 ，所以把所有 “cmd” 后面跟着的命令都改为 “python3” 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">     &#123;</span><br><span class="line">        &quot;id&quot;: &quot;tools&quot;,</span><br><span class="line">        &quot;children&quot;:</span><br><span class="line">        [&#123;</span><br><span class="line">            &quot;caption&quot;: &quot;SublimeREPL&quot;,</span><br><span class="line">            &quot;mnemonic&quot;: &quot;R&quot;,</span><br><span class="line">            &quot;id&quot;: &quot;SublimeREPL&quot;,</span><br><span class="line">            &quot;children&quot;:</span><br><span class="line">            [</span><br><span class="line">                &#123;&quot;caption&quot;: &quot;Python&quot;,</span><br><span class="line">                &quot;id&quot;: &quot;Python&quot;,</span><br><span class="line"></span><br><span class="line">                 &quot;children&quot;:[</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;P&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;],</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;python_virtualenv_repl&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;python_virtualenv_repl&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - virtualenv&quot;&#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - PDB current file&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python_pdb&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;D&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;, &quot;-m&quot;, &quot;pdb&quot;, &quot;$file_basename&quot;],</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - RUN current file&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python_run&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;R&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;cmd&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$file_basename&quot;],</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - IPython&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python_ipython&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;I&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;autocomplete_server&quot;: true,</span><br><span class="line">                        &quot;cmd&quot;: &#123;</span><br><span class="line">                            &quot;osx&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;],</span><br><span class="line">                            &quot;linux&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;],</span><br><span class="line">                            &quot;windows&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;</span><br><span class="line">                            &quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;,</span><br><span class="line">                            &quot;SUBLIMEREPL_EDITOR&quot;: &quot;$editor&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;别忘了， Sublime Text 3 也有自己的 build 功能，即也支持 python 等语言的代码构建（ ctrl + b ）。同样的，我们如何添加不同的 python 版本到我们的构建系统呢？很简单，Sublime &gt; Tools &gt; Build System &gt; New Build System，分别添加如下代码之后，再分别保存为 python2.sublime-build 和 python3.sublime-build ，这样，当我们再次打开 Sublime &gt; Tools &gt; Build System 之后，就会发现我们新添加的 python2 和 python3 构建系统了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;cmd&quot;: [&quot;D:/Program Files/Python/Python27/python.exe&quot;, &quot;-u&quot;, &quot;$file&quot;],</span><br><span class="line">	&quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line([0-9]*)&quot;,</span><br><span class="line">	&quot;selector&quot;: &quot;source.python&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;cmd&quot;: [&quot;D:/Program Files/Python/Python36/python3.exe&quot;, &quot;-u&quot;, &quot;$file&quot;],</span><br><span class="line">	&quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line([0-9]*)&quot;,</span><br><span class="line">	&quot;selector&quot;: &quot;source.python&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SublimeTmpl"><a href="#SublimeTmpl" class="headerlink" title="SublimeTmpl"></a>SublimeTmpl</h3><p>&emsp;&emsp;快速生成文件模板</p>
<p>&emsp;&emsp;，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。</p>
<p>&emsp;&emsp;SublimeTmpl默认的快捷键:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctrl+alt+h html</span><br><span class="line">ctrl+alt+j javascript</span><br><span class="line">ctrl+alt+c css</span><br><span class="line">ctrl+alt+p php</span><br><span class="line">ctrl+alt+r ruby</span><br><span class="line">ctrl+alt+shift+p python</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里我想修改一下python模板，所以就需要进行如下操作：Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl &gt; Settings – User 添加如下代码。然后 ctrl+alt+shift+p 来新建一个模板试试看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    &quot;disable_keymap_actions&quot;: false, // &quot;all&quot;; &quot;html,css&quot;  </span><br><span class="line">    &quot;date_format&quot; : &quot;%Y-%m-%d %H:%M:%S&quot;,  </span><br><span class="line">    &quot;attr&quot;: &#123;  </span><br><span class="line">        &quot;author&quot;: &quot;WordZzzz&quot;,  </span><br><span class="line">        &quot;email&quot;: &quot;wordzzzz@foxmail.com&quot;,  </span><br><span class="line">        &quot;link&quot;: &quot;http://blog.csdn.net/u011475210&quot;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;快捷键也是可以更改的，全部在 Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl 的设置中。</p>
<p>&emsp;&emsp;如果想要新建其他类型的文件模板的话，先自定义文件模板方在templates文件夹里，再分别打开Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings这四个文件照着里面的格式自定义想要新建的类型，这里就不详细介绍了，请各位自己折腾哈~</p>
<h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul>
<li>跳转到任意内容 (“cmd+p”) 用来快速查找和打开文件。你仅仅只需要工程中文件的一部分路径或者文件名你就可以很容易的打开这个文件。这在一个大型的 Django 工程中显得非常方便。</li>
<li>跳转到指定行 (“ctrl+g”) 让你在当前文件中跳转到指定行数。</li>
<li>跳转到标志 (“cmd+r”) 可以列出当前文件中所有的函数或者类，让你更方便查找。你可以通过输入关键字来查找你所需要的函数或者类。</li>
<li>跳转到行首 (cmd+left-arrow-key) 与 跳转到行尾 (cmd+right-arrow-key)</li>
<li>删除当前行(ctrl+shift+k)</li>
<li>多重编辑 是我迄今为止最喜欢的快捷键<br>选定一个单词，点击 “cmd+d”来选择同样的单词，再次点击 “cmd+d”*继续选择下一个单词…<br>或者 “cmd+单击”来指定多个你想要同时修改的地方。</li>
<li>块编辑 (option+left-mouse-click) 用于选择一整块的内容。通常在整理 CSV 文件的时候用于删除空白内容。</li>
</ul>
<h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h2><p>&emsp;&emsp;你可以很容易地使用 Python 来编辑你自己的自定义命令和快捷键组合。例如：</p>
<ul>
<li>拷贝当前文件路径到剪贴板 – 链接</li>
<li>关闭除当前活动标签页以外的所有其他标签页 – 链接</li>
</ul>
<p>&emsp;&emsp;通过文件选项打开你的 Package 文件夹(Sublime &gt; Preferences &gt; Browse Packages)，然后打开 User 文件夹，接下来将上述的 Python 文件添加到 “/Sublime Text 3/Packages/User” 文件夹中。</p>
<p>&emsp;&emsp;最后请在 Key Bindings – User file (Sublime Text &gt; Preferences &gt; Package Settings &gt; AdvancedNewFile &gt; Key Bindings – User) 文件中完成快捷键绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  // Copy file name</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;keys&quot;: [&quot;cmd+shift+c&quot;],</span><br><span class="line">     &quot;command&quot;: &quot;copy_path_to_clipboard&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Close all other tabs</span><br><span class="line">  &#123;  </span><br><span class="line">    &quot;keys&quot;: [&quot;cmd+alt+w&quot;],</span><br><span class="line">    &quot;command&quot;: &quot;close_tabs&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3：字典中的items()函数</title>
    <url>/folder/2019/11/08/2017-10-01-py-6/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">一、Python2.x中items()：</font></strong></p>
<p>&emsp;&emsp;和之前一样，本渣渣先贴出来python中help的帮助信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.items)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">items(...)</span><br><span class="line">    D.items() -&gt; list of D's (key, value) pairs, as 2-tuples</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.iteritems)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">iteritems(...)</span><br><span class="line">    D.iteritems() -&gt; an iterator over the (key, value) items of D</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.viewitems)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">viewitems(...)</span><br><span class="line">    D.viewitems() -&gt; a set-like object providing a view on D's items</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在Python2.x中，items( )用于 返回一个字典的拷贝列表【Returns a copy of the list of all items (key/value pairs) in D】，占额外的内存。</p>
<p>&emsp;&emsp;iteritems() 用于返回本身字典列表操作后的迭代【Returns an iterator on all items(key/value pairs) in D】，不占用额外的内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="number">1</span>:<span class="string">'one'</span>,<span class="number">2</span>:<span class="string">'two'</span>,<span class="number">3</span>:<span class="string">'three'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.items())</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.iteritems())</span><br><span class="line">&lt;type <span class="string">'dictionary-itemiterator'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.viewitems())</span><br><span class="line">&lt;type <span class="string">'dict_items'</span>&gt;</span><br></pre></td></tr></table></figure>

<p><strong><font color="black" size=5 face="仿宋">二、Python3.x中items()：</font></strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.items)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">items(...)</span><br><span class="line">    D.items() -&gt; a set-like object providing a view on D's items</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Python 3.x 里面，iteritems() 和 viewitems() 这两个方法都已经废除了，而 items() 得到的结果是和 2.x 里面 viewitems() 一致的。在3.x 里 用 items()替换iteritems() ，可以用于 for 来循环遍历。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="number">1</span>:<span class="string">'one'</span>,<span class="number">2</span>:<span class="string">'two'</span>,<span class="number">3</span>:<span class="string">'three'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.items())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict_items</span>'&gt;</span></span><br></pre></td></tr></table></figure>
<p>简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123; <span class="string">'Adam'</span>: <span class="number">95</span>, <span class="string">'Lisa'</span>: <span class="number">85</span>, <span class="string">'Bart'</span>: <span class="number">59</span>, <span class="string">'Paul'</span>: <span class="number">74</span> &#125;</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">	sum = sum + value</span><br><span class="line">	print(key, <span class="string">':'</span> ,value)</span><br><span class="line">print(<span class="string">'平均分为:'</span> ,sum /len(d))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D:\Users\WordZzzz\Desktop&gt;python3 test.py</span><br><span class="line">Adam : <span class="number">95</span></span><br><span class="line">Lisa : <span class="number">85</span></span><br><span class="line">Bart : <span class="number">59</span></span><br><span class="line">Paul : <span class="number">74</span></span><br><span class="line">平均分为: <span class="number">78.25</span></span><br></pre></td></tr></table></figure>

<p>关于python3.x中items具体的应用，可以通过下面的传送门到达机器学习实战中找到：</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>items</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3：string中的split()函数</title>
    <url>/folder/2019/11/08/2017-10-01-py-5/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="Python2-x中split-函数："><a href="#Python2-x中split-函数：" class="headerlink" title="Python2.x中split()函数："></a>Python2.x中split()函数：</h2><p>&emsp;&emsp;老规矩，help！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(str.split)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">split(...)</span><br><span class="line">    S.split([sep [,maxsplit]]) -&gt; list of strings</span><br><span class="line"></span><br><span class="line">    Return a list of the words <span class="keyword">in</span> the string S, using sep <span class="keyword">as</span> the</span><br><span class="line">    delimiter string.  If maxsplit <span class="keyword">is</span> given, at most maxsplit</span><br><span class="line">    splits are done. If sep <span class="keyword">is</span> <span class="keyword">not</span> specified <span class="keyword">or</span> <span class="keyword">is</span> <span class="literal">None</span>, any</span><br><span class="line">    whitespace string <span class="keyword">is</span> a separator <span class="keyword">and</span> empty strings are removed</span><br><span class="line">    <span class="keyword">from</span> the result.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看出，在Python2.x中，split()返回的是字符串列表。</p>
<h2 id="Python3-x中split-函数："><a href="#Python3-x中split-函数：" class="headerlink" title="Python3.x中split()函数："></a>Python3.x中split()函数：</h2><p>&emsp;&emsp;同样，help！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(str.split)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">split(...)</span><br><span class="line">    S.split(sep=None, maxsplit=-1) -&gt; list of strings</span><br><span class="line"></span><br><span class="line">    Return a list of the words <span class="keyword">in</span> S, using sep <span class="keyword">as</span> the</span><br><span class="line">    delimiter string.  If maxsplit <span class="keyword">is</span> given, at most maxsplit</span><br><span class="line">    splits are done. If sep <span class="keyword">is</span> <span class="keyword">not</span> specified <span class="keyword">or</span> <span class="keyword">is</span> <span class="literal">None</span>, any</span><br><span class="line">    whitespace string <span class="keyword">is</span> a separator <span class="keyword">and</span> empty strings are</span><br><span class="line">    removed <span class="keyword">from</span> the result.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;啊哦，在Python3.x中，split()返回的也是字符串列表。</p>
<h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (str.split( ))</span><br><span class="line">[<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'string'</span>, <span class="string">'example....wow!!!'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (str.split(<span class="string">'i'</span>,<span class="number">1</span>))</span><br><span class="line">[<span class="string">'th'</span>, <span class="string">'s is string example....wow!!!'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (str.split(<span class="string">'w'</span>))</span><br><span class="line">[<span class="string">'this is string example....'</span>, <span class="string">'o'</span>, <span class="string">'!!!'</span>]</span><br></pre></td></tr></table></figure>

<p>加入正则表达式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySent=<span class="string">'This book is the best book on Python or M.L. I have ever laid eyes upon'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySent.split()                                      <span class="comment">#不带参数切分</span></span><br><span class="line">[<span class="string">'This'</span>, <span class="string">'book'</span>, <span class="string">'is'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'on'</span>, <span class="string">'Python'</span>, <span class="string">'or'</span>, <span class="string">'M.L.'</span>, <span class="string">'I'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regEx = re.compile(<span class="string">'\\W'</span>)                               <span class="comment">#正则表达式，定义分隔符是除单词、数字外的任意字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listOfTokens = regEx.split(mySent)                      <span class="comment">#根据正则表达式的规则进行切分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listOfTokens</span><br><span class="line">[<span class="string">'This'</span>, <span class="string">'book'</span>, <span class="string">'is'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'on'</span>, <span class="string">'Python'</span>, <span class="string">'or'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">''</span>, <span class="string">'I'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[tok <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">0</span>]           <span class="comment">#去掉空格</span></span><br><span class="line">[<span class="string">'This'</span>, <span class="string">'book'</span>, <span class="string">'is'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'on'</span>, <span class="string">'Python'</span>, <span class="string">'or'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">'I'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">2</span>]   <span class="comment">#全部小写，去掉长度小于3的单词</span></span><br><span class="line">[<span class="string">'this'</span>, <span class="string">'book'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'python'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>split</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3：sorted()函数及列表中的sort()函数</title>
    <url>/folder/2019/11/08/2017-10-01-py-4/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">一、sort，sorted函数介绍：</font></strong></p>
<p>&emsp;&emsp;Sort函数是list列表中的函数，而sorted可以对list或者iterator进行排序。</p>
<p>&emsp;&emsp;下面我们使用help来查看他们的用法及功能：<br>sort：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(list.sort)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">sort(...)</span><br><span class="line">    L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*</span><br></pre></td></tr></table></figure>

<p>sorted：<br>Python3.x:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sorted)</span><br><span class="line">Help on built-<span class="keyword">in</span> function sorted <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">sorted(iterable, /, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">    Return a new list containing all items <span class="keyword">from</span> the iterable <span class="keyword">in</span> ascending order.</span><br><span class="line"></span><br><span class="line">    A custom key function can be supplied to customize the sort order, <span class="keyword">and</span> the</span><br><span class="line">    reverse flag can be set to request the result <span class="keyword">in</span> descending order.</span><br></pre></td></tr></table></figure>

<p>Python2.x:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sorted)</span><br><span class="line">Help on built-<span class="keyword">in</span> function sorted <span class="keyword">in</span> module __builtin__:</span><br><span class="line"></span><br><span class="line">sorted(...)</span><br><span class="line">    sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;好吧，Python3.x和Python2.x的sorted函数有点不太一样，少了cmp参数。下面本渣渣主要基于Python2.x的sorted函数进行讲解，Python3.x直接忽略cmp这个参数即可，为了保证代码通用性，不建议大家在今后的编程中使用cmp参数。</p>
<p><strong><font color="black" size=5 face="仿宋">二、sort和sorted的比较：</font></strong></p>
<p>&emsp;&emsp;用sort函数对列表排序时会影响列表本身，而sorted不会。<br>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Python2.x的sorted函数：sorted(iterable，cmp，key，reverse）<br>参数：</p>
<ul>
<li>iterable可以是list或者iterator；</li>
<li>cmp是带两个参数的比较函数；</li>
<li>key 是带一个参数的函数；</li>
<li>reverse为False或者True；</li>
</ul>
<p>举例说明:<br>（1）用cmp函数排序:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>,<span class="number">90</span>), (<span class="string">'sara'</span>,<span class="number">80</span>),(<span class="string">'lily'</span>,<span class="number">95</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,cmp = <span class="keyword">lambda</span> x,y: cmp(x[<span class="number">0</span>],y[<span class="number">0</span>]))</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,cmp = <span class="keyword">lambda</span> x,y: cmp(x[<span class="number">1</span>],y[<span class="number">1</span>]))</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>)]</span><br></pre></td></tr></table></figure>

<p>（2）用key函数排序:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>,<span class="number">90</span>), (<span class="string">'sara'</span>,<span class="number">80</span>),(<span class="string">'lily'</span>,<span class="number">95</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,key = <span class="keyword">lambda</span> list1: list1[<span class="number">0</span>])</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,key = <span class="keyword">lambda</span> list1: list1[<span class="number">1</span>])</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>)]</span><br></pre></td></tr></table></figure>

<p>（3）用reverse排序:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,reverse = <span class="literal">True</span>)</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'david'</span>, <span class="number">90</span>)]</span><br></pre></td></tr></table></figure>

<p>（4）用operator.itemgetter函数排序:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=itemgetter(<span class="number">1</span>))</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=itemgetter(<span class="number">0</span>))</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;介绍operator.itemgetter函数:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = operator.itemgetter(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(a)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;operator.itemgetter函数获取的不是值，而是定义了一个函数。</p>
<p>（5）多级排序:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=itemgetter(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>sort</tag>
        <tag>sorted</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3：operator模块中的itemgetter()函数</title>
    <url>/folder/2019/11/08/2017-10-01-py-3/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<p>&emsp;&emsp;和之前一样，本渣渣先贴出来python中help的帮助信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(operator.itemgetter)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">itemgetter</span> <span class="title">in</span> <span class="title">module</span> <span class="title">operator</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">itemgetter</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">itemgetter</span><span class="params">(item, ...)</span> --&gt; itemgetter object</span></span><br><span class="line"><span class="class"> |</span></span><br><span class="line"><span class="class"> |  Return a callable object that fetches the given item(s) from its operand.</span></span><br><span class="line"><span class="class"> |  After f = itemgetter(2), the call f(r) returns r[2].</span></span><br><span class="line"><span class="class"> |  After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])</span></span><br><span class="line"><span class="class"> |</span></span><br><span class="line"><span class="class"> |  Methods defined here:</span></span><br><span class="line"> |</span><br><span class="line"> |  __call__(self, /, *args, **kwargs)</span><br><span class="line"> |      Call self <span class="keyword">as</span> a function.</span><br><span class="line"> |</span><br><span class="line"> |  __getattribute__(self, name, /)</span><br><span class="line"> |      Return getattr(self, name).</span><br><span class="line"> |</span><br><span class="line"> |  __new__(*args, **kwargs) <span class="keyword">from</span> builtins.type</span><br><span class="line"> |      Create <span class="keyword">and</span> <span class="keyword">return</span> a new object.  See help(type) <span class="keyword">for</span> accurate signature.</span><br><span class="line"> |</span><br><span class="line"> |  __reduce__(...)</span><br><span class="line"> |      Return state information <span class="keyword">for</span> pickling</span><br><span class="line"> |</span><br><span class="line"> |  __repr__(self, /)</span><br><span class="line"> |      Return repr(self).</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;operator.itemgetter函数<br>operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号（即需要获取的数据在对象中的序号），下面看例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=operator.itemgetter(<span class="number">1</span>)      //定义函数b，获取对象的第<span class="number">1</span>个域的值</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(a) </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=operator.itemgetter(<span class="number">1</span>,<span class="number">0</span>)   //定义函数b，获取对象的第<span class="number">1</span>个域和第<span class="number">0</span>个的值</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(a) </span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;要注意，operator.itemgetter函数获取的不是值，而是定义了一个函数，通过该函数作用到对象上才能获取值。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>itemgetter</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3：numpy模块中的argsort()函数</title>
    <url>/folder/2019/11/08/2017-10-01-py-2/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<p>&emsp;&emsp;argsort函数是Numpy模块中的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(numpy.argsort)</span><br><span class="line">Help on function argsort <span class="keyword">in</span> module numpy.core.fromnumeric:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argsort(a, axis=<span class="number">-1</span>, kind=<span class="string">'quicksort'</span>, order=<span class="literal">None</span>)</span><br><span class="line">Returns the indices that would sort an array.</span><br><span class="line"></span><br><span class="line">Perform an indirect sort along the given axis using the algorithm specified</span><br><span class="line">by the `kind` keyword. It returns an array of indices of the same shape <span class="keyword">as</span></span><br><span class="line">`a` that index data along the given axis <span class="keyword">in</span> sorted order.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从中可以看出argsort函数返回的是数组值从小到大的索引值</p>
<p>Examples：</p>
<p>One dimensional array:一维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>Two-dimensional array:二维数组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([[<span class="number">0</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x, axis=<span class="number">0</span>) <span class="comment">#按列排序</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x, axis=<span class="number">1</span>) <span class="comment">#按行排序</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<p>Examples：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x) <span class="comment">#按升序排列</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(-x) <span class="comment">#按降序排列</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[np.argsort(x)] <span class="comment">#通过索引值排序后的数组</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[np.argsort(-x)]</span><br><span class="line">array([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>另一种方式实现按降序排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = x[np.argsort(x)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>]</span><br><span class="line">array([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>argsort</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3：input()函数</title>
    <url>/folder/2019/11/08/2017-10-01-py-1/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="Python2-x中range-函数："><a href="#Python2-x中range-函数：" class="headerlink" title="Python2.x中range()函数："></a>Python2.x中range()函数：</h2><p>&emsp;&emsp;老规矩，help！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(range)</span><br><span class="line">Help on built-<span class="keyword">in</span> function range <span class="keyword">in</span> module __builtin__:</span><br><span class="line"></span><br><span class="line">range(...)</span><br><span class="line">    range(stop) -&gt; list of integers</span><br><span class="line">    range(start, stop[, step]) -&gt; list of integers</span><br><span class="line"></span><br><span class="line">    Return a list containing an arithmetic progression of integers.</span><br><span class="line">    range(i, j) returns [i, i+<span class="number">1</span>, i+<span class="number">2</span>, ..., j<span class="number">-1</span>]; start (!) defaults to <span class="number">0.</span></span><br><span class="line">    When step <span class="keyword">is</span> given, it specifies the increment (<span class="keyword">or</span> decrement).</span><br><span class="line">    For example, range(<span class="number">4</span>) returns [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].  The end point <span class="keyword">is</span> omitted!</span><br><span class="line">    These are exactly the valid indices <span class="keyword">for</span> a list of <span class="number">4</span> elements.</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看出，在Python2.x中，range()返回的是可以用来迭代的列表。</p>
<h2 id="Python3-x中range-函数："><a href="#Python3-x中range-函数：" class="headerlink" title="Python3.x中range()函数："></a>Python3.x中range()函数：</h2><p>&emsp;&emsp;同样，help！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(range)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">range</span> <span class="title">in</span> <span class="title">module</span> <span class="title">builtins</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">range</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">range</span><span class="params">(stop)</span> -&gt; range object</span></span><br><span class="line"><span class="class"> |  range(start, stop[, step]) -&gt; range object</span></span><br><span class="line"><span class="class"> |</span></span><br><span class="line"><span class="class"> |  Return an object that produces a sequence of integers from start (inclusive)</span></span><br><span class="line"><span class="class"> |  to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.</span></span><br><span class="line"><span class="class"> |  start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.</span></span><br><span class="line"><span class="class"> |  These are exactly the valid indices for a list of 4 elements.</span></span><br><span class="line"><span class="class"> |  When step is given, it specifies the increment (or decrement).</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;啊哦，在Python3.x中，range()返回的是一个range对象。</p>
<h2 id="样例对比："><a href="#样例对比：" class="headerlink" title="样例对比："></a>样例对比：</h2><p>Python2.x：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>Python3.x：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过list强制类型转换，可以在Python3.x中实现Python2.x中的range函数一样的效果。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python3</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>CVPR2014 Objectness BING 源码编译</title>
    <url>/folder/2019/11/08/2017-10-01-bing-3/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：VS2013+OpenCV2.4.13</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<h2 id="一、资源"><a href="#一、资源" class="headerlink" title="一、资源"></a>一、资源</h2><p>1.论文作者主页：<a href="http://mmcheng.net/zh/bing/" target="_blank" rel="noopener">http://mmcheng.net/zh/bing/</a><br>2.代码下载地址：<a href="http://mmcheng.net/zh/code-data/" target="_blank" rel="noopener">http://mmcheng.net/zh/code-data/</a><br>3.数据集下载地址：<a href="http://mmcheng.net/zh/bing/" target="_blank" rel="noopener">http://mmcheng.net/zh/bing/</a></p>
<h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>&emsp;&emsp;如果你用的是Visual Studio 2012，正好电脑也支持X64平台，那么你只需要配置一下VS2012下的OpenCV（版本要求2.4.8以上），下载的程序就可以直接用了。<br>&emsp;&emsp;我做了一些排雷的动作，尝试了Visual Studio 2013中Release、Debug中的x64和win32版本，即：Release+x64、Debug+x64、Release+win32、Debug+win32.但是因为本渣渣能力有限，最终没能把Visual Studio 2013中的Debug+win32版本跑出来。</p>
<p>1.解压下载的源码：<br>&emsp;&emsp;解压后文件夹内容如图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903110934676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>2.解压VOC2007数据集：<br>&emsp;&emsp;在上图的源码文件中我们也可以看到有个VOC2007文件夹，里面只有ImageSets一个文件夹（里面是训练时会用到的文本文档）。在这一步，我们要把下载好的800多MB的数据集解压到源码的VOC2007文件夹下。（注意在解压过程中当出现是否覆盖的选项时，一律选择跳过,虽然覆盖了也不是很影响效果。）</p>
<p>3.用VS2013打开解决方案，提示升级VC++编译器和库，直接点击确定就好：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111124791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>4.X64-&gt;WIN32:</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111218240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111248523?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111311467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>添加win32配置管理器，注意一定要从x64继承下来其他东西。</p>
<p>5.配置LibLinear：</p>
<ul>
<li>右键LibLinear，选为启动项目；</li>
<li>在linear.cpp文件中，修改print_string_stdout函数为：extern “C” static void print_string_stdout(const char *s)</li>
<li>静态库配置：</li>
</ul>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111729176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>6.LibLinear代码生成：<br>&emsp;&emsp;最重要的就是这一块的东西了，我直接把四种配置的截图贴在这里，注意，MT对应Release，MTD对应Debug，但是作者的Debug版本用的是DLL(/MDd)，所以本渣渣在Debug版本中也没做更改：</p>
<p>Release+x64：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111535986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>Debug+x64：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111413318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>Release+win32：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111515044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>Debug+win32（失败）：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903111445504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>


<p>&emsp;&emsp;ctrl+F5之后在相应目录下生成LibLinear.lib静态库，记下这个地址。<br>7.配置Objectness：<br>&emsp;&emsp;以Debug+win32的配置为例进行介绍（虽然配置失败，但是这些属性设置是通用的，所以没有更新截图）</p>
<ul>
<li><p>右键Objectness，选为启动项目；</p>
</li>
<li><p>打开Debug属性，链接器-&gt;附加库目录，添加LibLinear.lib的目录；（注意:链接库依赖项 要设为是（yes））</p>
</li>
<li><p>用_popcnt函数实现_popcnt64函数功能：需要自己动手在INT64类型基础上写函数。要加头文件#include&lt;intrin.h&gt;在stdafx.h中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">inline</span> <span class="selector-tag">INT64</span> __<span class="selector-tag">popcnt64</span>(<span class="selector-tag">INT64</span> <span class="selector-tag">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">       return __popcnt((unsigned int)(x )) +__popcnt((unsigned int)(x&gt;&gt; 32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>8.配置opencv：<br>&emsp;&emsp;这里大家可以参考浅墨的博客进行配置，当然本渣渣要是有时间了也会写一篇博客并在此更新链接。浅墨opencv配置链接：<br><a href="http://blog.csdn.net/poem_qianmo/article/details/19809337" target="_blank" rel="noopener">http://blog.csdn.net/poem_qianmo/article/details/19809337</a></p>
<p>&emsp;&emsp;这里我只贴出一些需要填写路径的截图：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903150731185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903150751508?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903150810256?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903150831273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903150858382?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;<strong><font color="red" size=3 face="仿宋">需要注意的是上图部分，Debug版本就用d结尾的库，Release版本就用不带d结尾的库，千万不要像浅墨那样两个版本都塞进去，否则会莫名其妙报错。</font></strong></p>
<p>9.再次配置Objectness的代码生成，和第6步是一样的。</p>
<p>&emsp;&emsp;ctrl+F5之后，运行成功。</p>
<p>10.效果展示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903151152107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" /></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903151223762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>11.其他：<br>&emsp;&emsp;如果想优化代码，可以打开openmp，并且设置一下优化等级，本渣渣在这里只是为了看处理效果，所以就没做优化的配置。关于优化配置可参考链接（有些情况不一定好使）：<a href="http://www.cnblogs.com/larch18/p/4560690.html" target="_blank" rel="noopener">http://www.cnblogs.com/larch18/p/4560690.html</a></p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>BING</category>
      </categories>
      <tags>
        <tag>BING</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>CVPR2014 Objectness BING 源码详解</title>
    <url>/folder/2019/11/08/2017-10-01-bing-2/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：VS2013+OpenCV2.4.13</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<h2 id="一、样本生成："><a href="#一、样本生成：" class="headerlink" title="一、样本生成："></a>一、样本生成：</h2><h3 id="1-正样本"><a href="#1-正样本" class="headerlink" title="1.正样本"></a>1.正样本</h3><p>&emsp;&emsp;算法首先对每张图像上可能的所有标注框采样,生成不同尺度（该尺度在一定经验值范围内）的样本位置，并计算新生成的正样本与原始样本重叠率，保留重叠率超过50%的，重新归一化到8 * 8大小，计算新生成的有效正样本的梯度特征，并在水平方向翻转，最终保存新生成样本8 * 8的梯度特征与该特征的水平翻转特征作为xP.</p>
<h3 id="2-负样本"><a href="#2-负样本" class="headerlink" title="2.负样本"></a>2.负样本</h3><p>&emsp;&emsp;固定100次随机产生100个备选的负样本窗口，筛选出与每张图片中，与所有目标的重叠率都小于50%的负样本窗，并将该窗口内保存图像作为负样本。</p>
<h3 id="3-尺度处理"><a href="#3-尺度处理" class="headerlink" title="3.尺度处理"></a>3.尺度处理</h3><p>&emsp;&emsp;在筛选有效正样本时，同时保存了水平，垂直尺度系数，但是实际保存的尺度是归一化映射后的值，即(h - min) * num + w - min + 1,其中h,w表示筛选出的有效正样本相对原始目标的垂直，水平尺度系数，实际上，还是保存的尺度系数，只是在数据结构上，采用哈希映射存储罢了。</p>
<h3 id="4-判定有效样本"><a href="#4-判定有效样本" class="headerlink" title="4.判定有效样本"></a>4.判定有效样本</h3><p>&emsp;&emsp;程序下一步，会在上面采样生成的所有有效正样本，进行直方图统计，统计出每个尺度下的样本数。例如有2500多个图像文件，计算所有正样本数，统计每个尺度下的正样本数。根据统计结果，剔除掉正样本数少于50的尺度。保存剩下的尺度统计结果，接着，对所有正负样本，统一分配到一个二维矩阵，垂直表示样本数，水平表示样本的8<em>8梯度特征值，直接保存。<br>以上，属于该算法的第一个亮点。<br>&emsp;&emsp;算法主要是用来加速传统的滑动窗口对象检测，通过训练通用的对象估计方法来产生候选对象窗口。作者观察到一般对象都会有定义完好的封闭轮廓，而且通过将相关图像窗口重置为固定大小，就可以通过梯度幅值进行区分。基于以上的观察以及复杂度的考虑，为了明确训练方法，将窗口固定为8</em>8的，并将梯度幅值转化为一个简单的64维的特征来描述这个窗口。这就相当于我们看路上走的人一样，在很远的地方即使我们没看清楚脸，只是看到一个轮廓也能识别出是不是我们认识的人，反而，如果脸贴着脸去看一个人可能会认不出来。<br>&emsp;&emsp;也就是作者发现，在固定窗口的大小下，物体与背景的梯度模式有所不同。如下图所示。图（a）中绿框代表背景，红框代表物体。如果把这些框都resize成固定大小，比如8X8，然后求出8X8这些块中每个点的梯度（Normed Gradient，简称NG特征，叫赋范梯度特征，就是计算梯度范数，即<code>!$\sqrt{(g_x^2 + g_y^2)}$</code>,实际就是该点的L2范数梯度，但是作者实现时，采用-1,0,1方式计算gx或者gy,因此，用|gx| + |gy|近似代替梯度的L2范数），可以明显看到物体与背景的梯度模式的差别，如图1（c）所示，物体的梯度分布呈现出较为杂乱的模式，而背景的较为单一和清楚。其实这个道理很浅显，就是图像中背景区域往往呈现出homogeneous的特性，早期的图像区域分割方法就是依靠这种特性来做的。然后我个人觉得这里不一定要用梯度，用其他一些统计特征甚至是图像特征都有可能得到类似的结果。<br>&emsp;&emsp;所以，作者首先将所有的标注样本，用不同尺度缩放采样，将采样出的有效正样本统一缩放到8 * 8，计算NG特征，也就是下面图中a生成c在过程。这样，通过SVM训练这些NG特征，得到目标和背景的第一次区分模型。<br>&emsp;&emsp;下面是原文的解释<br>&emsp;&emsp;对象一般是具有很好定义封闭轮廓和中心的。重置窗口的时候，就相当于将现实中的对象缩小到一个固定大小，因为在封闭的轮廓中，图像梯度变化很小，所以它是一个很好的可区分特征，就像是图1中，轮船和人在颜色，形状，纹理，光照等方面都有很大的不同，他们在梯度空间都存在共性。为了有效地利用观察结果，我们首先将输入图像重置为不同尺度的，在不同的尺度下计算梯度。然后再重置为取8 * 8大小的框，作为一个对应图像的64维的NG特征。<br>我们采用的NG特征，是一个密集的且紧凑的objectness特性，有以下几点优势：首先，由于归一化了支持域，所以无论对象窗口如何改变位置，尺度以及纵横比，它对应的NG特征基本不会改变。也就是说，NG特征是对于位置，尺度，纵横比是不敏感的，这一点是对于任意类别对象检测是很有用的。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823181219294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700" /></div>
<p></p>

<p>&emsp;&emsp;图1 尽管对象（红色）和背景（绿色），在图像空间（a）呈现出了很大的不同，通过一个适当的尺度和纵横比，我们将其分别重置为固定大小(b)，他们对应的NG特征(c)表现出很大的共性,基于NG特征，我们学习了一个简单的64D线性模型（d），用来筛选对象窗口。<br>这种不敏感的特性是一个好的对象检测方法应该具备的。第二，NG特征的紧凑性，使得计算和核实更加有效率，而且能够很好的应用在实时应用程序中。<br>NG特征的缺点就是识别能力不够。但一般而言，会采用检测器来最终缺点结果的误报率。</p>
<h2 id="二、两级SVM训练："><a href="#二、两级SVM训练：" class="headerlink" title="二、两级SVM训练："></a>二、两级SVM训练：</h2><h3 id="1-SVM第一级训练"><a href="#1-SVM第一级训练" class="headerlink" title="1.SVM第一级训练"></a>1.SVM第一级训练</h3><p>&emsp;&emsp;首先，算法传递进入第一级SVM的样本总数，在超过SVM默认参数值时，采用SVM默认训练总样本数。用所有正样本以及剩下的数量采用随机从原负样本中抽取。即，负样本在这种情况下，不是全部参加SVM第一级训练。而是随机抽取一部分，保证总样本数达到SVM默认训练总样本数。<br>&emsp;&emsp;算法做一些SVM的初始化，涉及到样本标签Y，实际上，正样本默认都为有标签，以及SVM参数初始化等。<br>&emsp;&emsp;通过第一级SVM训练后，算法生成第一级SVM模型，转换成8 * 8，并归一化到1~255，保存。该模型w是用来下文中投票打分的，为第二级SVM学习做准备。</p>
<h3 id="2-二值化模型参数w"><a href="#2-二值化模型参数w" class="headerlink" title="2.二值化模型参数w"></a>2.二值化模型参数w</h3><p>&emsp;&emsp;首先通过上面的训练，我们可以得到分类的模型线性w，第一个要二值化的目标就是它，二值化的思想可以简单想象成找若干个基向量，并用这些基向量的线性组合来记表示w， 而且这些基向量的每一维只能取1或者-1（二值嘛）。那么假设我们用了Nw个基向量，每个基向量为aj, j = 1,…,Nw，那么就有<code>!$ w ≈  \sum_{j=1}^{N_w} \beta_j \alpha_j$</code>。具体模型的二值化近似可以按如下算法1的步骤进行：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823184337349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400" /></div>
<p></p>

<p>&emsp;&emsp;算法1的步骤也很明确，每一个都生成一个基向量，此基向量每一维都是由当前残差的符号决定，然后用当前残差减去残差在这基向量的投影（相当于去掉模型在这一维上的分量）。但在计算中因为二进制位只能为0或者1，所以为了处理方便，取：$\alpha_j^+∈{ 0,1 }^{64}$,那么就可以将基向量表示为$\alpha_j = \alpha_j^+ - \overline{\alpha_j^+}$。即基向量二进制与该二进制表示的补。<br>&emsp;&emsp;也就是说，αj表示基向量{-1,1}，βj表示校准系数，同时，将每个基向量，映射到一个64位类型的数据中。<br>这里，实际上采用Gram-Schmidt正交化，只取了包含大部分信息的前Nw个正交向量作为输出，目的也是为了降低计算量。二值化的目的在于后期位运算，后面还会把NG特征也二值化。直接采用硬件指令大幅度地提升速度。<br>&emsp;&emsp;代码中，Nw取2，也就是SVM生成的W 是8 * 8矩阵，矩阵元素任意值，通过这个二值化过程，生成2个基向量，每个基向量完全覆盖了W中每个元素，但是此时在基向量中，每个元素对应的取值变成0或者1，因此，原w的64个元素，拼接成了一个64位的单个数据，即基向量。同时，对应该基向量的校准系数，算法为了后期加速，只近似处理高4位的数据，因此，校准系数只有保存4个，且都是一样的值，但是由于后期位移运算，这里就把校准值放置到了对应bit位。于是，2个基向量，生成8个校准系数，2个64位的数据。</p>
<h3 id="3-打分窗口"><a href="#3-打分窗口" class="headerlink" title="3.打分窗口"></a>3.打分窗口</h3><p>&emsp;&emsp;为了找到图像中的一般对象，对每张训练图像（注意，这里是原图像，不是标注框），进行上文生成正样本时得到所有尺度的量化，扫描每个尺度定义好的量化窗口（依据尺度或者是纵横比，也就是说，这里只是对原图像依据之前尺度系数做缩放，不是缩放到8 * 8,因此，才有下文的I）。每一个窗口通过上文得到模型w获得得分</p>
<p>$$<br>s_l = &lt; w,g_l &gt;(1)<br>$$</p>
<p>$$<br>l = &lt; i,x,y &gt;(2)<br>$$<br>&emsp;&emsp;$s_l$ 代表过滤器得分，  $g_l$ 代表NG特征，  $l$表示坐标，  $i$表示尺度，  $(x,y)$表示窗口位置。运用非最大抑制(NMS)，我们为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 * 100），一些尺度（例如:10 * 500）的窗口包含对象的可能性是很小的。因此我们定义对象状态得分（校准过滤器得分）：</p>
<p>$$<br>o_l = v_i · s_l + t_i  (3)<br>$$</p>
<p>&emsp;&emsp;只需要按位与和字节统计操作.下面解释如何得到b.<br>因此，为了实现（1）的快速计算，作者先用上面的算法，二值化了w,现在开始二值化NG，即gl参数，得到上面的b.</p>
<p>&emsp;&emsp;接下来我们还要对NG特征进行二值化，还记得我们刚才将NG归一化到[0,255]之间吧，那么8 * 8窗口上的每个点的NG特征值就可以用一个byte来存储，也就是每个值我们都可以用一个8位的二进制串来表示。那么我们就有一个8X8X8的三维矩阵，前两维是窗口位置（行，列），第三维是在二进制串中的位置（页）。举个例子，比如窗口中第1行，第2列的NG特征值是192，换成二进制就是1100 0000，那么矩阵的元素（1,2,1） = （1,2,2）= 1，（1,2,3），…,（1,2,8）= 0;那么我们一页一页地将矩阵元素取出来，再将每页8X8的矩阵元素排成一个64位的二进制串并存进一个int64里。既然思路已经有了，做法也就很简单了：对于每一页，将每一行每个元素取出来，不断加入int64中并左移1位，最后得到那个int64每一位对应的元素坐标排列就应该是（1,1）（1,2）（1,3）…(8,8)。然后作者在这里又玩了一个trick，他说你这样每次移动一位不是要循环64次嘛，如果先将8个拼成一组（就是刚才那样左移1次），那么只需要移动8组就好了啊！而且，这样在相邻的窗口中还能重用重叠的部分（在VS2010 的Debug模式下我试了下，1个数“每次左移1位，移动1万次”和“每次左移100位，移动100次”两种情况，的确是后者速度快）。<br>最后，为了进一步节省存储空间，还可以只取NG值的高位来作二值化。因为比如192和193、194，它们的二进制表达分别是1100 0000， 1100 0001和 1100 0010，要是我只看前面4位，后面4位忽略（取0）的话，那么它们的取值都是192。也就是我们可以用192来约等于193和194，这样我们就不需要用到8位那么多了！写成公式就是下面的式（2）这样，其中Ng 是我们要用的高位的位数（也就是前面说的三维矩阵的页）,bk,l就是对应三维矩阵中的第k页（二值）。</p>
<p>最后将二值化模型w和二值化NG，结合起来对窗口打分的操作由卷积运算变成了大部分是位运算操作，</p>
<p>&emsp;&emsp;一个图像窗口对应的BING特征  $b_{k,l}$ 的过滤器得分,见式(1),可以表示为：</p>
<p>$$<br>s_l≈ \sum_{j=1}^{N_w}\beta_j\sum_{k=1}^{N_g}C_{j,k}<br>$$</p>
<p>&emsp;&emsp;其中，  $C_{j,k} = 2^{8-k}(2&lt; \alpha_j^+,b_{k,l}&gt;-|b_{k,l}|)$可以通过一些快速的按位操作以及SSE指令操作计算得到。</p>
<p>&emsp;&emsp;然后，运用非最大抑制(NMS)，做下滤波。</p>
<p>&emsp;&emsp;总结一下：首先，根据第一级SVM得到模型参数w,对每张训练图像，进行所有尺度变换（不是固定8*8大小），然后计算NG特征，接着根据上文的打分系统，计算每个尺度下的sl（实际上，二值化w和二值化NG特征，就是BING特征）.并重新排序，利用NMS消除掉高分点附近领域内的打分值。这里只选择指定阈值以上的高分点。然后，在原始图像，找到对应打分点对应的方框大小，并保存。这样，针对每张图像，我们计算了不同尺度i下的打分项以及相对应的可能目标匡。然后，针对所有可能的目标匡，我们将其与原始图像中所有有效正样本做重叠率比对，只要有一个正样本框与该可能目标匡重叠与大于0.5，则该可能目标匡作为正样本，否则为负样本。在传入第二级SVM时，作者将可能目标框的打分值，重新根据尺度整合，即不同尺度下下，所有的打分值，作为正负样本。在第二级训练时，针对每个尺度，训练一次。</p>
<h3 id="4-第二级SVM训练"><a href="#4-第二级SVM训练" class="headerlink" title="4.第二级SVM训练"></a>4.第二级SVM训练</h3><p>&emsp;&emsp;作者针对每种尺度下的打分值，训练SVM，每种尺度下样本总数不超过10W。超过，则随机在正负样本中抽取。确保先读取正样本，后需剩余的位置随即用负样本填满。训练结束后，生成新的权值vi,ti.</p>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>&emsp;&emsp;在读入测试图片后，计算图像的BING特征，跟二级SVM训练预处理一样，对图像进行不同尺度的缩放，计算NG，打分统计得到sl（用的还是第一级模型的w）</p>
<p>&emsp;&emsp;然后，为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 * 100），一些尺度（例如:10 * 500）的窗口包含对象的可能性是很小的。<br>&emsp;&emsp;针对不同尺度i的窗口，得到不同的独立学习系数。使用校准函数(3)是非常快的，通常只需要在最终的建议窗口重排。<br>这里，打分用的权值是二级模型训练出的，即上文的vi,ti.得到ol重新排序。整个过程，计算时间，给出每个检测图象的平均测试时间。并保存打分结果与对应的目标框。</p>
<p>&emsp;&emsp;打分越高，越接近目标。实际上，算法生成的就是打分窗口，也就是所为的对象状态。下面测试的时候，根据打分窗口与标注的测试窗口重叠率大于0.5就认为检测到了。<br>接着，作者开始绘制结果，根据检测出的候选框与每个测试标注框计算重叠率，大于0.5，就认为检测到了，否则score为0未检到。之后，计算平均重叠率和平均检测率。</p>
<p>这里解释下重叠率：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823185011109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700" /></div>
<p></p>

<p>&emsp;&emsp;上面的精度曲线称为DR-#WIN curves，源自TPAMI 2012的一篇论文：Measuring the objectness of image windows。原文还提出了将窗口数量比如[[0,5000]归一化到[0,1]之间，用曲线下的面积作为目标检测的度量结果，并称之为the area under the curve(AUC)，这样AUC的范围就在[0,1]之间了。</p>
<p>&emsp;&emsp;DR的计算是参考The PASCAL Visual Object Classes (VOC) Challenge，目标检测任务中DR的计算的是true/false positive精度，将算法检测目标结果放到groud truth中，将“预测目标区域与groud truth区域的交集”除以“预测目标区域与groud truth区域的并集”作为DR：</p>
<p>&emsp;&emsp;DR自少在50%以上才算目标检测正确，其实，50%已经是很低的了，几乎不能做为检测结果。</p>
<p>&emsp;&emsp;自己在程序中加了单张图片测试的显示部分，如果有同学需要可以私信我。</p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>BING</category>
      </categories>
      <tags>
        <tag>BING</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>BING: Binarized Normed Gradients for Objectness Estimation at 300fps</title>
    <url>/folder/2019/11/08/2017-10-01-bing-1/</url>
    <content><![CDATA[<p><strong><div align=center><font color="black" size=6 face="仿宋">BING: Binarized Normed Gradients for Objectness Estimation at 300fps</font></div></strong><br><strong><div align=center><font color="black" size=6 face="仿宋">基于二值化赋范梯度特征的一般对象估计</font></div></strong></p>
<p><strong><font color="black" size=5 face="仿宋">摘要：</font></strong></p>
<p>&emsp;&emsp;训练通用对象度量来生成一小组候选对象窗口，已经显示出加速了经典的滑动窗口对象检测范式。我们观察到，通过观察梯度的标准，可以通过将其对应的图像窗口适当地调整到小的固定尺寸来区分具有良好定义的闭合边界的通用对象。基于这个观察和计算复杂度，我们建议将窗口大小调整为8*8并使用赋范梯度作为简单的64D特征来描述，用于明确地训练通用的对象度量。</p>
<p>&emsp;&emsp;我们进一步展示了这种特征的二值化版本，即二值化赋范梯度（BING），它可以用于高效的对象估计，这只需要少量的原子操作（例如加法，按位移动等）。对有挑战性的PASCAL VOC 2007数据集的实验表明，我们的方法有效生成一小组类别无关的高质量对象窗口（单个笔记本电脑CPU上的300fps），通过使用1,000个建议窗口，产生96.2％的对象检测率（DR）。通过增加建议窗口和颜色空间的数量来计算BING特征，我们的性能可以进一步提高到99.5％的DR。</p>
<p>&emsp;&emsp;作为计算机视觉中最重要的领域之一，近年来，对象检测取得了长足的进步。然而，大多数最先进的检测器仍然需要每个类别的特定分类器以滑动窗口方式评估许多图像窗口[17,25]。为了减少每个分类器需要考虑的窗口数量，训练类别通用的对象度量最近变得流行[2,3,21,22,48,49,57]。对象通常表示为反映图像窗口覆盖任何类别的对象的可能性的值[3]。通用对象度量在预过滤过程中具有很大的潜力，可以显着改善：i）通过减少搜索空间来提高计算效率，以及ii）通过允许在测试期间使用强分类器来提高检测精度。然而，设计好的通用对象度量方法是困难的，需要：</p>
<ul>
<li>具备很好的检测率，找到所有前景对象；</li>
<li>提出少量建议，用于减少对象检测的计算时间；</li>
<li>达到很高的计算效率，很容易拓展到其他实时以及大规模的应用程序中；</li>
<li>具备很好的通用性，方便用于各个类别的检测器中，这样可以减少计算量</li>
</ul>
<p>&emsp;&emsp;据我们所知，暂时还没有任何方法可以同时满足以上全部要求。</p>
<p>&emsp;&emsp;认知心理学[47,54]和神经生物学[20,38]的研究表明，人们在识别物体之前具有很强的感知对象能力。 基于观察到的人类反应时间和估计的生物信号传播时间，人类注意理论假设人类视觉系统仅处理图像的一部分，而对图像的其余部分几乎视而不见。这进一步表明，在识别对象之前，在人类视觉系统中有简单的机制来选择可能的对象位置。</p>
<p>&emsp;&emsp;在本文中，我们提出了一个非常简单而又强大的特征“BING”，通过使用对象状态分数来帮助搜索对象。我们的工作动机是基于物体是具有明确的封闭边界和中心的独立事物[3，26，32]的事实。我们观察到，当查看赋范梯度（见图1和图3）时，将其相应的图像窗口大小调整为小的固定大小（例如8 * 8）后，具有明确定义的闭合边界的通用对象具有惊人的强相关性）。因此，为了有效地量化图像窗口的目标，我们将其大小调整为8 * 8，并使用梯度的范数作为一个简单的64D特征，用于在级联SVM框架中学习通用对象度量。我们进一步展示了NG功能的二值化版本，即二值化规范梯度（BING）功能，可以用于图像窗口的有效对象估计，只需要几个原子CPU操作（即加法，按位移动等） ）。 大部分现存的先进方法，一般采用复杂的分类特征，而且需要采用加速方法以至于计算时间是可控的，相对于此，BING特征是简单朴素的。</p>
<p>&emsp;&emsp;我们已经在PASCAL VOC2007数据集上，广义的评价了我们的方法。实验结果表明，我们的方法有效（在单个笔记本电脑CPU上为300fps）生成一小组数据驱动，类别无关，高品质的对象窗口，通过使用1000个窗口（约为整个滑动窗口的0.2%），产生96.2％的检测率（DR）。将目标窗口数量增加到5000个，估计3个不同颜色空间的对象，我们的方法可以达到99.5％的DR。在[3,22,48]之后，我们也验证了我们的方法的泛化能力。当我们对6个物体类别的对象度量进行训练时，对其他14个不可见的类别进行测试，我们观察到与标准设置类似的高性能（见图3）。与大多数流行的替代方案相比[3,22,48]，BING功能使我们能够使用较小的提议来实现更好的DR，而且能够预测不可见的类别，更简单，更快1000倍。这满足了良好的目标检测器的上述要求。我们的源代码将与论文一起发布。</p>
<p><strong><font color="black" size=5 face="仿宋">2.相关工作</font></strong></p>
<p>&emsp;&emsp;能够在识别物体之前感知物体与自下而上的视觉注意（显着性）密切相关。根据显著性定义，我们将相关研究大致分为三类：固定点预测、显著性对象检测，对象提案生成。</p>
<p>&emsp;&emsp;固定点预测：该模型旨在预测人眼运动的显着性[4,37]。 灵感来自神经生物学研究关于早期灵长类动物视觉系统，Itti等人[36]提出了显着检测的第一个计算模型之一，其估计了多尺度图像特征中的中心包围的差异。Ma和Zhang[42]提出了一种模糊增长模型来分析局部对比度显着性。Harel等人[29]提出了将中心包围的特征图归一化以突出显眼部分。虽然固定点预测模型已经取得了显着的发展，但预测结果倾向于突出边缘和角落而不是整个对象。因此，这些模型不适合生成用于检测目的的对象提案。</p>
<p>&emsp;&emsp;显著性对象检测：该模型尝试检测场景中最引人注意的对象，然后对该对象的整个范围进行细分[5,40]。Liu等人[41]将CRF框架中的局部，区域和全局显着性检测结合起来。 Achanta等人[1]使用频率调节方法的局部显着区域。 Cheng等[11,14]提出了一种基于区域对比分析和迭代图分割的显著性对象检测和分割方法。最近的研究还试图在基于滤波的框架[46]中生成高质量的显着性图，使用有效的数据表示[12]或考虑分层结构[55]。对于简单图像的这种显著性物体分割在图像场景分析[15,58]，内容感知图像编辑[13,56,60]中取得了巨大的成功，并且可以用作处理大量互联网图像或构建的便宜工具通过自动选择好的结果[10,11]，可以很好的应用[7,8,16,31,34,35]。然而，这些方法不太可能用于呈现许多对象的复杂图像，并且它们很少占主导地位（例如VOC[23]）。</p>
<p>&emsp;&emsp;对象提案生成：该方法通过提出少量（例如1,000个）类别无关的提案，并不作出决定，将覆盖图像中的所有对象[3,22,48]。生成粗略分割[6,21]作为对象提案已被证明是减少针对特定分类器的搜索空间的有效方法，同时允许使用强分类器来提高准确性。然而，这两种方法在计算上是昂贵的，每个图像需要2-7分钟。 Alexe等人[3]提出了一种提示集成方法，以更有效地获得更好的预测性能。张等人[57]提出了一种具有定向梯度特征的级联排序SVM方法，用于有效的提案生成。 Uijlings等人[48]提出了一种选择性搜索方法来获得更高的预测性能。我们提出一种简单而直观的方法，通常可以比其他方法更好地实现检测性能，并且比最流行的替代品快了1000倍[3,22,48]（见第4节）。</p>
<p>&emsp;&emsp;另外，对于一个有效的滑动窗口对象检测方法，保证计算量可控是非常重要的[43,51]。Lampert等人[39]提出了一个优雅的分支定界方法用于检测。但是，这些方法只能用于加速分类器，而且是用户已经提供了一个好的边框。一些其他有效的分类器[17]和近似核方法[43,51]也已经被提出。这些方法旨在减小估计单个窗口的计算量，自然也能结合对象性建议进而减小损失。</p>
<p><strong><font color="black" size=5 face="仿宋">3.方法</font></strong></p>
<p>&emsp;&emsp;灵感来自人类视觉系统的能力，在识别物体之前有效地感知对象[20,38,47,54]，我们引入了梯度（NG）特征（第3.1节）的简单64D范数，以及其二进制近似 ，即二值化赋范梯度（BING）特征（第3.3节），以有效捕获图像窗口的对象性。</p>
<p>&emsp;&emsp;为了找到图像中的一般对象，我们扫描一个定义好的量化窗口（依据尺度或者是纵横比）。每一个窗口通过一个线性模型  $w ∈ R64$ 获得得分</p>
<p>$$<br>s_l = &lt; w,g_l &gt;(1)<br>$$</p>
<p>$$<br>l = &lt; i,x,y &gt;(2)<br>$$</p>
<p>    $s_l$ 代表过滤器得分，  $g_l$ 代表NG特征，  $l$ 表示坐标，  $i$ 表示尺度，  $(x,y)$ 表示窗口位置。运用非最大抑制(NMS)，我们为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 * 100），一些尺度（例如:10 * 500）的窗口包含对象的可能性是很小的。因此我们定义对象状态得分（校准过滤器得分）：</p>
<p>$$<br>o_l = v_i · s_l + t_i  (3)<br>$$</p>
<p>  其中  $v_i，t_i∈ R$ ，针对不同尺度  $i$ 的窗口，得到不同的独立学习系数。使用校准函数（3）是非常快的，通常只需要在最终的建议窗口重排之后进行。</p>
<p>3.1 梯度幅值（NG）和对象状态</p>
<p>  对象是具有明确界限的边界和中心的独立事物[3,26,32]。当将与现实世界对象相对应的窗口大小调整为小的固定大小（例如8 * 8，由于计算原因而选择，将在第3.3节中进行说明）时，相应图像梯度的范数（即幅度）将成为良好的辨别特征，因为封闭边界在这种抽象视图中可能存在的小变化。如图1所示，虽然游轮和人在颜色，形状，质地，照明等方面有很大的差异，但它们在赋范梯度空间中具有明显的相关性。为了有效地预测对象实例的存在，利用这一观察，我们首先将输入图像的大小调整为不同的量化尺寸，并计算出每个调整大小的图像的规范梯度。这些调整大小的规范梯度图的8 * 8个区域的值被定义为其对应窗口的64D规范梯度（NG）特征。</p>
<p>  我们的NG特征，作为图像窗口的密集和紧凑的对象特征，具有以下几个优点。 首先，无论物体的位置，尺度和纵横比如何变化，由于该特征的归一化支持区域，其对应的NG特征将保持大致不变。 换句话说，NG特征对于位置，比例和纵横比的变化不敏感，这对于检测任意类别的对象非常有用。而这些不敏感的属性就是一个很好的对象建议生成方法。 其次，NG特征的密集紧凑表示使得计算和验证非常有效，因此具有很大的实际应用潜力。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823181219294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700" /></div>
<p></p>
Figure 1 尽管对象（红色）和背景（绿色），在图像空间（a）呈现出了很大的不同，通过一个适当的尺度和纵横比，我们将其分别重置为固定大小(b)，他们对应的NG特征(c)表现出很大的共性,基于NG特征，我们学习了一个简单的64D线性模型（d），用来筛选对象窗口。"
  
  将这种优势引入NG特征的成本是丧失描述能力。 幸运的是，所产生的误报将由后续的类别特定检测器处理。 在第4节，我们显示我们的方法产生了一小组高质量的提案，涵盖了具有挑战性的VOC2007数据集中的96.2％的真实对象窗口。

<p>3.2 objectness度量</p>
<p>  为了学习图像窗口的对象度量，我们遵循两级SVM的总体思路[57]。</p>
<ul>
<li><p>使用线性SVM学习式（1）中的单个模型w [24]。 真实对象窗口和随机采样背景窗口的NG特征分别用作正和负训练样本。</p>
</li>
<li><p>在（3）中使用线性SVM学习  $v_i$ 和  $t_i$ [24]，我们评估（1）在尺寸  $i$ 上训练图像，并将所选择的（NMS）提案作为训练样本，将它们的过滤分数作为1D特征，并使用训练图像注释检查其标签（有关评估标准，请参阅第4节）。</p>
</li>
<li><p>讨论：如图1d所示，学习的线性模型w（参见实验设置的第4节）看起来类似于假设为灵长类动物的生物似然结构的多尺寸中心包围模式[27,38,54]。 沿着边界的大的权重有利于将物体（中心）与其背景（包围）分开的边界。 与手动设计的中心环绕模式[36]相比，我们学到的w捕获更复杂更自然的前景。 比如，低层面的对象相对于高层面的部分要更加阻塞。也就表示模型w中会给予低层次的对象更低的置信度。</p>
</li>
</ul>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823184337349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400" /></div>
<p></p>


<p>3.3 二值化梯度幅值(BING)</p>
<p>  为了能够利用二值化近似模型[28,59]中的优点，我们提出了一个NG特征的加速版，二值化赋范梯度，加速特征提取和测试过程。我们学习的线性模型w∈R64可以通过算法1近似表示为一系列基向量的组合  $ w ≈  \sum_{j=1}^{N_w} \beta_j \alpha_j$ 。</p>
<p>  其中  $N_w$ 表示基向量的个数，  $\alpha_j∈{ -1,1 }^{64}$ 表示基向量，  $\beta_j∈R$ 表示校准系数。  $\alpha_j$ 可以进一步表示为二值向量和它的补：  $\alpha_j = \alpha_j^+ - \overline{\alpha_j^+}$ , 其中  $\alpha_j^+∈{ 0,1 }^{64}$ ,由  $α$ 二值化之后得到的  $b$ 可以被直接用于测试，而且只需要按位与和字节统计操作[28]</p>
<p>$$<br>&lt; w,b &gt; ≈ \sum_{j=1}^{N_w}\beta_j(2&lt; \alpha_j^+,b&gt;-|b|)  (4)<br>$$</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823184540642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400" /></div>
<p></p>

<p>  关键过程就是如何二值化以及有效的计算NG特征。我们近似采用梯度幅值（以及转化为01字节）的前Ng位来作二值化。因此，64维 NG特征  $g_l$ 值可以通过前Ng位二值化梯度幅值(BING)近似表示为：</p>
<p>$$<br>g_l≈ \sum_{k=1}^{N_g}2^{8-k}b_{k,l}  (5)<br>$$</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823184656137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400" /></div>
<p></p>
Figure 2 变量说明：BING特征  $b_{x,y}$ ,它的最后一行是  $r_{x,y}$ ，最后一个元素  $b_{x,y}$ 。注意出现在式(2)和式(5)中的下标  $i, x, y, l, k,$ 这些是定位整个向量而不是向量元素的索引。我们可以用一个简单的原子变量(INT64和BYTE)表示BING特征和它的最后一行，这样能够更有效的进行特征计算。

<p>  注意：这些BING特征拥有不同的权重，依据它原本不同的字节位。获取8 * 8的BING特征一般需要遍历64位，依据8 * 8 BING特征的两个特征，我们提出了一个快速的特征计算方法，能够只使用一些简单的原子操作（按位或和按位移动）避免循环计算。</p>
<p>  第一，BING特征  $b_{x,y}$ 以及它的最后一行  $r_{x,y}$ 可以存储在一个简单的INT64和一个BYTE变量中；第二，相邻的BING特征以及他们的行之间拥有一个简单的累积关系。如图2，将  $r_{x-1,y}$ 按位移动1位，这1位将自动进位到  $r_{x,y}$ ，插入  $b_{x,y}$ 的过程可以用按位或来实现。同样，将  $b_{x-1,y}$ 按位移动8位，这8位将自动进位到  $b_{x,y}$ ，自动插入  $r_{x,y}$ 。</p>
<p>  我们的BING特征有效的利用了整体图像之间的累积性质[52]。与之前的方法在任意矩形范围内计算一些值不同的是，我们采用一些原子操作在一个固定8 * 8大小范围内计算一系列二进制模式。</p>
<p>  一个图像窗口对应的BING特征  $b_{k,l}$ 的过滤器得分,见式(1),可以表示为：</p>
<p>$$<br>s_l≈ \sum_{j=1}^{N_w}\beta_j\sum_{k=1}^{N_g}C_{j,k}  (6)<br>$$</p>
<p>  其中，  $C_{j,k} = 2^{8-k}(2&lt; \alpha_j^+,b_{k,l}&gt;-|b_{k,l}|)$ 可以通过一些快速的按位操作以及SSE指令操作计算得到。</p>
<p>  实现细节：我们使用一维的标识[-1,0,1]，来定义水平方向和垂直方向上的图像梯度  $g_x$ 和  $g_y$ ，当计算梯度幅值是采用  $min(|g_x|+|g_y|,255)$ ,然后将其存入一个BYTE中。</p>
<p><strong><font color="black" size=5 face="仿宋">4.实验评估</font></strong></p>
<p>  我们在VOC2007数据集上实验评估了我们的方法，使用的是DR和WIN的评估标准，与3个现存最先进的方法建议质量、通用性以及效率上做了对比。正如[3,48]，一系列高检测率的粗糙集对于有效对象检测是足够了的，，而且它允许使用复杂的特征和补充线索来得到比传统方法更好的质量和更高的效率。在对比试验中，我们采用的对应作者公布的实现方式和建议的参数设置。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823185011109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700" /></div>
<p></p>
Figure 3 不同方法关于#WIN和DR的权衡曲线。我们的方法使用1000建议窗口，达到了96.2%DR，使用5000个建议窗口可以达到99.5DR.其他三个方法我们采用了相同的评估标准，可以看出来优于一些其他的方法[6,21,25,30,50]，显著性测量[33，36]，特征点检测[44]以及HOG检测[17].

<p>  建议质量对比：参照[3,48,57]，我们在数据集VOC2007上采用DR-WIN评估测试集，该数据集包含4952张20个类别的带有边框注释图像。数量巨大，种类繁多，视角、尺度、位置、阻塞、光照等都有不同，这些特点非常符合我们识别所有对象的要求。图3展示了数据统计对比，对比的方法有：OBN[3]，SEL[48]，以及CSVM[57]。正如[48]，通过收集不同参数设置下的结果，可以增加建议窗口的离散度，也能提高检测率DR，当然也需要提高建议窗口的数量（#WIN）。SEL[48]组合了80个不同参数设置的结果，达到了99.1%的DR和使用了10000多个建议窗口。我们的方法达到99.5%的DR，但只需要5000个建议窗口，而且仅仅收集了3个颜色空间的结果（RGB，HSV，GRAY）。如同DR-#WIN数据分析展示的那样，我们简单的方法在总体上达到了更好的效果，速率上比最流行的的方法[3,22,48]提升了3个数量级（见表格1），我们举例阐述了一些不同复杂度下的结果，如图4.</p>
<p>  通用性测试：参照[3]，为了证明我们的方法具有通用性，采用包含未训练类别的对象图像进行测试。我们采用6个类别的对象训练我们的方法，通过剩下的14个类别进行测试。图3中，训练和测试是通过BING和BING-generic表示的。正如我们看到了那样，两个曲线基本一致，证明了我们方法的通用性。</p>
<p>  最近的工作[18]能够在20秒内检测100000对象类别，主要采用的是减低传统多类别计算复杂度从O(LC)到O(L),L表示推荐窗口的数量，C表示分类器的数量。我们的方法可以得到任意类别（训练过的以及未训练的）的高质量的推荐窗口，可以通过减小L来显著减少计算复杂度。</p>
<p>  计算时间：见表1，我们的方法可以在300fps的视频中，提供高效率的提供高质量的对象窗口，其他的方法对一张图片都需要几秒。这些方法通常是作为现存最先进的算法，而且很难大幅度的提升速度。我们在2501张图片上的训练需要很少的时间（包括加载XML文件，总共20S），而现有的先进的方法[6,21]测试一张图片通常需要多于2分钟.</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823185136104?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="200" /></div>
<p></p>
Table 1 在VOC2007上的平均计算时间

<p>  如表2，通过采用二进制近似的方法学习线性过滤器和BING特征提取，计算每个图像窗口的得分只需要一些原子操作。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823185234675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="300" /></div>
<p></p>
Table 2 用于计算不同阶段每个图像窗口的对象的平均原子操作数：计算规范梯度，提取BING特征，并获得对象分数。

<p>  在每个标准化的尺度和纵横比下，定位的数量相当于O（N），N代表图像中的像素数.因此，在所有尺寸和纵横比的图像中，计算得分的复杂度也是O(N)。在每一个潜在的位置上，提取BING特征和计算得分可以利用它邻近的2个位置(例如：左和上)。这意味着空间复杂度也是O(N)。我们在同一个Intel i7-3940XM CPU上，对比其他基准方法[3,2，，48,57]的运行时间。</p>
<p>  如表3，我们可以进一步意识到，不同的近似对结果质量的影响，通过对比我们在其他试验中采用Nw=2，Ng=4.</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823185400065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="250" /></div>
<p></p>
Table 3 在不同近似层下的，平均检测结果（DR，使用1000个建议窗口），控制（Nw和Ng），N/A表示没有近似。

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170823185822979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700" /></div>
<p></p>
Figure 4 在VOC2007上的真实的测试样例。

<p><strong><font color="black" size=5 face="仿宋">5.结论以及将来的工作</font></strong></p>
<p>  我们呈现了一个非常简单，快速而且高质量的objectness方法，通过采用BING特征，计算任意尺度和纵横比的图像窗口中，我们仅仅需要一些原子操作（加，按位等）。通过最广泛的基准（VOC2007）和DR-#WIN评估标准进行结果评价，结果表明，与其他现存先进方法[3,22,48]相比，我们的方法不仅表现突出，而且速度上提升了3个数量级。</p>
<p>  局限性： 与其他objectness方法[3,57]和滑动窗口[17,25]一样，我们都预测了一系列的对象矩形边框，因此，也有相似的局限性，对于一些类别的对象，一个矩形框并不能很好的集中实体，以便用来进行区域分割[6,21,33,45]，例如蛇。</p>
<p>  进一步的工作：由于我们的方法具备高质量以及高效率的特性，所以它很适合实时多类别的对象检测和大规模图像收集应用程序（如：ImageNet[19]）。由于使用的简单的二进制操作，而且空间效率高，使得我们的方法可以在普通的设备上运行[28,59]。</p>
<p>  我们的加速策略主要是减少窗口数量，这个可以通过其他的加速技术（通常旨在减少分类时间）来实现。将我们的方法和[18]的方法的进行组合将是很有趣的这样能够在一个机器上实时检测数以千计类别的对象。我们的方法解决了基于对象检测方法[53]的效率屏障，使得能够进行实时的高质量的对象检测。</p>
<p>  通过使用简单的BING特征，我们能够使用一小部分（1000）的建议窗口得到涵盖几乎（96.2%）所有的对象区域。引入新的线索进一步降低建议窗口的数量，以便维持高效率的对象检测，以及在更多的应用程序[9]上使用BING特征，将是很值得研究的。</p>
]]></content>
      <categories>
        <category>BING</category>
      </categories>
      <tags>
        <tag>BING</tag>
      </tags>
  </entry>
  <entry>
    <title>我的个人博客之旅：从jekyll到hexo</title>
    <url>/folder/2019/11/08/2018-01-10-HEXO/</url>
    <content><![CDATA[<hr>
<p>[toc]</p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;喜欢写Blog的人，会经历三个阶段。</p>
<ul>
<li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</li>
<li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li>
<li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li>
</ul>
<p>引自<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">阮一峰</a></p>
<p>&emsp;&emsp;第一阶段我已经经历过了，目前在CSDN的文章仍然在更新。但是作为一个免费空间，一个技术博客的聚集地，其管理和运营虽说正在变得越来越好，但是恶心人的事件也时有发生，比如对新手不友好的审核机制、近期改版造成的各种不兼容问题。</p>
<p>&emsp;&emsp;于是，就想着挣脱枷锁，向第二第三阶段发展。</p>
<p>&emsp;&emsp;我这人吧凡事都考虑的比较详尽，，我感觉我如果再去经历第二阶段的话既浪费精力又消耗时间，而且自己也过了玩网站、玩博客的年纪，如果申请个域名再搞个网站，我不知道这股热度会持续多久。</p>
<p>&emsp;&emsp;所以，我就直接跳到了第三个阶段，开始在github上搭建自己的博客。由于自己对前端一无所知，即使使用现成的博客框架，刚开始玩的时候特别费劲。但是经过不断摸索，我的博客已经基本成型，传送门开启：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a> <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于gitee</a>。</p>
<p>&emsp;&emsp;本篇博文并不打算长篇大论的介绍基于GitHub Pages或者Gitee Pages搭建博客的步骤，因为这类的文章实在是太多了，青菜萝卜又各有所爱，不如给出资源，让大家自己折腾。所以我只是在此有序贴出我在搭建博客的过程中用到的各种有用资源，以及搭建博客的大致流程，也算是对我这段时间的一个告别仪式吧。</p>
<h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>&emsp;&emsp;我想在GitHub Pages推出之前，由于技术门槛的存在，第三个阶段应该会很少有人涉足。所以在开始一切之前，我们先来看看什么是<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>。</p>
<p>&emsp;&emsp;Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。Github Pages 支持 自动利用 Jekyll 生成站点，也同样支持纯 HTML 文档，将你的 Jekyll 站 点托管在 Github Pages 上是一个不错的选择。</p>
<p>&emsp;&emsp;网站首页就是搭建GitHub Pages的过程其中第一步之后，选择不同的git客户端选项，会出现相应的初始化步骤，很人性化。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110111003603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;大家可以跟着上面的链接先在自己的github新建仓库，仓库名称为username.github.io，其中username要替换成你github的名称，比如我的github名称为wordzzzz，所以我新建的仓库就应该是wordzzzz.github.io。那么等我以后搭建好了我的博客，我就可以通过<a href="https://wordzzzz.github.io来访问我的主页了。" target="_blank" rel="noopener">https://wordzzzz.github.io来访问我的主页了。</a></p>
<p>&emsp;&emsp;到现在为止，只是搭建博客的准备工作。搭建博客的下一步是选择合适的静态博客框架。</p>
<h2 id="jekyll-or-hexo"><a href="#jekyll-or-hexo" class="headerlink" title="jekyll or hexo"></a>jekyll or hexo</h2><p>&emsp;&emsp;目前有两大静态博客主流框架：<a href="http://jekyllcn.com/" target="_blank" rel="noopener">jekyll</a>和<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110111311091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110111420247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;我一开始用的是jekyll，这是中文社区翻译出来的<a href="http://jekyllcn.com/" target="_blank" rel="noopener">中文开发文档</a>。我使用的主题是<a href="https://mmistakes.github.io/minimal-mistakes/" target="_blank" rel="noopener">Minimal Mistakes</a>，开发文档很详细。但是后来由于jekyll体验不是很好（中文资料少，我英语比较差我会说嘛），依赖环境总是出问题（需要安装ruby），markdown采用的是Kramdown（Kramdown对我之前的一些博客格式支持的不是很好，我自己写文档用的都是小书匠，然后发表到CSDN，所以并不想花时间在改格式上面），而且我使用的这个主题是个人维护的，种种原因导致最后做出来的博客很难符合我的胃口，最后被我扔进了停尸房<a href="https://github.com/WordZzzz/jekyll_mysite" target="_blank" rel="noopener">jekyll_mysite</a>。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110111512090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110111533728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;就在我将要放弃之时，hexo拯救了我。对，没错，它有<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">中文开发文档</a>。而在hexo界，使用最多的主题就是<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>了。光是看到这两份资料，我就已经激动的不行了，这种扁平化设计的网站，不就正是我需要的么。加上详尽的开发文档和丰富的第三方接口，让我对它爱不释手。最终定稿了自己的个人博客，存储在github<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a>和gitee<a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于gitee</a>上。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110142732584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110142739639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h2><p>&emsp;&emsp;next主题支持三种外观显示，支持多国语言，5套代码高亮主题，可以深度定制。在其<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Github</a>上，更是有三个主题的代表作，其中我最喜欢的莫过于基于Muse scheme的<a href="https://notes.wanghao.work/" target="_blank" rel="noopener">wanghao的博客</a>。于是，我就在wanghao的博客的基础上进行了相应的更改，形成了我现在的博客，主题文件全部在我的<a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">github</a>上，欢迎大家fork、star、follow。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180110114341558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;其实先按照hexo配置开发环境，再按照next文档配置站点文件，完全可以轻松搭建起自己的博客。但是还是藏不住内心那颗年轻的心啊，终究还是搜罗了一些好玩的东西放到了自己的博客上，比如音乐播放器。</p>
<p>&emsp;&emsp;下面我先简单介绍一下基于github平台、hexo框架的next主题博客开发步骤：</p>
<ul>
<li><a href="">Github上新建username.github.io仓库并初始化</a></li>
<li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">PC端安装hexo及其依赖项并熟悉开发流程</a></li>
<li><a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">下载我的主题文件</a>或者<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">下载next主题文件</a></li>
<li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">按照next官方教程验证主题</a></li>
<li><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">按照next官方教程配置站点文件和主题文件</a></li>
<li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">按照next官方教程集成第三方服务</a></li>
<li><a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="noopener">生成静态文件</a></li>
<li><a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">开启本地服务查看站点效果</a></li>
<li><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">部署至Github</a></li>
</ul>
<p>&emsp;&emsp;文档都非常详细，下面我主要就第三方服务做一些说明。我提到的大部分三方服务在<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>都提及到了，所以具体配置大家跟着官方文档走就行，我只是为每一类服务选择哪个做一下建议。</p>
<h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>&emsp;&emsp;我用的韩国的<a href="https://livere.com/" target="_blank" rel="noopener">livere</a>，从国内到国外，支持几乎全部社交账号登陆，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p>
<h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><p>&emsp;&emsp;<a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>和<a href="https://www.google.com/intl/zh-CN/analytics/" target="_blank" rel="noopener">google分析</a>我都加上了，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p>
<h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h3><p>&emsp;&emsp;我用的<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>，具体操作步骤请直接跳转至<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener"> 为NexT主题添加文章阅读量统计功能</a>。</p>
<h3 id="内容分享服务"><a href="#内容分享服务" class="headerlink" title="内容分享服务"></a>内容分享服务</h3><p>&emsp;&emsp;我采用的是<a href="https://github.com/revir/need-more-share2" target="_blank" rel="noopener">need-more-share2</a>，直接在主题配置文件里面打开就行。</p>
<h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3><p>&emsp;&emsp;我采用的是<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p>
<h3 id="网站收录"><a href="#网站收录" class="headerlink" title="网站收录"></a>网站收录</h3><p>&emsp;&emsp;<a href="https://www.google.com/webmasters/tools/" target="_blank" rel="noopener">Google Webmaster tools</a>收录特别快，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。但是<a href="http://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">百度站长</a>收录的就很慢了，我的到现在还没被收录。</p>
<h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><p>&emsp;&emsp;NexT 借助于 MathJax 来显示数学公式，此选项默认关闭，如果博客中有公式，那么一定要打开这个选项。</p>
<h2 id="next进阶"><a href="#next进阶" class="headerlink" title="next进阶"></a>next进阶</h2><p>&emsp;&emsp;最后想说一下其他一些配置，比如添加背景图片、侧边栏头像旋转、侧边栏鼠标滑入显示、背景音乐等等，此处大部分参考<a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">这个博客</a>。</p>
<p>&emsp;&emsp;next人性化的为用户提供了custom接口，我们可以在不影响主题文件的基础上进行个性化定制。</p>
<h3 id="给页面添加背景图片"><a href="#给页面添加背景图片" class="headerlink" title="给页面添加背景图片"></a>给页面添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(/images/blogbk.jpg) no-repeat;</span><br><span class="line">  <span class="comment">/* 背景图垂直、水平均居中 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="comment">/* 设置背景颜色，背景图加载过程中会显示背景色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中的css样式属性都可以根据你的自定义图片来更改，以达到最佳的效果。</p>
<h3 id="给侧边栏添加背景图片"><a href="#给侧边栏添加背景图片" class="headerlink" title="给侧边栏添加背景图片"></a>给侧边栏添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">            background:url(/images/sidebar.jpg);</span><br><span class="line">            <span class="attribute">background-size</span>: cover;</span><br><span class="line">            <span class="attribute">background-position</span>:center;</span><br><span class="line">            <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">            <span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文字背景色以及半透明的设置"><a href="#文字背景色以及半透明的设置" class="headerlink" title="文字背景色以及半透明的设置"></a>文字背景色以及半透明的设置</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">			<span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中border-radius是给文章背景设置圆角，margin-top是设置文章到顶部的距离，其中属性可根据自己的需要进行调整。</p>
<h3 id="评论-来必力-添加背景色"><a href="#评论-来必力-添加背景色" class="headerlink" title="评论(来必力)添加背景色"></a>评论(来必力)添加背景色</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#lv-container</span> &#123;</span><br><span class="line">       <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">	   <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">       <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;和上面一样，背景色和圆角可自己调整更改。</p>
<h3 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h3><p>&emsp;&emsp;在网址输入如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="侧边栏头像旋转"><a href="#侧边栏头像旋转" class="headerlink" title="侧边栏头像旋转"></a>侧边栏头像旋转</h3><p>&emsp;&emsp;打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$site</span>-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="variable">$site</span>-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$site</span>-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$site</span>-author-image-border-width solid <span class="variable">$site</span>-author-image-border-color;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* start*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line">  webkit-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  moz-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  ms-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="comment">/* end */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start */</span></span><br><span class="line"><span class="selector-class">.site-author-image</span>:hover &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#55DAE1</span>;</span><br><span class="line">  webkit-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  moz-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  ms-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br></pre></td></tr></table></figure>

<h3 id="设置鼠标划入侧边栏才显示站点信息："><a href="#设置鼠标划入侧边栏才显示站点信息：" class="headerlink" title="设置鼠标划入侧边栏才显示站点信息："></a>设置鼠标划入侧边栏才显示站点信息：</h3><h4 id="设置自定义div"><a href="#设置自定义div" class="headerlink" title="设置自定义div"></a>设置自定义div</h4><p>&emsp;&emsp;在theme/next/layout/_macro文件夹下打开sidebar.swig文件，找到以下代码行的位置：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"site-state motion-element"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在其上添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.0/velocity.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">"#sidebar"</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#mydivshow"</span>).velocity(<span class="string">'stop'</span>).velocity(&#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;);</span></span><br><span class="line"><span class="actionscript">  &#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#mydivshow"</span>).velocity(<span class="string">'stop'</span>).velocity(&#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mydivshow"</span> <span class="attr">class</span>=<span class="string">"mydivshow"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后找到代码行：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在此</section>的上方添加一个</div>，如下所示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-toc"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义区域的初始化设置"><a href="#自定义区域的初始化设置" class="headerlink" title="自定义区域的初始化设置"></a>自定义区域的初始化设置</h4><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，向里面增添下列代码：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">#mydivshow&#123;<span class="attribute">opacity</span>: <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure>

<p>注：具体代码添加位置以及代码里的section.site-overview可以自己修改，<div id="mydivshow" class="mydivshow">和末尾的</div>是控制显示区域，section.site-overview则是用户鼠标滑入划出时的触发事件区域。</p>
<h3 id="自定义音乐播放器"><a href="#自定义音乐播放器" class="headerlink" title="自定义音乐播放器"></a>自定义音乐播放器</h3><p>&emsp;&emsp;描述：本站所用的音乐播放器是由DIYgod所制作的APlayer，其详细资料可参见<a href="https://aplayer.js.org/docs/#/" target="_blank" rel="noopener">这里</a>。</p>
<h4 id="安装APlayer插件"><a href="#安装APlayer插件" class="headerlink" title="安装APlayer插件"></a>安装APlayer插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install aplayer --save</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;安装完后在node_modules目录下找到APlayer.min.js文件，将其复制到theme/next/source/js/src/目录下。</p>
<h4 id="生成音乐播放器"><a href="#生成音乐播放器" class="headerlink" title="生成音乐播放器"></a>生成音乐播放器</h4><p>&emsp;&emsp;在你想要加入音乐播放器的地方插入以下代码，本站把他放在了侧边栏里，具体操作如下。</p>
<p>&emsp;&emsp;打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"player1"</span> <span class="attr">class</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> ap = <span class="keyword">new</span> APlayer(&#123;</span></span><br><span class="line"><span class="javascript">    element: <span class="built_in">document</span>.getElementById(<span class="string">'player1'</span>),                       <span class="comment">// Optional, player element</span></span></span><br><span class="line"><span class="actionscript">    narrow: <span class="literal">false</span>,                                                     <span class="comment">// Optional, narrow style</span></span></span><br><span class="line"><span class="actionscript">    autoplay: <span class="literal">false</span>,                                                    <span class="comment">// Optional, autoplay song(s), not supported by mobile browsers</span></span></span><br><span class="line"><span class="actionscript">    showlrc: <span class="number">0</span>,                                                        <span class="comment">// Optional, show lrc, can be 0, 1, 2, see: ###With lrc</span></span></span><br><span class="line"><span class="actionscript">    mutex: <span class="literal">true</span>,                                                       <span class="comment">// Optional, pause other players when this player playing</span></span></span><br><span class="line"><span class="actionscript">    theme: <span class="string">'#e6d0b2'</span>,                                                  <span class="comment">// Optional, theme color, default: #b7daff</span></span></span><br><span class="line"><span class="actionscript">    mode: <span class="string">'random'</span>,                                                    <span class="comment">// Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`</span></span></span><br><span class="line"><span class="actionscript">    preload: <span class="string">'metadata'</span>,                                               <span class="comment">// Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'</span></span></span><br><span class="line"><span class="actionscript">    listmaxheight: <span class="string">'513px'</span>,                                             <span class="comment">// Optional, max height of play list</span></span></span><br><span class="line"><span class="actionscript">    music: &#123;                                                           <span class="comment">// Required, music info, see: ###With playlist</span></span></span><br><span class="line"><span class="actionscript">        title: <span class="string">'你曾是少年'</span>,                                          <span class="comment">// Required, music title</span></span></span><br><span class="line"><span class="actionscript">        author: <span class="string">'cover'</span>,                                              <span class="comment">// Required, music author</span></span></span><br><span class="line"><span class="actionscript">        url: <span class="string">'http://mp3.qqmusic.cc/yq/102426570.mp3'</span>,                <span class="comment">// Required, music url</span></span></span><br><span class="line"><span class="actionscript">        pic: <span class="string">'/images/visitor.jpg'</span>,                                   <span class="comment">// Optional, music picture</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里的歌曲url必须是在线音乐，当时现在大部分播放器都不会曝露出真实的歌曲播放地址，找资源很是费劲。这里给大家推荐一个<a href="http://www.qqmusic.cc/" target="_blank" rel="noopener">解析平台</a>，大部分的qq音乐还是可以解析出来或者直接在该平台上找到播放链接的。大家可以写多个music结构，以此来添加多个音乐。</p>
<p>&emsp;&emsp;当然，我们还可以通过添加网易云音乐外链的方式在我们的博客中添加音乐。打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"music163player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=458789090&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;替换上述代码中的iframe标签之间的内容，就可以替换不同的音乐进行播放了。网易云音乐的歌单也可以生成外链，前提是歌单里的歌曲都有版权哦~</p>
<h4 id="自定义播放器样式"><a href="#自定义播放器样式" class="headerlink" title="自定义播放器样式"></a>自定义播放器样式</h4><p>&emsp;&emsp;包含颜色更改，列表歌曲信息的排版修改。</p>
<p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span>:hover &#123;   <span class="comment">/*列表悬停颜色*/</span></span><br><span class="line">                  <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span> &#123;   <span class="comment">/*列表底色*/</span></span><br><span class="line">                        <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list-light</span> &#123;   <span class="comment">/*列表播放歌曲颜色*/</span></span><br><span class="line">                      <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-id">#player1</span> &#123;    <span class="comment">/*边框样式*/</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">          <span class="selector-tag">div</span>,<span class="selector-tag">ol</span> &#123;<span class="attribute">border-radius</span>: <span class="number">6px</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="selector-id">#player1</span> *&#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;    <span class="comment">/*字体颜色*/</span></span><br><span class="line"><span class="comment">/*列表歌曲信息的排版*/</span></span><br><span class="line">.aplayer-list-index&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-title&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-author&#123;<span class="attribute">float</span>:right;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义萌萌哒音乐播放控制边栏"><a href="#自定义萌萌哒音乐播放控制边栏" class="headerlink" title="自定义萌萌哒音乐播放控制边栏"></a>自定义萌萌哒音乐播放控制边栏</h3><p>&emsp;&emsp;这一步要在自定义音乐播放器的配置完成之后才能进行，因为aplayer-controler依赖于aplayer来实现播放功能。</p>
<h4 id="安装aplayer-controler插件"><a href="#安装aplayer-controler插件" class="headerlink" title="安装aplayer-controler插件"></a>安装aplayer-controler插件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install aplayer-controler --save</span><br></pre></td></tr></table></figure>

<h4 id="添加js代码"><a href="#添加js代码" class="headerlink" title="添加js代码"></a>添加js代码</h4><p>&emsp;&emsp;安装APlayer-Controler的js文件：<a href="https://github.com/Mashiro-Sorata/APlayer-Controler/blob/master/demo/src/Aplayer-Controler.js" target="_blank" rel="noopener">APlayer-Controler.js</a></p>
<p>&emsp;&emsp;将其放入theme/next/source/js/src下。</p>
<h4 id="创建按钮区域"><a href="#创建按钮区域" class="headerlink" title="创建按钮区域"></a>创建按钮区域</h4><p>&emsp;&emsp;在theme/next/layout/_custom/文件夹下新建一个myapcontroler.swig的文件。向其中添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/Aplayer-Controler.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"AP-controler"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> myapc=<span class="keyword">new</span> APlayer_Controler(&#123;</span></span><br><span class="line"><span class="javascript">		APC_dom:$(<span class="string">'#AP-controler'</span>),</span></span><br><span class="line"><span class="actionscript">		aplayer:ap, <span class="comment">//此为绑定的aplayer对象</span></span></span><br><span class="line"><span class="actionscript">		attach_right:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">		position:&#123;top:<span class="string">'300px'</span>,bottom:<span class="string">''</span>&#125;,</span></span><br><span class="line"><span class="actionscript">		fixed:<span class="literal">true</span>,</span></span><br><span class="line">		btn_width:100,</span><br><span class="line">		btn_height:120,</span><br><span class="line"><span class="actionscript">		img_src:[<span class="string">'http://oty1v077k.bkt.clouddn.com/bukagirl.jpg'</span>,</span></span><br><span class="line"><span class="actionscript">				<span class="string">'http://oty1v077k.bkt.clouddn.com/jumpgirl.jpg'</span>,</span></span><br><span class="line"><span class="actionscript">				<span class="string">'http://oty1v077k.bkt.clouddn.com/pentigirl.jpg'</span>,</span></span><br><span class="line"><span class="actionscript">				<span class="string">'http://oty1v077k.bkt.clouddn.com/%E8%90%8C1.gif'</span>],</span></span><br><span class="line"><span class="actionscript">		img_style:&#123;repeat:<span class="string">'no-repeat'</span>,position:<span class="string">'center'</span>,size:<span class="string">'contain'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">		ctrls_color:<span class="string">'rgba(173,255,47,0.8)'</span>,</span></span><br><span class="line"><span class="actionscript">		ctrls_hover_color:<span class="string">'rgba(255,140,0,0.7)'</span>,</span></span><br><span class="line"><span class="actionscript">		tips_on:<span class="literal">true</span>,</span></span><br><span class="line">		tips_width:140,</span><br><span class="line">		tips_height:25,</span><br><span class="line"><span class="actionscript">		tips_color:<span class="string">'rgba(255,255,255,0.6)'</span>,</span></span><br><span class="line">		tips_content:&#123;&#125;,</span><br><span class="line">		timeout:30</span><br><span class="line">	&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="将控制按钮加入body页面"><a href="#将控制按钮加入body页面" class="headerlink" title="将控制按钮加入body页面"></a>将控制按钮加入body页面</h4><p>&emsp;&emsp;在theme/next/layout文件夹下打开_layout.swig文件，在</body>前添加以下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% include '_custom/myapcontroler.swig' %&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;到此，自定义音乐播放控制边栏就基本完成，完成整个配置需要根据自己的主题背景进一步修改完善。</p>
<hr>
<p><strong><font color="red" size=3 face="仿宋">本教程到此结束，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>jekyll</tag>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序综述</title>
    <url>/folder/2019/11/08/2018-01-09-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort</a></strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;剑指offer刷完了，是时候总结一波数据结构与算法了。本系列文章暂定包括数据结构中树和图的各种操作，以及查找、排序等基本算法和动态规划等高级算法。本系列文章只是作为总结性的文献，为自己日后的面试做准备。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;直接引自维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">排序算法</a>。总结性强。</p>
<p>&emsp;&emsp;在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p>
<ul>
<li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li>
<li>输出结果是原输入的一种排列、或是重组</li>
</ul>
<p>&emsp;&emsp;虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表）</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>&emsp;&emsp;在计算机科学所使用的排序算法通常被分类为：</p>
<ul>
<li>计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，坏的性能是O(n2)。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(n log n)。</li>
<li>内存使用量（以及其他电脑资源的使用）</li>
<li>稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</li>
<li>依据排序的方法：插入、交换、选择、合并等等。</li>
</ul>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>&emsp;&emsp;当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(4, 1)  (3, 1)  (3, 7)（5, 6）</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(3, 1)  (3, 7)  (4, 1)  (5, 6)  （维持次序）</span><br><span class="line">(3, 7)  (3, 1)  (4, 1)  (5, 6)  （次序被改变）</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。实现的一个方式是人工扩充键值的比较（比如上面的比较中加入第二个标准：第二个键值的大小），从而在键值相同的两个对象之间进行比较时，使用在原先数据次序中的条目。然而，要记录这种次序通常牵涉到额外的空间负担。</p>
<h3 id="排序算法列表"><a href="#排序算法列表" class="headerlink" title="排序算法列表"></a>排序算法列表</h3><p>&emsp;&emsp;在这个表格中，n是要被排序的纪录数量以及k是不同键值的数量。</p>
<h4 id="稳定的排序"><a href="#稳定的排序" class="headerlink" title="稳定的排序"></a>稳定的排序</h4><ul>
<li>冒泡排序（bubble sort）— O(n2)</li>
<li>插入排序（insertion sort）— O(n2)</li>
<li>鸡尾酒排序（cocktail sort）— O(n2)</li>
<li>桶排序（bucket sort）— O(n)；需要O(k)额外空间</li>
<li>计数排序（counting sort）— O(n+k)；需要O(n+k)额外空间</li>
<li>归并排序（merge sort）— O(n log n)；需要O(n)额外空间</li>
<li>原地归并排序 — O(n log2 n)如果使用最佳的现在版本</li>
<li>二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间</li>
<li>鸽巢排序（pigeonhole sort）— O(n+k)；需要O(k)额外空间</li>
<li>基数排序（radix sort）— O(n·k)；需要O(n)额外空间</li>
<li>侏儒排序（gnome sort）— O(n2)</li>
<li>图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间</li>
<li>块排序（block sort）— O(n log n)</li>
</ul>
<h4 id="不稳定的排序"><a href="#不稳定的排序" class="headerlink" title="不稳定的排序"></a>不稳定的排序</h4><ul>
<li>选择排序（selection sort）— O(n2)</li>
<li>希尔排序（shell sort）— O(n log2 n)如果使用最佳的现在版本</li>
<li>Clover排序算法（Clover sort）— O(n)期望时间，O(n2)最坏情况</li>
<li>梳排序 — O(n log n)</li>
<li>堆排序（heap sort）— O(n log n)</li>
<li>平滑排序（smooth sort）— O(n log n)</li>
<li>快速排序（quick sort）— O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序</li>
<li>内省排序（introsort）—O (n log n)</li>
<li>耐心排序（patience sort）— O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence）</li>
</ul>
<h4 id="不实用的排序"><a href="#不实用的排序" class="headerlink" title="不实用的排序"></a>不实用的排序</h4><ul>
<li>Bogo排序 — O(n × n!)，最坏的情况下期望时间为无穷</li>
<li>Stupid排序 — O(n3);递归版本需要O(n2)额外内存</li>
<li>珠排序（bead sort）— O(n) or O(√n),但需要特别的硬件</li>
<li>煎饼排序 — O(n),但需要特别的硬件</li>
<li>臭皮匠排序（stooge sort）算法简单，但需要约n^2.7的时间</li>
</ul>
<hr>
<p>==概述到此结束，下面分八篇文章依次对典型的八种排序进行图文并茂的讲解和c++实现。==</p>
<hr>
<p>&emsp;&emsp;先贴一下八大排序的性能概括图：</p>
<p>&emsp;&emsp;再贴出来以后要用到的main函数和头文件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="comment">//	double arr[] = &#123;4.5, 2.3,6.7, 3.5, 1.1&#125;;</span></span><br><span class="line"><span class="comment">//	const int len = sizeof(arr) / sizeof(arr[0]);</span></span><br><span class="line"><span class="comment">//	BubbleSort(arr, len);</span></span><br><span class="line"><span class="comment">//	BubbleSort1(arr, len);</span></span><br><span class="line"><span class="comment">//	BubbleSort2(arr, len);</span></span><br><span class="line"><span class="comment">//	BubbleSort3(arr, len);</span></span><br><span class="line"><span class="comment">//	InsertSort(arr, len);</span></span><br><span class="line"><span class="comment">//	ShellSort(arr, len);	</span></span><br><span class="line"><span class="comment">//	QuickSort(arr, len);</span></span><br><span class="line"><span class="comment">//	QuickSortIteration(arr, len);</span></span><br><span class="line"><span class="comment">//	SelectSort(arr, len);	</span></span><br><span class="line"><span class="comment">//	HeapSort(arr, len);		</span></span><br><span class="line"><span class="comment">//	MergeSort(arr, len); </span></span><br><span class="line">	MergeSortIteration(arr, len);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">	&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后就要打开传送门了：</p>
<p>csdn告诉我今天上传博客的次数到达上限了，然而我还有两个没有上传，那我只好先引流到我的个人博客了。</p>
<ul>
<li><a href="https://wordzzzz.github.io/2018/01/01/DS/" target="_blank" rel="noopener">插入排序</a>：（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。</li>
<li><a href="https://wordzzzz.github.io/2018/01/02/DS/" target="_blank" rel="noopener">希尔排序</a>：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。</li>
<li><a href="https://wordzzzz.github.io/2018/01/03/DS/" target="_blank" rel="noopener">选择排序</a>：（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。</li>
<li><a href="https://wordzzzz.github.io/2018/01/04/DS/" target="_blank" rel="noopener">堆排序</a>：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。</li>
<li><a href="https://wordzzzz.github.io/2018/01/05/DS/" target="_blank" rel="noopener">冒泡排序</a>：（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</li>
<li><a href="https://wordzzzz.github.io/2018/01/06/DS/" target="_blank" rel="noopener">快速排序</a>：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</li>
<li><a href="https://wordzzzz.github.io/2018/01/07/DS/" target="_blank" rel="noopener">归并排序</a>：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>可从上到下或从下到上进行。</li>
<li><a href="https://wordzzzz.github.io/2018/01/08/DS/" target="_blank" rel="noopener">基数排序</a>：一种多关键字的排序算法，可用桶排序实现。</li>
</ul>
<p>参考链接：<br><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a><br><a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener">数据结构与算法可视化可视化</a><br><a href="http://www.cnblogs.com/skywang12345/category/508186.html" target="_blank" rel="noopener">数据结构与算法</a><br><a href="http://www.open-open.com/lib/view/open1404781467544.html" target="_blank" rel="noopener">排序算法可视化</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">经典排序算法总结与实现</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之基数排序</title>
    <url>/folder/2019/11/08/2018-01-08-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。</p>
<p>&emsp;&emsp;基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;它是这样实现的：</p>
<ul>
<li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li>
<li>然后，从最低位开始，依次进行一次排序。</li>
<li>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</li>
</ul>
<p>&emsp;&emsp;基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180109153959062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="radixsort from wordzzzz"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取数组a中最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, max;</span><br><span class="line"></span><br><span class="line">	max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max)</span><br><span class="line">			max = <span class="built_in">array</span>[i];</span><br><span class="line">	<span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对数组按照"某个位数"进行排序(桶排序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	T* output = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> i, buckets[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)					<span class="comment">// 将数据出现的次数存储在buckets[]中</span></span><br><span class="line">		buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)						<span class="comment">// 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span></span><br><span class="line">		buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)				<span class="comment">// 将数据存储到临时数组output[]中，这里的对应关系一定要捋清楚</span></span><br><span class="line">		output[--buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)					<span class="comment">// 将排序好的数据赋值给array[]</span></span><br><span class="line">		<span class="built_in">array</span>[i] = output[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">exp</span>;										<span class="comment">// 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；...</span></span><br><span class="line">	<span class="keyword">int</span> max = get_max(<span class="built_in">array</span>, length);				<span class="comment">// 数组array中的最大值</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">exp</span> = <span class="number">1</span>; max / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>)			<span class="comment">// 从个位开始，对数组array按"指数"进行排序</span></span><br><span class="line">		count_sort(<span class="built_in">array</span>, length, <span class="built_in">exp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    数组</li>
<li>平均时间复杂度 $O(d*(n+r))$</li>
<li>最好情况 $O(d*(n+r))$</li>
<li>最坏情况 $O(d*(n+r))$</li>
<li>空间复杂度 $O(n+r)$</li>
</ul>
<p>&emsp;&emsp;其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;如果捋不清上述代码中的数组对应关系，可以参考一下下面这两张图的讲解，来源：<a href="http://www.cnblogs.com/skywang12345/p/3603669.html。" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3603669.html。</a></p>
<ul>
<li>个位的数值范围是[0,10)。因此，参见桶数组buckets[]，将数组按照个位数值添加到桶中。</li>
</ul>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180109154616722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step1"/></div>
<p></p>

<ul>
<li>接着是根据桶数组buckets[]来进行排序。假设将排序后的数组存在output[]中；找出output[]和buckets[]之间的联系就可以对数据进行排序了。</li>
</ul>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180109154657318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step2"/></div>
<p></p>

<p>&emsp;&emsp;基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p>
<p>&emsp;&emsp;基数排序 vs 计数排序 vs 桶排序</p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>基数排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之归并排序</title>
    <url>/folder/2019/11/08/2018-01-07-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 ${\displaystyle O(n\log n)}$ 。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p>
<p>递归法（Bottom-up）<br>原理如下（假设序列共有 ${\displaystyle n}$ 个元素）：</p>
<ul>
<li>将序列每相邻两个数字进行归并操作，形成 ${\displaystyle ceil(n/2)}$ 个序列，排序后每个序列包含两/一个元素。</li>
<li>若此时序列数不是1个则将上述序列再次归并，形成 ${\displaystyle ceil(n/4)}$个序列，每个序列包含四/三个元素。</li>
<li>重复步骤2，直到所有元素排序完毕，即序列数为1。</li>
</ul>
<p>迭代法（Top-down）</p>
<ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</li>
<li>重复步骤3直到某一指针到达序列尾。</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180109111825567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="merge from wikipedia"/></div>
<p></p>

<p>&emsp;&emsp;wordzzzz的小数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180109111851701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line">	<span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line">	<span class="keyword">int</span> k = left;</span><br><span class="line">	<span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">		reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line">	<span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">		reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line">	<span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">		reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line">	<span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line">		<span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">	MergeSortRecursive(<span class="built_in">array</span>, reg, left, mid);		<span class="comment">//左序列排序</span></span><br><span class="line">	MergeSortRecursive(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);	<span class="comment">//右序列排序</span></span><br><span class="line">	Merge(<span class="built_in">array</span>, reg, left, mid, right);			<span class="comment">//合并左右序列</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	MergeSortRecursive(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;												<span class="comment">//步长，每次翻倍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line">			<span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line">			<span class="keyword">int</span> k = low;</span><br><span class="line">			<span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line">			<span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line">			<span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)											<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">				regB[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line">			<span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">				regB[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line">			<span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">				regB[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line">		&#125;			</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)														<span class="comment">//更新array</span></span><br><span class="line">			<span class="built_in">array</span>[i] = regB[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    数组</li>
<li>最坏时间复杂度    ${\displaystyle O(n\log n)}$ </li>
<li>最优时间复杂度    ${\displaystyle O(n)}$ </li>
<li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li>
<li>空间复杂度    ${\displaystyle O(n)}$</li>
</ul>
<p>&emsp;&emsp;比较操作的次数介于 ${\displaystyle (n\log n)/2}$ 和 ${\displaystyle n\log n-n+1}$ 。 赋值操作的次数是 ${\displaystyle (2n\log n)}$ 。归并算法的空间复杂度为： ${\displaystyle \Theta (n)}$。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;对于归并排序有几点说明：</p>
<ul>
<li>和快速排序一样，归并排序在小数组上面的表现不如插入排序。</li>
<li>辅助数组是一个共用的数组。如果在每个归并的过程中都申请一个临时数组会造成比较大的时间开销。</li>
<li>归并的过程需要将元素复制到辅助数组，再从辅助数组排序复制回原数组，会拖慢排序速度。</li>
</ul>
<p>&emsp;&emsp;归并排序有以下几点优化方法：</p>
<ul>
<li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用。（代码见下面的归并排序递归版优化）</li>
<li>在merge()调用之前，可以判断一下a[mid]是否小于等于a[mid+1]。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么a[mid]是第一个子数组的最大值，a[mid+1]是第二个子数组的最小值。当a[mid]&lt;=a[mid+1]时，数组整体有序。</li>
<li>为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。（代码见下面的归并排序迭代版优化）</li>
</ul>
<h4 id="递归版优化"><a href="#递归版优化" class="headerlink" title="递归版优化"></a>递归版优化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版合并函数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line">	<span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line">	<span class="keyword">int</span> k = left;</span><br><span class="line">	<span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">		reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line">	<span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">		reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line">	<span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">		reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line">	<span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line">		<span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序递归版递归函数优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive1</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (right - left &lt;= M)								<span class="comment">//序列长度小于阈值就采用插入排序</span></span><br><span class="line">		InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">		MergeSortRecursive1(<span class="built_in">array</span>, reg, left, mid);		<span class="comment">//左序列排序</span></span><br><span class="line">		MergeSortRecursive1(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);	<span class="comment">//右序列排序</span></span><br><span class="line">		Merge(<span class="built_in">array</span>, reg, left, mid, right);			<span class="comment">//合并左右序列</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	MergeSortRecursive1(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代版优化"><a href="#迭代版优化" class="headerlink" title="迭代版优化"></a>迭代版优化</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	T* regA = <span class="built_in">array</span>;</span><br><span class="line">	T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">		<span class="built_in">abort</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;												<span class="comment">//步长，每次翻倍</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line">			<span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line">			<span class="keyword">int</span> k = low;</span><br><span class="line">			<span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line">			<span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line">			<span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)											<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">				regB[k++] = regA[left1] &lt; regA[left2] ? regA[left1++] : regA[left2++];</span><br><span class="line">			<span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">				regB[k++] = regA[left1++];</span><br><span class="line">			<span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">				regB[k++] = regA[left2++];</span><br><span class="line">		&#125;</span><br><span class="line">		T* temp = regA;																			<span class="comment">//优化：交换辅助数组与原始数组的角色</span></span><br><span class="line">		regA = regB;</span><br><span class="line">		regB = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (regA != <span class="built_in">array</span>) &#123;																		<span class="comment">//如果regA != array，则说明现在regA是辅助数组</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)														<span class="comment">//所以需要拷贝数据到regB，也就是array。</span></span><br><span class="line">			regB[i] = regA[i];</span><br><span class="line">		regB = regA;																			<span class="comment">//regB重新指向辅助数组</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之快速排序</title>
    <url>/folder/2019/11/08/2018-01-06-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 ${\displaystyle n}$ 个项目要 ${\displaystyle O(n\log n)}$ （大O符号）次比较。在最坏状况下则需要 ${\displaystyle O(n^{2})}$ 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 ${\displaystyle O(n\log n)}$ 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<p>&emsp;&emsp;步骤为：</p>
<ul>
<li>从数列中挑出一个元素，称为”基准”（pivot）.</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
<li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>
</ul>
<p>&emsp;&emsp;wikipedia的大数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108223019362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wikipedia"/></div>
<p></p>

<p>&emsp;&emsp;wordzzzz的小数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108223101863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wordzzzz"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&emsp;&emsp;先给出公用接口，之后的三个递归实现和一个迭代实现在代码中都有详细的说明，我就不再在此赘述。</p>
<h4 id="公用接口"><a href="#公用接口" class="headerlink" title="公用接口"></a>公用接口</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 快速排序主体函数（递归）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; </span><br><span class="line">void QuickSort(T *array, const int length) &#123; </span><br><span class="line">	if (array == NULL)</span><br><span class="line">		throw invalid_argument(&quot;Array must not be empty&quot;); </span><br><span class="line">	if (length &lt;= 0) </span><br><span class="line">		return; </span><br><span class="line"></span><br><span class="line">	Partion1(array, 0, length - 1);</span><br><span class="line">//  Partion2(array, 0, length - 1);</span><br><span class="line">//  Partion3(array, 0, length - 1);</span><br><span class="line">//	PartionInsert(array, 0, length - 1);</span><br><span class="line">//	PartionSecond(array, 0, length - 1);</span><br><span class="line">//	PartionThird(array, 0, length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速排序1：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i=left(该索引之前的数比pivot小，初始值为left)，</span></span><br><span class="line"><span class="comment"> * j从left+1开始遍历数组，找到一个比pivot小的数，i+1，如果i和j序列号不等就交换（小值到前）。</span></span><br><span class="line"><span class="comment"> * j到最右端之后，for循环结束，再把pivot与i所指数据做交换，当前pivot就到达了它的最终位置。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = left;</span><br><span class="line">	<span class="keyword">int</span> j = left + <span class="number">1</span>;</span><br><span class="line">	T pivot = <span class="built_in">array</span>[left];						<span class="comment">// 取第一个数为基准</span></span><br><span class="line">	<span class="keyword">for</span> (; j &lt;= right; ++j)&#123;					<span class="comment">// 循环直至 j 扫描至 right</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; pivot)&#123;					<span class="comment">// 如果遇到比基准小的数，i右移一位</span></span><br><span class="line">			i++;</span><br><span class="line">			<span class="keyword">if</span> (j != i)&#123;						<span class="comment">// 如果i与j不重合，则交换他们指向的值</span></span><br><span class="line">				swap(<span class="built_in">array</span>[j],<span class="built_in">array</span>[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[i]);				<span class="comment">// 基准值的位置确定</span></span><br><span class="line">	Partion1(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">	Partion1(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序2：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i = left+1从左向右遍历找到一个比pivot大的数停止，</span></span><br><span class="line"><span class="comment"> * 然后等待j从右往左遍历找到一个pivot小的数，两者交换，然后继续寻找直到i=j，for循环结束。</span></span><br><span class="line"><span class="comment"> * 之后我们需要做判断，如果pivot比i所指数据大就交换两者，否则i回退一步（因为开始忽略了首元素）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> j = right;</span><br><span class="line">	T pivot = <span class="built_in">array</span>[left];						<span class="comment">// 取第一个数为基准</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)&#123;								<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)		<span class="comment">// j向左遍历，直到找到比pivot小的值</span></span><br><span class="line">			--j;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)		<span class="comment">// i向右遍历，直到找到比pivot大的值</span></span><br><span class="line">			++i;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)								<span class="comment">// 如果i &lt; j，就交换刚才找到的那两个值</span></span><br><span class="line">			swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[i]);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[left])				<span class="comment">// 这里一定要做判断再决定是否交换</span></span><br><span class="line">		swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line">		</span><br><span class="line">	<span class="keyword">else</span>										<span class="comment">// 如果不交换，说明left是最小，但i是不是第二小不确定，所以需要下次判断</span></span><br><span class="line">		--i;</span><br><span class="line">	Partion2(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">	Partion2(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序3：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，然后从j = right向前搜索第一个比pivot小的元素假设为array[k]，</span></span><br><span class="line"><span class="comment"> * 该元素放在array[left]的位置。因为array[left]已经保存pivot覆盖也没关系，于是array[k]又可以被覆盖了，</span></span><br><span class="line"><span class="comment"> * 从前往后搜索比pivot大的元素放到array[k]。一直进行下去直到i=j。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i = left;</span><br><span class="line">	<span class="keyword">int</span> j = right;</span><br><span class="line">	T pivot = <span class="built_in">array</span>[left];						<span class="comment">// 取第一个数为基准</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)&#123;								<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">			--j; </span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			<span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];				<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">			++i; </span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			<span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];				<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">	&#125; </span><br><span class="line">	<span class="built_in">array</span>[i] = pivot;							<span class="comment">// 将基准数填回</span></span><br><span class="line">	Partion3(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">	Partion3(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序迭代实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; trace;</span><br><span class="line">	trace.push(make_pair(<span class="number">0</span>, length - <span class="number">1</span>));		<span class="comment">// 将数组首尾压栈</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!trace.empty()) &#123;</span><br><span class="line">		<span class="keyword">auto</span> top = trace.top();					<span class="comment">// 将栈顶元素保存下来</span></span><br><span class="line">		trace.pop();							<span class="comment">// 弹出栈顶</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> i = top.first;						<span class="comment">// 取出首尾地址</span></span><br><span class="line">		<span class="keyword">int</span> j = top.second;</span><br><span class="line"></span><br><span class="line">		T pivot = <span class="built_in">array</span>[i];						<span class="comment">// 取第一个数为基准</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j) &#123;							<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line">			<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">				--j;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">				<span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];			<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line">			<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">				++i;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">				<span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];			<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">array</span>[i] = pivot;						<span class="comment">// 将基准数填回</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (i &gt; top.first) trace.push(make_pair(top.first, i - <span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span> (j &lt; top.second) trace.push(make_pair(j + <span class="number">1</span>, top.second));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    不定</li>
<li>最坏时间复杂度    ${\displaystyle O(n^{2})}$ </li>
<li>最优时间复杂度    ${\displaystyle O(n\log n)}$ </li>
<li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li>
<li>空间复杂度    根据实现的方式不同而不同</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;快速排序是二叉查找树（二叉查找树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。</p>
<p>&emsp;&emsp;快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是 ${\displaystyle O(n\log n)}$ 。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要 ${\displaystyle O(\log n)}$ 的空间。然而，堆排序需要有效率的随机存取才能变成可行。</p>
<p>&emsp;&emsp;快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况 ${\displaystyle O(n\log n)}$ 运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要 ${\displaystyle \Omega (n)}$ 额外的空间。</p>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>&emsp;&emsp;快排的优化、归并排序的优化一向是面试的考察重点，至于算法的优化，重点还是要知道现有算法的不足之处。</p>
<ul>
<li>当序列长度很小时，快排效率低，研究表明长度在5~25的数组，快排表现不如插入排序。</li>
<li>当pivot选择不当是，会导致树的不平衡，这样导致快排的时间复杂度为${\displaystyle O(n^{2})}$。</li>
<li>当数组中有大量重复的元素，快排效率将非常之低。</li>
</ul>
<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>&emsp;&emsp;针对上面提出的快排的局限性，我们依次做出优化策略：</p>
<ul>
<li>当当前序列长度小于特定值时，直接采用插入排序，或者不做处理，等到快排都执行完毕后（大致有序）在执行一次插入排序。</li>
<li>针对pivot的选择，不再选取固定值，而是采用其他选取策略，如随机、三值取中等。</li>
<li>如果数组中重复元素多，就采用三路划分算法：以某个数为基准将一个数组分成三部分：第一部分表示小于该pivot，第二部分等于pivot，第三部分大于pivot，要得到三部分得区间范围。</li>
</ul>
<p>&emsp;&emsp;下面的代码是对上述改进算法的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化1：</span></span><br><span class="line"><span class="comment">* 当排序的子序列小于预定的值M时，采用插入排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionInsert</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (right - left &lt;= M)</span><br><span class="line">		InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> i = left;</span><br><span class="line">		<span class="keyword">int</span> j = right;</span><br><span class="line">		T pivot = <span class="built_in">array</span>[left];					<span class="comment">// 取第一个数为基准</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j)&#123;							<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line">			<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">				--j;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">				<span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];			<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line">			<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">				++i;</span><br><span class="line">			<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">				<span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];			<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">array</span>[i] = pivot;						<span class="comment">// 将基准数填回</span></span><br><span class="line">		PartionInsert(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">		PartionInsert(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生随机数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Random</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> i = left + rand() % size;</span><br><span class="line">	swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取中位数移至left</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Median</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> mid = left + ((right - left )&gt;&gt; <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">int</span> minIndex = right;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[mid])</span><br><span class="line">		minIndex = mid;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[left])</span><br><span class="line">		minIndex = left;</span><br><span class="line">	<span class="keyword">if</span> (minIndex != right)						<span class="comment">//三个判断，把最小值移到最右侧</span></span><br><span class="line">		swap(<span class="built_in">array</span>[minIndex], <span class="built_in">array</span>[right]);</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; <span class="built_in">array</span>[left])				<span class="comment">//那么剩下的两个数，最小的那个就是中位数了</span></span><br><span class="line">		swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[mid]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化2：</span></span><br><span class="line"><span class="comment">* 取随机数或者三值取中作为基准值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionSecond</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	Random(array, left, right);					// 优化2-1：取随机数至最左端（基准值）</span></span><br><span class="line">	Median(<span class="built_in">array</span>, left, right);					<span class="comment">// 优化2-2：取中位数至最左端（基准值）</span></span><br><span class="line">	<span class="keyword">int</span> i = left;</span><br><span class="line">	<span class="keyword">int</span> j = right;</span><br><span class="line">	T pivot = <span class="built_in">array</span>[left];						<span class="comment">// 取第一个数为基准</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; j)&#123;								<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">			--j;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			<span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];				<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line">		<span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">			++i;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">			<span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];				<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">array</span>[i] = pivot;							<span class="comment">// 将基准数填回</span></span><br><span class="line">	PartionSecond(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">	PartionSecond(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化3：</span></span><br><span class="line"><span class="comment">* 重复数据比较多的话，可以分为小于等于大于三段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionThird</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> less = left;</span><br><span class="line">	<span class="keyword">int</span> greater = right;</span><br><span class="line">	<span class="keyword">int</span> it = left;</span><br><span class="line">	T pivot = <span class="built_in">array</span>[left];						<span class="comment">// 取第一个数为基准</span></span><br><span class="line">	<span class="keyword">while</span> (it &lt;= greater)&#123;						<span class="comment">// 循环直至it和greater相遇</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">array</span>[it] == pivot)					<span class="comment">// 如果等于pivot，it右移</span></span><br><span class="line">			++it;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[it] &lt; pivot)&#123;			<span class="comment">// 如果小于pivot，扔左边，it和less右移</span></span><br><span class="line">			swap(<span class="built_in">array</span>[less], <span class="built_in">array</span>[it]);</span><br><span class="line">			++it;</span><br><span class="line">			++less;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;									<span class="comment">// 如果大于pivot，扔右边，greater左移</span></span><br><span class="line">			swap(<span class="built_in">array</span>[greater], <span class="built_in">array</span>[it]);</span><br><span class="line">			--greater;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	PartionThird(<span class="built_in">array</span>, left, less - <span class="number">1</span>);</span><br><span class="line">	PartionThird(<span class="built_in">array</span>, greater + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>快速排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之冒泡排序</title>
    <url>/folder/2019/11/08/2018-01-05-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>&emsp;&emsp;冒泡排序对 ${\displaystyle n}$ 个项目需要${\displaystyle O(n)}$ )的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>冒泡排序算法的运作如下：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108094645331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wikipedia"/></div>
<p></p>

<p>&emsp;&emsp;wordzzzz的小数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108095446582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 标准冒泡排序：嵌套循环比大小。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;				<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;		<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;				<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">				T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">				<span class="built_in">array</span>[j] = tmp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    数组</li>
<li>最坏时间复杂度    ${\displaystyle O(n^{2})}$</li>
<li>最优时间复杂度    ${\displaystyle O(n)}$</li>
<li>平均时间复杂度    ${\displaystyle O(n^{2})}$</li>
<li>空间复杂度    总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 ${\displaystyle O(n^{2})}$次交换，而插入排序只要最多 ${\displaystyle O(n)}$ 交换。冒泡排序的实现（类似上面）通常会对已经排序好的数列拙劣地运行（ ${\displaystyle O(n^{2})}$ ），而插入排序在这个例子只需要 ${\displaystyle O(n)}$ 个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。</p>
<p>&emsp;&emsp;在面试中，一般都会涉及到算法的优化，重点考察的其实还是你对现有算法的理解，分析现有算法的缺点，就能找到优化的思路。</p>
<p>优化1：冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 ${\displaystyle O(n)}$ 。在这个情况，已经排序好的数列就无交换的需要。<br>优化2：可以记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>优化3：若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。</p>
<p>优化代码如下：</p>
<p>优化1：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 冒泡排序优化1：如果某次内循环没有改变任何数据，则结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;									<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;				<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">		flag = <span class="literal">false</span>;									<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;		<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;				<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">				T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">				<span class="built_in">array</span>[j] = tmp;</span><br><span class="line">				flag = <span class="literal">true</span>;							<span class="comment">//如果有交换，则标志位置1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="keyword">return</span>;								<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化2：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冒泡排序优化2：在优化1的基础上，记录上次排序结束位置，减少排序次数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> k = length;</span><br><span class="line">	<span class="keyword">int</span> flag = k;										<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;				<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">		k = flag;</span><br><span class="line">		flag = <span class="number">0</span>;										<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; ++j)&#123;				<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;				<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">				T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line">				<span class="built_in">array</span>[j] = tmp;</span><br><span class="line">				flag = j + <span class="number">1</span>;							<span class="comment">//如果有交换，更新交换位置的记录</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="keyword">return</span>;								<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化3：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *冒泡排序优化3：鸡尾酒排序，一个外循环内跑两个内循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> high = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (high &gt; low)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; ++i)				<span class="comment">//正向冒泡，确定最大值  </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[i + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				T temp = <span class="built_in">array</span>[i];</span><br><span class="line">				<span class="built_in">array</span>[i] = <span class="built_in">array</span>[i + <span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[i + <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		--high;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = high; j &gt; low; --j)				<span class="comment">//反向冒泡，确定最小值  </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				T temp = <span class="built_in">array</span>[j];</span><br><span class="line">				<span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line">				<span class="built_in">array</span>[j - <span class="number">1</span>] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		++low;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>冒泡排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之堆排序</title>
    <url>/folder/2019/11/08/2018-01-04-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>&emsp;&emsp;通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p>
<ul>
<li>父节点i的左子节点在位置 ${\displaystyle (2i+1)}$。</li>
<li>父节点i的右子节点在位置 ${\displaystyle (2i+2)}$。</li>
<li>子节点i的父节点在位置 ${\displaystyle floor((i-1)/2)}$。</li>
</ul>
<p>&emsp;&emsp;在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p>
<ul>
<li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。</li>
<li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序。</li>
<li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;基于以上堆相关的操作，我们可以很容易的定义堆排序。例如，假设我们已经读入一系列数据并创建了一个堆，一个最直观的算法就是反复的调用del_max()函数，因为该函数总是能够返回堆中最大的值，然后把它从堆中删除，从而对这一系列返回值的输出就得到了该序列的降序排列。真正的原地堆排序使用了另外一个小技巧。堆排序的过程是：</p>
<ul>
<li>创建一个堆 ${\displaystyle H[0..n-1]}$。</li>
<li>把堆首（最大值）和堆尾互换。</li>
<li>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置。</li>
<li>重复步骤2，直到堆的尺寸为1。</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108145757178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="heapsort from wikipedia"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序递归版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyRecursive</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sonl = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> sonr = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">int</span> dad = i;</span><br><span class="line">	<span class="keyword">if</span> (sonl &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonl]&gt;<span class="built_in">array</span>[i])&#123;					<span class="comment">//如果左子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">		dad = sonl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (sonr &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonr]&gt;<span class="built_in">array</span>[dad])&#123;				<span class="comment">//如果右子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">		dad = sonr;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (dad != i)&#123;													<span class="comment">//如果dad != i则说明父结点不是最大值，交换后递归执行MaxHeapifyRecursive</span></span><br><span class="line">		swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[dad]);</span><br><span class="line">		MaxHeapifyRecursive(<span class="built_in">array</span>, dad, heapSize);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">		<span class="comment">//构建最大堆 </span></span><br><span class="line">		MaxHeapifyRecursive(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//		MaxHeapifyIteration(array, i, length - 1);</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">		swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line">		MaxHeapifyRecursive(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//		MaxHeapifyIteration(array, 0, i - 1);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//建立父结点指针和子结点指针</span></span><br><span class="line">	<span class="keyword">int</span> dad = left;</span><br><span class="line">	<span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (son &lt;= right) &#123;											<span class="comment">//若子结点指针在范围内才做比较</span></span><br><span class="line">		<span class="keyword">if</span> (son + <span class="number">1</span> &lt;= right &amp;&amp; <span class="built_in">array</span>[son] &lt; <span class="built_in">array</span>[son + <span class="number">1</span>])		<span class="comment">//先比较两个子结点的大小，选择最大的</span></span><br><span class="line">			son++;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">array</span>[dad] &gt; <span class="built_in">array</span>[son])								<span class="comment">//如果父结点大于子结点代表调整完毕，直接跳出循环</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;														<span class="comment">//否则交换父子内容在继续子结点和孙结点的比较</span></span><br><span class="line">			swap(<span class="built_in">array</span>[dad], <span class="built_in">array</span>[son]);</span><br><span class="line">			dad = son;</span><br><span class="line">			son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">		<span class="comment">//构建最大堆 </span></span><br><span class="line"><span class="comment">//		MaxHeapifyRecursive(array, i, length - 1);</span></span><br><span class="line">		MaxHeapifyIteration(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">		swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line"><span class="comment">//		MaxHeapifyRecursive(array, 0, i - 1);</span></span><br><span class="line">		MaxHeapifyIteration(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    数组</li>
<li>最坏时间复杂度    ${\displaystyle O(n\log n)}$</li>
<li>最优时间复杂度    ${\displaystyle O(n\log n)}$</li>
<li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li>
<li>空间复杂度    ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;原地堆排序已经是空间优化版本了，因为它不再需要申请额外的空间。</p>
<p>&emsp;&emsp;整个算法的过程分为建堆和排序两个过程，首先对现有数组建立最大堆，然后一边提取堆顶的最大值，一边减小堆的尺寸，最后堆尺寸为1时，排序也就完成了。如果大家对整个算法的执行过程不太了解，可以看一下下面这两张图，第一张是建堆的过程示意图，第二张是排序的过程示意图。图片来自：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108145915265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108145935165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"/></div>
<p></p>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>堆排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之选择排序</title>
    <url>/folder/2019/11/08/2018-01-03-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p>&emsp;&emsp;选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 ${\displaystyle n}$ 个元素的表进行排序总共进行至多 ${\displaystyle n-1}$ 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>找到列表中的最小值。</li>
<li>把它和第一个位置的元素交换。</li>
<li>列表其余部分重复上面的步骤(从第二个位置开始，且每次加1)。</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108111324944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="selectsort from wikipedia"/></div>
<p></p>

<p>&emsp;&emsp;wordzzzz的小数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108111351977?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="selectsort from wordzzzz"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*直接选择排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelectSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;		<span class="comment">//外循环，每次选出一个最小的元素放到前面</span></span><br><span class="line">		<span class="keyword">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; length; ++j)	<span class="comment">//内循环，确定最小元素的下标</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[min])</span><br><span class="line">				min = j;</span><br><span class="line">		<span class="keyword">if</span> (min != i)&#123;							<span class="comment">//如果当前数据不是最小元素，就交换</span></span><br><span class="line">			T tmp = <span class="built_in">array</span>[i];</span><br><span class="line">			<span class="built_in">array</span>[i] = <span class="built_in">array</span>[min];</span><br><span class="line">			<span class="built_in">array</span>[min] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    数组</li>
<li>最坏时间复杂度    ${\displaystyle O(n^2)}$ </li>
<li>最优时间复杂度    ${\displaystyle O(n^2)}$</li>
<li>平均时间复杂度    ${\displaystyle O(n^2)}$</li>
<li>空间复杂度    ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;选择排序的交换操作介于 ${\displaystyle 0}$ 和 ${\displaystyle (n-1)}$ 次之间。选择排序的比较操作为 ${\displaystyle n(n-1)/2}$ 次之间。选择排序的赋值操作介于 ${\displaystyle 0}$ 和 ${\displaystyle 3(n-1)}$ 次之间。</p>
<p>&emsp;&emsp;比较次数 ${\displaystyle O(n^{2})}$ ，比较次数与关键字的初始状态无关，总的比较次数 ${\displaystyle N=(n-1)+(n-2)+…+1=n\times (n-1)/2}$ 。交换次数 ${\displaystyle O(n)}$ ，最好情况是，已经有序，交换0次；最坏情况是，逆序，交换 ${\displaystyle n-1} 次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多， ${\displaystyle n}$ 值较小时，选择排序比冒泡排序快。</p>
<p>&emsp;&emsp;原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之希尔排序</title>
    <url>/folder/2019/11/08/2018-01-02-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>&emsp;&emsp;希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<p>&emsp;&emsp;插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率<br>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;原始的算法实现在最坏的情况下需要进行${\displaystyle O(n^{2})}$ 的比较和交换。V. Pratt的书对算法进行了少量修改，可以使得性能提升至${\displaystyle O(n\log ^{2}n)}$ 。这比最好的比较算法的${\displaystyle O(n\log n)}$ 要差一些。</p>
<p>&emsp;&emsp;希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>&emsp;&emsp;假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>&emsp;&emsp;一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。</p>
<p>&emsp;&emsp;例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">13 14 94 33 82</span><br><span class="line">25 59 94 65 23</span><br><span class="line">45 27 73 25 39</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后我们对每列进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73 25 23</span><br><span class="line">13 27 94 33 39</span><br><span class="line">25 59 94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 73</span><br><span class="line">25 23 13</span><br><span class="line">27 94 33</span><br><span class="line">39 25 59</span><br><span class="line">94 65 82</span><br><span class="line">45</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;排序之后变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10 14 13</span><br><span class="line">25 23 33</span><br><span class="line">27 25 59</span><br><span class="line">39 65 73</span><br><span class="line">45 94 82</span><br><span class="line">94</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108104308360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="shellsort from wikipedia"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> gap = length &gt;&gt; <span class="number">1</span>; gap &gt; <span class="number">0</span>; gap &gt;&gt;= <span class="number">1</span>)&#123;	<span class="comment">//gap是设置的步长</span></span><br><span class="line">		T tmp;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; length; ++i)&#123;</span><br><span class="line">			tmp = <span class="built_in">array</span>[i];</span><br><span class="line">			<span class="keyword">int</span> j = i;									<span class="comment">//后面要用到j，所以在for循环的外面初始化</span></span><br><span class="line">			<span class="keyword">while</span> (j &gt;= gap &amp;&amp; tmp &lt; <span class="built_in">array</span>[j - gap])&#123;</span><br><span class="line">				<span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - gap];</span><br><span class="line">				j -= gap;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">array</span>[j] = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    数组</li>
<li>最坏时间复杂度    根据步长序列的不同而不同。已知最好的： ${\displaystyle O(n\log ^{2}n)}$ </li>
<li>最优时间复杂度    ${\displaystyle O(n)}$</li>
<li>平均时间复杂度    根据步长序列的不同而不同。</li>
<li>空间复杂度        ${\displaystyle O(n)}$</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p>&emsp;&emsp;Donald Shell最初建议步长选择为 ${\displaystyle {\frac {n}{2}}}$ 并且对步长取半直到步长达到1。虽然这样取可以比 ${\displaystyle O(n^{2})}$ 类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p>
<table>
<thead>
<tr>
<th>步长序列</th>
<th>最坏情况下复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>${\displaystyle {n/2^{i}}}$</td>
<td>${\displaystyle O(n^{2})}$</td>
</tr>
<tr>
<td>${\displaystyle 2^{k}-1}$</td>
<td>${\displaystyle O(n^{3/2})}$</td>
</tr>
<tr>
<td>${\displaystyle 2^{i}3^{j}}$</td>
<td>${\displaystyle O(n\log ^{2}n)}$</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自 ${\displaystyle 9\times 4^{i}-9\times 2^{i}+1}$和 ${\displaystyle 2^{i+2}\times (2^{i+2}-3)+1}$ 这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p>
<p>&emsp;&emsp;另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法系列之一：八大排序之插入排序</title>
    <url>/folder/2019/11/08/2018-01-01-DS/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li>
<li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 ${\displaystyle O(1)}$ 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序。</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描。</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置。</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置。</li>
<li>将新元素插入到该位置后。</li>
<li>重复步骤2~5。</li>
</ul>
<h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108102156155?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="insertsort from wikipedia"/></div>
<p></p>

<p>&emsp;&emsp;wordzzzz的小数据规模演示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20180108102249736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="insertsortfrom wordzzzz"/></div>
<p></p>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line">	<span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; ++i)&#123;					<span class="comment">//外循环，一次插入一个数据</span></span><br><span class="line">		T tmp = <span class="built_in">array</span>[i]; </span><br><span class="line">		<span class="keyword">int</span> j = i - <span class="number">1</span>;									<span class="comment">//内循环，从i-1开始</span></span><br><span class="line">		<span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; <span class="built_in">array</span>[j] &gt; tmp)&#123;				</span><br><span class="line">			<span class="built_in">array</span>[j+<span class="number">1</span>] = <span class="built_in">array</span>[j]; </span><br><span class="line">			--j; </span><br><span class="line">		&#125; </span><br><span class="line">		<span class="built_in">array</span>[j+<span class="number">1</span>] = tmp; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>数据结构    数组</li>
<li>最坏时间复杂度    ${\displaystyle O(n^{2})}$</li>
<li>最优时间复杂度    ${\displaystyle O(n)}$</li>
<li>平均时间复杂度    ${\displaystyle O(n^{2})}$</li>
<li>空间复杂度    总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$</li>
</ul>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找插入排序。</p>
<p>&emsp;&emsp;如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 ${\displaystyle n-1}$ 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 ${\displaystyle {\frac {1}{2}}n(n-1)}$ 次。插入排序的赋值操作是比较操作的次数减去 ${\displaystyle n-1}$ 次，（因为 ${\displaystyle n-1}$ 次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为 ${\displaystyle O(n^{2})}$ 。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>
<p>&emsp;&emsp;下一篇将介绍插入排序的升级版：希尔排序。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（综合）：树中两个结点的最低公共祖先</title>
    <url>/folder/2019/11/08/2017-12-01-offer-69/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个树节点，求他们的最低公共祖先。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>求树中两个节点的最低公共祖先，不能说只是一个题目，而应该说是一组题目。不同条件下的题目解法是完全不一样的，比如，是否是二叉树、二叉排序树；如果不是二叉树，是否有指向父节点的指针（是的话可以转换成求两个链表的第一个公共节点，不是的话可以转换成求两个链表的最后一个公共节点）。</p>
<p>下面的代码针对的是普通树，并且没有指向父节点的指针，所以我们转换成求两个链表的最后一个公共节点。代码中GetNodePath用来得到根节点pRoot开始到达节点pNode的路径，这条路径保存在path中，函数GetLastCommonNode用来得到两个路径path1和path2的最后一个公共节点。函数GetLastCommonParent先调用GetNodePath得到pRoot到达pNode1的路径path1，再得到pRoot到达pNode2的路径path2，接着调用GetLastCommonNode得到path1和path2的最后一个公共节点，即我们要找的最低公共祖先。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetNodePath</span><span class="params">(<span class="keyword">const</span> TreeNode* pRoot, <span class="keyword">const</span> TreeNode* pNode, <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;&amp; path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == pNode)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    path.push_back(pRoot);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt;::const_iterator i = pRoot-&gt;m_vChildren.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">while</span>(!found &amp;&amp; i &lt; pRoot-&gt;m_vChildren.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        found = GetNodePath(*i, pNode, path);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!found)</span><br><span class="line">        path.pop_back();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TreeNode* GetLastCommonNode</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;&amp; path1, </span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;&amp; path2</span><br><span class="line">)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;::const_iterator iterator1 = path1.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt;::const_iterator iterator2 = path2.<span class="built_in">begin</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> TreeNode* pLast = <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(iterator1 != path1.<span class="built_in">end</span>() &amp;&amp; iterator2 != path2.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(*iterator1 == *iterator2)</span><br><span class="line">            pLast = *iterator1;</span><br><span class="line"> </span><br><span class="line">        iterator1++;</span><br><span class="line">        iterator2++;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> pLast;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> TreeNode* <span class="title">GetLastCommonParent</span><span class="params">(<span class="keyword">const</span> TreeNode* pRoot, <span class="keyword">const</span> TreeNode* pNode1, <span class="keyword">const</span> TreeNode* pNode2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">nullptr</span> || pNode1 == <span class="literal">nullptr</span> || pNode2 == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt; path1;</span><br><span class="line">    GetNodePath(pRoot, pNode1, path1);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">const</span> TreeNode*&gt; path2;</span><br><span class="line">    GetNodePath(pRoot, pNode2, path2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> GetLastCommonNode(path1, path2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（综合）：把字符串转换成整数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-68/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p>
<h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>输入一个字符串,包括数字字母符号,可以为空</p>
<h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a>输出描述:</h3><p>如果是合法的数值表达则返回该数字，否则返回0</p>
<h2 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h2><p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+2147483647</span><br><span class="line">    1a33</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2147483647</span><br><span class="line">    0</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目虽然简单，但是要写出完整的代码也是需要经过全面的思考才可以。</p>
<p>给出一个题目，我们首先要考虑的就是边界问题。对于这个题目，边界问题有：</p>
<ul>
<li>空指针；</li>
<li>空字符串””；</li>
<li>带有正负号；</li>
<li>只有正负号；</li>
<li>上下溢出；</li>
<li>错误标志输出。</li>
</ul>
<p>代码中用两个函数来实现该功能，其中标志位g_nStatus用来表示是否为异常输出，标志位用来表示是否为负数。需要注意的也就只有上面提到的边界问题。具体实现如下。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> Status &#123;kValid = <span class="number">0</span>, kInvalid&#125;;</span><br><span class="line">    <span class="keyword">int</span> g_nStatus = kValid;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        g_nStatus = kInvalid;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* cstr = str.c_str();</span><br><span class="line">        <span class="comment">//判断是否为空指针和是否为空字符串</span></span><br><span class="line">        <span class="keyword">if</span>(cstr != <span class="literal">NULL</span> &amp;&amp; *cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">bool</span> minus = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//正负号区分</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr == <span class="string">'+'</span>)</span><br><span class="line">                cstr++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(*cstr == <span class="string">'-'</span>)&#123;</span><br><span class="line">                cstr++;</span><br><span class="line">                minus = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果不是只有正负号，就进入下一个函数</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr != <span class="string">'\0'</span>)</span><br><span class="line">                num = StrToIntCore(cstr, minus);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">StrToIntCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cstr, <span class="keyword">bool</span> minus)</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(*cstr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否为非法值</span></span><br><span class="line">            <span class="keyword">if</span>(*cstr &gt;= <span class="string">'0'</span> &amp;&amp; *cstr &lt;= <span class="string">'9'</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> flag = minus ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line">                num = num * <span class="number">10</span> + flag * (*cstr - <span class="string">'0'</span>);</span><br><span class="line">                <span class="comment">//判断是否溢出</span></span><br><span class="line">                <span class="keyword">if</span>((!minus &amp;&amp; num &gt; <span class="number">0x7fffffff</span>) || (minus &amp;&amp; num &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)<span class="number">0x80000000</span>))&#123;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cstr++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #判断是否正常结束</span><br><span class="line">        <span class="keyword">if</span>(*cstr == <span class="string">'\0'</span>)</span><br><span class="line">            g_nStatus = kValid;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>综合</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：字符流中第一个不重复的字符</title>
    <url>/folder/2019/11/08/2017-12-01-offer-67/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>如果当前字符流没有存在出现一次的字符，返回#字符。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>好吧，我是第一次见这种需要写部分测试函数的题目。</p>
<p>题目很简单，用hash表来实现，其实hash表的键值为输入字符的ASCII码，hash的值初始化为-1，出现一次则设置为该字符在字符串中的位置，出现两次以上则设置为-2。</p>
<p>最后搜索的时候，根据hash表的值就可以找到第一个不重复的字符。</p>
<ul>
<li>occurrence[i] = -1: 这个字符不存在；</li>
<li>occurrence[i] = -2: 这个字符出现了多次；</li>
<li>occurrence[i] &gt;= 0: 这个字符只出现一次。</li>
</ul>
<p>需要注意的是，因为我们要求如果当前字符流没有存在出现一次的字符，返回#字符，所以我们初始化字符时应该设置为’#’而不是’\0’。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Solution()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(occurrence, <span class="number">-1</span>, <span class="keyword">sizeof</span>(occurrence));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(occurrence[ch] == <span class="number">-1</span>)</span><br><span class="line">            occurrence[ch] = index;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(occurrence[ch] &gt;= <span class="number">0</span>)</span><br><span class="line">            occurrence[ch] = <span class="number">-2</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">'#'</span>;</span><br><span class="line">        <span class="keyword">int</span> minIndex = numeric_limits&lt;<span class="keyword">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(occurrence[i] &gt;= <span class="number">0</span> &amp;&amp; occurrence[i] &lt;= minIndex)&#123;</span><br><span class="line">                ch = (<span class="keyword">char</span>)i;</span><br><span class="line">                minIndex = occurrence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ch;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> occurrence[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：正则表达式匹配</title>
    <url>/folder/2019/11/08/2017-12-01-offer-66/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来匹配包括’.’和’*‘的正则表达式。模式中的字符’.’表示任意一个字符，而’*‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab*ac*a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>只有当模式串和字符串同时等于’\0’，才可以认为两个串匹配。</p>
<p>在匹配中，对于每个位的匹配可以分为三种情况:</p>
<ul>
<li>1、（相应位匹配||模式串为’.’&amp;&amp;字符串不是’\0’）&amp;&amp;模式串下一位是’*’</li>
<li>2、（相应位匹配||模式串为’.’&amp;&amp;字符串不是’\0’）&amp;&amp;模式串下一位不是’*’</li>
<li>3、相应位不匹配&amp;&amp;（模式位不为’.’||字符串是’\0’）</li>
</ul>
<p>对应1，最复杂。分为*取0，*取1，*&gt;=2三种情况。<br>*取0对应跳过当前匹配位，继续寻找patter的下一个匹配位，str不变，pattern+2<br>*取1对应当前匹配位算一次成功匹配，str+1，pattern+2<br>*取&gt;=2对应一次成功匹配，继续匹配字符串的下一位是否匹配，str+1，pattern不变<br>三者取或。即只要有一种情况能匹配成功认为字符串就是匹配成功的。<br>对应2，相当于一次成功匹配，str+1，pattern+1<br>对应3，匹配失败，直接返回false</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span> || pattern == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str, <span class="keyword">const</span> <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(*pattern == *str || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">                <span class="comment">// 进入有限状态机的下一个状态</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>)</span><br><span class="line">                <span class="comment">// 继续留在有限状态机的当前状态 </span></span><br><span class="line">                || matchCore(str + <span class="number">1</span>, pattern)</span><br><span class="line">                <span class="comment">// 略过一个'*' </span></span><br><span class="line">                || matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 略过一个'*'</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))</span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：替换空格</title>
    <url>/folder/2019/11/08/2017-12-01-offer-65/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>C/C++中每个字符串都以字符‘\0’作为结尾，这样我们就能很方便地找到字符串的最后尾部。但是由于这个特点，每个字符串中都有一个额外字符的开销，稍不留神就会造成字符串的越界。</p>
<p>为了节省内存，C/C++把常量字符串放到单独的一个内存区域。当几个指针赋值给相同的常量字符串时，他们实际上会指向相同的内存地址，在下面的代码中，str1 == str2成立，因为它们指向同一地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* str1 = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span>* str2 = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure>

<p>但用常量内存初始化数组，情况就不同了，在下面的代码中，str3 == str4不成立，因为这是两个字符串数组，会为它们分配两个长度为12个字节的空间，他们的初始地址是不同的，所以str3和str4的值也不相同。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> str3[] = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="keyword">char</span> str4[] = <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure>

<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="时间复杂度为O-n-2-的解法"><a href="#时间复杂度为O-n-2-的解法" class="headerlink" title="时间复杂度为O(n^2)的解法"></a>时间复杂度为O(n^2)的解法</h3><p>最直观的做法是从头到尾扫描字符串，每一个碰到空格字符的时候做替换。由于是把1个字符替换成3个字符，我们必须要把空格后面所有的字符都后移两个字节，否则就有两个字符被覆盖。</p>
<p>假设字符串的长度是n。对每个空格字符，需要移动后面O(n)个字符，因此对含有O(n)个空格字符的字符串而言总的时间效率是O(n^2)。</p>
<h3 id="时间复杂度为O-n-的解法"><a href="#时间复杂度为O-n-的解法" class="headerlink" title="时间复杂度为O(n)的解法"></a>时间复杂度为O(n)的解法</h3><p>先遍历一遍字符串，统计处空格的总数，由此计算出替换之后的字符串的总长度。然后用两个指针从字符串的后面开始复制和替换。P1指向原始字符串的末尾，而P2指向替换之后的字符串的末尾，然后向前移动P1，逐个把它指向的字符复制到P2指向的位置，直到碰到第一个空格位置。碰到第一个空格之后，把P1向前移动一格，P2之前插入字符串“%20”，同时把P2向前移动三格。具体如图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170925111500819?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>


<p>由于所有的字符都只复制一次，因此时间效率为O(n)。</p>
<h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(str == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> originalLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numberOfBlank = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            ++ originalLength;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">' '</span>)</span><br><span class="line">                ++ numberOfBlank;</span><br><span class="line">            ++ i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> newLength = originalLength + numberOfBlank * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(newLength &gt;= length)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> indexOfOriginal = originalLength;</span><br><span class="line">        <span class="keyword">int</span> indexOfNew = newLength;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(indexOfOriginal &gt;= <span class="number">0</span> &amp;&amp; indexOfNew &gt; indexOfOriginal)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[indexOfOriginal] == <span class="string">' '</span>)&#123;</span><br><span class="line">                str[indexOfNew--] = <span class="string">'0'</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">'2'</span>;</span><br><span class="line">                str[indexOfNew--] = <span class="string">'%'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                str[indexOfNew--] = str[indexOfOriginal];</span><br><span class="line">            &#125;</span><br><span class="line">            -- indexOfOriginal;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h2><h3 id="手动替换"><a href="#手动替换" class="headerlink" title="手动替换"></a>手动替换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        res = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> ele <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> ele.strip():</span><br><span class="line">                res += ele</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += <span class="string">'%20'</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="调用replace"><a href="#调用replace" class="headerlink" title="调用replace"></a>调用replace</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># s 源字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> s.replace(<span class="string">" "</span>, <span class="string">"%20"</span>)</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（字符串）：表示数值的字符串</title>
    <url>/folder/2019/11/08/2017-12-01-offer-64/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>其实这道题也是正则表达式的匹配过程。判断一个字符串是否表示数值的正则表达式为：[+-]?[0-9]*(.[0-9]*)?([eE][+-]?[0-9]*)?。更加详细的注释都在程序里了，这里就不再赘述。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，其中A和C都是</span></span><br><span class="line">    <span class="comment">// 整数（可以有正负号，也可以没有），而B是一个无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> numeric = scanInteger(&amp;str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现'.'，接下来是数字的小数部分</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'.'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面一行代码用||的原因：</span></span><br><span class="line">            <span class="comment">// 1. 小数可以没有整数部分，例如.123等于0.123；</span></span><br><span class="line">            <span class="comment">// 2. 小数点后面可以没有数字，例如233.等于233.0；</span></span><br><span class="line">            <span class="comment">// 3. 当然小数点前面和后面可以有数字，例如233.666</span></span><br><span class="line">            numeric = scanUnsignedInteger(&amp;str) || numeric;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果出现'e'或者'E'，接下来跟着的是数字的指数部分</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'e'</span> || *str == <span class="string">'E'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++str;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 下面一行代码用&amp;&amp;的原因：</span></span><br><span class="line">            <span class="comment">// 1. 当e或E前面没有数字时，整个字符串不能表示数字，例如.e1、e1；</span></span><br><span class="line">            <span class="comment">// 2. 当e或E后面没有整数时，整个字符串不能表示数字，例如12e、12e+5.4</span></span><br><span class="line">            numeric = numeric &amp;&amp; scanInteger(&amp;str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numeric &amp;&amp; *str == <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* before = *str;</span><br><span class="line">        <span class="keyword">while</span>(**str != <span class="string">'\0'</span> &amp;&amp; **str &gt;= <span class="string">'0'</span> &amp;&amp; **str &lt;= <span class="string">'9'</span>)</span><br><span class="line">            ++(*str);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当str中存在若干0-9的数字时，返回true</span></span><br><span class="line">        <span class="keyword">return</span> *str &gt; before;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 整数的格式可以用[+|-]B表示, 其中B为无符号整数</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>** str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(**str == <span class="string">'+'</span> || **str == <span class="string">'-'</span>)</span><br><span class="line">            ++(*str);</span><br><span class="line">        <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：左旋转字符串</title>
    <url>/folder/2019/11/08/2017-12-01-offer-63/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>和上一道题一样，我们根据n将字符串分为两部分，这两部分先自己反转，然后再一同反转。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string LeftRotateString(string str, int n) &#123;</span><br><span class="line">        int length = str.size();</span><br><span class="line">        if(length &lt; 0)</span><br><span class="line">            return NULL;</span><br><span class="line">        if(length &gt;= 0 &amp;&amp; n &gt;= 0 &amp;&amp; n &lt;= length)&#123;</span><br><span class="line">            int pFirstStart = 0;</span><br><span class="line">            int pFirstEnd = n - 1;</span><br><span class="line">            int pSecondStart = n;</span><br><span class="line">            int pSecondEnd = length - 1;</span><br><span class="line"></span><br><span class="line">            // 翻转字符串的前面n个字符</span><br><span class="line">            reverseWord(str, pFirstStart, pFirstEnd);</span><br><span class="line">            // 翻转字符串的后面部分</span><br><span class="line">            reverseWord(str, pSecondStart, pSecondEnd);</span><br><span class="line">            // 翻转整个字符串</span><br><span class="line">            reverseWord(str, pFirstStart, pSecondEnd);</span><br><span class="line">        &#125;</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    void reverseWord(string &amp;str, int begin, int end)&#123;</span><br><span class="line">        while(begin &lt; end)</span><br><span class="line">            swap(str[begin++], str[end--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：数组中只出现一次的数字</title>
    <url>/folder/2019/11/08/2017-12-01-offer-62/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<p>[toc]</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我刚看到这道题的时候，一点思路都没有，看了别人的解法之后才恍然大悟。</p>
<p>这道题我们可以利用异或的特性–两个相同数字异或，结果为0。把数组中的数据全部想成二进制会更容易理解。</p>
<p>首先我们来考虑数组中只有一个出现一次的数字的情况，这种情况下，我们直接异或数组中的所有值即可得到这个数字；接下来考虑有两个出现一次的数字的情况，这种情况下，我们可以把原来的数组分成两组，每组里面各有一个只出现一次的数字，然后运用前面的解法即可得到结果。</p>
<p>问题的关键是如何划分成两个数组。我们呢可以根据全部值异或的结果进行思考，我们可以先把结果中最右边的1作为划分条件，然后判断数组中每个数字该位置上是不是1，如果是则为第一组，否则为第二组。这样分完之后，一组里面正好一个只出现一次的数字。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123;</span><br><span class="line">        int length = data.size();</span><br><span class="line">        if(length &lt; 2)</span><br><span class="line">            return;</span><br><span class="line">        //异或操作</span><br><span class="line">        int resultExclusiveOR = 0;</span><br><span class="line">        for(int i = 0; i &lt; length; ++i)</span><br><span class="line">            resultExclusiveOR ^= data[i];</span><br><span class="line">        //获取倒数第一个1的位置</span><br><span class="line">        unsigned int indexOf1 = findFirstBitIs1(resultExclusiveOR);</span><br><span class="line">        //分组异或</span><br><span class="line">        *num1 = *num2 = 0;</span><br><span class="line">        for(int j=0; j &lt; length; ++j)&#123;</span><br><span class="line">            if(isBit1(data[j], indexOf1))</span><br><span class="line">                *num1 ^= data[j];</span><br><span class="line">            else</span><br><span class="line">                *num2 ^= data[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    unsigned int findFirstBitIs1(int num)&#123;</span><br><span class="line">        int indexBit = 0;</span><br><span class="line">        while((num &amp; 1) == 0 &amp;&amp; indexBit &lt; 8 * sizeof(int))&#123;</span><br><span class="line">            num = num&gt;&gt;1;</span><br><span class="line">            ++ indexBit;</span><br><span class="line">        &#125;</span><br><span class="line">        return indexBit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool isBit1(int num, unsigned int indexBit)&#123;</span><br><span class="line">        num = num &gt;&gt; indexBit;</span><br><span class="line">        return (num &amp; 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：数字在排序数组中出现的次数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-61/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>统计一个数字在排序数组中出现的次数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>数组是排序的，那就没什么好说的了，直接二分查找。</p>
<p>假设我们给定的数字是2，二分查找可以帮我们找到一个2。然后我们左右两边顺序扫描，找到第一个2和最后一个2。因为要查找的数字在长度为n的数组中有可能出现O(n)次，所以顺序扫描的时间复杂度为O(n)。因此这种算法的效率和从头到尾直接顺序扫描整个数组统计出2的个数是一样的。</p>
<p>我们在这里采用更高效的方法。还是二分法找到一个2，然后我们开始判断，这个2是不是第一个2（或者最后一个2）：如果是，那么就返回序列号，如果不是，就继续二分查找。由于二分法查找第一个2和最后一个2在此处的判断条件不一样，所以得分开写。</p>
<p>我们不要拘泥于迭代，也可以试着写写循环嘛。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data ,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> firstK = getFirstK(data, <span class="number">0</span>, length<span class="number">-1</span>, k);</span><br><span class="line">        <span class="keyword">int</span> lastK = getLastK(data, <span class="number">0</span>, length<span class="number">-1</span>, k);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(firstK != <span class="number">-1</span> &amp;&amp; lastK != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> lastK-firstK+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> &gt; <span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> middleIndex = (<span class="built_in">end</span>+<span class="built_in">begin</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(middleData == k)&#123;</span><br><span class="line">            <span class="keyword">if</span>((middleIndex &gt; <span class="number">0</span> &amp;&amp; data[middleIndex<span class="number">-1</span>] != k) || middleIndex == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> middleIndex;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">end</span> = middleIndex - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(middleData &gt; k)</span><br><span class="line">            <span class="built_in">end</span> = middleIndex - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">begin</span> = middleIndex + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> getFirstK(data, <span class="built_in">begin</span>, <span class="built_in">end</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环实现</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = data.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> middleIndex = (<span class="built_in">end</span>+<span class="built_in">begin</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> middleData = data[middleIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">begin</span> &lt;= <span class="built_in">end</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(middleData == k)&#123;</span><br><span class="line">                <span class="keyword">if</span>((middleIndex &lt; length<span class="number">-1</span> &amp;&amp; data[middleIndex+<span class="number">1</span>] != k) || middleIndex == length<span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> middleIndex;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">begin</span> = middleIndex + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(middleData &gt; k)</span><br><span class="line">                <span class="built_in">end</span> = middleIndex - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">begin</span> = middleIndex + <span class="number">1</span>;</span><br><span class="line">            middleIndex = (<span class="built_in">end</span>+<span class="built_in">begin</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            middleData = data[middleIndex];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetNumberOfK</span><span class="params">(self, data, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> data.count(k)</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：平衡二叉树</title>
    <url>/folder/2019/11/08/2017-12-01-offer-60/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以在之前求二叉树深度的基础上进行算法实现，但是需要多次遍历。我们也可以用后序遍历，这样我们只需要遍历一次即可，需要需要存储一下左右子树的深度。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="多次遍历"><a href="#多次遍历" class="headerlink" title="多次遍历"></a>多次遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsBalanced_Solution(TreeNode* pRoot) &#123;</span><br><span class="line">        if(pRoot == NULL)</span><br><span class="line">            return true;</span><br><span class="line">        int left = getDepth(pRoot-&gt;left);</span><br><span class="line">        int right = getDepth(pRoot-&gt;right);</span><br><span class="line">        int diff = left - right;</span><br><span class="line">        if(diff &gt; 1 || diff &lt; -1)</span><br><span class="line">            return false;</span><br><span class="line">        return IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    int getDepth(TreeNode* pRoot)&#123;</span><br><span class="line">        return pRoot ? max(getDepth(pRoot-&gt;left),getDepth(pRoot-&gt;right))+1 :0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsBalanced_Solution(TreeNode* pRoot) &#123;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        return IsBalanced(pRoot, &amp;depth);</span><br><span class="line">    &#125;</span><br><span class="line">    int IsBalanced(TreeNode* pRoot, int* depth)&#123;</span><br><span class="line">        if(pRoot == NULL)&#123;</span><br><span class="line">            *depth = 0;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        int left, right;</span><br><span class="line">        if(IsBalanced(pRoot-&gt;left, &amp;left) &amp;&amp; IsBalanced(pRoot-&gt;right, &amp;right))&#123;</span><br><span class="line">            int diff = left - right;</span><br><span class="line">            if(diff &lt;= 1 &amp;&amp; diff &gt;= -1)&#123;</span><br><span class="line">                *depth = 1 + (left &gt; right ? left : right);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="多次遍历-1"><a href="#多次遍历-1" class="headerlink" title="多次遍历"></a>多次遍历</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    def IsBalanced_Solution(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if pRoot == None:</span><br><span class="line">            return True</span><br><span class="line">        left = self.getDepth(pRoot.left)</span><br><span class="line">        right = self.getDepth(pRoot.right)</span><br><span class="line">        diff = abs(left - right)</span><br><span class="line">        if diff &gt; 1:</span><br><span class="line">            return False</span><br><span class="line">        return self.IsBalanced_Solution(pRoot.left) and self.IsBalanced_Solution(pRoot.right)</span><br><span class="line">    def getDepth(self, pRoot):</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return 0</span><br><span class="line">        return max(self.getDepth(pRoot.left),self.getDepth(pRoot.right))+1</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：和为S的两个数字</title>
    <url>/folder/2019/11/08/2017-12-01-offer-59/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，是的他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>对应每个测试案例，输出两个数，小的先输出。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>暴力的时间复杂度为O(n^2)。</p>
<p>下面我们想一下时间复杂度为O(n)的算法。我们可以定义两个指针，一个从前往后遍历（ahead），另一个从后往前遍历（behind）。首先，我们比较第一个数字和最后一个数字的和curSum与给定数字sum，如果curSum &lt; sum，那么我们就要加大输入值，所以，ahead向后移动一位，重复之前的计算；如果curSum &gt; sum，那么我们就要减小输入值，所以，behind向前移动一位，重复之前的计算；如果相等，那么这两个数字就是我们要找的数字，直接输出即可。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123;</span><br><span class="line">        vector&lt;int&gt; result;</span><br><span class="line">        int length = array.size();</span><br><span class="line">        if(length &lt; 1)</span><br><span class="line">            return result;</span><br><span class="line">        int ahead = length-1;</span><br><span class="line">        int behind = 0;</span><br><span class="line">        int curSum;</span><br><span class="line">        while(ahead &gt; behind)&#123;</span><br><span class="line">            curSum = array[ahead] + array[behind];</span><br><span class="line">            if(curSum == sum)&#123;</span><br><span class="line">                result.push_back(array[behind]);</span><br><span class="line">                result.push_back(array[ahead]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(curSum &lt; sum)</span><br><span class="line">                ++behind;</span><br><span class="line">            else</span><br><span class="line">                --ahead;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：和为S的连续正数序列</title>
    <url>/folder/2019/11/08/2017-12-01-offer-58/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p>
<h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h2><p>输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>延续我们上一道题的思路，可以先给定两个数（phigh = 2,plow = 1），然后开始遍历求和，如果curSum大了，plow加1，如果curSum小了，phigh就加1；每次遇到curSum和sum相等了，就将当前plow和phigh之间的数据全部压入临时tmp中，最后再将tmp压入最终结果result。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt; &gt; result;</span><br><span class="line">        int phigh = 2,plow = 1;</span><br><span class="line">         </span><br><span class="line">        while(phigh &gt; plow)&#123;</span><br><span class="line">            int curSum = (phigh + plow) * (phigh - plow + 1) / 2;</span><br><span class="line">            if( curSum &lt; sum)</span><br><span class="line">                phigh++;</span><br><span class="line">             </span><br><span class="line">            if( curSum == sum)&#123;</span><br><span class="line">                vector&lt;int&gt; res;</span><br><span class="line">                for(int i = plow; i &lt;= phigh; i++)</span><br><span class="line">                    res.push_back(i);</span><br><span class="line">                result.push_back(res);</span><br><span class="line">                plow++;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            if(curSum &gt; sum)</span><br><span class="line">                plow++;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：翻转单词顺序列</title>
    <url>/folder/2019/11/08/2017-12-01-offer-57/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路很简单，先将每个单词反转，再将所有字符串一起反转。我们这里写个函数封装一下反转的过程，同时用追加空格字符的方式来减少判断条件。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string ReverseSentence(string str) &#123;</span><br><span class="line">        auto length = str.size();</span><br><span class="line">        if(length == 0)</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        str += &apos; &apos;;</span><br><span class="line">        int mark = 0;</span><br><span class="line">        for(int i = 0; i &lt; length + 1; ++i)&#123;</span><br><span class="line">            if(str[i] == &apos; &apos;)&#123;</span><br><span class="line">                reverseWord(str, mark, i-1);</span><br><span class="line">                mark = i + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        str = str.substr(0, length);</span><br><span class="line">        reverseWord(str, 0, length-1);</span><br><span class="line">        </span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line">    void reverseWord(string &amp;str, int begin, int end)&#123;</span><br><span class="line">        while(end &gt; begin)</span><br><span class="line">            swap(str[begin++],str[end--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（知识迁移能力）：二叉树的深度</title>
    <url>/folder/2019/11/08/2017-12-01-offer-56/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>DFS:题目很简单，用递归遍历只需一行。如果传入的树指针为空指针，则直接返回0；否则，递归调用TreeDepth，遍历左右子树并返回最大值。<br>BFS:层次遍历，需要使用队列。如果队列不为空，则在循环内不断的pop根节点、push左右子树，同时累加depth。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        return pRoot ? max(TreeDepth(pRoot-&gt;left),TreeDepth(pRoot-&gt;right))+1 :0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历："><a href="#层序遍历：" class="headerlink" title="层序遍历："></a>层序遍历：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">struct TreeNode &#123;</span><br><span class="line">	int val;</span><br><span class="line">	struct TreeNode *left;</span><br><span class="line">	struct TreeNode *right;</span><br><span class="line">	TreeNode(int x) :</span><br><span class="line">			val(x), left(NULL), right(NULL) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int TreeDepth(TreeNode* pRoot)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!pRoot) return 0;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        int depth = 0;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        while(!que.empty())&#123;</span><br><span class="line">            int size = que.size();</span><br><span class="line">            depth++;</span><br><span class="line">            for(int i=0; i &lt; size; i++)&#123;</span><br><span class="line">                TreeNode* node = que.front();</span><br><span class="line">                que.pop();</span><br><span class="line">                if(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">                if(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现："><a href="#Python版代码实现：" class="headerlink" title="Python版代码实现："></a>Python版代码实现：</h2><h3 id="递归：-1"><a href="#递归：-1" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return 0</span><br><span class="line">        return max(self.TreeDepth(pRoot.left),self.TreeDepth(pRoot.right))+1</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历："><a href="#层次遍历：" class="headerlink" title="层次遍历："></a>层次遍历：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line">class Solution:</span><br><span class="line">    def TreeDepth(self, pRoot):</span><br><span class="line">        # write code here</span><br><span class="line">        if not pRoot:</span><br><span class="line">            return 0</span><br><span class="line">        a=[pRoot]</span><br><span class="line">        depth=0</span><br><span class="line">        while a:</span><br><span class="line">            b=[]</span><br><span class="line">            for node in a:</span><br><span class="line">                if node.left:</span><br><span class="line">                    b.append(node.left)</span><br><span class="line">                if node.right:</span><br><span class="line">                    b.append(node.right)</span><br><span class="line">            a=b</span><br><span class="line">            depth=depth+1</span><br><span class="line">        return depth</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>知识迁移能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（栈和队列）：用两个栈实现队列</title>
    <url>/folder/2019/11/08/2017-12-01-offer-55/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>栈是一个非常常见的数据结构，它在计算机领域被广泛应用，比如操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址及临时变量等。栈的特点是后进先出，即最后被压入（push）栈的元素会第一个被弹出（pop）。通常栈是一个不考虑排序的数据结构，所以我们需要O(n)时间才能找到栈中最大或者最小的元素。如果想要在O(1)时间内得到栈的最大或者最小值，我们需要对栈进行特殊的设计，以后会讲到。</p>
<p>队列是另外一种很重要的数据结构。与栈不同，队列的特点是先进先出。栈和队列虽然是特点针锋相对的两个数据结构，但有意思的是它们却相互联系，比如用两个栈实现队列，当然也可以用两个队列实现栈。</p>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>栈：后进先出（LIFO）;<br>队列：先进先出（FIFO）.<br>入队：将元素进栈A<br>出队：判断栈B是否为空，如果为空，则将栈A中所有元素pop，并push进栈B，栈B出栈；<br> 如果不为空，栈B直接出栈</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                tmp = stack1.top();</span><br><span class="line">                stack2.push(tmp);</span><br><span class="line">                stack1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现："><a href="#Python版代码实现：" class="headerlink" title="Python版代码实现："></a>Python版代码实现：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.stack1 = []</span><br><span class="line">        self.stack2 = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.stack1.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># return xx</span></span><br><span class="line">        <span class="keyword">if</span> self.stack2 == []:</span><br><span class="line">            <span class="keyword">while</span> self.stack1:</span><br><span class="line">                self.stack2.append(self.stack1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stack2.pop()</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（栈和队列）：滑动窗口的最大值</title>
    <url>/folder/2019/11/08/2017-12-01-offer-54/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>实际上一个滑动窗口可以看成是一个队列。当窗口滑动时，处于窗口的第一个数字被删除，同时在窗口的末尾添加一个新的数字。这符合队列的先进先出特性。那么剩下的任务就是如何从队列中找出它的最大值了。</p>
<p>之前有题目是用O(1)时间得到最小值的栈，也有题目是用两个栈实现队列，如果结合起来，我们就会很容易写出来代码。总的时间复杂度为O(n)。</p>
<p>但是在这里，我们并不打算用上述方法，因为这相当于要写两个题的代码。我们试想一下，如果把比大小这一步放在入栈之前，情况会不会好点？</p>
<p>我们可以用STL中的deque来实现，接下来我们以数组{2,3,4,2,6,2,5,1}为例，来细说整体思路。</p>
<p>数组的第一个数字是2，把它存入队列中。第二个数字是3，比2大，所以2不可能是滑动窗口中的最大值，因此把2从队列里删除，再把3存入队列中。第三个数字是4，比3大，同样的删3存4。此时滑动窗口中已经有3个数字，而它的最大值4位于队列的头部。</p>
<p>第四个数字2比4小，但是当4滑出之后它还是有可能成为最大值的，所以我们把2存入队列的尾部。下一个数字是6，比4和2都大，删4和2，存6。就这样依次进行，最大值永远位于队列的头部。</p>
<p>但是我们怎样判断滑动窗口是否包括一个数字？应该在队列里存入数字在数组里的下标，而不是数值。当一个数字的下标与当前处理的数字的下标之差大于或者相等于滑动窗口大小时，这个数字已经从窗口中滑出，可以从队列中删除。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171226163637275?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>下述代码中，index是一个两端开口的队列，用来保存有可能是滑窗最大值的数字的下标。在存入一个数字的下标之前，首先要判断队列里已有数字是否小于待存入的数字。如果已有的数字小于待存入的数字，这些数字已经不可能是滑动窗口的最大值，因此它们将会依次从队列的尾部删除（调用pop_back）。同时，如果队列头部的数字已经从窗口里滑出，滑出的数字也需要从队列的头部删除（调用pop_front）。由于队列的头部和尾部都有可能删除数字，这也是需要两段开口的队列的原因。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; num, <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxInWindows;</span><br><span class="line">        <span class="keyword">if</span>(num.<span class="built_in">size</span>() &gt;= <span class="built_in">size</span> &amp;&amp; <span class="built_in">size</span> &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; index;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)&#123;</span><br><span class="line">                <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">                    index.pop_back();</span><br><span class="line">                index.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="built_in">size</span>; i &lt; num.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">                maxInWindows.push_back(num[index.front()]);</span><br><span class="line">                <span class="keyword">while</span>(!index.empty() &amp;&amp; num[i] &gt;= num[index.back()])</span><br><span class="line">                    index.pop_back();</span><br><span class="line">                <span class="keyword">if</span>(!index.empty() &amp;&amp; index.front() &lt;= (<span class="keyword">int</span>)(i-<span class="built_in">size</span>))</span><br><span class="line">                    index.pop_front();</span><br><span class="line">                index.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">            maxInWindows.push_back(num[index.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxInWindows;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（位运算）：二进制中1的个数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-53/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>方法一：用1（循环左移）与n的每一位进行位与，来判断1的个数；注意，如果用n进行循环右移，一定要注意负数的情况，因为如果是负数，n右移之后高位补位为1，如果一开始不对n加以判断和处理，就会进入死循环。</p>
<p>方法二：目前我认为最优的解。n=(n-1) &amp; n;<br>举个栗子：一个二进制数n为1100，那么n-1为1011，1011&amp;1100=1000，我们会发现，这样操作之后，相当于把n最右边的一个1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<p>方法三：python的解法给了我另一种思路，为什么不用位数作为循环终止条件呢？</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; flag) != <span class="number">0</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="keyword">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            ++count;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现："><a href="#Python版代码实现：" class="headerlink" title="Python版代码实现："></a>Python版代码实现：</h2><h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sum([(n&gt;&gt;i &amp; <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">32</span>)])</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（数组）：数组中重复的数字</title>
    <url>/folder/2019/11/08/2017-12-01-offer-52/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果先排序，再找出重复的数字是一件很容易的事情，只需要从头到尾遍历排序后的数组就可以了。排序一个长度为n的数组需要O(nlogn)的时间。</p>
<p>还可以利用hash表来解决这个问题，从头到尾按顺序扫描数组中的每个数，每扫描到一个数字的时候，都可以用O(1)的时间来判断哈希表里是否已经包含了该数字。如果哈希表里还没有这个数字，就把它加入到哈希表中；如果已经存在，就说明找到了一个重复的数字。算法复杂度为O(n)，但是是以一个大小为O(n)的哈希表为代价的。</p>
<p>还可以把当前序列当成是一个下标和下标对应值是相同的数组（时间复杂度为O(n),空间复杂度为O(1)）；<br>遍历数组，判断当前位的值和下标是否相等： </p>
<ol>
<li>若相等，则遍历下一位； </li>
<li>若不等，则将当前位置i上的元素和a[i]位置上的元素比较：若它们相等，则成功！若不等，则将它们两交换。换完之后a[i]位置上的值和它的下标是对应的，但i位置上的元素和下标并不一定对应；重复2的操作，直到当前位置i的值也为i，将i向后移一位，再重复2.</li>
</ol>
<p>本文复现的是最后一种方法。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//        numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//        length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//        duplication: (Output) the duplicated number in the array number</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//非法输入1</span></span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="literal">NULL</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//非法输入2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &lt; <span class="number">0</span> || numbers[i] &gt; length<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历查找第一个重复的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">            <span class="keyword">while</span>(numbers[i] != i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                    *duplication = numbers[i];</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不相等就交换</span></span><br><span class="line">                <span class="keyword">int</span> temp = numbers[i];</span><br><span class="line">                numbers[i] = numbers[temp];</span><br><span class="line">                numbers[temp] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（数组）：构建乘积数组</title>
    <url>/folder/2019/11/08/2017-12-01-offer-51/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]。不能使用除法。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>B[i]=A[0] * A[1] * … * A[i-1] * A[i+1] * … * A[n-1]<br>1.从左到右算 B[i]=A[0] * A[1] * … * A[i-1]<br>2.从右到左算 B[i] * =A[i+1] * … * A[n-1]<br>拒绝嵌套循环。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; multiply(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    	<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; B(n);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ret*=A[i++])</span><br><span class="line">            B[i] = ret;</span><br><span class="line">        ret=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span>; ret*=A[i--])</span><br><span class="line">            B[i] *=ret;</span><br><span class="line">        <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现："><a href="#Python版代码实现：" class="headerlink" title="Python版代码实现："></a>Python版代码实现：</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        num = len(A)</span><br><span class="line">        B = [<span class="literal">None</span>] * num</span><br><span class="line">        B[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, num):</span><br><span class="line">            B[i] = B[i<span class="number">-1</span>] * A[i<span class="number">-1</span>]</span><br><span class="line">        tmp = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            tmp *= A[i+<span class="number">1</span>]   </span><br><span class="line">            B[i] *= tmp</span><br><span class="line">        <span class="keyword">return</span> B</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（数组）：二维数组中的查找</title>
    <url>/folder/2019/11/08/2017-12-01-offer-50/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>首先选取数组中右上角的数字。如果该数字等于要查找的数字，查找过程结束；如果该数字大于要查找的数字，剔除这个数字所在的列；如果该数字小于要查找的数字，剔除这个数字所在的行。也就是说如果要查找的数字不在数组的右上角，则每一次都在数组的查找范围中剔除一行或者一列，这样每一步都可以缩小查找的范围，直到找到要查找的数字，或者查找范围为空。</p>
<p>当然，大家也可以制定自己的规则，建议从左下角或者右上角开始，因为如果直接随机选取数组中的一个数开始进行比较，剩下的区域会出现重合的现象，即所谓的岔路，不好操作。比如我用的右上角，那就一直用右上角的进行判断，进行比较后剔除一行或者一列。算法时间复杂度为O(m+n)。</p>
<p>还有人直接对每一行用二分法进行查找，算法时间复杂度为O(mlogn)。</p>
<h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h2><h3 id="右上角"><a href="#右上角" class="headerlink" title="右上角"></a>右上角</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> col = <span class="built_in">array</span>[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">array</span>.empty() &amp;&amp; row &gt; <span class="number">0</span> &amp;&amp; col &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> j = col - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(i &lt; row &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] == target)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">array</span>[i][j] &gt; target)</span><br><span class="line">                    --j;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="二分遍历"><a href="#二分遍历" class="headerlink" title="二分遍历"></a>二分遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high=<span class="built_in">array</span>[i].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(target &gt; <span class="built_in">array</span>[i][mid])</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; <span class="built_in">array</span>[i][mid])</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h2><h3 id="右上角-1"><a href="#右上角-1" class="headerlink" title="右上角"></a>右上角</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        </span><br><span class="line">        row=len(array)</span><br><span class="line">        col=len(array[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> row &gt; <span class="number">0</span> <span class="keyword">and</span> col &gt; <span class="number">0</span>:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            j = col <span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; row <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> array[i][j] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> array[i][j] &gt; target:</span><br><span class="line">                    j = j - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># array 二维列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Find</span><span class="params">(self, target, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        n=len(array)</span><br><span class="line">        flag=<span class="string">'false'</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> target <span class="keyword">in</span> array[i]:</span><br><span class="line">                flag=<span class="string">'true'</span>;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> flag</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        S=Solution()</span><br><span class="line">        <span class="comment"># 字符串转为list</span></span><br><span class="line">        L=list(eval(raw_input()))</span><br><span class="line">        array=L[<span class="number">1</span>]</span><br><span class="line">        target=L[<span class="number">0</span>]</span><br><span class="line">        print(S.Find(target, array))</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：重建二叉树</title>
    <url>/folder/2019/11/08/2017-12-01-offer-49/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>树是一种实际编程中经常遇到的数据结构。由于树的操作会设计大量的指针，因此与树有关的面试题都不太容易。当面试官想考查应聘者在有复杂指针操作的情况下写代码的能力，他往往会想到用与树有关的面试题。</p>
<p>面试的时候提到的树，大部分都是二叉树。所谓二叉树是树的一种特殊结构，在二叉树中每个结点最多只能有两个子结点。在二叉树中最重要的操作莫过于遍历，即按照某一顺序访问树中的所有结点。通常树有如下几种遍历方式：</p>
<ul>
<li>前序遍历：先访问根结点，再访问左子结点，最后访问右子结点。</li>
<li>中序遍历：先访问左子结点，再访问根结点，最后访问右子结点。</li>
<li>后序遍历：先访问左子结点，再访问右子结点，最后访问根结点。</li>
</ul>
<p>前中后都是指的根结点在遍历中的位置。每一种遍历都有递归和循环两种不同的实现方式，每一种遍历的递归实现都比循环实现要简捷很多。我们需要对着三种遍历的六种实现方法都了如指掌。</p>
<ul>
<li>宽度优先遍历：先访问树的第一层结点，再访问树的第二层结点，一直访问到最下面一层节点。在同一层结点中，以从左到右的顺序依次访问。</li>
</ul>
<p>特例：</p>
<ul>
<li>二叉搜索树。在二叉搜索树中，左子结点总是小于或等于根结点，而右子结点总是大于或等于根结点。我们可以平均在O(logn)的时间内根据数值在二叉搜索树中找到一个结点。</li>
<li>堆。堆分为最大堆和最小堆。在最大堆中根结点的值最大，在最小堆中结点的值最小。有很多需要快速找到最大值或者最小值的问题都可以用堆来解决。</li>
<li>红黑树。红黑树是把树中的结点定义为红、黑两种颜色，并通过规则确保从根结点到叶结点的最长路径的长度不超过最短路径的两倍。</li>
</ul>
<p>在C++的STL中，set、multiset、map、multimap等数据结构都是基于红黑树实现的。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>前序遍历序列中，第一个数字总是树的根结点的值。在中序遍历序列中，根结点的值在序列的中间，左子树的结点的值位于根结点的值的左边，而右子树的结点的值位于根结点的值的右边。剩下的我们可以递归来实现，具体如图：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170927101737391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">reConstructBinaryTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vinlen = vin.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(vinlen == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; left_pre, right_pre, left_vin, right_vin;</span><br><span class="line">        <span class="comment">//创建根节点，根节点肯定是前序遍历的第一个数</span></span><br><span class="line">        TreeNode* head = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//找到中序遍历根节点所在位置,存放于变量gen中</span></span><br><span class="line">        <span class="keyword">int</span> gen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vinlen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (vin[i] == pre[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                gen = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边</span></span><br><span class="line">        <span class="comment">//利用上述这点，对二叉树节点进行归并</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            left_vin.push_back(vin[i]);</span><br><span class="line">            left_pre.push_back(pre[i+<span class="number">1</span>]);<span class="comment">//前序第一个为根节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gen + <span class="number">1</span>; i &lt; vinlen; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            right_vin.push_back(vin[i]);</span><br><span class="line">            right_pre.push_back(pre[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取出前序和中序遍历根节点左边和右边的子树</span></span><br><span class="line">        <span class="comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span></span><br><span class="line">        head-&gt;left=reConstructBinaryTree(left_pre,left_vin);</span><br><span class="line">        head-&gt;right=reConstructBinaryTree(right_pre,right_vin);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回构造的TreeNode根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reConstructBinaryTree</span><span class="params">(self, pre, tin)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> len(pre) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag = TreeNode(pre[<span class="number">0</span>])</span><br><span class="line">            flag.left = self.reConstructBinaryTree(pre[<span class="number">1</span>:tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>],tin[:tin.index(pre[<span class="number">0</span>])])</span><br><span class="line">            flag.right = self.reConstructBinaryTree(pre[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:],tin[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:] )</span><br><span class="line">        <span class="keyword">return</span> flag</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：序列化二叉树</title>
    <url>/folder/2019/11/08/2017-12-01-offer-48/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题其实没什么好说的，在牛客网上，即使你在反序列化的时候直接输出root也能通过测试。</p>
<p>书上倒是写的听清楚。用到了dfs的思想，通过前序遍历来序列化或者反序列化。这块你只要自己写的格式能对应上，都是可以的。比如可以按照书中那样用$表示null并且用逗号分隔每个节点，也可以直接用下面代码所示的0xFFFFFFFF标识null。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; buf;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            buf.push_back(<span class="number">0xFFFFFFFF</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            buf.push_back(root-&gt;val);</span><br><span class="line">            dfs1(root-&gt;left);</span><br><span class="line">            dfs1(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span>* &amp;str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="number">0xFFFFFFFF</span>)&#123;</span><br><span class="line">            ++str;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* res = <span class="keyword">new</span> TreeNode(*str);</span><br><span class="line">        str++;</span><br><span class="line">        res-&gt;left = dfs2(str);</span><br><span class="line">        res-&gt;right = dfs2(str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123;    </span><br><span class="line">        buf.<span class="built_in">clear</span>();</span><br><span class="line">        dfs1(root);</span><br><span class="line">        <span class="keyword">int</span> bufSize = buf.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> *res = <span class="keyword">new</span> <span class="keyword">int</span>[bufSize];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; bufSize; i++) res[i] = buf[i];</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">char</span>*)res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)str;</span><br><span class="line">        <span class="keyword">return</span> dfs2(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：数据流中的中位数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-47/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>解法很多，直接列出表格吧。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171226114037598?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>我们这里采用最优的最大最小堆来实现。下面来讨论一些细节问题。</p>
<p>首先要保证数据平均分配到两个堆中，因此两个堆中数据的数目之差不能超过1.为了实现平均分配，可以在数据的总数目是偶数时把新数据插入到最小堆中，否则插入到最大堆中。</p>
<p>此外，还要保证最大堆中所有数据小于最小堆中数据。所以，新传入的数据需要先和最大堆的最大值或者最小堆中的最小值进行比较。以总数目为偶数为例，按照我们制定的规则，新的数据会被插入到最小堆中，但是在这之前，我们需要判断这个数据和最大堆中的最大值谁更大，如果最大堆中的数据比较大，那么我们就需要把当前数据插入最大堆，然后弹出新的最大值，再插入到最小堆中。由于最终插入到最小堆的数字是原最大堆中最大的数字，这样就保证了最小堆中所有数字都大于最大堆的数字。</p>
<p>下面代码中，我们基于stl中的函数push_heap、pop_heap以及vector实现堆。比较仿函数less和greater分别用来实现最大堆和最小堆。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(((<span class="built_in">min</span>.<span class="built_in">size</span>() + <span class="built_in">max</span>.<span class="built_in">size</span>()) &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">max</span>.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; num &lt; <span class="built_in">max</span>[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="built_in">max</span>.push_back(num);</span><br><span class="line">                push_heap(<span class="built_in">max</span>.<span class="built_in">begin</span>(), <span class="built_in">max</span>.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                num = <span class="built_in">max</span>[<span class="number">0</span>];</span><br><span class="line">                pop_heap(<span class="built_in">max</span>.<span class="built_in">begin</span>(), <span class="built_in">max</span>.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                <span class="built_in">max</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">min</span>.push_back(num);</span><br><span class="line">            push_heap(<span class="built_in">min</span>.<span class="built_in">begin</span>(), <span class="built_in">min</span>.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span>.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; num &gt; <span class="built_in">min</span>[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="built_in">min</span>.push_back(num);</span><br><span class="line">                push_heap(<span class="built_in">min</span>.<span class="built_in">begin</span>(), <span class="built_in">min</span>.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                num = <span class="built_in">min</span>[<span class="number">0</span>];</span><br><span class="line">                pop_heap(<span class="built_in">min</span>.<span class="built_in">begin</span>(), <span class="built_in">min</span>.<span class="built_in">end</span>(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">                <span class="built_in">min</span>.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">max</span>.push_back(num);</span><br><span class="line">            push_heap(<span class="built_in">max</span>.<span class="built_in">begin</span>(), <span class="built_in">max</span>.<span class="built_in">end</span>(), less&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">max</span>.<span class="built_in">size</span>() + <span class="built_in">min</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>((<span class="built_in">size</span> &amp; <span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">min</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">min</span>[<span class="number">0</span>] + <span class="built_in">max</span>[<span class="number">0</span>]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">min</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">max</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：二叉搜索树的第k个结点</title>
    <url>/folder/2019/11/08/2017-12-01-offer-46/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我感觉大家都很容易就能想到中序遍历，因为二叉搜索树本来就是排序的，左结点小于根结点小于右结点，这个顺序正好和中序遍历的顺序一样。参考代码如下，其中遍历右子树的时候多加了对target == NULL 的判断，意思是如果target有值了就没必要往下再遍历了。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNode</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> KthNodeCore(pRoot, k);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">KthNodeCore</span><span class="params">(TreeNode* pRoot, <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">        TreeNode* target = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            target = KthNodeCore(pRoot-&gt;left, k);</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">1</span>)</span><br><span class="line">                target = pRoot;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="literal">NULL</span> &amp;&amp; pRoot-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            target = KthNodeCore(pRoot-&gt;right, k);</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：二叉树的下一个结点</title>
    <url>/folder/2019/11/08/2017-12-01-offer-45/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果一个结点有右子树，那么它的下一个结点就是它的右子树中的最左子结点；<br>如果给定结点是其父结点的左子结点，那么它的下一个结点就是它的父结点；<br>如果一个结点既没有右子树，并且它还是它父结点的右子结点，那我们就需要一直向上遍历，知道找到一个是其父结点的左子结点的结点。</p>
<p>对最后一种情况做下解释，比如我们为了找到下图中结点i的下一个结点，我们沿着指向父结点的指针向上遍历，先到达结点e。由于结点e是它父结点的b的右结点，我们继续遍历到b。b是其父结点a的左子结点，因此b的父结点a就是结点i的下一个结点。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171222173052841?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *right;</span></span><br><span class="line"><span class="comment">    struct TreeLinkNode *next;</span></span><br><span class="line"><span class="comment">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">GetNext</span><span class="params">(TreeLinkNode* pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        TreeLinkNode* pNext = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//当前结点有右子树，则下一结点是右子树的最左结点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            TreeLinkNode* pRight = pNode-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(pRight-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                pRight = pRight-&gt;left;</span><br><span class="line">            pNext = pRight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前结点无右子树，则需要向上找到其父结点（可以是当前结点）可以作为左子树的时候</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            TreeLinkNode* pCurrent = pNode;</span><br><span class="line">            TreeLinkNode* pParrent = pNode-&gt;next;</span><br><span class="line">            <span class="keyword">while</span>(pParrent != <span class="literal">NULL</span> &amp;&amp; pCurrent == pParrent-&gt;right)&#123;</span><br><span class="line">                pCurrent = pParrent;</span><br><span class="line">                pParrent = pParrent-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            pNext = pParrent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：对称的二叉树</title>
    <url>/folder/2019/11/08/2017-12-01-offer-44/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以通过比较二叉树的前序遍历序列和对称前序遍历序列来判断二叉树是不是对称的。如果两个序列是一样的，那么二叉树就是对称的。需要注意的是，我们一定要加上null值得判断，要不然如果一棵树所有结点数值都一样的时候，我们就没办法区分是否对称了。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> &amp;&amp; pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> || pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1-&gt;val != pRoot2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot1-&gt;left, pRoot2-&gt;right)</span><br><span class="line">            &amp;&amp; isSymmetrical(pRoot1-&gt;right, pRoot2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：把二叉树打印成多行</title>
    <url>/folder/2019/11/08/2017-12-01-offer-43/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>层序遍历，之前求数的深度的时候简单用过。</p>
<p>在线测试由于种种原因，测试结果需要是一个二维数组（vector&lt;vector<int> &gt;），而不是原著中的每一层输出一行（其实意思都差不多），所以我们这里用两个队列进行实现（如果没有分行输出这个要求，一个队列就够了）。</p>
<p>queue是先进先出规则，我们初始化两个queue（q1和q2）交替来存储每一层结点（这种结构在下一个题目中也将用到，只不过queue变成了stack），从而达到所谓的每一层输出一行。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">            <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; q1;</span><br><span class="line">            <span class="built_in">queue</span>&lt;TreeNode*&gt; q2;</span><br><span class="line">            q1.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!q1.empty()||!q2.empty())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">                <span class="keyword">while</span>(!q1.empty())&#123;</span><br><span class="line">                    v1.push_back(q1.front()-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(q1.front()-&gt;left!=<span class="literal">NULL</span>) q2.push(q1.front()-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(q1.front()-&gt;right!=<span class="literal">NULL</span>) q2.push(q1.front()-&gt;right);</span><br><span class="line">                    q1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v1.<span class="built_in">size</span>()!=<span class="number">0</span>)</span><br><span class="line">                ret.push_back(v1);</span><br><span class="line">                <span class="keyword">while</span>(!q2.empty())&#123;</span><br><span class="line">                    v2.push_back(q2.front()-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(q2.front()-&gt;left!=<span class="literal">NULL</span>)   q1.push(q2.front()-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(q2.front()-&gt;right!=<span class="literal">NULL</span>)  q1.push(q2.front()-&gt;right);</span><br><span class="line">                    q2.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v2.<span class="built_in">size</span>()!=<span class="number">0</span>)</span><br><span class="line">                ret.push_back(v2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（树）：按之字形顺序打印二叉树</title>
    <url>/folder/2019/11/08/2017-12-01-offer-42/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题和上一道《把二叉树打印成多行》的思路是一样的，只不过，我们需要考虑如何来实现奇偶行的不同顺序输出。首先，肯定不能再上一道题的基础上对偶数行进行reverse，那样效率太低，根本不实用。</p>
<p>如果还和上一道题一样用queue（左右结点的遍历顺序稍作更改），我们会发现，对于一个三层的二叉树（1-2-3-4-5-6-7），前两行都没问题，到了第三行，就乱了，无论你怎么更改第二个queue的遍历顺序。原因就在于，我上一行输出的最后一个结点，它的子结点要紧接着作为下一个输出才对，而queue是先进先出，所以你上一行输出的最后一个结点，它的子结点只能在同行中最后输出。</p>
<p>先入先出不行，我们就用先入后出的stack。对于一个三层的二叉树（1-2-3-4-5-6-7），第一个stack压入1，弹出1后第二个stack顺序压入2、3，顺序弹出3（压7、6）、2（压5、4）后第一个stack顺序压入7、6、5、4，顺序弹出4、5、6、7后结束。没毛病。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ret;</span><br><span class="line">            <span class="keyword">if</span>(pRoot==<span class="literal">NULL</span>) <span class="keyword">return</span> ret;</span><br><span class="line">            <span class="built_in">stack</span>&lt;TreeNode*&gt; s1;</span><br><span class="line">            <span class="built_in">stack</span>&lt;TreeNode*&gt; s2;</span><br><span class="line">            s1.push(pRoot);</span><br><span class="line">            <span class="keyword">while</span>(!s1.empty()||!s2.empty())&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">                <span class="keyword">while</span>(!s1.empty())&#123;</span><br><span class="line">                    v1.push_back(s1.top()-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(s1.top()-&gt;left!=<span class="literal">NULL</span>) s2.push(s1.top()-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(s1.top()-&gt;right!=<span class="literal">NULL</span>) s2.push(s1.top()-&gt;right);</span><br><span class="line">                    s1.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v1.<span class="built_in">size</span>()!=<span class="number">0</span>)</span><br><span class="line">                ret.push_back(v1);</span><br><span class="line">                <span class="keyword">while</span>(!s2.empty())&#123;</span><br><span class="line">                    v2.push_back(s2.top()-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(s2.top()-&gt;right!=<span class="literal">NULL</span>)   s1.push(s2.top()-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(s2.top()-&gt;left!=<span class="literal">NULL</span>)  s1.push(s2.top()-&gt;left);</span><br><span class="line">                    s2.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v2.<span class="built_in">size</span>()!=<span class="number">0</span>)</span><br><span class="line">                ret.push_back(v2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间效率）：最小的K个数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-41/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路一：结合快排。排序后直接for循环将最小的K个数填入结果。时间复杂度O（NlogK）。</p>
<p>思路二：最大堆或者红黑树。我们可以先创建一个大小为K的数据容器来存储最小的k个数字，然后每次从N个整数中读取一个数。如果容器中已有的数字个数少于K，则直接把这次读入的整数放入容器中；如果容器中已经有K个数了，此时我们需要找出容器中的最大值，然后与待插入的整数进行比较，谁小就留着谁。</p>
<p>我们再来捋一遍，容器满了之后我们要做的三件事情：一是在k个证书中找到最大数；二是有可能在这个容器中删除最大数；三是有可能要插入一个新的数字。如果用一个二叉树来实现这个数据容器，那么我们能在O(logK)时间内实现这三步操作。因此对于N个输入数字而言，总时间效率就是O(Nlogk)。</p>
<p>最大堆：根结点的值总是大于它的子树中任意结点的值。我们需要O(1)时间得到最大值，O(logK)时间来完成删除及插入操作；</p>
<p>红黑树：根据一定规则确保树在一定程度上是平衡的，从而保证在红黑树种查找、删除和插入操作都只需要O(logK)时间。</p>
<p>Python中没有现成的最大堆或者红黑树实现，本渣渣就不再这里折腾了。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(input.empty() || k &gt; input.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        sort(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">            res.push_back(input[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span> || k &gt; len || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>()+k);</span><br><span class="line">        <span class="comment">//建堆</span></span><br><span class="line">        make_heap(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=k; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(input[i] &lt; res[<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//先pop,然后在容器中删除</span></span><br><span class="line">                pop_heap(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">                res.pop_back();</span><br><span class="line">                <span class="comment">//先在容器中加入，再push</span></span><br><span class="line">                res.push_back(input[i]);</span><br><span class="line">                push_heap(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使其从小到大输出</span></span><br><span class="line">        sort_heap(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; GetLeastNumbers_Solution(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = input.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len &lt;= <span class="number">0</span> || k &gt; len || k &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        <span class="comment">//仿函数中的greater&lt;T&gt;模板，从大到小排序</span></span><br><span class="line">        <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt; leastNums;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vec_it = input.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span>(; vec_it != input.<span class="built_in">end</span>(); vec_it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//将前k个元素插入集合</span></span><br><span class="line">            <span class="keyword">if</span>(leastNums.<span class="built_in">size</span>() &lt; k)</span><br><span class="line">                leastNums.insert(*vec_it);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//第一个元素是最大值</span></span><br><span class="line">                <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt; &gt;::iterator greatest_it = leastNums.<span class="built_in">begin</span>();</span><br><span class="line">                <span class="comment">//如果后续元素&lt;第一个元素，删除第一个，加入当前元素</span></span><br><span class="line">                <span class="keyword">if</span>(*vec_it &lt; *(leastNums.<span class="built_in">begin</span>()))</span><br><span class="line">                &#123;</span><br><span class="line">                    leastNums.erase(greatest_it);</span><br><span class="line">                    leastNums.insert(*vec_it);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(leastNums.<span class="built_in">begin</span>(), leastNums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetLeastNumbers_Solution</span><span class="params">(self, tinput, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> tinput <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        n = len(tinput)</span><br><span class="line">        <span class="keyword">if</span> n &lt; k:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        tinput = sorted(tinput)</span><br><span class="line">        <span class="keyword">return</span> tinput[:k]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间效率）：整数中1出现的次数（从1到n整数中1出现的次数）</title>
    <url>/folder/2019/11/08/2017-12-01-offer-40/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>求出1<del>13的整数中1出现的次数,并算出100</del>1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>两种方法，一种是从1到n遍历，每次通过对10求余数判断整数的个位数字是不是1，大于10的除以10之后再判断。我们对每个数字都要做除法和求余运算以求出该数字中1出现的次数。如果输入数字n，n有O(logn)位，我们需要判断每一位是不是1，那么时间复杂度为O(n*logn)。</p>
<p>第二种方法是数学之美上面提出的方法，设定整数点（如1、10、100等等）作为位置点i（对应n的各位、十位、百位等等），分别对每个数位上有多少包含1的点进行分析。</p>
<ul>
<li>根据设定的整数位置，对n进行分割，分为两部分，高位n/i，低位n%i</li>
<li>当i表示百位，且百位对应的数&gt;=2,如n=31456,i=100，则a=314,b=56，此时百位为1的次数有a/10+1=32（最高两位0~31），每一次都包含100个连续的点，即共有(a/10+1)*100个点的百位为1</li>
<li>当i表示百位，且百位对应的数为1，如n=31156,i=100，则a=311,b=56，此时百位对应的就是1，则共有a/10(最高两位0-30)次是包含100个连续点，当最高两位为31（即a=311），本次只对应局部点00~56，共b+1次，所有点加起来共有（a/10*100）+(b+1)，这些点百位对应为1</li>
<li>当i表示百位，且百位对应的数为0,如n=31056,i=100，则a=310,b=56，此时百位为1的次数有a/10=31（最高两位0~30）</li>
<li>综合以上三种情况，当百位对应0或&gt;=2时，有(a+8)/10次包含所有100个点，还有当百位为1(a%10==1)，需要增加局部点b+1</li>
<li>之所以补8，是因为当百位为0，则a/10==(a+8)/10，当百位&gt;=2，补8会产生进位位，效果等同于(a/10+1)</li>
</ul>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">while</span>(temp)</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">if</span>(temp % <span class="number">10</span> == <span class="number">1</span>)</span><br><span class="line">                    ++count;</span><br><span class="line">                temp /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i *= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//i表示当前分析的是哪一个数位</span></span><br><span class="line">        <span class="keyword">int</span> a = n / i, b = n % i;</span><br><span class="line">        count = count + (a + <span class="number">8</span>) / <span class="number">10</span> * i + (a % <span class="number">10</span> == <span class="number">1</span>) * (b + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,n+<span class="number">1</span>):</span><br><span class="line">            temp = i</span><br><span class="line">            <span class="keyword">while</span> temp:</span><br><span class="line">                <span class="keyword">if</span> temp % <span class="number">10</span> == <span class="number">1</span>:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                temp /= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h3 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">            count += (n // i + <span class="number">8</span>) // <span class="number">10</span> * i + (n // i % <span class="number">10</span> == <span class="number">1</span>) * (n % i + <span class="number">1</span>)</span><br><span class="line">            i *= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间效率）：数组中出现次数超过一半的数字</title>
    <url>/folder/2019/11/08/2017-12-01-offer-39/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>思路一：结合快排。数组排序后，如果符合条件的数存在，则一定是数组中间那个数。（比如：1，2，2，2，3；或2，2，2，3，4；或2，3，4，4，4等等）<br>这种方法虽然容易理解，但由于涉及到快排sort，其时间复杂度为O(NlogN)并非最优；</p>
<p>思路二：书上的解法，时间复杂度为O(N)。如果有符合条件的数字，则它出现的次数比其他所有数字出现的次数和还要多。其实和第一个思路差不多，都是利用次数。<br>在遍历数组时保存两个值：一是数组中一个数字，一是次数。遍历下一个数字时，若它与之前保存的数字相同，则次数加1，否则次数减1；若次数为0，则保存下一个数字，并将次数置为1。遍历结束后，所保存的数字即为所求。然后再判断它是否符合条件即可。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>()); <span class="comment">// 排序，取数组中间那个数</span></span><br><span class="line">        <span class="keyword">int</span> middle = numbers[numbers.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>; <span class="comment">// 出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == middle) ++count;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> (count &gt; numbers.<span class="built_in">size</span>()/<span class="number">2</span>) ? middle :  <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers.empty()) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1</span></span><br><span class="line">        <span class="keyword">int</span> result = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">1</span>; <span class="comment">// 次数</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(times == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 更新result的值为当前元素，并置次数为1</span></span><br><span class="line">                result = numbers[i];</span><br><span class="line">                times = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[i] == result)</span><br><span class="line">            &#123;</span><br><span class="line">                ++times; <span class="comment">// 相同则加1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                --times; <span class="comment">// 不同则减1               </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 判断result是否符合条件，即出现次数大于数组长度的一半</span></span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; numbers.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] == result) </span><br><span class="line">            ++times;</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> (times &gt; numbers.<span class="built_in">size</span>()/<span class="number">2</span>) ? result : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="思路一-1"><a href="#思路一-1" class="headerlink" title="思路一"></a>思路一</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        tmp = collections.Counter(numbers)</span><br><span class="line">        x = len(numbers)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> tmp.items():</span><br><span class="line">            <span class="keyword">if</span> v &gt; x:</span><br><span class="line">                <span class="keyword">return</span> k</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="思路二-1"><a href="#思路二-1" class="headerlink" title="思路二"></a>思路二</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(numbers) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 遍历每个元素，并记录次数；若与前一个元素相同，则次数加1，否则次数减1</span></span><br><span class="line">        result = numbers[<span class="number">0</span>]</span><br><span class="line">        times = <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> times == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 更新result的值为当前元素，并置次数为1</span></span><br><span class="line">                result = numbers[i]</span><br><span class="line">                times = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> numbers[i] == result:</span><br><span class="line">                times += <span class="number">1</span> <span class="comment">#相同则加1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                times -= <span class="number">1</span> <span class="comment">#不同则减1 </span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 判断result是否符合条件，即出现次数大于数组长度的一半</span></span><br><span class="line">        times = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            <span class="keyword">if</span> numbers[i] == result:</span><br><span class="line">                times += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> times &gt; len(numbers) /<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间效率）：连续子数组的最大和</title>
    <url>/folder/2019/11/08/2017-12-01-offer-38/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1)</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>和leetcode里面的股票题目很像。看到这个题目，如果我们枚举出数组的所有子数组并求出他们的和。一个长度为n的数组，总共有n(n+1)/2个子数组。计算出所有的子数组的和，最快也需要O(n^2)的时间。运用数组分析或者动态规划则可以实现时间复杂度为O(n)，但是二者在本题的实现上是一样的。</p>
<p>数组分析：下图是我们计算数组（1，-2，3，10，-4，7，2，-5）中子数组的最大和的过程。通过分析我们发现，累加的子数组和，如果大于零，那么我们继续累加就行；否则，则需要剔除原来的累加和重新开始。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171123112556089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>动态规划：如果用函数f(i)表示第i个数字结尾的子数组的最大和，那么我们需要求出man[f(i)]，其中0&lt;=i&lt;=n。我们可以用如下递归公式求f(i)：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171123112614392?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>当以第i-个数字结尾的子数组中的所有数字的和小于0时，如果把这个负数与第i个数累加，得到的结果比第i个数字本身还要小，所以这种情况下第i个数字结尾的字数子就是第i个数字本身。否则，累加。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始值最好不要设置为0，防止全是负数的情况出现</span></span><br><span class="line">        <span class="keyword">int</span> nCurSum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> nGreatestSum = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//从1开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nCurSum &lt;= <span class="number">0</span>)</span><br><span class="line">                nCurSum = <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nCurSum += <span class="built_in">array</span>[i];</span><br><span class="line">            <span class="keyword">if</span>(nCurSum &gt; nGreatestSum)</span><br><span class="line">                nGreatestSum = nCurSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nGreatestSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment">#初始值最好不要设置为0，防止全是负数的情况出现</span></span><br><span class="line">        nCurSum = nGreatestSum = array[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#从1开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(array)):</span><br><span class="line">            <span class="keyword">if</span> nCurSum &lt;= <span class="number">0</span>:</span><br><span class="line">                nCurSum = array[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nCurSum += array[i]</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> nCurSum &gt; nGreatestSum:</span><br><span class="line">                nGreatestSum = nCurSum</span><br><span class="line">        <span class="keyword">return</span> nGreatestSum</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间效率）：把数组排成最小的数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-37/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遇到这个题，全排列当然可以做，但是时间复杂度为O(n!)。在这里我们自己定义一个规则，对拼接后的字符串进行比较。</p>
<p>排序规则如下：</p>
<ul>
<li>若ab &gt; ba 则 a 大于 b，</li>
<li>若ab &lt; ba 则 a 小于 b，</li>
<li>若ab = ba 则 a 等于 b；</li>
</ul>
<p>根据上述规则，我们需要先将数字转换成字符串再进行比较，因为需要串起来进行比较。比较完之后，按顺序输出即可。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">PrintMinNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = numbers.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        sort(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        <span class="built_in">string</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">            res += to_string(numbers[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="built_in">string</span> A = to_string(a) + to_string(b);</span><br><span class="line">        <span class="built_in">string</span> B = to_string(b) + to_string(a);</span><br><span class="line">        <span class="keyword">return</span> A &lt; B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintMinNumber</span><span class="params">(self, numbers)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> numbers:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        compare = <span class="keyword">lambda</span> a, b:cmp(str(a) + str(b), str(b) + str(a))</span><br><span class="line">        cur = sorted(numbers, cmp = compare)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(str(s) <span class="keyword">for</span> s <span class="keyword">in</span> cur)</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间效率</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间空间效率的平衡）：数组中的逆序对</title>
    <url>/folder/2019/11/08/2017-12-01-offer-36/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>题目保证输入的数组中没有的相同的数字<br>数据范围：<br>    对于%50的数据,size&lt;=10^4<br>    对于%75的数据,size&lt;=10^5<br>    对于%100的数据,size&lt;=2*10^5</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3,4,5,6,7,0</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>看到这个题目，首先想到的可能是顺序遍历整个数组。每扫描到一个数组的时候，逐个比较该数字和它后面的数字的大小。如果后面的数字比它小，则这两个数字就组成了一个逆序对。假设数组中含有n个数字。由于每个数字都要和O(n)这个数字比较，因此这个算法的时间复杂度为O(n^2)。<br>我们以数组{7,5,6,4}为例来分析统计逆序对的过程。每次扫描到一个数字的时候，我们不拿它和后面的每一个数字作比较，否则时间复杂度就是O(n^2)，因此我们可以考虑先比较两个相邻的数字。</p>
<ul>
<li>把长度为4的数组分解成两个长度为2的子数组；</li>
<li>把长度为2的数组分解成两个成都为1的子数组；</li>
<li>把长度为1的子数组 合并、排序并统计逆序对 ；</li>
<li>把长度为2的子数组合并、排序，并统计逆序对；</li>
</ul>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171201194017235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>在上图（a）和（b）中，我们先把数组分解成两个长度为2的子数组，再把这两个子数组分别拆成两个长度为1的子数组。接下来一边合并相邻的子数组，一边统计逆序对的数目。在第一对长度为1的子数组{7}、{5}中7大于5，因此（7,5）组成一个逆序对。同样在第二对长度为1的子数组{6}、{4}中也有逆序对（6,4）。由于我们已经统计了这两对子数组内部的逆序对，因此需要把这两对子数组 排序 如上图（c）所示， 以免在以后的统计过程中再重复统计。</p>
<p>接下来我们统计两个长度为2的子数组子数组之间的逆序对。合并子数组并统计逆序对的过程如下图如下图所示。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171201194034965?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>我们先用两个指针分别指向两个子数组的末尾，并每次比较两个指针指向的数字。如果第一个子数组中的数字大于第二个数组中的数字，则构成逆序对，并且逆序对的数目等于第二个子数组中剩余数字的个数，如下图（a）和（c）所示。如果第一个数组的数字小于或等于第二个数组中的数字，则不构成逆序对，如图b所示。每一次比较的时候，我们都把较大的数字从后面往前复制到一个辅助数组中，确保 辅助数组（记为copy） 中的数字是递增排序的。在把较大的数字复制到辅助数组之后，把对应的指针向前移动一位，接下来进行下一轮比较。</p>
<p>过程：先把数组分割成子数组，先统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行排序。如果对排序算法很熟悉，我们不难发现这个过程实际上就是归并排序。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; copy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            copy.push_back(data[i]);</span><br><span class="line">        <span class="keyword">return</span> InversePairsCore(copy, data, <span class="number">0</span>, data.<span class="built_in">size</span>() - <span class="number">1</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">InversePairsCore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;data, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;copy, <span class="keyword">int</span> <span class="built_in">begin</span>, <span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == <span class="built_in">end</span>)&#123;</span><br><span class="line">            copy[<span class="built_in">begin</span>] = data[<span class="built_in">end</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> length = (<span class="built_in">end</span>-<span class="built_in">begin</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">long</span> left = InversePairsCore(copy, data, <span class="built_in">begin</span>, <span class="built_in">begin</span> + length);</span><br><span class="line">        <span class="keyword">long</span> right = InversePairsCore(copy, data, <span class="built_in">begin</span> + length + <span class="number">1</span>, <span class="built_in">end</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">begin</span> + length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">int</span> indexcopy = <span class="built_in">end</span>;</span><br><span class="line">        <span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="built_in">begin</span> &amp;&amp; j &gt;= <span class="built_in">begin</span>+length+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(data[i] &gt; data[j])&#123;</span><br><span class="line">                copy[indexcopy--] = data[i--];</span><br><span class="line">                count = count + j - <span class="built_in">begin</span> - length;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                copy[indexcopy--] = data[j--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(;i&gt;= <span class="built_in">begin</span>; --i)</span><br><span class="line">            copy[indexcopy--] = data[i];</span><br><span class="line">        <span class="keyword">for</span>(;j&gt;=<span class="built_in">begin</span>+length+<span class="number">1</span>; --j)</span><br><span class="line">            copy[indexcopy--] = data[j];</span><br><span class="line">        <span class="keyword">return</span> left + right + count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间空间效率的平衡）：两个链表的第一个公共结点</title>
    <url>/folder/2019/11/08/2017-12-01-offer-35/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个链表，找出它们的第一个公共结点。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们一定要理解题目：输入两个链表，找出它们的第一个公共结点。从链表结点的定义可以看出，这两个链表是单向链表。如果两个单向链表有公共的结点，那么这两个链表从某一个结点开始，他妈嗯的next都指向同一个结点。但是，我们都知道，每个单向链表的结点只有一个next，因此，因此，因此，敲重点了，从第一个公共结点开始，之后他们所有的结点必定重合，也就是最终肯定是Y型而不是X型。</p>
<p>理解了题目，接下来的一切都好说了。</p>
<p>方法一：</p>
<p>我们可以把两个链表拼接起来，一个pHead1在前，一个pHead2在前，这样，生成了两个相同长度的链表，那么我们只要一同遍历这两个表，就一定能找到公共结点。时间复杂度O(m+n)，空间复杂度O(m+n)。</p>
<p>方法二：</p>
<p>我们也可以先让把长的链表的头砍掉，让两个链表长度相同，这样，同时遍历也能找到公共结点。此时，时间复杂度O(m+n)，空间复杂度为O(MAX(m,n))。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="简单粗暴"><a href="#简单粗暴" class="headerlink" title="简单粗暴"></a>简单粗暴</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        ListNode *p1 = pHead1;</span><br><span class="line">        ListNode *p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">            p1 = (p1==<span class="literal">NULL</span> ? pHead2 : p1-&gt;next);</span><br><span class="line">            p2 = (p2==<span class="literal">NULL</span> ? pHead1 : p2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="节省空间"><a href="#节省空间" class="headerlink" title="节省空间"></a>节省空间</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindFirstCommonNode</span><span class="params">( ListNode* pHead1, ListNode* pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> len1 = getLength(pHead1);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> len2 = getLength(pHead2);</span><br><span class="line">        <span class="keyword">int</span> nLengthDif = len1-len2;</span><br><span class="line">        </span><br><span class="line">        ListNode* pHeadLong = pHead1;</span><br><span class="line">        ListNode* pHeadShort = pHead2;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(len1 &lt; len2)&#123;</span><br><span class="line">            pHeadLong = pHead2;</span><br><span class="line">            pHeadShort = pHead1;</span><br><span class="line">            nLengthDif = len2-len1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLengthDif; ++i)&#123;</span><br><span class="line">            pHeadLong = pHeadLong-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pHeadLong != <span class="literal">NULL</span> &amp;&amp; pHeadShort != <span class="literal">NULL</span> &amp;&amp; pHeadShort != pHeadLong)&#123;</span><br><span class="line">            pHeadLong = pHeadLong-&gt;next;</span><br><span class="line">            pHeadShort = pHeadShort-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pHeadLong;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">( ListNode* pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        ListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            ++ len;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="简单粗暴-1"><a href="#简单粗暴-1" class="headerlink" title="简单粗暴"></a>简单粗暴</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        p1 = pHead1</span><br><span class="line">        p2 = pHead2</span><br><span class="line">        <span class="keyword">while</span> p1!=p2:</span><br><span class="line">            p1 = p1.next <span class="keyword">if</span> p1!=<span class="literal">None</span> <span class="keyword">else</span> pHead2</span><br><span class="line">            p2 = p2.next <span class="keyword">if</span> p2!=<span class="literal">None</span> <span class="keyword">else</span> pHead1</span><br><span class="line">        <span class="keyword">return</span> p1</span><br></pre></td></tr></table></figure>

<h3 id="节省空间-1"><a href="#节省空间-1" class="headerlink" title="节省空间"></a>节省空间</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindFirstCommonNode</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">GetListLength</span><span class="params">(pHead)</span>:</span></span><br><span class="line">            length = <span class="number">0</span></span><br><span class="line">            pNode = pHead</span><br><span class="line">            <span class="keyword">while</span> pNode != <span class="literal">None</span>:</span><br><span class="line">                length += <span class="number">1</span></span><br><span class="line">                pNode = pNode.next</span><br><span class="line">            <span class="keyword">return</span> length</span><br><span class="line">        </span><br><span class="line">        length1 = GetListLength(pHead1)</span><br><span class="line">        length2 = GetListLength(pHead2)</span><br><span class="line">        lengthDif = abs(length1 - length2)</span><br><span class="line">        </span><br><span class="line">        pListHeadLong = pHead1</span><br><span class="line">        pListHeadShort = pHead2</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> length1 &lt; length2:</span><br><span class="line">            pListHeadLong = pHead2</span><br><span class="line">            pListHeadShort = pHead1</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(lengthDif):</span><br><span class="line">            pListHeadLong = pListHeadLong.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (pListHeadLong != <span class="literal">None</span>) <span class="keyword">and</span> (pListHeadShort != <span class="literal">None</span>) <span class="keyword">and</span> (pListHeadLong != pListHeadShort):</span><br><span class="line">            pListHeadLong = pListHeadLong.next</span><br><span class="line">            pListHeadShort = pListHeadShort.next</span><br><span class="line">        <span class="keyword">return</span> pListHeadLong</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间空间效率的平衡）：第一个只出现一次的字符</title>
    <url>/folder/2019/11/08/2017-12-01-offer-34/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个字符串(1&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们首先想到的可能就是遍历数组，对每一个字符串再遍历判断是否唯一，这样的时间复杂度为O(n^2)。这显然不是我们想要的。</p>
<p>然后我们可能会想到，为什么不用hash表呢？首先遍历数组建立hash表，key为字符串，value为该字符串出现的次数。然后再遍历hash，找到里面value为1的key就可以了。</p>
<p>C++中，我们可以用数组实现，此时，数组长度设定为256，对应字符串的ASCII码；也可以用map实现。<br>Python中，我们可以用字典实现，但是很耗空间。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">char</span> ch[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            ch[str[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">char</span>, <span class="keyword">char</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)</span><br><span class="line">            mp[str[i]]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[str[i]] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        cur = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> cur.keys():</span><br><span class="line">                cur[s[i]] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur[s[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> cur[s[i]] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（时间空间效率的平衡）：丑数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-33/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>同样的，我们首先想到的可能就是遍历判断，但是每个数都要计算一次是不是ugly，很是麻烦。于是我们想，能不能只对ugly进行计算呢，显然是可以的。</p>
<p>我们用一个数组来从小到大存放ugly，那现在的问题就是排序问题了，我们如何来保障这里面的数组是排好序的呢？</p>
<p>我们把当前数组里面最大的ugly记为M，那么，下一个ugly肯定是前面的数与2或者3或者5的乘积中的最小值。然后我们拿这个最小值和M进行比较，如果小于M，就说明已经存在于数组中，如果大于M，则说明需要添加进数组。需要注意的是，我们每次判断之后，我们只需要第一个比M大的值，其他的以后会重新计算。程序中通过t2、t3、t5分别记录上次计算用到的ugly的相应序号。</p>
<p>比如现在res中存放的是[1,2,3]，此时，t2、t3都为1，t5为0，min(res[1] * 2, min(res[1] * 3, res[1] * 5)) 结果为4，res变为[1,2,3,4]，判断后t2变成2，以此类推。</p>
<p>因为7之前的数（7除外）都是ugly，所以程序一开始的判断可以和i直接写index &lt; 7。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">7</span>)</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(index);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t2=<span class="number">0</span>, t3=<span class="number">0</span>, t5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; index; ++i)&#123;</span><br><span class="line">            res[i] = <span class="built_in">min</span>(res[t2] * <span class="number">2</span>, <span class="built_in">min</span>(res[t3] * <span class="number">3</span>, res[t5] * <span class="number">5</span>));</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[t2] * <span class="number">2</span>)</span><br><span class="line">                t2++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[t3] * <span class="number">3</span>)</span><br><span class="line">                t3++;</span><br><span class="line">            <span class="keyword">if</span>(res[i] == res[t5] * <span class="number">5</span>)</span><br><span class="line">                t5++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        res = [<span class="number">1</span>]</span><br><span class="line">        t2 = t3 = t5 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,index):</span><br><span class="line">            res.append(min(res[t2] * <span class="number">2</span>, min(res[t3] * <span class="number">3</span>, res[t5] * <span class="number">5</span>)))</span><br><span class="line">            <span class="keyword">if</span> res[i] == res[t2] * <span class="number">2</span>:</span><br><span class="line">                t2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[i] == res[t3] * <span class="number">3</span>:</span><br><span class="line">                t3 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> res[i] == res[t5] * <span class="number">5</span>:</span><br><span class="line">                t5 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>时间空间效率的平衡</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（面试思路）：二叉树的镜像</title>
    <url>/folder/2019/11/08/2017-12-01-offer-32/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p>二叉树的镜像定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">源二叉树 </span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  6   10</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	5  7 9 11</span><br><span class="line">镜像二叉树</span><br><span class="line">    	    8</span><br><span class="line">    	   /  \</span><br><span class="line">    	  10   6</span><br><span class="line">    	 / \  / \</span><br><span class="line">    	11 9 7  5</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>还是BFS和DFS的套路，要么递归实现要么利用队列进行层序遍历。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(pRoot)&#123;</span><br><span class="line">            swap(pRoot-&gt;left, pRoot-&gt;right);</span><br><span class="line">            Mirror(pRoot-&gt;left);</span><br><span class="line">            Mirror(pRoot-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode *pRoot)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!pRoot) <span class="keyword">return</span>;</span><br><span class="line">        TreeNode* node;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        que.push(pRoot);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            swap(node-&gt;left, node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) que.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) que.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> root != <span class="literal">None</span>:</span><br><span class="line">            root.left,root.right = root.right,root.left</span><br><span class="line">            self.Mirror(root.left)</span><br><span class="line">            self.Mirror(root.right)</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回镜像树的根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Mirror</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span></span><br><span class="line">        a=[root]</span><br><span class="line">        <span class="keyword">while</span> a:</span><br><span class="line">            b=[]</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> a:</span><br><span class="line">                node.left,node.right = node.right,node.left</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    b.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    b.append(node.right)</span><br><span class="line">            a=b</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>面试思路</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（链表）：删除链表中重复的结点</title>
    <url>/folder/2019/11/08/2017-12-01-offer-31/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>删除重复结点，只需要记录当前结点前的最晚访问过的不重复结点pPre、当前结点pCur、指向当前结点后面的结点pNext的三个指针即可。如果当前节点和它后面的几个结点数值相同，那么这些结点都要被剔除，然后更新pPre和pCur；如果不相同，则直接更新pPre和pCur。</p>
<p>需要考虑的是，如果第一个结点是重复结点我们该怎么办？这里我们分别处理一下就好，如果第一个结点是重复结点，那么久把头指针也更新一下。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* pPre = <span class="literal">NULL</span>;  <span class="comment">//指向当前结点前最晚访问过的不重复结点</span></span><br><span class="line">        ListNode* pCur = pHead; <span class="comment">//指向当前处理的结点</span></span><br><span class="line">        ListNode* pNext = <span class="literal">NULL</span>; <span class="comment">//指向当前结点后面的结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pCur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//如果当前结点与下一结点值相同，则进一步处理</span></span><br><span class="line">            <span class="keyword">if</span>(pCur-&gt;next != <span class="literal">NULL</span> &amp;&amp; pCur-&gt;next-&gt;val == pCur-&gt;val)&#123;</span><br><span class="line">                pNext = pCur-&gt;next;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//找到pNext，它指向最后一个与pCur的val相同的结点，那pCur到pNext之间的结点都是要删除的</span></span><br><span class="line">                <span class="keyword">while</span>(pNext-&gt;next != <span class="literal">NULL</span> &amp;&amp; pNext-&gt;next-&gt;val == pCur-&gt;val)</span><br><span class="line">                    pNext = pNext-&gt;next;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果pCur指向链表中第一个元素，pCur -&gt; ... -&gt; pNext -&gt;... , 要删除pCur到pNext, 将指向链表第一个元素的指针pHead指向pNext-&gt;next。</span></span><br><span class="line">                <span class="keyword">if</span>(pCur == pHead)</span><br><span class="line">                    pHead = pNext-&gt;next;</span><br><span class="line">                <span class="comment">//如果pCur不指向链表中第一个元素，pPre -&gt; pCur -&gt;...-&gt;pNext -&gt;... ，要删除pCur到pNext，即pPre-&gt;next = pNext-&gt;next</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pPre-&gt;next = pNext-&gt;next;</span><br><span class="line">                <span class="comment">//当前处理的p要向链表尾部移动</span></span><br><span class="line">                pCur = pNext-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前结点与下一结点值不同，更新pPre和pCur。</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pPre = pCur;</span><br><span class="line">                pCur = pCur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（链表）：链表中环的入口结点</title>
    <url>/folder/2019/11/08/2017-12-01-offer-30/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个链表中包含环，请找出该链表的环的入口结点。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以用两个指针来解决此类问题。如果链表中的环有n个结点，指针P1先在链表上向前移动n步，然后两个指针以相同的速度向前移动。当第二个指针指向环的入口结点时，第一个指针已经环绕着环走了一圈又回到了入口结点。如下图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171221160256337?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>那我们接下来要考虑的就是如何获取这个环的结点个数n了。我们可以用快慢指针来实现，如果两个指针相遇，表明链表存在环。两个指针相遇的结点一定是在环中。可以从这个结点出发，一边继续向前移动一边计数，当再次回到这个结点时，就可以得到环中结点数了。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct ListNode *next;</span></span><br><span class="line"><span class="comment">    ListNode(int x) :</span></span><br><span class="line"><span class="comment">        val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">MeetingNode</span><span class="params">(ListNode* pHead)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* pSlow = pHead-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(pSlow == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode* pFast = pSlow-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(pFast != <span class="literal">NULL</span> &amp;&amp; pSlow != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pFast == pSlow)</span><br><span class="line">                <span class="keyword">return</span> pFast;</span><br><span class="line">            </span><br><span class="line">            pSlow = pSlow-&gt;next;</span><br><span class="line">            </span><br><span class="line">            pFast = pFast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pFast-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">                pFast = pFast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode* meetingNode = MeetingNode(pHead);</span><br><span class="line">        <span class="keyword">if</span>(meetingNode == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 得到环中结点的数目</span></span><br><span class="line">        <span class="keyword">int</span> nodesInLoop = <span class="number">1</span>;</span><br><span class="line">        ListNode* pNode1 = meetingNode;</span><br><span class="line">        <span class="keyword">while</span>(pNode1-&gt;next != meetingNode)&#123;</span><br><span class="line">            pNode1 = pNode1-&gt;next;</span><br><span class="line">            ++nodesInLoop;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先移动pNode1，次数为环中结点的数目</span></span><br><span class="line">        pNode1 = pHead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; nodesInLoop; ++i)</span><br><span class="line">            pNode1 = pNode1-&gt;next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再移动pNode1和pNode2</span></span><br><span class="line">        ListNode* pNode2 = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode1 != pNode2)&#123;</span><br><span class="line">            pNode1 = pNode1-&gt;next;</span><br><span class="line">            pNode2 = pNode2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pNode1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（链表）：从尾到头打印链表</title>
    <url>/folder/2019/11/08/2017-12-01-offer-29/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>链表应该是面试被提及最频繁的数据结构。链表的创建、插入节点、删除结点等操作都只需要20行左右的代码就能实现，其代码量比较适合面试。</p>
<p>在创建链表时，无需知道链表的长度，当插入一个结点时，我们只需要为新结点分配内存，然后调整指针的指向来确保新节点被链接到链表当中。内存分配不是在创建链表时一次性完成，而是没添加一个结点分配一次内存。由于没有闲置的内存，链表的空间效率比数组好。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，从尾到头打印链表每个节点的值。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="直接修改输入数据"><a href="#直接修改输入数据" class="headerlink" title="直接修改输入数据"></a>直接修改输入数据</h3><p>如果可以修改原来链表的结构，那么把链表中链接结点的指针反转过来，改变链表的方向，然后就可以从头到尾输出了。</p>
<p>但是，打印通常是一个只读操作，我们不希望打印时修改内容，所以就得想别的办法。</p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>后进先出，我们可以用栈实现这种顺序。没经过一个结点的时候，把该节点放到一个栈里面，当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归在本质上就是一个栈结构，于是很自然地又想到了用递归来实现。每访问到一个结点的时候，先递归输出它后面的节点，再输出该节点自身，这样链表的输出结果就反过来了。</p>
<h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h2><h3 id="循环-1"><a href="#循环-1" class="headerlink" title="循环"></a>循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  struct ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        struct ListNode *next;</span></span><br><span class="line"><span class="comment">*        ListNode(int x) :</span></span><br><span class="line"><span class="comment">*              val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*  &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        </span><br><span class="line">        ListNode* pNode = head;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            nodes.push(pNode-&gt;val);</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            result.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">*  struct ListNode &#123;</span><br><span class="line">*        int val;</span><br><span class="line">*        struct ListNode *next;</span><br><span class="line">*        ListNode(int x) :</span><br><span class="line">*              val(x), next(NULL) &#123;</span><br><span class="line">*        &#125;</span><br><span class="line">*  &#125;;</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</span><br><span class="line">        vector&lt;int&gt; value;</span><br><span class="line">        if(head != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            value.insert(value.begin(),head-&gt;val);</span><br><span class="line">            if(head-&gt;next != NULL)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;int&gt; tempVec = printListFromTailToHead(head-&gt;next);</span><br><span class="line">                if(tempVec.size()&gt;0)</span><br><span class="line">                value.insert(value.begin(),tempVec.begin(),tempVec.end());  </span><br><span class="line">            &#125;         </span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h2><p>python的实现依旧是那么简单，一直往列表头放数据就好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从尾部到头部的列表值序列，例如[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printListFromTailToHead</span><span class="params">(self, listNode)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l = []</span><br><span class="line">        head = listNode</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            l.insert(<span class="number">0</span>, head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（举例让抽象具体化）：栈的压入、弹出序列</title>
    <url>/folder/2019/11/08/2017-12-01-offer-28/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>下面给出例子中的示意图：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171025224243366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171025224302956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushV.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; stackData;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushV.<span class="built_in">size</span>();)&#123;</span><br><span class="line">            stackData.push_back(pushV[i++]);</span><br><span class="line">            <span class="keyword">while</span>(j &lt; popV.<span class="built_in">size</span>() &amp;&amp; stackData.back() == popV[j])&#123;</span><br><span class="line">                stackData.pop_back();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackData.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">IsPopOrder</span><span class="params">(self, pushV, popV)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(pushV) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stackData = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> pushV:</span><br><span class="line">            stackData.append(i)</span><br><span class="line">            <span class="keyword">while</span> len(stackData) <span class="keyword">and</span> stackData[<span class="number">-1</span>] == popV[<span class="number">0</span>]:</span><br><span class="line">                stackData.pop()</span><br><span class="line">                popV.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> len(stackData):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（举例让抽象具体化）：二叉搜索树的后序遍历序列</title>
    <url>/folder/2019/11/08/2017-12-01-offer-27/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>深度优先遍历中的先序遍历、中序遍历、后序遍历，都是针对在遍历中根结点的位置来命名的，先序遍历，第一个元素是根结点，后序遍历，最后一个元素是根结点。</p>
<p>二叉搜索树中，在后序遍历得到的序列中，最后一个数字是树的根结点的值。数组中前面的数字可以分为两部分：第一部分是左子树结点的值，他们都比根节点的值小；第二部分是右子树结点的值，他们都比根结点的值大。</p>
<p>递归循环都可以实现。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bst(sequence,<span class="number">0</span>,sequence.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence,<span class="keyword">int</span> <span class="built_in">begin</span>,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence.empty()||<span class="built_in">begin</span>&gt;<span class="built_in">end</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//获取根节点，后序遍历最后一个元素就是根节点</span></span><br><span class="line">        <span class="keyword">int</span> root = sequence[<span class="built_in">end</span>];</span><br><span class="line">        <span class="comment">//在二叉树搜索树中左子树的结点小于根节点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">begin</span>;</span><br><span class="line">        <span class="keyword">for</span>(; i &lt; <span class="built_in">end</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &gt; root)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//在二叉搜索树中右子树的节点大于根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; <span class="built_in">end</span>; ++j)</span><br><span class="line">            <span class="keyword">if</span>(sequence[j] &lt; root)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//判断左子树是不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">bool</span> left = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; <span class="built_in">begin</span>)</span><br><span class="line">            left = bst(sequence, <span class="built_in">begin</span>, i<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">//判断右子树是不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">bool</span> right=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="built_in">end</span> - <span class="number">1</span>)</span><br><span class="line">            right = bst(sequence, i, <span class="built_in">end</span><span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sequence)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = sequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(--length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(sequence[i++] &lt; sequence[length]);</span><br><span class="line">            <span class="keyword">while</span>(sequence[i++] &gt; sequence[length]);</span><br><span class="line">            <span class="keyword">if</span>(i &lt; length)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(sequence) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        length=len(sequence)</span><br><span class="line">        <span class="comment"># 获取根节点，后序遍历最后一个元素就是根节点</span></span><br><span class="line">        root=sequence[<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 在二叉树搜索树中左子树的结点小于根节点</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>  sequence[i] &lt; root:</span><br><span class="line">            i=i+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 在二叉搜索树中右子树的节点大于根节点</span></span><br><span class="line">        k=i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, length<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> sequence[j] &lt; root:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        left_s = sequence[:k]</span><br><span class="line">        right_s = sequence[k:length<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 判断左子树是不是二叉搜索树</span></span><br><span class="line">        leftIs = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> len(left_s) &gt; <span class="number">0</span>:</span><br><span class="line">            leftIs = self.VerifySquenceOfBST(left_s)</span><br><span class="line">        <span class="comment"># 判断右子树是不是二叉搜索树</span></span><br><span class="line">        rightIs = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> len(right_s) &gt; <span class="number">0</span>:</span><br><span class="line">            rightIs = self.VerifySquenceOfBST(right_s)</span><br><span class="line">        <span class="keyword">return</span> leftIs <span class="keyword">and</span> rightIs</span><br></pre></td></tr></table></figure>

<h3 id="循环-1"><a href="#循环-1" class="headerlink" title="循环"></a>循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">VerifySquenceOfBST</span><span class="params">(self, sequence)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sequence:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> len(sequence)==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        length=len(sequence)</span><br><span class="line">        <span class="keyword">while</span> length:</span><br><span class="line">            length -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> sequence[i] &lt; sequence[length]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> sequence[i] &gt; sequence[length]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; length:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（举例让抽象具体化）：二叉树中和为某一值的路径</title>
    <url>/folder/2019/11/08/2017-12-01-offer-26/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>还是深度优先搜索，这次我们用前序遍历，就是先对root做一些该有的处理，再遍历左右子树。这里我们用到两个全局变量，result来存放最终结果，tmp用来存放临时结果。</p>
<p>每次遍历，我们先把root的值压入tmp，然后判断现有root是否同时满足：</p>
<ul>
<li>与给定数值相减为0；</li>
<li>左子树为空；</li>
<li>右子树为空。</li>
</ul>
<p>如果满足条件，就将tmp压入result中，否则，依次遍历左右子树。需要注意的是，遍历左右子树的时候，全局变量tmp是不清空的，直到到了根结点才请空tmp。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; FindPath(TreeNode* root,<span class="keyword">int</span> expectNumber) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        tmp.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>((expectNumber - root-&gt;val) == <span class="number">0</span> &amp;&amp; root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            result.push_back(tmp);</span><br><span class="line">        FindPath(root-&gt;left, expectNumber-root-&gt;val);</span><br><span class="line">        FindPath(root-&gt;right, expectNumber-root-&gt;val);</span><br><span class="line">        tmp.pop_back();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回二维列表，内部每个列表表示找到的路径</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindPath</span><span class="params">(self, root, expectNumber)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == expectNumber:</span><br><span class="line">            <span class="keyword">return</span> [[root.val]]</span><br><span class="line">        res = []</span><br><span class="line">        left = self.FindPath(root.left, expectNumber-root.val)</span><br><span class="line">        right = self.FindPath(root.right, expectNumber-root.val)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> left+right:</span><br><span class="line">            res.append([root.val]+i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（举例让抽象具体化）：从上往下打印二叉树</title>
    <url>/folder/2019/11/08/2017-12-01-offer-25/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>再熟悉不过的层序遍历，BFS即可实现。用队列来进行层序遍历，同时用一个vector容器来存储每一层的值。</p>
<p>举例如下：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171104152007252?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PrintFromTopToBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;  result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">        TreeNode* fr;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        que.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">            fr = que.front();</span><br><span class="line">            result.push_back(fr-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(fr-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                que.push(fr-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(fr-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                que.push(fr-&gt;right);</span><br><span class="line">            que.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回从上到下每个节点值列表，例：[1,2,3]</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PrintFromTopToBottom</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result=[]</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        que=[]</span><br><span class="line">        que.append(root)</span><br><span class="line">        <span class="keyword">while</span> len(que):</span><br><span class="line">            t=que.pop(<span class="number">0</span>)</span><br><span class="line">            result.append(t.val)</span><br><span class="line">            <span class="keyword">if</span> t.left:</span><br><span class="line">                que.append(t.left)</span><br><span class="line">            <span class="keyword">if</span> t.right:</span><br><span class="line">                que.append(t.right)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</strong></p>
<p><strong>完的汪(∪｡∪)｡｡｡zzz</strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（举例让抽象具体化）：包含min函数的栈</title>
    <url>/folder/2019/11/08/2017-12-01-offer-24/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>当一眼看不出问题中隐藏的规律时，我们可以试着用一两个具体的例子模拟操作的过程，说不定这样那就能通过具体的例子找到抽象的规律。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们很自然的可以想到，可以利用两个栈来实现该操作：一个栈sData用来存放数据，另一个栈sMin用来辅助更新最小值状态。</p>
<p>栈内压入3、4、2、1之后接连两次弹出栈顶数字之后再压入0时，数据栈、辅助栈和最小值状态举例如图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171021102238518?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171021102303045?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        sData.push(value);</span><br><span class="line">        <span class="keyword">if</span>(sMin.empty())</span><br><span class="line">            sMin.push(value);</span><br><span class="line">        <span class="keyword">if</span>(sMin.top() &gt; value)</span><br><span class="line">            sMin.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sData.top() == sMin.top())</span><br><span class="line">            sMin.pop();</span><br><span class="line">        sData.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sData.top();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sMin.top();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sData;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; sMin;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sData = []</span><br><span class="line">        self.sMin = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.sData.append(node)</span><br><span class="line">        <span class="keyword">if</span> len(self.sMin) == <span class="number">0</span>:</span><br><span class="line">            self.sMin.append(node)</span><br><span class="line">        <span class="keyword">if</span> self.sMin[<span class="number">-1</span>] &gt; node:</span><br><span class="line">            self.sMin.append(node)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> self.sData[<span class="number">-1</span>] == self.sMin[<span class="number">-1</span>]:</span><br><span class="line">            self.sMin.pop()</span><br><span class="line">        self.sData.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.sData[<span class="number">-1</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> self.sMin[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>举例让抽象具体化</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（回溯法）：矩阵中的路径</title>
    <url>/folder/2019/11/08/2017-12-01-offer-23/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题其实让我想到了图的一些操作。这是一个可以用回溯法解决的典型题。</p>
<p>首先，遍历这个矩阵，我们很容易就能找到与字符串str中第一个字符相同的矩阵元素ch。然后遍历ch的上下左右四个字符，如果有和字符串str中下一个字符相同的，就把那个字符当作下一个字符（下一次遍历的起点），如果没有，就需要回退到上一个字符，然后重新遍历。为了避免路径重叠，需要一个辅助矩阵来记录路径情况。</p>
<p>下面代码中，当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。</p>
<p>如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。</p>
<p>一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置（此时str[pathLength] == ‘\0’）。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="literal">NULL</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span> || str == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">bool</span> * visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows * cols);</span><br><span class="line">        <span class="keyword">int</span> pathLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; rows; ++row)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; cols; ++col)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasPathCore(matrix, rows, cols, row, col, str, pathLength, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>*matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span>* str, <span class="keyword">int</span>&amp; pathLength, <span class="keyword">bool</span>* visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[pathLength] == <span class="string">'\0'</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> hasPath = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; cols &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; matrix[row * cols + col] == str[pathLength] &amp;&amp; !visited[row * cols + col])&#123;</span><br><span class="line">            ++pathLength;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            hasPath = hasPathCore(matrix, rows, cols, row<span class="number">-1</span>, col, str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row+<span class="number">1</span>, col, str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row, col<span class="number">-1</span>, str, pathLength, visited)</span><br><span class="line">                || hasPathCore(matrix, rows, cols, row, col+<span class="number">1</span>, str, pathLength, visited);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!hasPath)&#123;</span><br><span class="line">                --pathLength;</span><br><span class="line">                visited[row * cols + col] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（回溯法）：机器人的运动范围</title>
    <url>/folder/2019/11/08/2017-12-01-offer-22/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>和上一道题十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++)</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; getDigitSum(row) + getDigitSum(col) &lt;= threshold &amp;&amp; !visited[row * cols + col])&#123;</span><br><span class="line">            visited[row * cols + col] = <span class="literal">true</span>;</span><br><span class="line">            </span><br><span class="line">            count = <span class="number">1</span> + movingCountCore(threshold, rows, cols, row+<span class="number">1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row<span class="number">-1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row, col+<span class="number">1</span>, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row, col<span class="number">-1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(number)&#123;</span><br><span class="line">            sum += number % <span class="number">10</span>;</span><br><span class="line">            number /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（画图让抽象形象化）：顺时针打印矩阵</title>
    <url>/folder/2019/11/08/2017-12-01-offer-21/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这个题完全没有涉及复杂的数据结构或者高级的算法，看起来是一个很简单的问题。但实际上解决这个问题，会在代码中包含多个循环，并且还需要判断多个边界条件。</p>
<p>顺时针打印就是按圈数循环打印，一圈包含两行两列（完整圆），在打印的时候会出现某一圈中只包含一行，要判断从左向右打印和从右向左打印的时候是否会出现重复打印，同样只包含一列时，要判断从上向下打印和从下向上打印的时候是否会出现重复打印的情况。</p>
<p>首先是while循环的终止条件：left &lt;= right &amp;&amp; top &lt;= bottom。相信这个条件大家很容易就能理解。</p>
<p>接下来是后两个for循环的终止条件，因为到了最后一个圆的时候，这个圆可能不是一个完整的圆了，所以需要加入判断，以防止打印重复的行或者列。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.<span class="built_in">size</span>();<span class="comment">//行数</span></span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();<span class="comment">//列数</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(row == <span class="number">0</span> &amp;&amp; col == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = col - <span class="number">1</span>, top = <span class="number">0</span>, bottom = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right &amp;&amp; top &lt;= bottom)&#123;</span><br><span class="line">            <span class="comment">//left&gt;&gt;right</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; ++i)</span><br><span class="line">                result.push_back(matrix[top][i]);</span><br><span class="line">            <span class="comment">//top&gt;&gt;bottom</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = top+<span class="number">1</span>; i &lt;= bottom; ++i)</span><br><span class="line">                result.push_back(matrix[i][right]);</span><br><span class="line">            <span class="comment">//right&gt;&gt;left</span></span><br><span class="line">            <span class="keyword">if</span>(top != bottom)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = right<span class="number">-1</span>; i &gt;= left; --i)</span><br><span class="line">                    result.push_back(matrix[bottom][i]);</span><br><span class="line">            <span class="comment">//bottom&gt;&gt;top</span></span><br><span class="line">            <span class="keyword">if</span>(left != right)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = bottom<span class="number">-1</span>; i &gt; top; --i)</span><br><span class="line">                    result.push_back(matrix[i][left]);</span><br><span class="line">            left++,top++,right--,bottom--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># matrix类型为二维列表，需要返回列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printMatrix</span><span class="params">(self, matrix)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        row = len(matrix)</span><br><span class="line">        col = len(matrix[<span class="number">0</span>])</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> row == <span class="number">0</span> <span class="keyword">and</span> col == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span>; right = col<span class="number">-1</span>; top = <span class="number">0</span>; bottom = row<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> left &lt;= right <span class="keyword">and</span> top &lt;= bottom:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(left, right+<span class="number">1</span>):</span><br><span class="line">                result.append(matrix[top][i])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> xrange(top+<span class="number">1</span>, bottom+<span class="number">1</span>):</span><br><span class="line">                result.append(matrix[i][right])</span><br><span class="line">            <span class="keyword">if</span> top <span class="keyword">is</span> <span class="keyword">not</span> bottom:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(right<span class="number">-1</span>, left<span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">                    result.append(matrix[bottom][i])</span><br><span class="line">            <span class="keyword">if</span> left <span class="keyword">is</span> <span class="keyword">not</span> right:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> xrange(bottom<span class="number">-1</span>, top, <span class="number">-1</span>):</span><br><span class="line">                    result.append(matrix[i][left])</span><br><span class="line">            left += <span class="number">1</span>;top += <span class="number">1</span>;right -= <span class="number">1</span>;bottom -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>画图让抽象形象化</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（分解让复杂问题简单）：字符串的排列</title>
    <url>/folder/2019/11/08/2017-12-01-offer-20/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在计算机领域有一类算法叫分治法，即“分而治之”。采用的就是各个击破的思想，我们把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p>
<h2 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述"></a>输入描述</h2><p>输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>全排列，我们很快就想到递归。</p>
<p>首先，我们把一个字符串看成两部分组成：第一部分为它的第一个字符，第二部分为后面的所有字符。首先求所有可能出现在第一个位置的字符，即把第一个字符和后面所有的字符交换。第二步固定第一个字符，求后面的所有字符的排列。这个时候我们仍然把后面所有的字符分成两部分：后面字符的第一个字符，以及这个字符之后的所有字符，然后把第一个字符逐一和它后面的字符交换。</p>
<p>典型的递归思想，下面分别用C/C++和python实现，python还是那么的简单暴力。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; Permutation(<span class="built_in">string</span> str) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        Permutation1(str, <span class="number">0</span>);</span><br><span class="line">        sort(result.<span class="built_in">begin</span>(), result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Permutation1</span><span class="params">(<span class="built_in">string</span> str, <span class="keyword">int</span> <span class="built_in">begin</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">begin</span> == str.length())&#123;</span><br><span class="line">            result.push_back(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="built_in">begin</span>; str[i] != <span class="string">'\0'</span>; ++i)&#123;</span><br><span class="line">            <span class="comment">//如果有重复的，交换没什么卵用，所以直接跳过，其实这段话不加也行</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="built_in">begin</span> &amp;&amp; str[<span class="built_in">begin</span>] == str[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//交换</span></span><br><span class="line">            swap(str[<span class="built_in">begin</span>], str[i]);</span><br><span class="line">            <span class="comment">//递归</span></span><br><span class="line">            Permutation1(str, <span class="built_in">begin</span>+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//复位</span></span><br><span class="line">            swap(str[<span class="built_in">begin</span>], str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ss:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">return</span> sorted(list(set(map(<span class="string">''</span>.join, itertools.permutations(ss)))))</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>分解让复杂问题简单</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（分解让复杂问题简单）：复杂链表的复制</title>
    <url>/folder/2019/11/08/2017-12-01-offer-19/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在计算机领域有一类算法叫分治法，即“分而治之”。采用的就是各个击破的思想，我们把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>我们可以将复杂链表的复制过程分解为三个步骤。在写代码的时候我们每一步定义一个函数，这样每个函数完成一个功能，整个过程的逻辑也就非常清晰明了了。</p>
<p>大部分人首先想到的可能是先复制复杂指针的label和next，然后再查找random并更新。查找random又分为两种，一种是每次都从头查找，时间复杂度为O(n^2)；另一种是空间换时间，复制label和next的同时建立一个hash表来存放新旧复杂指针的对应关系，所以后续只需一步就能找到random，算法时间复杂度为O(n)。</p>
<p>我们这里采用三步走战略，也是剑指offer上推崇的方法：</p>
<ul>
<li>第一步：复制复杂指针的label和next。但是这次我们把复制的结点跟在元结点后面，而不是直接创建新的链表；</li>
<li>第二步：设置复制出来的结点的random。因为新旧结点是前后对应关系，所以也是一步就能找到random；</li>
<li>第三步：拆分链表。奇数是原链表，偶数是复制的链表。</li>
</ul>
<p>有图思路更清晰：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171108132929521?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171108132947451?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171108133004592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    struct RandomListNode *next, *random;</span></span><br><span class="line"><span class="comment">    RandomListNode(int x) :</span></span><br><span class="line"><span class="comment">            label(x), next(NULL), random(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//第一步，复制复杂指针的label和next</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(RandomListNode* pHead)</span></span>&#123;</span><br><span class="line">        RandomListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloned = <span class="keyword">new</span> RandomListNode(<span class="number">0</span>);</span><br><span class="line">            pCloned-&gt;label = pNode-&gt;label;</span><br><span class="line">            pCloned-&gt;next = pNode-&gt;next;</span><br><span class="line">            pCloned-&gt;<span class="built_in">random</span> = <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">            pNode-&gt;next = pCloned;</span><br><span class="line">            pNode = pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二步，处理复杂指针的random</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConnectSiblingNodes</span><span class="params">(RandomListNode* pHead)</span></span>&#123;</span><br><span class="line">        RandomListNode* pNode = pHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            RandomListNode* pCloned = pNode-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;<span class="built_in">random</span> != <span class="literal">NULL</span>)</span><br><span class="line">                pCloned-&gt;<span class="built_in">random</span> = pNode-&gt;<span class="built_in">random</span>-&gt;next;</span><br><span class="line">            pNode = pCloned-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第三步，拆分复杂指针</span></span><br><span class="line">    <span class="function">RandomListNode* <span class="title">ReconnectNodes</span><span class="params">(RandomListNode* pHead)</span></span>&#123;</span><br><span class="line">        RandomListNode* pNode = pHead;</span><br><span class="line">        RandomListNode* pCloneHead = <span class="literal">NULL</span>;</span><br><span class="line">        RandomListNode* pCloneNode = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pCloneHead = pCloneNode = pNode-&gt;next;</span><br><span class="line">            pNode-&gt;next = pCloneNode-&gt;next;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(pNode != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pCloneNode-&gt;next = pNode-&gt;next;</span><br><span class="line">            pCloneNode = pCloneNode-&gt;next;</span><br><span class="line">            pNode-&gt;next = pCloneNode-&gt;next;</span><br><span class="line">            pNode = pNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pCloneHead;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">RandomListNode* <span class="title">Clone</span><span class="params">(RandomListNode* pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CloneNodes(pHead);</span><br><span class="line">        ConnectSiblingNodes(pHead);</span><br><span class="line">        <span class="keyword">return</span> ReconnectNodes(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class RandomListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="comment">#         self.random = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment">#RandomListNode</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">CloneNodes</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pCloned = RandomListNode(<span class="number">0</span>)</span><br><span class="line">            pCloned.label = pNode.label</span><br><span class="line">            pCloned.next = pNode.next</span><br><span class="line">            pCloned.random = <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">            pNode.next = pCloned</span><br><span class="line">            pNode = pCloned.next</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ConnectSiblingNodes</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        <span class="keyword">while</span> pNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pCloned = pNode.next</span><br><span class="line">            <span class="keyword">if</span> pNode.random <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                pCloned.random = pNode.random.next</span><br><span class="line">            pNode = pCloned.next</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ReconnectNodes</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        pNode = pHead</span><br><span class="line">        pCloneHead = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> pNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pCloneHead = pCloneNode = pNode.next</span><br><span class="line">            pNode.next = pCloneNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">while</span> pNode <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            pCloneNode.next = pNode.next</span><br><span class="line">            pCloneNode = pCloneNode.next</span><br><span class="line">            pNode.next = pCloneNode.next</span><br><span class="line">            pNode = pNode.next</span><br><span class="line">        <span class="keyword">return</span> pCloneHead</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Clone</span><span class="params">(self, pHead)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        self.CloneNodes(pHead)</span><br><span class="line">        self.ConnectSiblingNodes(pHead)</span><br><span class="line">        <span class="keyword">return</span> self.ReconnectNodes(pHead)</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>分解让复杂问题简单</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（分解让复杂问题简单）：二叉搜索树与双向链表</title>
    <url>/folder/2019/11/08/2017-12-01-offer-18/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在计算机领域有一类算法叫分治法，即“分而治之”。采用的就是各个击破的思想，我们把分解后的小问题各个解决，然后把小问题的解决方案结合起来解决大问题。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>哇偶，中序遍历啊！中序遍历，递归和循环都可以撒~</p>
<p>二叉搜索树是一种排序的数据结构，每个结点都有两个指向子结点的指针。在双向链表中，每个结点也有两个指针，他们分别指向前一个结点和后一个结点。在二叉搜索树中，左子结点的值总是小于父结点的值，右子结点的值总是大于父结点的值。因此我们在转换成排序双向链表时，原先指向左子结点的指针调整为链表中指向前一结点的指针，原先指向右子结点的指针调整为链表中指向后一个结点指针。</p>
<p>中序遍历在二叉搜索树中的特点是按照从小到大的顺序遍历二叉树的每一个结点。下图中，我们可以把树分成三个部分：值为10的结点、根结点为6的左子树、根结点为14的右子树。根绝排序链表的定义，值为10的结点将和它的左子树的最大一个结点链接起来，同时它还将和右子树最小的结点链接起来。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171120114509493?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>按照中序遍历的顺序，当我们遍历转换到根结点时，它的左子树已经转换成一个排序的链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个借点，接着我们就去遍历转换右子树，并把根结点和右子树中最小的结点链接起来。</p>
<p>下面个分别用C/C++和Python来实现，其中递归1是书中的解法，递归2是更加容易理解的解法，原理都是一样的，只不过递归1中涉及到指针的指针，容易把自己搞蒙。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归1"><a href="#递归1" class="headerlink" title="递归1"></a>递归1</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode *pLastNodeInList = <span class="literal">NULL</span>;</span><br><span class="line">        ConvertNode(pRootOfTree, &amp;pLastNodeInList);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//需要返回头结点，所以需要遍历到头结点（最左子叶）</span></span><br><span class="line">        TreeNode *pHeadOfList = pLastNodeInList;</span><br><span class="line">        <span class="keyword">while</span>(pHeadOfList != <span class="literal">NULL</span> &amp;&amp; pHeadOfList-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            pHeadOfList = pHeadOfList-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> pHeadOfList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ConvertNode</span><span class="params">(TreeNode* pNode, TreeNode** pLastNodeInList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode* pCurrent = pNode;</span><br><span class="line">        <span class="comment">//递归左子树</span></span><br><span class="line">        <span class="keyword">if</span>(pCurrent-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            ConvertNode(pCurrent-&gt;left, pLastNodeInList);</span><br><span class="line">        <span class="comment">//处理指针</span></span><br><span class="line">        pCurrent-&gt;left = *pLastNodeInList;</span><br><span class="line">        <span class="keyword">if</span>(*pLastNodeInList != <span class="literal">NULL</span>)</span><br><span class="line">            (*pLastNodeInList)-&gt;right = pCurrent;</span><br><span class="line">        *pLastNodeInList = pCurrent;</span><br><span class="line">        <span class="comment">//递归右子树</span></span><br><span class="line">        <span class="keyword">if</span>(pCurrent-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            ConvertNode(pCurrent-&gt;right, pLastNodeInList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归2"><a href="#递归2" class="headerlink" title="递归2"></a>递归2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree-&gt;left == <span class="literal">NULL</span> &amp;&amp; pRootOfTree-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        <span class="comment">//遍历左子树</span></span><br><span class="line">        TreeNode* pLeft = Convert(pRootOfTree-&gt;left);</span><br><span class="line">        TreeNode* pCurrent = pLeft;</span><br><span class="line">        <span class="comment">//定位至左子树最右的一个结点</span></span><br><span class="line">        <span class="keyword">while</span>(pCurrent != <span class="literal">NULL</span> &amp;&amp; pCurrent-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            pCurrent = pCurrent-&gt;right;</span><br><span class="line">        <span class="comment">//如果左子树不为空，则将当前pRootOfTree加到左子树链表</span></span><br><span class="line">        <span class="keyword">if</span>(pLeft != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pCurrent-&gt;right = pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left = pCurrent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历右子树</span></span><br><span class="line">        TreeNode* pRight = Convert(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="comment">//如果右子树不为空，则将当前pRootOfTree加到右子树链表</span></span><br><span class="line">        <span class="keyword">if</span>(pRight != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pRight-&gt;left = pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;right= pRight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pLeft != <span class="literal">NULL</span>?pLeft:pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">        TreeNode* pHeadOfList = <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* pLastNodeInList = <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* pCurrent = pRootOfTree;</span><br><span class="line">        <span class="keyword">while</span>(pCurrent != <span class="literal">NULL</span> || !s.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(pCurrent != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.push(pCurrent);</span><br><span class="line">                pCurrent = pCurrent-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!s.empty())&#123;</span><br><span class="line">                pCurrent = s.top();</span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="keyword">if</span>(pLastNodeInList != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    pLastNodeInList-&gt;right = pCurrent;</span><br><span class="line">                    pCurrent-&gt;left = pLastNodeInList;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果为空，则说明是最左边子结点，未来的头结点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    pHeadOfList = pCurrent;</span><br><span class="line">                pLastNodeInList = pCurrent;</span><br><span class="line">                pCurrent = pCurrent-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pHeadOfList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现"><a href="#Python版代码实现" class="headerlink" title="Python版代码实现"></a>Python版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRootOfTree.left <span class="keyword">and</span> <span class="keyword">not</span> pRootOfTree.right:</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree</span><br><span class="line">        <span class="comment">#遍历左子树</span></span><br><span class="line">        pLeft = self.Convert(pRootOfTree.left)</span><br><span class="line">        pCurrent = pLeft</span><br><span class="line">        <span class="comment">#定位至左子树最右的一个结点</span></span><br><span class="line">        <span class="keyword">while</span> pCurrent <span class="keyword">and</span> pCurrent.right:</span><br><span class="line">            pCurrent = pCurrent.right</span><br><span class="line">        <span class="comment">#如果左子树不为空，则将当前pRootOfTree加到左子树链表</span></span><br><span class="line">        <span class="keyword">if</span> pLeft:</span><br><span class="line">            pCurrent.right = pRootOfTree</span><br><span class="line">            pRootOfTree.left = pCurrent</span><br><span class="line">        <span class="comment">#遍历右子树</span></span><br><span class="line">        pRight = self.Convert(pRootOfTree.right)</span><br><span class="line">        <span class="comment">#如果右子树不为空，则将当前pRootOfTree加到右子树链表</span></span><br><span class="line">        <span class="keyword">if</span> pRight:</span><br><span class="line">            pRight.left = pRootOfTree</span><br><span class="line">            pRootOfTree.right = pRight</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pLeft <span class="keyword">if</span> pLeft <span class="keyword">else</span> pRootOfTree</span><br></pre></td></tr></table></figure>

<h3 id="循环-1"><a href="#循环-1" class="headerlink" title="循环"></a>循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Convert</span><span class="params">(self, pRootOfTree)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        s = []</span><br><span class="line">        pCurrent = pRootOfTree</span><br><span class="line">        pHeadOfList = <span class="literal">None</span></span><br><span class="line">        pLastNodeInList = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> pCurrent <span class="keyword">or</span> s:</span><br><span class="line">            <span class="keyword">while</span> pCurrent:</span><br><span class="line">                s.append(pCurrent)</span><br><span class="line">                pCurrent = pCurrent.left</span><br><span class="line">            <span class="keyword">if</span> s:</span><br><span class="line">                pCurrent = s.pop()</span><br><span class="line">                <span class="keyword">if</span> pLastNodeInList:</span><br><span class="line">                    pLastNodeInList.right = pCurrent</span><br><span class="line">                    pCurrent.left = pLastNodeInList</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pHeadOfList = pCurrent</span><br><span class="line">                pLastNodeInList = pCurrent</span><br><span class="line">                pCurrent = pCurrent.right</span><br><span class="line">        <span class="keyword">return</span> pHeadOfList</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>分解让复杂问题简单</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（发散思维能力）：求1+2+3+...+n</title>
    <url>/folder/2019/11/08/2017-12-01-offer-17/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>不能使用乘除法就意味着不能使用公式，循环和条件判断也不能用，所以只能用递归，递归的停止条件用逻辑与来终止（短路特性），即当n为0时，不再递归直接返回结果。</p>
<p>在网上还找了一种解题思路，就是利用计算二维数组的元素数量来实现的，妙，实在是妙。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><p>###递归：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = n;</span><br><span class="line">        ans &amp;&amp; (ans += Sum_Solution(n - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>###二维数组：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> a[n][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(a)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现："><a href="#Python版代码实现：" class="headerlink" title="Python版代码实现："></a>Python版代码实现：</h2><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.sum = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">qiusum</span><span class="params">(n)</span>:</span></span><br><span class="line">            self.sum += n</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> n&gt;<span class="number">0</span> <span class="keyword">and</span> self.Sum_Solution(n)</span><br><span class="line">         </span><br><span class="line">        qiusum(n)</span><br><span class="line">        <span class="keyword">return</span> self.sum</span><br></pre></td></tr></table></figure>

<h3 id="reduce："><a href="#reduce：" class="headerlink" title="reduce："></a>reduce：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Sum_Solution</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> x+y</span><br><span class="line">        <span class="keyword">return</span> reduce(f,range(n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>发散思维能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（发散思维能力）：不用加减乘除做加法</title>
    <url>/folder/2019/11/08/2017-12-01-offer-16/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>首先看十进制是如何做的： 5+7=12，三步走<br>第一步：相加各位的值，不算进位，得到2。<br>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。<br>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。<br>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111<br>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。<br>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。<br>第三步：重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num2 ? Add(num1^num2, (num1&amp;num2)&lt;&lt;<span class="number">1</span>) : num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python版代码实现："><a href="#Python版代码实现：" class="headerlink" title="Python版代码实现："></a>Python版代码实现：</h2><p>python可以直接用内置函数实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Add</span><span class="params">(self, num1, num2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> sum([num1,num2])</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>发散思维能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（递归和循环）：跳台阶</title>
    <url>/folder/2019/11/08/2017-12-01-offer-15/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>对于n级台阶，第一步有2种跳法：跳1级、跳2级；<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)。<br>其中：f(1) = 1, f(2) = 2。</p>
<p>实现f(n)=f(n-1)+f(n-2)的方法有很多种，递归、循环都可以。</p>
<p>注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> jumpFloor(number<span class="number">-1</span>)+jumpFloor(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloor</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>, second = <span class="number">2</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) &#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现："><a href="#Python-代码实现：" class="headerlink" title="Python 代码实现："></a>Python 代码实现：</h2><h3 id="递归：-1"><a href="#递归：-1" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.jumpFloor(number<span class="number">-1</span>) + self.jumpFloor(number<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环：-1"><a href="#循环：-1" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloor</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        first = <span class="number">1</span></span><br><span class="line">        second = <span class="number">2</span></span><br><span class="line">        third = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,number+<span class="number">1</span>):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        <span class="keyword">return</span> third</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（递归和循环）：矩形覆盖</title>
    <url>/folder/2019/11/08/2017-12-01-offer-14/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>和跳台阶的解题思路是一样的。</p>
<p>对于2 * n的矩形，第一步有2种覆盖方法：横着放一个2 * 1的矩形、竖着放两个2 * 1的矩形；<br>横着放一个2 * 1的矩形，剩下2 * n-1的矩形，则剩下覆盖方法是f(n-1)<br>竖着放两个2 * 1的矩形，剩下2 * n-2的矩形，则剩下覆盖方法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)。<br>其中：f(1) = 1, f(2) = 2。</p>
<p>实现f(n)=f(n-1)+f(n-2)的方法有很多种，递归、循环都可以。</p>
<p>注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> rectCover(number<span class="number">-1</span>)+rectCover(number<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rectCover</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>, second = <span class="number">2</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= number; i++) &#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现："><a href="#Python-代码实现：" class="headerlink" title="Python 代码实现："></a>Python 代码实现：</h2><h3 id="递归：-1"><a href="#递归：-1" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.rectCover(number<span class="number">-1</span>) + self.rectCover(number<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环：-1"><a href="#循环：-1" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rectCover</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> number &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        first = <span class="number">1</span></span><br><span class="line">        second = <span class="number">2</span></span><br><span class="line">        third = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>,number+<span class="number">1</span>):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        <span class="keyword">return</span> third</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（递归和循环）：斐波那契数列</title>
    <url>/folder/2019/11/08/2017-12-01-offer-13/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果我们需要重复地多次计算相同的问题，通常可以选择用递归或者循环两种不同的方法。递归式在一个函数的内部调用这个函数自身。而循环则是通过设置计算的初始值及终止条件，在一个范围内重复运算。</p>
<p>通常递归的代码会比较简洁。在面试的时候，如果面试官没有特别的要求，应聘者可以尽量多采用递归。</p>
<p>递归虽然有简介的优点，但它同时也有显著的缺点，那就是时间和空间的消耗：每一次函数调用，都需要在内存栈中分配空间以保存参数、返回地址及临时变量，而且往栈里面压入数据和弹出数据都需要时间，这就不难理解上述的例子中递归实现的效率不如循环了。</p>
<p>除了效率，递归还有可能引起更严重的问题：调用栈溢出。当递归调用的层数太多时，就会超出栈的容量，从而导致调用栈溢出。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br>n&lt;=39</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>斐波那契数列的定义如下：</p>
<p><code>!$f(n) = \begin{cases} 0, &amp; \text{n = 0} \\ 1, &amp; \text{n = 1} \\ {f(n-1)+f(n-2)}, &amp; \text{n &gt; 1} \end{cases} $</code></p>
<p>实现f(n)=f(n-1)+f(n-2)的方法有很多种，递归、循环都可以。</p>
<p>注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。这次C++的递归调用也超时了，所以啊，面试手写优先使用递归，在线编程优先使用循环呐。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>)+Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>, third = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            third = first + second;</span><br><span class="line">            first = second;</span><br><span class="line">            second = third;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> third;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现："><a href="#Python-代码实现：" class="headerlink" title="Python 代码实现："></a>Python 代码实现：</h2><h3 id="递归：-1"><a href="#递归：-1" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.Fibonacci(n<span class="number">-1</span>) + self.Fibonacci(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环：-1"><a href="#循环：-1" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Fibonacci</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        second = <span class="number">1</span></span><br><span class="line">        third = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n+<span class="number">1</span>):</span><br><span class="line">            third = first + second</span><br><span class="line">            first = second</span><br><span class="line">            second = third</span><br><span class="line">        <span class="keyword">return</span> third</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（递归和循环）：变态跳台阶</title>
    <url>/folder/2019/11/08/2017-12-01-offer-12/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/nowcoder/blob/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/nowcoder/blob/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>因为n级台阶，第一步有n种跳法：跳1级、跳2级、到跳n级<br>跳1级，剩下n-1级，则剩下跳法是f(n-1)<br>跳2级，剩下n-2级，则剩下跳法是f(n-2)<br>所以f(n)=f(n-1)+f(n-2)+…+f(1)<br>因为f(n-1)=f(n-2)+f(n-3)+…+f(1)<br>所以f(n)=2*f(n-1)</p>
<p>实现f(n)=2*f(n-1)的方法有很多种，递归、循环都可以。</p>
<p>注意：由于递归比较耗费时间，加上python的运行效率本来就低，所以python的递归调用一般在牛客网的实例测试中下总是超时。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(number &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(number == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * jumpFloorII(number <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环："><a href="#循环：" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> number;</span><br><span class="line">        <span class="keyword">int</span> total=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;number; i++)</span><br><span class="line">            total *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="移位："><a href="#移位：" class="headerlink" title="移位："></a>移位：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jumpFloorII</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;--number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现："><a href="#Python-代码实现：" class="headerlink" title="Python 代码实现："></a>Python 代码实现：</h2><h3 id="递归：-1"><a href="#递归：-1" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number &lt;= <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">elif</span> number == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>*self.jumpFloorII(number<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="循环：-1"><a href="#循环：-1" class="headerlink" title="循环："></a>循环：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> number == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> number</span><br><span class="line">        total = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(number<span class="number">-1</span>):</span><br><span class="line">            total *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> total</span><br></pre></td></tr></table></figure>

<h3 id="移位：-1"><a href="#移位：-1" class="headerlink" title="移位："></a>移位：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jumpFloorII</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>&lt;&lt;(number<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>递归和循环</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码完整性）：在O(1)时间删除链表结点</title>
    <url>/folder/2019/11/08/2017-12-01-offer-11/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>同样的，这道题牛客网上也没有。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表结点与函数的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct ListNode&#123;</span><br><span class="line">    int m_nValue;</span><br><span class="line">    ListNode* m_pNext;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted);</span><br></pre></td></tr></table></figure>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p></p>
<div align=center><img src="http://img.blog.csdn.net/20171010113522746?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>方法一：顺序遍历（时间复杂度O(n)）</p>
<p>从单向链表中删除一个结点，最常规的做法就是从链表的头结点开始，顺序遍历查找要删除的结点，并在链表中删除该结点。之所以需要从头开始查找，是因为我们需要得到将被删除的节点的前面一个结点。在单向链表中，结点中没有指向前一个结点的指针，所以只好从链表的头结点开始顺序查找。</p>
<p>方法二：复制结点（时间复杂度O(1)）</p>
<p>当然，我们并不是非得得到前一个结点才能来删除该结点。上图C中，我们要删除结点i，先把i的下一个结点j的内容复制到i，然后把i的指针指向结点j的下一个结点。此时再删除节点j，其效果刚好是把结点i给删除了。</p>
<p>但是，这种思路，需要考虑删除尾结点的问题，这个时候只能顺序遍历。同时，还要注意如果链表中只有一个结点的情况，记得删除之后把头结点设置为NULL。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="顺序遍历"><a href="#顺序遍历" class="headerlink" title="顺序遍历"></a>顺序遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    ListNode* pNode = *pListHead;</span><br><span class="line">    <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        pNode = pNode-&gt;m_pNext;            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pNode-&gt;m_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">    pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复制结点"><a href="#复制结点" class="headerlink" title="复制结点"></a>复制结点</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode** pListHead, ListNode* pToBeDeleted)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!pListHead || !pToBeDeleted)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的结点不是尾结点</span></span><br><span class="line">    <span class="keyword">if</span>(pToBeDeleted-&gt;m_pNext != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pToBeDeleted-&gt;m_pNext;</span><br><span class="line">        pToBeDeleted-&gt;m_nValue = pNext-&gt;m_nValue;</span><br><span class="line">        pToBeDeleted-&gt;m_pNext = pNext-&gt;m_pNext;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">delete</span> pNext;</span><br><span class="line">        pNext = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表只有一个结点，删除头结点（也是尾结点）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(*pListHead == pToBeDeleted)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">        *pListHead = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 链表中有多个结点，删除尾结点</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNode = *pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pNode-&gt;m_pNext != pToBeDeleted)</span><br><span class="line">        &#123;</span><br><span class="line">            pNode = pNode-&gt;m_pNext;            </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        pNode-&gt;m_pNext = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">delete</span> pToBeDeleted;</span><br><span class="line">        pToBeDeleted = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码完整性）：调整数组顺序使奇数位于偶数前面</title>
    <url>/folder/2019/11/08/2017-12-01-offer-10/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书上这道题没要求相对位置不变，所以这道题我们以牛客网为准，毕竟有测试平台。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>方法一：</p>
<p>类似冒泡算法，前偶后奇就交换。时间复杂度O(n^2)。</p>
<p>方法二：</p>
<p>空间换时间，再创建一个数组，或者双向队列。时间复杂度O(n)，空间复杂度O(n)。</p>
<p>方法三：</p>
<p>双向队列，一次循环插入。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">array</span>.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="built_in">array</span>.<span class="built_in">size</span>() - <span class="number">1</span>; j  &gt; i; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">array</span>[j] % <span class="number">2</span> == <span class="number">1</span> &amp;&amp; <span class="built_in">array</span>[j - <span class="number">1</span>] % <span class="number">2</span> == <span class="number">0</span>) <span class="comment">//前偶后奇交换</span></span><br><span class="line">                &#123;</span><br><span class="line">                    swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="新建数组"><a href="#新建数组" class="headerlink" title="新建数组"></a>新建数组</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span> = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;<span class="built_in">array</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="built_in">array</span>.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[num-i<span class="number">-1</span>] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">                result.push_front(<span class="built_in">array</span>[num-i<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[i] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                result.push_back(<span class="built_in">array</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">array</span>.assign(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现："><a href="#Python-代码实现：" class="headerlink" title="Python 代码实现："></a>Python 代码实现：</h2><h3 id="冒泡："><a href="#冒泡：" class="headerlink" title="冒泡："></a>冒泡：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(array)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(array)<span class="number">-1</span>, i, <span class="number">-1</span>):</span><br><span class="line">                <span class="keyword">if</span> array[j<span class="number">-1</span>] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">and</span> array[j] % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                    array[j], array[j<span class="number">-1</span>] = array[j<span class="number">-1</span>], array[j]</span><br><span class="line">        <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure>

<h3 id="新建列表"><a href="#新建列表" class="headerlink" title="新建列表"></a>新建列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                result.append(array[i])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(array)):</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                result.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="双向队列-1"><a href="#双向队列-1" class="headerlink" title="双向队列"></a>双向队列</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reOrderArray</span><span class="params">(self, array)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        odd = deque()</span><br><span class="line">        l = len(array)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span> array[l-i<span class="number">-1</span>] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                odd.appendleft(array[l-i<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">if</span> array[i] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                odd.append(array[i])</span><br><span class="line">        <span class="keyword">return</span> list(odd)</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码完整性）：数值的整数次方</title>
    <url>/folder/2019/11/08/2017-12-01-offer-9/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码的规范性：书写清晰，布局清晰，命名合理。<br>代码的完整性：功能测试，边界测试，负面测试。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>方法一：公式求解</p>
<p>我们知道当指数为负数的时候，可以先对指针求绝对值，然后算出次方的结果之后再取倒数。如果要自己实现，那么就需要考虑各种错误处理和边界问题。比如，既然有求倒数，对0求倒数怎么办，当底数是0且指数是负数的时候，如果不做特殊处理，就会出现对0求倒数而导致程序运行出错。</p>
<p>一个细节值得我们注意：在判断底数是不是等于0时，不能直接写base == 0，这是因为在计算机内表示小数时都有误差。判断两个小数是否相等，只能判断他们之差的绝对值是不是在一个很小的范围内。如果两个数差值很小，就可以认为它们相等。这就是我们定义函数equal的原因。</p>
<p>方法二：迭代</p>
<p><code>!$a^n = \begin{cases} a^{n/2}*a^{n/2}, &amp; \text{n为偶数} \\ a^{(n-1)/2}*a^{(n-1)/2}*a, &amp; \text{n为奇数} \end{cases} $</code></p>
<p>这个公式很容易就用递归来实现。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="调用pow："><a href="#调用pow：" class="headerlink" title="调用pow："></a>调用pow：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result;</span><br><span class="line">        <span class="keyword">if</span>(exponent &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            result = <span class="built_in">pow</span>(base, exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            result = <span class="built_in">pow</span>(base, -exponent);</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="不调用pow："><a href="#不调用pow：" class="headerlink" title="不调用pow："></a>不调用pow：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool g_InvalidInput = false;</span><br><span class="line">    </span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        g_InvalidInput = false;</span><br><span class="line">        </span><br><span class="line">        if(equal(base, 0.0) &amp;&amp; exponent &lt; 0) &#123;</span><br><span class="line">            g_InvalidInput = true;</span><br><span class="line">            return 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        unsigned int absExponent = (unsigned int)(exponent);</span><br><span class="line">        if(exponent &lt; 0)</span><br><span class="line">            absExponent = (unsigned int)(-exponent);</span><br><span class="line">        </span><br><span class="line">        double result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">        if(exponent &lt; 0)</span><br><span class="line">            result = 1.0 / result;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    double PowerWithUnsignedExponent(double base, unsigned int exponent)&#123;</span><br><span class="line">        double result = 1.0;</span><br><span class="line">        for (int i = 1; i &lt;= exponent; ++i)</span><br><span class="line">            result *= base;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    bool equal(double num1, double num2)&#123;</span><br><span class="line">        if((num1 - num2 &gt; -0.0000001) &amp;&amp; (num1 - num2 &lt; 0.0000001))</span><br><span class="line">            return true;</span><br><span class="line">        else</span><br><span class="line">            return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        g_InvalidInput = <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(equal(base, <span class="number">0.0</span>) &amp;&amp; exponent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            g_InvalidInput = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(exponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">            absExponent = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(-exponent);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, absExponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)</span><br><span class="line">            result = <span class="number">1.0</span> / result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">PowerWithUnsignedExponent</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">unsigned</span> <span class="keyword">int</span> exponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> result = PowerWithUnsignedExponent(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>(exponent &amp; <span class="number">0x1</span> == <span class="number">1</span>)</span><br><span class="line">            result *= base;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((num1 - num2 &gt; <span class="number">-0.0000001</span>) &amp;&amp; (num1 - num2 &lt; <span class="number">0.0000001</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现："><a href="#Python-代码实现：" class="headerlink" title="Python 代码实现："></a>Python 代码实现：</h2><h3 id="调用pow：-1"><a href="#调用pow：-1" class="headerlink" title="调用pow："></a>调用pow：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Power</span><span class="params">(self, base, exponent)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> exponent &gt;= <span class="number">0</span>:</span><br><span class="line">            result = pow(base, exponent)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = pow(base, -exponent)</span><br><span class="line">            result = <span class="number">1</span> / result</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="不调用pow"><a href="#不调用pow" class="headerlink" title="不调用pow"></a>不调用pow</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">class Solution:</span><br><span class="line">    def Power(self, base, exponent):</span><br><span class="line">        # write code here</span><br><span class="line">        flag = 0</span><br><span class="line">        if base == 0:</span><br><span class="line">            return False</span><br><span class="line">        if exponent == 0:</span><br><span class="line">            return 1</span><br><span class="line">        if exponent &lt; 0:</span><br><span class="line">            flag = 1</span><br><span class="line">        result = 1</span><br><span class="line">        for i in range(abs(exponent)):</span><br><span class="line">            result *= base</span><br><span class="line">        if flag == 1:</span><br><span class="line">            result = 1 / result</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码完整性）：打印1到最大的n位数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-8/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这道题牛客网上没有，但是剑指offer上有，看完之后觉得挺有用的，所以我还是整理一下吧。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数即999。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>没有规定n的范围，所以我们需要考虑大数的问题。</p>
<p>方法一：字符串模拟</p>
<p>用字符串表示数字的时候，最直观的方法就是字符串里每个字符都是‘0’到‘9’之间的某一个字符，用来表示数字中的一位。因为数字最大是n位，所以我们需要一个长度为n+1的字符串（字符串结尾符号‘\0’，这个我记得之前强调过了）。当实际数字不够n位的时候在字符串前半部分补0，打印的时候不打印前半部分的0就好。同时我们用进位标志位作为循环终止条件。</p>
<p>方法二：递归</p>
<p>如果我们在数字前面补0的话，就会发现n位所有十进制数其实就是n个从0到9的全排列。也就是说，我们把数字的每一位都从0到9排列一遍，就得到所有的十进制数，只是我们在打印的时候，数字排在前面的0我们不打印出来罢了。</p>
<h2 id="C-版代码实现："><a href="#C-版代码实现：" class="headerlink" title="C++版代码实现："></a>C++版代码实现：</h2><h3 id="字符串模拟："><a href="#字符串模拟：" class="headerlink" title="字符串模拟："></a>字符串模拟：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ====================方法一====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(number, <span class="string">'0'</span>, n);</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!Increment(number))</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[]number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，在 number上增加1</span></span><br><span class="line"><span class="comment">// 如果做加法溢出，则返回true；否则为false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Increment</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isOverflow = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> nTakeOver = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nSum = number[i] - <span class="string">'0'</span> + nTakeOver;</span><br><span class="line">        <span class="keyword">if</span> (i == nLength - <span class="number">1</span>)</span><br><span class="line">            nSum++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nSum &gt;= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">                isOverflow = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                nSum -= <span class="number">10</span>;</span><br><span class="line">                nTakeOver = <span class="number">1</span>;</span><br><span class="line">                number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            number[i] = <span class="string">'0'</span> + nSum;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isOverflow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================公共函数====================</span></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，数字有若干个0开头</span></span><br><span class="line"><span class="comment">// 打印出这个数字，并忽略开头的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ====================方法二====================</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigits_2</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* number = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>];</span><br><span class="line">    number[n] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[<span class="number">0</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print1ToMaxOfNDigitsRecursively</span><span class="params">(<span class="keyword">char</span>* number, <span class="keyword">int</span> length, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == length - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PrintNumber(number);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        number[index + <span class="number">1</span>] = i + <span class="string">'0'</span>;</span><br><span class="line">        Print1ToMaxOfNDigitsRecursively(number, length, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================公共函数====================</span></span><br><span class="line"><span class="comment">// 字符串number表示一个数字，数字有若干个0开头</span></span><br><span class="line"><span class="comment">// 打印出这个数字，并忽略开头的0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintNumber</span><span class="params">(<span class="keyword">char</span>* number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginning0 = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> nLength = <span class="built_in">strlen</span>(number);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginning0 &amp;&amp; number[i] != <span class="string">'0'</span>)</span><br><span class="line">            isBeginning0 = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isBeginning0)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%c"</span>, number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\t"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码完整性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码的鲁棒性）：树的子结构</title>
    <url>/folder/2019/11/08/2017-12-01-offer-7/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在leetcode刷题的时候，感觉做的最多的就是树这块了。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>第一步在树A中查找与根结点的值一样的结点，这实际上就是树的遍历。所以，递归和循环都可以。</p>
<p>第二步是判断树A中以R为根结点的子树是不是和树B有相同的结构。同样的，递归和循环都可以。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct TreeNode *left;</span></span><br><span class="line"><span class="comment">	struct TreeNode *right;</span></span><br><span class="line"><span class="comment">	TreeNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">HasSubtree</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span> || pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> dfs(pRoot1, pRoot2) || HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* pRoot1, TreeNode* pRoot2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(pRoot1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> pRoot1-&gt;val == pRoot2-&gt;val &amp;&amp; dfs(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; dfs(pRoot1-&gt;right, pRoot2-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h2><h3 id="DFS-1"><a href="#DFS-1" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">HasSubtree</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1 <span class="keyword">or</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(pRoot1, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.left, pRoot2) <span class="keyword">or</span> self.HasSubtree(pRoot1.right, pRoot2)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, pRoot1, pRoot2)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot2:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> pRoot1:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> pRoot1.val == pRoot2.val <span class="keyword">and</span> self.dfs(pRoot1.left, pRoot2.left) <span class="keyword">and</span> self.dfs(pRoot1.right, pRoot2.right)</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码的鲁棒性）：链表中倒数第k个结点</title>
    <url>/folder/2019/11/08/2017-12-01-offer-6/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>所谓的鲁棒性是指程序能够判断输入是否符合规范要求，并对不合要求的输入予以合理的处理。</p>
<p>提高代码的鲁棒性的有效途径是进行防御性编程。防御性编程是一种变成习惯，是指预见在什么地方可能会出现问题，并为这些可能出现的问题制定处理方式。比如试图打开文件时发现文件不存在，我们可以提示用户检查文件名和路径等等，这样当异常发生时，软件的行为也尽在我们的掌握之中，而不至于出现不可预见的事情。</p>
<p>比如下面这道题，“链表中倒数第K个结点”，这里隐含着一个条件就是链表中结点的个数大于k。我们想，如果链表中的结点的数目不是大于k个，那么代码会出什么问题？这样的思考方式能够帮助我们发现潜在的问题并提前解决问题。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>定义两个指针，第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不变；从第K步开始，第二个指针也是从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个指针到达链表的伪结点时，第二个指针正好是倒数第k个结点。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="鲁棒性低"><a href="#鲁棒性低" class="headerlink" title="鲁棒性低"></a>鲁棒性低</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">            </span><br><span class="line">        ListNode* pAhead = pListHead;</span><br><span class="line">        ListNode* pBehind = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            pAhead = pAhead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pBehind = pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pAhead-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pAhead = pAhead-&gt;next;</span><br><span class="line">            pBehind = pBehind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pBehind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="鲁棒性高"><a href="#鲁棒性高" class="headerlink" title="鲁棒性高"></a>鲁棒性高</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">FindKthToTail</span><span class="params">(ListNode* pListHead, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pListHead == <span class="literal">NULL</span> || k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            </span><br><span class="line">        ListNode* pAhead = pListHead;</span><br><span class="line">        ListNode* pBehind = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pAhead-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">                pAhead = pAhead-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        pBehind = pListHead;</span><br><span class="line">        <span class="keyword">while</span>(pAhead-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pAhead = pAhead-&gt;next;</span><br><span class="line">            pBehind = pBehind-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pBehind;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h2><h3 id="鲁棒性差"><a href="#鲁棒性差" class="headerlink" title="鲁棒性差"></a>鲁棒性差</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        pAhead = head</span><br><span class="line">        pBehind = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, k<span class="number">-1</span>):</span><br><span class="line">            pAhead = pAhead.next</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        pBehind = head</span><br><span class="line">        <span class="keyword">while</span> pAhead.next != <span class="literal">None</span>:</span><br><span class="line">            pAhead = pAhead.next</span><br><span class="line">            pBehind = pBehind.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pBehind</span><br></pre></td></tr></table></figure>

<h3 id="鲁棒性高-1"><a href="#鲁棒性高-1" class="headerlink" title="鲁棒性高"></a>鲁棒性高</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        pAhead = head</span><br><span class="line">        pBehind = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, k<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> pAhead.next != <span class="literal">None</span>:</span><br><span class="line">                pAhead = pAhead.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        pBehind = head</span><br><span class="line">        <span class="keyword">while</span> pAhead.next != <span class="literal">None</span>:</span><br><span class="line">            pAhead = pAhead.next</span><br><span class="line">            pBehind = pBehind.next</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> pBehind</span><br></pre></td></tr></table></figure>

<h3 id="更快"><a href="#更快" class="headerlink" title="更快"></a>更快</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">FindKthToTail</span><span class="params">(self, head, k)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        l=[]</span><br><span class="line">        <span class="keyword">while</span> head != <span class="literal">None</span>:</span><br><span class="line">            l.append(head)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span> k &gt; len(l) <span class="keyword">or</span> k &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">return</span> l[-k]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码的鲁棒性）：合并两个排序的链表</title>
    <url>/folder/2019/11/08/2017-12-01-offer-5/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在面试过程中，最容易犯两种错误：一是在写代码之前没有对合并的过程想清楚，最终合并出来的链表要么中间断开了要么并没有做到递增排序；二是代码在鲁棒性方面存在问题，程序一旦有特殊的输入（如空链表）就会崩溃。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>递归：</p>
<p>新创建一个指针就可以，比较两个链表的值，然后做相应递归更新。</p>
<p>循环：</p>
<p>需要创建两个指针，一个指向合并链表的表头，另一个用于更新，不断指向合并链表的表尾。最后返回指向表头的指针即可。</p>
<p>需要注意的是，我为了简化代码，新建的是指向带有头结点的链表（链表有带头结点和不带头结点点两种）。如果全部初始化为NULL（python是None），那么我在循环之前，就得加个判断来给合并链表的第一个结点赋值。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="comment">//创建头指针</span></span><br><span class="line">        ListNode* pMergeHead = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">            pMergeHead = pHead1;</span><br><span class="line">            pMergeHead-&gt;next = Merge(pHead1-&gt;next, pHead2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pMergeHead = pHead2;</span><br><span class="line">            pMergeHead-&gt;next = Merge(pHead1, pHead2-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pMergeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">Merge</span><span class="params">(ListNode* pHead1, ListNode* pHead2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//边界判断</span></span><br><span class="line">        <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(pHead2 == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> pHead1;</span><br><span class="line">        <span class="comment">//创建头尾指针</span></span><br><span class="line">        ListNode* pMergeTail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode* pMergeHead = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//尾指针赋值</span></span><br><span class="line">        pMergeTail = pMergeHead;</span><br><span class="line">        <span class="comment">//循环开始</span></span><br><span class="line">        <span class="keyword">while</span>(pHead1 &amp;&amp; pHead2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pHead1-&gt;val &lt; pHead2-&gt;val)&#123;</span><br><span class="line">                pMergeTail-&gt;next = pHead1;</span><br><span class="line">                pHead1 = pHead1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pMergeTail-&gt;next = pHead2;</span><br><span class="line">                pHead2 = pHead2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">            pMergeTail = pMergeTail-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剩下的链表部分直接添加</span></span><br><span class="line">        pMergeTail-&gt;next = pHead1 ? pHead1 : pHead2;</span><br><span class="line">        <span class="keyword">return</span> pMergeHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python-代码实现"><a href="#Python-代码实现" class="headerlink" title="Python 代码实现"></a>Python 代码实现</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">elif</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        </span><br><span class="line">        pMergeHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">            pMergeHead = pHead1</span><br><span class="line">            pMergeHead.next = self.Merge(pHead1.next, pHead2)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pMergeHead = pHead2</span><br><span class="line">            pMergeHead.next = self.Merge(pHead1, pHead2.next)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> pMergeHead</span><br></pre></td></tr></table></figure>

<h3 id="循环-1"><a href="#循环-1" class="headerlink" title="循环"></a>循环</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># 返回合并后列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Merge</span><span class="params">(self, pHead1, pHead2)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> pHead1 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead2</span><br><span class="line">        <span class="keyword">elif</span> pHead2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> pHead1</span><br><span class="line">        </span><br><span class="line">        pMergeTail = pMergeHead = ListNode(<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> pHead1 <span class="keyword">and</span> pHead2:</span><br><span class="line">            <span class="keyword">if</span> pHead1.val &lt; pHead2.val:</span><br><span class="line">                pMergeTail.next = pHead1</span><br><span class="line">                pHead1 = pHead1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pMergeTail.next = pHead2</span><br><span class="line">                pHead2 = pHead2.next</span><br><span class="line">            pMergeTail = pMergeTail.next</span><br><span class="line">            </span><br><span class="line">        pMergeTail.next = pHead1 <span class="keyword">or</span> pHead2</span><br><span class="line">        <span class="keyword">return</span> pMergeHead.next</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（代码的鲁棒性）：反转链表</title>
    <url>/folder/2019/11/08/2017-12-01-offer-4/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个链表，反转链表后，输出链表的所有元素。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目比较简单，主要是需要考虑在调整某一结点的m_pNext之前，先把它的下一个节点保存下来，以免断链子了。同时还要满足下面的测试用例。</p>
<p>测试用例：</p>
<ul>
<li>输入的链表头指针是NULL。</li>
<li>输入的链表只有一个结点。</li>
<li>输入的链表有多个结点。</li>
</ul>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct ListNode &#123;</span></span><br><span class="line"><span class="comment">	int val;</span></span><br><span class="line"><span class="comment">	struct ListNode *next;</span></span><br><span class="line"><span class="comment">	ListNode(int x) :</span></span><br><span class="line"><span class="comment">			val(x), next(NULL) &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    ListNode* pReversedHead = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* pNode = pHead;</span><br><span class="line">    ListNode* pPrev = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(pNode != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ListNode* pNext = pNode-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pNext == <span class="literal">nullptr</span>)</span><br><span class="line">            pReversedHead = pNode;</span><br><span class="line"></span><br><span class="line">        pNode-&gt;next = pPrev;</span><br><span class="line"></span><br><span class="line">        pPrev = pNode;</span><br><span class="line">        pNode = pNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pReversedHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（抽象建模能力）：圆圈中最后剩下的数</title>
    <url>/folder/2019/11/08/2017-12-01-offer-3/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果只求最后一个报数胜利者的话，我们可以用数学归纳法解决该问题，为了讨      论方便，先把问题稍微改变一下，并不影响原意：<br> 问题描述：n个人（编号0~(n-1))，从0开始报数，报到(m-1)的退出，剩下的人 继续从0开始报数。求胜利者的编号。<br> 我们知道第一个人(编号一定是(m-1)%n) 出列之后，剩下的n-1个人组成了一个新      的约瑟夫环（以编号为k=(m-1)%n的人开始）:<br>        k  k+1  k+2  … n-2, n-1, 0, 1, 2, … k-2并且从k开始报0。<br>现在我们把他们的编号做一下转换：<br>k+1   –&gt; 0<br>k+2   –&gt; 1<br>…<br>n-1   –&gt; n-k-2<br>0     –&gt; n-k-1<br>1     –&gt; n-k<br>…<br>k-2   –&gt; n-2<br>k-1   –&gt; n-1<br>变换后就完完全全成为了(n-1)个人报数的子问题，假如我们知道这个子问题的解： 例如x是最终的胜利者，那么根据上面这个表把这个x变回去不刚好就是n个人情 况的解吗？！！变回去的公式很简单，相信大家都可以推出来：x’=(x+k+1)%n。<br>然后把k=(m-1)%n带入，就是下面的递推公式了。<br>令f[n]表示n个人玩游戏报m退出最后胜利者的编号，最后的结果自然是f[n]。<br>递推公式<br>f[1]=0;<br>f[n]=(f[n-1]+m)%n;  (n&gt;1)<br>有了这个公式，我们要做的就是从1-n顺序算出f[i]的数值，最后结果是f[n]。 </p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int LastRemaining_Solution(int n, int m)</span><br><span class="line">    &#123;</span><br><span class="line">        if(n &lt; 1 || m &lt; 1)</span><br><span class="line">            return -1;</span><br><span class="line">        int last = 0;</span><br><span class="line">        for(int i = 2; i &lt;= n; ++i)</span><br><span class="line">            last = (last + m) % i;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>代码的鲁棒性</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（抽象建模能力）：扑克牌顺子</title>
    <url>/folder/2019/11/08/2017-12-01-offer-2/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>一次for循环就可以搞定，满足如下条件才可以认为是顺子：</p>
<ul>
<li>输入数据个数为5；</li>
<li>输入数据都在0-13之间；</li>
<li>没有相同的数字；</li>
<li>最大值与最小值的差值不大于5；</li>
</ul>
<p>不用对输入数据做排序，直接设置一个flag，该flag的每一位分别用来记录1-13是否出现，出现过一次置1，出现两次则中止程序。</p>
<h2 id="C-版代码实现"><a href="#C-版代码实现" class="headerlink" title="C++版代码实现"></a>C++版代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool IsContinuous( vector&lt;int&gt; numbers ) &#123;</span><br><span class="line">        if(numbers.size() &lt; 5)</span><br><span class="line">            return false;</span><br><span class="line">        int max = -1;</span><br><span class="line">        int min = 14;</span><br><span class="line">        int flag = 0;</span><br><span class="line">        for(int i = 0; i &lt; numbers.size(); ++i)&#123;</span><br><span class="line">            int number = numbers[i];</span><br><span class="line">            if(number &lt; 0 || number &gt; 13)</span><br><span class="line">                return false;</span><br><span class="line">            if(number == 0)</span><br><span class="line">                continue;</span><br><span class="line">            if(((flag &gt;&gt; number) &amp; 1) == 1)</span><br><span class="line">                return false;</span><br><span class="line">            flag |= 1 &lt;&lt; number;</span><br><span class="line">            if(number &lt; min)</span><br><span class="line">                min = number;</span><br><span class="line">            if(number &gt; max)</span><br><span class="line">                max = number;</span><br><span class="line">            if(max - min &gt;= 5)</span><br><span class="line">                return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>抽象建模能力</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记（查找和排序）：旋转数组的最小数字</title>
    <url>/folder/2019/11/08/2017-12-01-offer-1/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查找和排序是面试时考查算法的重点，重点掌握二分查找、归并排序和快速排序。</p>
<p>查找相对而言较为简单，不外乎顺序查找、二分查找、哈希表查找和二叉排序树查找。必须要信手拈来。</p>
<p>哈希表表和二叉排序树查找的重点在于考察对应的数据结构而不是算法。哈希表最主要的优点是我们利用它能够在O(1)时间查找某一元素，是效率最高的查找方式，但是需要二外的空间来实现哈希表。与二叉排序树查找算法对应的数据结构是二叉搜索树，后面会涉及到。如果要在排序的数组（或者部分排序的数组）中查找一个数字或者统计某个数字出现的次数，我们都可以尝试用二分查找算法。</p>
<p>排序比查找要复杂一些，我们需要比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣，必须要烂熟于胸，能够从额外空间消耗、平均时间复杂度和最差时间复杂度等方面去比较他们的优缺点。同时，快排经常要求重写。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="直接查找"><a href="#直接查找" class="headerlink" title="直接查找"></a>直接查找</h3><p>算法复杂度O(n)。</p>
<h3 id="再次排序"><a href="#再次排序" class="headerlink" title="再次排序"></a>再次排序</h3><p>再次排序后输出第一个数字，算法复杂度O(n*logn)。</p>
<h3 id="分段二分查找"><a href="#分段二分查找" class="headerlink" title="分段二分查找"></a>分段二分查找</h3><p>算法复杂度O(logn)。</p>
<ul>
<li>我们用两个指针分别指向数组的第一个元素和最后一个元素。按照题目中旋转的规则，第一个元素应该是大于或者等于最后一个元素的（不完全对，有特例）。</li>
<li>接着我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。</li>
<li>同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。</li>
<li>第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。</li>
</ul>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170929105837807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>特殊情况：</p>
<ul>
<li>如果把排序数组的0个元素搬到最后面，这仍然是租住的一个需安装，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。</li>
<li>下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。</li>
</ul>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170929105856996?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="C-代码实现"><a href="#C-代码实现" class="headerlink" title="C++代码实现"></a>C++代码实现</h2><h3 id="再次排序-1"><a href="#再次排序-1" class="headerlink" title="再次排序"></a>再次排序</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">       sort(rotateArray.<span class="built_in">begin</span>(),rotateArray.<span class="built_in">end</span>());</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>];</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="分段二分法"><a href="#分段二分法" class="headerlink" title="分段二分法"></a>分段二分法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">size</span> = rotateArray.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">size</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="built_in">size</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// rotateArray[left] &gt;= rotateArray[right] 确保旋转</span></span><br><span class="line">        <span class="keyword">while</span>(rotateArray[left] &gt;= rotateArray[right])&#123;</span><br><span class="line">            <span class="comment">// 分界点</span></span><br><span class="line">            <span class="keyword">if</span>(right - left == <span class="number">1</span>)&#123;</span><br><span class="line">                mid = right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// rotateArray[left] rotateArray[right] rotateArray[mid]三者相等</span></span><br><span class="line">            <span class="comment">// 无法确定中间元素是属于前面还是后面的递增子数组</span></span><br><span class="line">            <span class="comment">// 只能顺序查找</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid])&#123;</span><br><span class="line">                <span class="keyword">return</span> MinOrder(rotateArray,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中间元素位于前面的递增子数组</span></span><br><span class="line">            <span class="comment">// 此时最小元素位于中间元素的后面</span></span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[left])&#123;</span><br><span class="line">                left = mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 中间元素位于后面的递增子数组</span></span><br><span class="line">            <span class="comment">// 此时最小元素位于中间元素的前面</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 顺序寻找最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MinOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = num[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = left + <span class="number">1</span>;i &lt; right;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i] &lt; result)&#123;</span><br><span class="line">                result = num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Python代码实现"><a href="#Python代码实现" class="headerlink" title="Python代码实现"></a>Python代码实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minNumberInRotateArray</span><span class="params">(self, rotateArray)</span>:</span></span><br><span class="line">        <span class="comment"># write code here</span></span><br><span class="line">        <span class="keyword">if</span> len(rotateArray) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        pre = <span class="number">-7e20</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> rotateArray:</span><br><span class="line">            <span class="keyword">if</span> num &lt; pre :</span><br><span class="line">                <span class="keyword">return</span> num</span><br><span class="line">            pre = num</span><br><span class="line">        <span class="keyword">return</span> rotateArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
        <tag>查找和排序</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指offer》刷题笔记系列综述</title>
    <url>/folder/2019/11/08/2017-12-01-offer-0/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></strong></li>
<li><strong>文章地址：<a href="https://github.com/WordZzzz/Note/tree/master/AtOffer" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/AtOffer</a></strong></li>
<li><strong>刷题平台：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">https://www.nowcoder.com/</a></strong></li>
<li><strong>题&emsp;&emsp;库：剑指offer</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;WordZzzz原计划按照牛客网上面的《剑指offer》的通过率高低来把66道编程题刷一遍，但是后来发现，相对于牛客网上大神的解答，WordZzzz更倾向于原书作者的详解。所以，从今天开始，本博主打算按照《剑指offer》纪念版上的题目顺序来进行后续的总结，以作者何大大思路为主，以牛客网上各路大声的代码为辅，对每一道题的解法进行详细的记录，方便自己日后查看，也为订阅本专栏的各位可爱的亲人们提供一些参考。</p>
<ul>
<li>《剑指offer》何大大的源码（含测试代码）传送门：<a href="https://github.com/zhedahht/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/zhedahht/CodingInterviewChinese2</a></li>
<li>当然我自己也fork了一下：<a href="https://github.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://github.com/WordZzzz/CodingInterviewChinese2</a></li>
<li>再来个码云的传送门吧：<a href="https://gitee.com/WordZzzz/CodingInterviewChinese2" target="_blank" rel="noopener">https://gitee.com/WordZzzz/CodingInterviewChinese2</a></li>
<li>至于《剑指offer》纪念版的电子版当然我也有，网上最清晰的资源，需要的请私信我。有条件的还是建议购买正版书籍，支持何大大，支持正版！</li>
</ul>
<p>&emsp;&emsp;另外，下面这道开胃菜牛客上没有，所以先贴出来了。</p>
<h2 id="赋值运算符函数"><a href="#赋值运算符函数" class="headerlink" title="赋值运算符函数"></a>赋值运算符函数</h2><p>&emsp;&emsp;如下为类型CMyString的生命，请为该类型添加赋值运算符函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">    CMyString(<span class="keyword">char</span>* CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CMyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CMyString(<span class="keyword">char</span>* pData = <span class="literal">NULL</span>);</span><br><span class="line">    CMyString(<span class="keyword">char</span>* CMyString&amp; str);</span><br><span class="line">    ~CMyString(<span class="keyword">void</span>);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span>* m_pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="考察细节"><a href="#考察细节" class="headerlink" title="考察细节"></a>考察细节</h3><ul>
<li>是否会把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（即*this）。只有返回一个引用，才可以允许连续赋值。否则如果函数的返回值是void，应用该赋值运算符将不能做连续赋值。假设有3个CMyString的对象：str1、str2和str3，在程序中语句str1=str2=str3是不能通过编译的。</li>
<li>是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函数，吧参数声明为引用可以避免这样的消耗，能提高代码的效率。同时，我们在赋值运算符函数中不会改变传入的实例的状态，因此应该为传入的引用参数加上const关键字。</li>
<li>是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释放自身已有的空间，程序将出现内存泄漏。</li>
<li>是否判断传入的参数和但钱的实例是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先不判断就进行赋值，那么在释放自身的内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，那么一旦释放了自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。</li>
</ul>
<h3 id="经典的解法"><a href="#经典的解法" class="headerlink" title="经典的解法"></a>经典的解法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> []m_pData;</span><br><span class="line">    m_pData = <span class="literal">NULL</span>;</span><br><span class="line">    m_pData = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(str.m_pData) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(m_pData, str.m_pData);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这是一般教材上提供的参考代码。明眼人可能会发现，上述代码在分配内存之前先用delete释放了实例m_pData的内存。如果此时内存不足导致new char抛出异常，m_pData将是一个空指针，这昂非常容易导致程序的崩溃。</p>
<h3 id="考虑异常安全性的解法"><a href="#考虑异常安全性的解法" class="headerlink" title="考虑异常安全性的解法"></a>考虑异常安全性的解法</h3><p>&emsp;&emsp;要想在赋值运算符函数中实现异常安全性，一般有两种方法。一个简单的办法是我们先用new分配新内存再用delete释放已有的内容；一个更好的方法是创建临时实例，再交换临时实例和原来的实例。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CMyString&amp; CMyString::<span class="keyword">operator</span> = (<span class="keyword">const</span> CMyString &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        CMyString strTemp(str);</span><br><span class="line">        </span><br><span class="line">        cahr* pTemp = strTemp.m_pData;</span><br><span class="line">        strTemp.m_pData = m_pData;</span><br><span class="line">        m_pData = pTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序比较简单，值得注意的是，strTemp是一个局部变量，程序运行到if的外面的时候，也就出了该变量的作用域，就会自动调用其析构函数，把strTemp.m_pData所指向的内存释放掉。由于strTemp.m_pData指向的内存就是实例之前m_pData的内存，这就相当于自动调用析构函数释放实例的内存。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>AtOffer</category>
      </categories>
      <tags>
        <tag>AtOffer</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之AdaBoost算法（2）算法实现</title>
    <url>/folder/2019/11/08/2017-11-06-ml-19/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch07" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch07</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="基于单层决策树构建弱分类器"><a href="#基于单层决策树构建弱分类器" class="headerlink" title="基于单层决策树构建弱分类器"></a>基于单层决策树构建弱分类器</h2><p>&emsp;&emsp;单层决策树（decision stump，也称决策树桩）是一种简单的决策树。前面我们已经介绍了决策树的工作原理，接下来将构建一个单层决策树，而它仅基于单个特征来做决策。</p>
<p>&emsp;&emsp;首先，需要通过一个简单数据集来确保在算法实现上一切就绪。建立adaboost.py文件并加入如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2017-10-10 16:04:14</span></span><br><span class="line"><span class="comment"># @Author  : WordZzzz (wordzzzz@foxmail.com)</span></span><br><span class="line"><span class="comment"># @Link    : http://blog.csdn.net/u011475210</span></span><br><span class="line"><span class="comment"># @Version : $Id$</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadSimpData</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	创建数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	datMat：数据集</span></span><br><span class="line"><span class="string">				classLabels：类别标签</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#创建数据集</span></span><br><span class="line">	datMat = matrix([[<span class="number">1.</span> , <span class="number">2.1</span>],</span><br><span class="line">		[<span class="number">2.</span> , <span class="number">1.1</span>],</span><br><span class="line">		[<span class="number">1.3</span>, <span class="number">1.</span> ],</span><br><span class="line">		[<span class="number">1.</span> , <span class="number">1.</span> ],</span><br><span class="line">		[<span class="number">2.</span> , <span class="number">1.</span> ]])</span><br><span class="line">	<span class="comment">#创建类别标签</span></span><br><span class="line">	classLabels = [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>]</span><br><span class="line">	<span class="comment">#返回数据集和标签</span></span><br><span class="line">	<span class="keyword">return</span> datMat, classLabels</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查看建立的数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> adaboost</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datMat, classLabels = adaboost.loadSimpData()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datMat</span><br><span class="line">matrix([[ <span class="number">1.</span> ,  <span class="number">2.1</span>],</span><br><span class="line">        [ <span class="number">2.</span> ,  <span class="number">1.1</span>],</span><br><span class="line">        [ <span class="number">1.3</span>,  <span class="number">1.</span> ],</span><br><span class="line">        [ <span class="number">1.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">        [ <span class="number">2.</span> ,  <span class="number">1.</span> ]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classLabels</span><br><span class="line">[<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可视化结果：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171016211322696?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;接下来，构建单层决策树，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将最小错误率minEroor设为无穷大</span><br><span class="line">对数据集中的每一个特征（第一层循环）：</span><br><span class="line">    对每个步长（第二层循环）：</span><br><span class="line">        对每个不等号（第三层循环）：</span><br><span class="line">            建立一颗单层决策树并利用加权数据集对它进行测试</span><br><span class="line">            如果错误率低于minError，则将当前单层决策树设为最佳单层决策树</span><br><span class="line">返回最佳单层决策树</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;单层决策树生成函数代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stumpClassify</span><span class="params">(dataMatrix, dimen, threshVal, threshIneq)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	通过阈值比较对数据进行分类</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatrix：数据集</span></span><br><span class="line"><span class="string">				dimen：数据集列数</span></span><br><span class="line"><span class="string">				threshVal：阈值</span></span><br><span class="line"><span class="string">				threshIneq：比较方式：lt，gt</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	retArray：分类结果</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#新建一个数组用于存放分类结果，初始化都为1</span></span><br><span class="line">	retArray = ones((shape(dataMatrix)[<span class="number">0</span>],<span class="number">1</span>))</span><br><span class="line">	<span class="comment">#lt：小于，gt；大于；根据阈值进行分类，并将分类结果存储到retArray</span></span><br><span class="line">	<span class="keyword">if</span> threshIneq == <span class="string">'lt'</span>:</span><br><span class="line">		retArray[dataMatrix[:, dimen] &lt;= threshVal] = <span class="number">-1.0</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		retArray[dataMatrix[:, dimen] &gt; threshVal] = <span class="number">-1.0</span></span><br><span class="line">	<span class="comment">#返回分类结果</span></span><br><span class="line">	<span class="keyword">return</span> retArray</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildStump</span><span class="params">(dataArr, classLabels, D)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	找到最低错误率的单层决策树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataArr：数据集</span></span><br><span class="line"><span class="string">				classLabels：数据标签</span></span><br><span class="line"><span class="string">				D：权重向量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	bestStump：分类结果</span></span><br><span class="line"><span class="string">				minError：最小错误率</span></span><br><span class="line"><span class="string">				bestClasEst：最佳单层决策树</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化数据集和数据标签</span></span><br><span class="line">	dataMatrix = mat(dataArr); labelMat = mat(classLabels).T</span><br><span class="line">	<span class="comment">#获取行列值</span></span><br><span class="line">	m,n = shape(dataMatrix)</span><br><span class="line">	<span class="comment">#初始化步数，用于在特征的所有可能值上进行遍历</span></span><br><span class="line">	numSteps = <span class="number">10.0</span></span><br><span class="line">	<span class="comment">#初始化字典，用于存储给定权重向量D时所得到的最佳单层决策树的相关信息</span></span><br><span class="line">	bestStump = &#123;&#125;</span><br><span class="line">	<span class="comment">#初始化类别估计值</span></span><br><span class="line">	bestClasEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">	<span class="comment">#将最小错误率设无穷大，之后用于寻找可能的最小错误率</span></span><br><span class="line">	minError = inf</span><br><span class="line">	<span class="comment">#遍历数据集中每一个特征</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		<span class="comment">#获取数据集的最大最小值</span></span><br><span class="line">		rangeMin = dataMatrix[:,i].min(); rangeMax = dataMatrix[:,i].max()</span><br><span class="line">		<span class="comment">#根据步数求得步长</span></span><br><span class="line">		stepSize = (rangeMax - rangeMin) / numSteps</span><br><span class="line">		<span class="comment">#遍历每个步长</span></span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">-1</span>, int(numSteps) + <span class="number">1</span>):</span><br><span class="line">			<span class="comment">#遍历每个不等号</span></span><br><span class="line">			<span class="keyword">for</span> inequal <span class="keyword">in</span> [<span class="string">'lt'</span>, <span class="string">'gt'</span>]:</span><br><span class="line">				<span class="comment">#设定阈值</span></span><br><span class="line">				threshVal = (rangeMin + float(j) * stepSize)</span><br><span class="line">				<span class="comment">#通过阈值比较对数据进行分类</span></span><br><span class="line">				predictedVals = stumpClassify(dataMatrix, i, threshVal, inequal)</span><br><span class="line">				<span class="comment">#初始化错误计数向量</span></span><br><span class="line">				errArr = mat(ones((m,<span class="number">1</span>)))</span><br><span class="line">				<span class="comment">#如果预测结果和标签相同，则相应位置0</span></span><br><span class="line">				errArr[predictedVals == labelMat] = <span class="number">0</span></span><br><span class="line">				<span class="comment">#计算权值误差，这就是AdaBoost和分类器交互的地方</span></span><br><span class="line">				weightedError = D.T * errArr</span><br><span class="line">				<span class="comment">#打印输出所有的值</span></span><br><span class="line">				<span class="comment">#print("split: dim %d, thresh %.2f, thresh ineqal: %s, the weighted error is %.3f" % (i, threshVal, inequal, weightedError))</span></span><br><span class="line">				<span class="comment">#如果错误率低于minError，则将当前单层决策树设为最佳单层决策树，更新各项值</span></span><br><span class="line">				<span class="keyword">if</span> weightedError &lt; minError:</span><br><span class="line">					minError = weightedError</span><br><span class="line">					bestClasEst = predictedVals.copy()</span><br><span class="line">					bestStump[<span class="string">'dim'</span>] = i</span><br><span class="line">					bestStump[<span class="string">'thresh'</span>] = threshVal</span><br><span class="line">					bestStump[<span class="string">'ineq'</span>] = inequal</span><br><span class="line">	<span class="comment">#返回最佳单层决策树，最小错误率，类别估计值</span></span><br><span class="line">	<span class="keyword">return</span> bestStump, minError, bestClasEst</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D = mat(ones((<span class="number">5</span>,<span class="number">1</span>))/<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adaboost.buildStump(datMat, classLabels, D)</span><br><span class="line">(&#123;<span class="string">'dim'</span>: <span class="number">0</span>, <span class="string">'thresh'</span>: <span class="number">1.3</span>, <span class="string">'ineq'</span>: <span class="string">'lt'</span>&#125;, matrix([[ <span class="number">0.2</span>]]), array([[<span class="number">-1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">-1.</span>],</span><br><span class="line">       [<span class="number">-1.</span>],</span><br><span class="line">       [ <span class="number">1.</span>]]))</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述单层决策树的生成函数是决策树的一个简化版本。它就是所谓的弱学习器，即弱分类算法。其中，weightError是AdaBoost和分类器交互的地方，大家可以留意一下。</p>
<h2 id="完整AdaBoost算法的实现"><a href="#完整AdaBoost算法的实现" class="headerlink" title="完整AdaBoost算法的实现"></a>完整AdaBoost算法的实现</h2><p>&emsp;&emsp;完成AdaBoost算法的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对每次迭代：</span><br><span class="line">    利用buildStump()函数找到最佳的单层决策树</span><br><span class="line">    将最佳单层决策树加入到单层决策树数组</span><br><span class="line">    计算alpha</span><br><span class="line">    计算新的权重向量D</span><br><span class="line">    更新累计类别估计值</span><br><span class="line">    如果错误率等于0.0，则退出循环</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaBoostTrainDS</span><span class="params">(dataArr, classLabels, numIt = <span class="number">40</span>)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	找到最低错误率的单层决策树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataArr：数据集</span></span><br><span class="line"><span class="string">				classLabels：数据标签</span></span><br><span class="line"><span class="string">				numIt：迭代次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	weakClassArr：单层决策树列表</span></span><br><span class="line"><span class="string">				aggClassEst：类别估计值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化列表，用来存放单层决策树的信息</span></span><br><span class="line">	weakClassArr = []</span><br><span class="line">	<span class="comment">#获取数据集行数</span></span><br><span class="line">	m = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#初始化向量D每个值均为1/m，D包含每个数据点的权重</span></span><br><span class="line">	D = mat(ones((m,<span class="number">1</span>))/m)</span><br><span class="line">	<span class="comment">#初始化列向量，记录每个数据点的类别估计累计值</span></span><br><span class="line">	aggClassEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">	<span class="comment">#开始迭代</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(numIt):</span><br><span class="line">		<span class="comment">#利用buildStump()函数找到最佳的单层决策树</span></span><br><span class="line">		bestStump, error, classEst = buildStump(dataArr, classLabels, D)</span><br><span class="line">		<span class="comment">#print("D: ", D.T)</span></span><br><span class="line">		<span class="comment">#根据公式计算alpha的值，max(error, 1e-16)用来确保在没有错误时不会发生除零溢出</span></span><br><span class="line">		alpha = float(<span class="number">0.5</span> * log((<span class="number">1.0</span> - error) / max(error, <span class="number">1e-16</span>)))</span><br><span class="line">		<span class="comment">#保存alpha的值</span></span><br><span class="line">		bestStump[<span class="string">'alpha'</span>] = alpha</span><br><span class="line">		<span class="comment">#填入数据到列表</span></span><br><span class="line">		weakClassArr.append(bestStump)</span><br><span class="line">		<span class="comment">#print("classEst: ", classEst.T)</span></span><br><span class="line">		<span class="comment">#为下一次迭代计算D</span></span><br><span class="line">		expon = multiply(<span class="number">-1</span> * alpha * mat(classLabels).T, classEst)</span><br><span class="line">		D = multiply(D, exp(expon))</span><br><span class="line">		D = D / D.sum()</span><br><span class="line">		<span class="comment">#累加类别估计值</span></span><br><span class="line">		aggClassEst += alpha * classEst</span><br><span class="line">		<span class="comment">#print("aggClassEst: ", aggClassEst.T)</span></span><br><span class="line">		<span class="comment">#计算错误率，aggClassEst本身是浮点数，需要通过sign来得到二分类结果</span></span><br><span class="line">		aggErrors = multiply(sign(aggClassEst) != mat(classLabels).T, ones((m,<span class="number">1</span>)))</span><br><span class="line">		errorRate = aggErrors.sum() / m</span><br><span class="line">		print(<span class="string">"total error: "</span>, errorRate)</span><br><span class="line">		<span class="comment">#如果总错误率为0则跳出循环</span></span><br><span class="line">		<span class="keyword">if</span> errorRate == <span class="number">0.0</span>: <span class="keyword">break</span></span><br><span class="line">	<span class="comment">#返回单层决策树列表和累计错误率</span></span><br><span class="line">	<span class="keyword">return</span> weakClassArr</span><br><span class="line">	<span class="comment">#return weakClassArr, aggClassEst</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(adaboost)</span><br><span class="line">&lt;module <span class="string">'adaboost'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch07\\adaboost.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classifierArr = adaboost.adaBoostTrainDS(datMat, classLabels, <span class="number">9</span>)</span><br><span class="line">D:  [[ <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>]]</span><br><span class="line">classEst:  [[<span class="number">-1.</span>  <span class="number">1.</span> <span class="number">-1.</span> <span class="number">-1.</span>  <span class="number">1.</span>]]</span><br><span class="line">aggClassEst:  [[<span class="number">-0.69314718</span>  <span class="number">0.69314718</span> <span class="number">-0.69314718</span> <span class="number">-0.69314718</span>  <span class="number">0.69314718</span>]]</span><br><span class="line">total error:  <span class="number">0.2</span></span><br><span class="line">D:  [[ <span class="number">0.5</span>    <span class="number">0.125</span>  <span class="number">0.125</span>  <span class="number">0.125</span>  <span class="number">0.125</span>]]</span><br><span class="line">classEst:  [[ <span class="number">1.</span>  <span class="number">1.</span> <span class="number">-1.</span> <span class="number">-1.</span> <span class="number">-1.</span>]]</span><br><span class="line">aggClassEst:  [[ <span class="number">0.27980789</span>  <span class="number">1.66610226</span> <span class="number">-1.66610226</span> <span class="number">-1.66610226</span> <span class="number">-0.27980789</span>]]</span><br><span class="line">total error:  <span class="number">0.2</span></span><br><span class="line">D:  [[ <span class="number">0.28571429</span>  <span class="number">0.07142857</span>  <span class="number">0.07142857</span>  <span class="number">0.07142857</span>  <span class="number">0.5</span>       ]]</span><br><span class="line">classEst:  [[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line">aggClassEst:  [[ <span class="number">1.17568763</span>  <span class="number">2.56198199</span> <span class="number">-0.77022252</span> <span class="number">-0.77022252</span>  <span class="number">0.61607184</span>]]</span><br><span class="line">total error:  <span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classifierArr</span><br><span class="line">[&#123;<span class="string">'dim'</span>: <span class="number">0</span>, <span class="string">'thresh'</span>: <span class="number">1.3</span>, <span class="string">'ineq'</span>: <span class="string">'lt'</span>, <span class="string">'alpha'</span>: <span class="number">0.6931471805599453</span>&#125;, &#123;<span class="string">'dim'</span>: <span class="number">1</span>, <span class="string">'thresh'</span>: <span class="number">1.0</span>, <span class="string">'ineq'</span>: <span class="string">'lt'</span>, <span class="string">'alpha'</span>: <span class="number">0.9729550745276565</span>&#125;, &#123;<span class="string">'dim'</span>: <span class="number">0</span>, <span class="string">'thresh'</span>: <span class="number">0.90000000000000002</span>, <span class="string">'ineq'</span>: <span class="string">'lt'</span>, <span class="string">'alpha'</span>: <span class="number">0.8958797346140273</span>&#125;]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们观察中间的运行结果，可以发现，第一轮迭代中，D中的所有值都相等，于是，只有第一个数据点被错分了。第二轮迭代中，D向量给第一个数据点0.5的权重。这就可以通过变量aggClassEst的符号来了解总的类别。第二次迭代之后，我们就会发现第一个数据点已经正确分类了，但最后一个数据点错分了。D向量中的最后一个元素变成0.5，而D向量中的其他值都变得非常小。最后，第三次迭代后aggClassEst所有值的符号和真实类别标签都完全吻合，那么训练错误率为0，程序就此退出。</p>
<h2 id="基于AdaBoost的分类"><a href="#基于AdaBoost的分类" class="headerlink" title="基于AdaBoost的分类"></a>基于AdaBoost的分类</h2><p>&emsp;&emsp;一旦拥有了多个弱分类器以及其对应的alpha值，进行测试就变得相当容易了。现在，我们就将之前的代码应用到具体的实例上去。每个分类器的结果以其对应的alpha值作为权重。所有这些弱分类器的结果加权求和就得到了最后的结果。</p>
<p>&emsp;&emsp;代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">adaClassify</span><span class="params">(datToClass, classifierArr)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	AdaBoost分类函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		datToClass：待分类样例</span></span><br><span class="line"><span class="string">				classifierArr：多个弱分类器组成的数组</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	sign(aggClassEst)：分类结果</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化数据集</span></span><br><span class="line">	dataMatrix = mat(datToClass)</span><br><span class="line">	<span class="comment">#获得待分类样例个数</span></span><br><span class="line">	m = shape(dataMatrix)[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#构建一个初始化为0的列向量，记录每个数据点的类别估计累计值</span></span><br><span class="line">	aggClassEst = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">	<span class="comment">#遍历每个弱分类器</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(classifierArr)):</span><br><span class="line">		<span class="comment">#基于stumpClassify得到类别估计值</span></span><br><span class="line">		classEst = stumpClassify(dataMatrix, classifierArr[i][<span class="string">'dim'</span>], classifierArr[i][<span class="string">'thresh'</span>], classifierArr[i][<span class="string">'ineq'</span>])</span><br><span class="line">		<span class="comment">#累加类别估计值</span></span><br><span class="line">		aggClassEst += classifierArr[i][<span class="string">'alpha'</span>]*classEst</span><br><span class="line">		<span class="comment">#打印aggClassEst，以便我们了解其变化情况</span></span><br><span class="line">		<span class="comment">#print(aggClassEst)</span></span><br><span class="line">	<span class="comment">#返回分类结果，aggClassEst大于0则返回+1，否则返回-1</span></span><br><span class="line">	<span class="keyword">return</span> sign(aggClassEst)</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;测试结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(adaboost)</span><br><span class="line">&lt;module <span class="string">'adaboost'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch07\\adaboost.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datMat, classLabels = adaboost.loadSimpData()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classifierArr = adaboost.adaBoostTrainDS(datMat, classLabels, <span class="number">30</span>)</span><br><span class="line">D:  [[ <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>  <span class="number">0.2</span>]]</span><br><span class="line">classEst:  [[<span class="number">-1.</span>  <span class="number">1.</span> <span class="number">-1.</span> <span class="number">-1.</span>  <span class="number">1.</span>]]</span><br><span class="line">aggClassEst:  [[<span class="number">-0.69314718</span>  <span class="number">0.69314718</span> <span class="number">-0.69314718</span> <span class="number">-0.69314718</span>  <span class="number">0.69314718</span>]]</span><br><span class="line">total error:  <span class="number">0.2</span></span><br><span class="line">D:  [[ <span class="number">0.5</span>    <span class="number">0.125</span>  <span class="number">0.125</span>  <span class="number">0.125</span>  <span class="number">0.125</span>]]</span><br><span class="line">classEst:  [[ <span class="number">1.</span>  <span class="number">1.</span> <span class="number">-1.</span> <span class="number">-1.</span> <span class="number">-1.</span>]]</span><br><span class="line">aggClassEst:  [[ <span class="number">0.27980789</span>  <span class="number">1.66610226</span> <span class="number">-1.66610226</span> <span class="number">-1.66610226</span> <span class="number">-0.27980789</span>]]</span><br><span class="line">total error:  <span class="number">0.2</span></span><br><span class="line">D:  [[ <span class="number">0.28571429</span>  <span class="number">0.07142857</span>  <span class="number">0.07142857</span>  <span class="number">0.07142857</span>  <span class="number">0.5</span>       ]]</span><br><span class="line">classEst:  [[ <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>  <span class="number">1.</span>]]</span><br><span class="line">aggClassEst:  [[ <span class="number">1.17568763</span>  <span class="number">2.56198199</span> <span class="number">-0.77022252</span> <span class="number">-0.77022252</span>  <span class="number">0.61607184</span>]]</span><br><span class="line">total error:  <span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classifierArr</span><br><span class="line">[&#123;<span class="string">'dim'</span>: <span class="number">0</span>, <span class="string">'thresh'</span>: <span class="number">1.3</span>, <span class="string">'ineq'</span>: <span class="string">'lt'</span>, <span class="string">'alpha'</span>: <span class="number">0.6931471805599453</span>&#125;, &#123;<span class="string">'dim'</span>: <span class="number">1</span>, <span class="string">'thresh'</span>: <span class="number">1.0</span>, <span class="string">'ineq'</span>: <span class="string">'lt'</span>, <span class="string">'alpha'</span>: <span class="number">0.9729550745276565</span>&#125;, &#123;<span class="string">'dim'</span>: <span class="number">0</span>, <span class="string">'thresh'</span>: <span class="number">0.90000000000000002</span>, <span class="string">'ineq'</span>: <span class="string">'lt'</span>, <span class="string">'alpha'</span>: <span class="number">0.8958797346140273</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adaboost.adaClassify([<span class="number">0</span>,<span class="number">0</span>], classifierArr)</span><br><span class="line">[[<span class="number">-0.69314718</span>]]</span><br><span class="line">[[<span class="number">-1.66610226</span>]]</span><br><span class="line">[[<span class="number">-2.56198199</span>]]</span><br><span class="line">matrix([[<span class="number">-1.</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>adaboost.adaClassify([[<span class="number">5</span>,<span class="number">5</span>],[<span class="number">0</span>,<span class="number">0</span>]], classifierArr)</span><br><span class="line">[[ <span class="number">0.69314718</span>]</span><br><span class="line"> [<span class="number">-0.69314718</span>]]</span><br><span class="line">[[ <span class="number">1.66610226</span>]</span><br><span class="line"> [<span class="number">-1.66610226</span>]]</span><br><span class="line">[[ <span class="number">2.56198199</span>]</span><br><span class="line"> [<span class="number">-2.56198199</span>]]</span><br><span class="line">matrix([[ <span class="number">1.</span>],</span><br><span class="line">        [<span class="number">-1.</span>]])</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们可以看到，随着迭代的进行，分类结果越来越强。下面我们换个数据集。</p>
<h2 id="在一个难数据集上应用AdaBoost"><a href="#在一个难数据集上应用AdaBoost" class="headerlink" title="在一个难数据集上应用AdaBoost"></a>在一个难数据集上应用AdaBoost</h2><p>&emsp;&emsp;这次我们在之前给出的马疝病数据集上应用AdaBoost分类器，之前用的是Logistic回归。</p>
<p>&emsp;&emsp;示例：在一个难数据集上的AdaBoost应用</p>
<ul>
<li>收集数据：提供的文本文件。</li>
<li>准备数据：确保类别标签是+1和-1而非1和0。</li>
<li>分析数据：手工检查数据。</li>
<li>训练算法：在数据上，利用adaBoostTrainDS()函数训练出一系列的分类器。</li>
<li>测试算法：我们拥有两个数据集。在不采用随机抽样的方法下，我们就会对AdaBoost和Logistic回归的结果进行完全对等的比较。</li>
<li>使用算法：观察该例子上的错误率。不过，这可以构建一个web网站，让驯马师输入马的症状然后预测马是否会死去。</li>
</ul>
<p>&emsp;&emsp;加入我们最熟悉的代码，唯一的区别就是这次是自动识别特征数目的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	自适应数据加载函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		fileName：文件名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	dataMat：数据集</span></span><br><span class="line"><span class="string">				labelMat：类别标签</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#自动获取特征个数，这是和之前不一样的地方</span></span><br><span class="line">	numFeat = len(open(fileName).readline().split(<span class="string">'\t'</span>))</span><br><span class="line">	<span class="comment">#初始化数据集和标签列表</span></span><br><span class="line">	dataMat = []; labelMat = []</span><br><span class="line">	<span class="comment">#打开文件</span></span><br><span class="line">	fr = open(fileName)</span><br><span class="line">	<span class="comment">#遍历每一行</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">		<span class="comment">#初始化列表，用来存储每一行的数据</span></span><br><span class="line">		lineArr = []</span><br><span class="line">		<span class="comment">#切分文本</span></span><br><span class="line">		curLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">		<span class="comment">#遍历每一个特征，某人最后一列为标签</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(numFeat<span class="number">-1</span>):</span><br><span class="line">			<span class="comment">#将切分的文本全部加入行列表中</span></span><br><span class="line">			lineArr.append(float(curLine[i]))</span><br><span class="line">		<span class="comment">#将每个行列表加入到数据集中</span></span><br><span class="line">		dataMat.append(lineArr)</span><br><span class="line">		<span class="comment">#将每个标签加入标签列表中</span></span><br><span class="line">		labelMat.append(float(curLine[<span class="number">-1</span>]))</span><br><span class="line">	<span class="comment">#返回数据集和标签列表</span></span><br><span class="line">	<span class="keyword">return</span> dataMat, labelMat</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;分类结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(adaboost)</span><br><span class="line">&lt;module <span class="string">'adaboost'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch07\\adaboost.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datArr, labelArr = adaboost.loadDataSet(<span class="string">'horseColicTraining2.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>classifierArr = adaboost.adaBoostTrainDS(datArr, labelArr, <span class="number">10</span>)</span><br><span class="line">total error:  <span class="number">0.284280936455</span></span><br><span class="line">total error:  <span class="number">0.284280936455</span></span><br><span class="line">total error:  <span class="number">0.247491638796</span></span><br><span class="line">total error:  <span class="number">0.247491638796</span></span><br><span class="line">total error:  <span class="number">0.254180602007</span></span><br><span class="line">total error:  <span class="number">0.240802675585</span></span><br><span class="line">total error:  <span class="number">0.240802675585</span></span><br><span class="line">total error:  <span class="number">0.220735785953</span></span><br><span class="line">total error:  <span class="number">0.247491638796</span></span><br><span class="line">total error:  <span class="number">0.230769230769</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testArr, testLabelArr = adaboost.loadDataSet(<span class="string">'horseColicTest2.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>prediction10 = adaboost.adaClassify(testArr, classifierArr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>errArr = mat(ones((<span class="number">67</span>,<span class="number">1</span>)))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'mat'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>errArr = mat(ones((<span class="number">67</span>,<span class="number">1</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>errArr[prediction10 != mat(testLabelArr).T].sum()</span><br><span class="line"><span class="number">16.0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;书上给了个表，我们直接来看表格数据：</p>
<table>
<thead>
<tr>
<th>Number of Classifiers</th>
<th>Training Error</th>
<th>Test Error</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0.28</td>
<td>0.27</td>
</tr>
<tr>
<td>10</td>
<td>0.23</td>
<td>0.24</td>
</tr>
<tr>
<td>50</td>
<td>0.19</td>
<td>0.21</td>
</tr>
<tr>
<td>100</td>
<td>0.19</td>
<td>0.22</td>
</tr>
<tr>
<td>500</td>
<td>0.16</td>
<td>0.25</td>
</tr>
<tr>
<td>1000</td>
<td>0.14</td>
<td>0.31</td>
</tr>
<tr>
<td>10000</td>
<td>0.11</td>
<td>0.33</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;我们发现，测试错误率在到达一个最小值之后又开始上升了。这类现象就是过拟合（overfitting）。有文献称，对于表现好的数据集，AdaBoost的测试错误率就会达到一个稳定值，并不会随着分类器的增多而上升。但是别忘了，我们这个数据集可是有百分之三十的缺失值哦。</p>
<p>&emsp;&emsp;很多人认为，AdaBoost和SVM是监督机器学习中最强大的两种方法。实际上，这两者之间拥有不少相似之处。我们可以把弱分类器想象成SVM中的一个核函数，也可以按照最大化某个最小间隔的方式重写AdaBoost算法。而他们的不同之处在于所定义的间隔计算方式有所不同。因此导致的结果也不同。特别是在高位空间下，这两者之间的差异就会更加明显。</p>
<p>&emsp;&emsp;至此，分类算法部分全部介绍完了，之后的回归、无监督学习等等，有机会了再更吧。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>AdaBoost</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之AdaBoost算法（1）算法概述</title>
    <url>/folder/2019/11/08/2017-11-06-ml-18/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch07" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch07</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;终于，分类问题要收尾了。</p>
<p>&emsp;&emsp;当做重要决定时，大家肯定是到处取经，集四海八荒之智后，再做出自己的决定。机器学习也是如此，元算法（meta-algorithm）应运而生。元算法是对其他算法进行组合的一种方式。接下来我们将集中关注一个称作AdaBoost的最流行的元算法，该算法可以说是最好的监督学习的方法（巨人说的），所以它也是机器学习工具箱中最强有力的工具之一。</p>
<p>&emsp;&emsp;本系列博客，首先讨论不同分类器的集成方法，然后主要关注boosting方法及其代表分类器AdaBoost；接下来，我们会建立一个单层决策树（decision stump）分类器（实际上，它是一个单节点的决策树）；最后，AdaBoost算法将应用在上述单层决策树分类器之上，并在之前的病马数据集上应用AdaBoost分类器，以此来了解该算法是入个迅速超越其他分类器的。</p>
<p>&emsp;&emsp;本节，我们先来介绍一些概念性的东西。</p>
<h2 id="基于数据集多重抽样的分类器"><a href="#基于数据集多重抽样的分类器" class="headerlink" title="基于数据集多重抽样的分类器"></a>基于数据集多重抽样的分类器</h2><p>&emsp;&emsp;我们自然可以将前面学习的五种不同的分类方法组合起来，而这种组合结果则被称为集成方法（ensemble method）或者元算法（meta-algorithm）。只用集成方法时会有多种形式：可以是多种不同的算法的集成，可以是同一算法在不同设置下的集成，也可以是数据集不同部分分配给不同分类器的集成。接下来，我们将介绍基于同一种分类器多个不同实例的两种计算方法：bagging和boosting。</p>
<h3 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h3><p>&emsp;&emsp;自举汇聚法（bootstrap aggregating），也称为bagging方法，实在从原始数据集选择S次之后得到S个新数据集的一种技术。新旧数据集大小相等，每个数据集都是通过在原始数据集中随机选择一个样本来进行替换而得到的（放回的随机抽样），也就是可以多次选择同一个样本。这一性质就允许新数据集中可以有重复的值，而原始数据集的某些值在新集合中则不再出现。</p>
<p>&emsp;&emsp;S个数据集建好之后，将某个学习算法分别作用于每个数据集就得到了S个分类器。当我们要对新数据进行分类时，就可以应用这S个分类器进行分类了（当然，还是多数表决的原则）。</p>
<p>&emsp;&emsp;当然，还有一些更先进的bagging方法，比如随机森林（random forest），在此就不多做介绍了，我们主要的精力，还是放在与bagging类似的集成分类器方法boosting。</p>
<h3 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h3><p>&emsp;&emsp;boosting是一种与bagging很类似的技术。不论是在boosting还是bagging当中，所使用的多个分类器的类型都是一致的。但是boosting算法中，不同的分类器是通过串行训练而得到的，每个新分类器都根据已训练出的分类器的性能来进行训练。boosting通过集中关注已有分类器错分的那些数据来获得新的分类器。</p>
<p>&emsp;&emsp;由于boosting分类的结果是基于所有分类器的加权求和的结果，因此boosting与bagging不太一样。bagging中分类器的权重是相等的，而boosting中分类器的权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。</p>
<p>&emsp;&emsp;基本要点就这些了，下面介绍boosting中一个最流行的版本AdaBoost。</p>
<p>AdaBoost的一般流程：</p>
<ul>
<li>收集数据：可以使用任意方法。</li>
<li>准备数据：依赖于所使用的弱分类器类型，本章使用的是单层决策树，这种分类器可以处理任何数据类型。当然也可以使用任意分类器作为弱分类器，前面介绍的五种分类器都可以充当弱分类器。作为弱分类器，简单分类器的效果更好。</li>
<li>分析数据：可以使用任意方法。</li>
<li>训练算法：AdaBoost的大部分时间都用在训练上，分类器将多次在同一数据集上训练弱分类器。</li>
<li>测试算法：计算分类的错误率；</li>
<li>使用算法：同SVM一样，AdaBoost预测两个类别中的一个。如果想把它应用到多个类别的场合，那么就要像多类SVM中的做法一样对AdaBoost进行修改。</li>
</ul>
<h2 id="基于错误提升分类器的性能"><a href="#基于错误提升分类器的性能" class="headerlink" title="基于错误提升分类器的性能"></a>基于错误提升分类器的性能</h2><p>&emsp;&emsp;能否使用弱分类器和多个实例来构建一个强分类器，这是一个非常有趣的理论问题。这里的“弱”意味着分类器的性能比随机猜测要略好，但是也不会好太多。也就是说，在二分类情况下弱分类器的错误率会高于50%，而“强“分类器的错误率将会低很多。AdaBoost算法就是基于上述理论的。</p>
<p>&emsp;&emsp;AdaBoost是adaptive boosting（自适应boosting）的缩写，其运行过程如下：训练数据中的每个样本，并赋予其一个权重，这些权重构成了向量D。一开始，这些权重都初始化成相等值。首先在训练数据上训练出一个弱分类器并计算该分类器的错误率，然后再同一数据集上再次训练弱分类器。在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分对的样本的权重将会降低，而第一次分错的样本的权重将会提高。为了从所有弱分类器中得到最终的分类结果，AdaBoost为每个分类器都分配了一个权重值alpha，这些alpha值是基于每个弱分类器的错误率进行计算的。其中，错误率ε的定义为：</p>
<p>$$<br>\epsilon = \frac{未正确分类的样本数目}{所有样本数目}<br>$$</p>
<p>&emsp;&emsp;而alpha的计算公式如下：</p>
<p>$$<br>\alpha = \frac{1}{2} ln (\frac{1-\epsilon}{\epsilon})<br>$$</p>
<p>&emsp;&emsp;AdaBoost算法的流程如图所示。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171016192150873?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;左边是数据集，中间直方图的不同宽度表示每个样例上的不同权重。在经过一个分类器之后，加权的预测结果会通过三角形中的alpha值进行加权。每个三角形中输出的甲醛结果在圆形中求和，从而得到最终的输出结果。</p>
<p>&emsp;&emsp;计算出alpha的值之后，可以对权重向量D进行更新，以使得那些正确分类的样本的权重降低而错分样本的权重升高。D的计算方法如下。<br>&emsp;&emsp;如果某个样本被正确分类，那么该样本的权重更改为：</p>
<p>$$<br>D_i^{(t+1)} = \frac{D_i^{(t)}e^{-\alpha}}{Sum(D)})<br>$$</p>
<p>&emsp;&emsp;如果某个样本被错误分类，那么该样本的权重更改为：</p>
<p>$$<br>D_i^{(t+1)} = \frac{D_i^{(t)}e^{\alpha}}{Sum(D)})<br>$$</p>
<p>&emsp;&emsp;计算出来D之后，AdaBoost又开始进入下一轮迭代。AdaBoost算法会不断地重复训练和调整权重的过程，直到训练错误率为0或者弱分类器的数目达到用户的指定值为止。</p>
<p>&emsp;&emsp;下一篇博文我们来实现AdaBoost。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>AdaBoost</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之支持向量机（4）核函数及其实现</title>
    <url>/folder/2019/11/08/2017-11-05-ml-17/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch06" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch06</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;前面三篇讲的都是SVM线性分类器，如果数据集非线性可分（如下图所示），那就需要做些修改了。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171009221829629?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;显而易见，在该数据中存在某种可以识别的模式。接下来，我们就需要使用一种称为核函数（kernel）的工具将数据转换成易于分类器理解的形式。在本篇博文中，我们先对核函数进行简单的了解，然后重点研究径向基函数（radial basis function，最流行的核函数）及其实现，最后在我们之前的手写数字识别问题上进行实践。</p>
<h2 id="核函数简介"><a href="#核函数简介" class="headerlink" title="核函数简介"></a>核函数简介</h2><p>&emsp;&emsp;再看本文章开头的图片，我们似乎可以用一个圆来吧数据划分开来，但是对于线性分类器来说，这好像很难实现。我们或许可以对数据进行某种形式的转换，从而得到某些新的变量来表示数据。在这个例子中，我们将数据从一个特征空间转换到另一个特征空间，在新空间下，我们可以很容易利用已有的工具对数据进行处理。这个过程，学过数学的都知道，即从一个特征空间到另一个特征空间的映射。通常情况下，核函数实现的是低维到高维的映射，以后其他算法涉及到的PCA等，则是高维到低微的映射。经过空间转换之后，我们可以在高维空间解决线性问题，这也就等价于在低维空间中解决非线性问题。</p>
<p>&emsp;&emsp;SVM优化中一个特别好的地方就是，所有的运算都可以写成内积（inner product，也叫点积）的形式。向量的内积指的是两个向量相乘，之后得到单个标量或者数值。我们可以把内积运算替换成核函数，而不必做简化处理。将内积替换成核函数的方式被称为核技巧（kernel trick）或者核“变电”（kernel substation）。</p>
<p>&emsp;&emsp;当然，核函数并不仅仅应用于SVM中，很多其他的机器学习算法也都用到核函数。接下来，我们就来介绍一个流行的核函数，那就是径向基函数。</p>
<h2 id="径向基函数"><a href="#径向基函数" class="headerlink" title="径向基函数"></a>径向基函数</h2><p>&emsp;&emsp;径向基函数是一个采用向量作为自变量的函数，能够基于向量距离运算输出一个标量。这个距离可以使从&lt;0,0&gt;向量或者其他向量开始计算的距离。我们用到的径向基函数的高斯版本公式为：</p>
<p>$$<br>k(x,y) = exp(\frac{ {-\begin{Vmatrix} x-y \end{Vmatrix} }^2}{2 \sigma^2})<br>$$</p>
<p>&emsp;&emsp;其中，σ是用户定义的用于确定到达率（reach）或者说是函数值跌落到0的速度参数。</p>
<p>&emsp;&emsp;上述高斯核函数将数据从其特征空间映射到跟高维的空间，具体来说这里是映射到一个无穷维的空间。在该数据集上，使用高斯核函数得到一个很好的结果，当然，该函数也可以用于许多其他的数据集，并且也能够得到低错误率的结果。</p>
<h2 id="核函数实现"><a href="#核函数实现" class="headerlink" title="核函数实现"></a>核函数实现</h2><p>&emsp;&emsp;如果在svmMLiA.py文件中添加一个函数并稍作修改，那么我们就能在已有代码中使用核函数了（所有与核函数实现相关的函数，函数名末尾都是K）。其中主要区分代码在innerLK()和calcEk()中，我已经重点标记出。</p>
<p>&emsp;&emsp;新添加的核转换函数，主要用于填充结构体和后续的计算：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTrans</span><span class="params">(X, A, kTup)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	核转换函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		X：数据集</span></span><br><span class="line"><span class="string">				A：某一行数据</span></span><br><span class="line"><span class="string">				kTup：核函数信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	K：计算出的核向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#获取数据集行列数</span></span><br><span class="line">	m, n = shape(X)</span><br><span class="line">	<span class="comment">#初始化列向量</span></span><br><span class="line">	K = mat(zeros((m, <span class="number">1</span>)))</span><br><span class="line">	<span class="comment">#根据键值选择相应核函数</span></span><br><span class="line">	<span class="comment">#lin表示的是线性核函数</span></span><br><span class="line">	<span class="keyword">if</span> kTup[<span class="number">0</span>] == <span class="string">'lin'</span>: K = X * A.T</span><br><span class="line">	<span class="comment">#rbf表示径向基核函数</span></span><br><span class="line">	<span class="keyword">elif</span> kTup[<span class="number">0</span>] == <span class="string">'rbf'</span>:</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">			deltaRow = X[j,:] - A</span><br><span class="line">			K[j] = deltaRow * deltaRow.T</span><br><span class="line">		<span class="comment">#对矩阵元素展开计算，而不像在MATLAB中一样计算矩阵的逆</span></span><br><span class="line">		K =  exp(K/(<span class="number">-1</span>*kTup[<span class="number">1</span>]**<span class="number">2</span>))</span><br><span class="line">	<span class="comment">#如果无法识别，就报错</span></span><br><span class="line">	<span class="keyword">else</span>: <span class="keyword">raise</span> NameError(<span class="string">'Houston We Have a Problem -- That Kernel is not recognized'</span>)</span><br><span class="line">	<span class="comment">#返回计算出的核向量</span></span><br><span class="line">	<span class="keyword">return</span> K</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其他函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStructK</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	存放运算中重要的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据集</span></span><br><span class="line"><span class="string">				classLabels：类别标签</span></span><br><span class="line"><span class="string">				C：常数C</span></span><br><span class="line"><span class="string">				toler：容错率</span></span><br><span class="line"><span class="string">				kTup：速度参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	X：数据集</span></span><br><span class="line"><span class="string">				labelMat：类别标签</span></span><br><span class="line"><span class="string">				C：常数C</span></span><br><span class="line"><span class="string">				tol：容错率</span></span><br><span class="line"><span class="string">				m：数据集行数</span></span><br><span class="line"><span class="string">				b：常数项</span></span><br><span class="line"><span class="string">				alphas：alphas矩阵</span></span><br><span class="line"><span class="string">				eCache：误差缓存</span></span><br><span class="line"><span class="string">				K：核函数矩阵</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataMatIn, classLabels, C, toler, kTup)</span>:</span></span><br><span class="line">		self.X = dataMatIn</span><br><span class="line">		self.labelMat = classLabels</span><br><span class="line">		self.C = C</span><br><span class="line">		self.tol = toler</span><br><span class="line">		self.m = shape(dataMatIn)[<span class="number">0</span>]</span><br><span class="line">		self.alphas = mat(zeros((self.m, <span class="number">1</span>)))</span><br><span class="line">		self.b = <span class="number">0</span></span><br><span class="line">		self.eCache = mat(zeros((self.m, <span class="number">2</span>)))</span><br><span class="line">		</span><br><span class="line">		<span class="string">""" 主要区分 """</span></span><br><span class="line">		self.K = mat(zeros((self.m, self.m)))</span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(self.m):</span><br><span class="line">			self.K[:,i] = kernelTrans(self.X, self.X[i,:], kTup)</span><br><span class="line">		<span class="string">""" 主要区分 """</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEkK</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	计算误差值E</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		oS：数据结构</span></span><br><span class="line"><span class="string">				k：下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	Ek：计算的E值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	</span><br><span class="line">	<span class="string">""" 主要区分 """</span></span><br><span class="line">	<span class="comment">#计算fXk，整个对应输出公式f(x)=w`x + b</span></span><br><span class="line">	<span class="comment">#fXk = float(multiply(oS.alphas, oS.labelMat).T * (oS.X * oS.X[k,:].T)) + oS.b</span></span><br><span class="line">	fXk = float(multiply(oS.alphas, oS.labelMat).T*oS.K[:, k] + oS.b)</span><br><span class="line">	<span class="string">""" 主要区分 """</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">#计算E值</span></span><br><span class="line">	Ek = fXk - float(oS.labelMat[k])</span><br><span class="line">	<span class="comment">#返回计算的误差值E</span></span><br><span class="line">	<span class="keyword">return</span> Ek</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJK</span><span class="params">(i, oS, Ei)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	选择第二个alpha的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		i：第一个alpha的下标</span></span><br><span class="line"><span class="string">				oS：数据结构</span></span><br><span class="line"><span class="string">				Ei：计算出的第一个alpha的误差值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	j：第二个alpha的下标</span></span><br><span class="line"><span class="string">				Ej：计算出的第二个alpha的误差值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化参数值</span></span><br><span class="line">	maxK = <span class="number">-1</span>; maxDeltaE = <span class="number">0</span>; Ej = <span class="number">0</span></span><br><span class="line">	<span class="comment">#构建误差缓存</span></span><br><span class="line">	oS.eCache[i] = [<span class="number">1</span>, Ei]</span><br><span class="line">	<span class="comment">#构建一个非零列表，返回值是第一个非零E所对应的alpha值，而不是E本身</span></span><br><span class="line">	validEcacheList = nonzero(oS.eCache[:, <span class="number">0</span>].A)[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#如果列表长度大于1，说明不是第一次循环</span></span><br><span class="line">	<span class="keyword">if</span> (len(validEcacheList)) &gt; <span class="number">1</span>:</span><br><span class="line">		<span class="comment">#遍历列表中所有元素</span></span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> validEcacheList:</span><br><span class="line">			<span class="comment">#如果是第一个alpha的下标，就跳出本次循环</span></span><br><span class="line">			<span class="keyword">if</span> k == i: <span class="keyword">continue</span></span><br><span class="line">			<span class="comment">#计算k下标对应的误差值</span></span><br><span class="line">			Ek = calcEkK(oS, k)</span><br><span class="line">			<span class="comment">#取两个alpha误差值的差值的绝对值</span></span><br><span class="line">			deltaE = abs(Ei - Ek)</span><br><span class="line">			<span class="comment">#最大值更新</span></span><br><span class="line">			<span class="keyword">if</span> (deltaE &gt; maxDeltaE):</span><br><span class="line">				maxK = k; maxDeltaE = deltaE; Ej = Ek</span><br><span class="line">		<span class="comment">#返回最大差值的下标maxK和误差值Ej</span></span><br><span class="line">		<span class="keyword">return</span> maxK, Ej</span><br><span class="line">	<span class="comment">#如果是第一次循环，则随机选择alpha，然后计算误差</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		j = selectJrand(i, oS.m)</span><br><span class="line">		Ej = calcEkK(oS, j)</span><br><span class="line">	<span class="comment">#返回下标j和其对应的误差Ej</span></span><br><span class="line">	<span class="keyword">return</span> j, Ej</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateEkK</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	更新误差缓存</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		oS：数据结构</span></span><br><span class="line"><span class="string">				j：alpha的下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	无</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#计算下表为k的参数的误差</span></span><br><span class="line">	Ek = calcEkK(oS, k)</span><br><span class="line">	<span class="comment">#将误差放入缓存</span></span><br><span class="line">	oS.eCache[k] = [<span class="number">1</span>, Ek]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerLK</span><span class="params">(i, oS)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	完整SMO算法中的优化例程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		oS：数据结构</span></span><br><span class="line"><span class="string">				i：alpha的下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	无</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#计算误差</span></span><br><span class="line">	Ei = calcEkK(oS, i)</span><br><span class="line">	<span class="comment">#如果标签与误差相乘之后在容错范围之外，且超过各自对应的常数值，则进行优化</span></span><br><span class="line">	<span class="keyword">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) <span class="keyword">and</span> (oS.alphas[i] &lt; oS.C)) <span class="keyword">or</span> ((oS.labelMat[i]*Ei &gt; oS.tol) <span class="keyword">and</span> (oS.alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">		<span class="comment">#启发式选择第二个alpha值</span></span><br><span class="line">		j, Ej = selectJK(i, oS, Ei)</span><br><span class="line">		<span class="comment">#利用copy存储刚才的计算值，便于后期比较</span></span><br><span class="line">		alphaIold = oS.alphas[i].copy(); alpahJold = oS.alphas[j].copy();</span><br><span class="line">		<span class="comment">#保证alpha在0和C之间</span></span><br><span class="line">		<span class="keyword">if</span> (oS.labelMat[i] != oS.labelMat[j]):</span><br><span class="line">			L = max(<span class="number">0</span>, oS.alphas[j] - oS. alphas[i])</span><br><span class="line">			H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			L = max(<span class="number">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)</span><br><span class="line">			H = min(oS.C, oS.alphas[j] + oS.alphas[i])</span><br><span class="line">		<span class="comment">#如果界限值相同，则不做处理直接跳出本次循环</span></span><br><span class="line">		<span class="keyword">if</span> L == H: print(<span class="string">"L==H"</span>); <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		</span><br><span class="line">		<span class="string">""" 主要区分 """</span></span><br><span class="line">		<span class="comment">#最优修改量，求两个向量的内积（核函数）</span></span><br><span class="line">		<span class="comment">#eta = 2.0 * oS.X[i, :]*oS.X[j, :].T - oS.X[i, :]*oS.X[i, :].T - oS.X[j, :]*oS.X[j, :].T</span></span><br><span class="line">		eta = <span class="number">2.0</span> * oS.K[i, j] - oS.K[i, i] - oS.K[j, j]</span><br><span class="line">		<span class="string">""" 主要区分 """</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#如果最优修改量大于0，则不做处理直接跳出本次循环，这里对真实SMO做了简化处理</span></span><br><span class="line">		<span class="keyword">if</span> eta &gt;= <span class="number">0</span>: print(<span class="string">"eta&gt;=0"</span>); <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="comment">#计算新的alphas[j]的值</span></span><br><span class="line">		oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">		<span class="comment">#对新的alphas[j]进行阈值处理</span></span><br><span class="line">		oS.alphas[j] = clipAlpha(oS.alphas[j], H, L)</span><br><span class="line">		<span class="comment">#更新误差缓存</span></span><br><span class="line">		updateEkK(oS, j)</span><br><span class="line">		<span class="comment">#如果新旧值差很小，则不做处理跳出本次循环</span></span><br><span class="line">		<span class="keyword">if</span> (abs(oS.alphas[j] - alpahJold) &lt; <span class="number">0.00001</span>): print(<span class="string">"j not moving enough"</span>); <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="comment">#对i进行修改，修改量相同，但是方向相反</span></span><br><span class="line">		oS.alphas[i] += oS.labelMat[j] * oS.labelMat[i] * (alpahJold - oS.alphas[j])</span><br><span class="line">		<span class="comment">#更新误差缓存</span></span><br><span class="line">		updateEkK(oS, i)</span><br><span class="line">		</span><br><span class="line">		<span class="string">""" 主要区分 """</span></span><br><span class="line">		<span class="comment">#更新常数项</span></span><br><span class="line">		<span class="comment">#b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[i, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[i, :]*oS.X[j, :].T</span></span><br><span class="line">		<span class="comment">#b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[j, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[j, :]*oS.X[j, :].T</span></span><br><span class="line">		b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i, i] - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.K[i, j]</span><br><span class="line">		b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.K[i, j] - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.K[j, j]</span><br><span class="line">		<span class="string">""" 主要区分 """</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">#谁在0到C之间，就听谁的，否则就取平均值</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> &lt; oS.alphas[i]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b1</span><br><span class="line">		<span class="keyword">elif</span> (<span class="number">0</span> &lt; oS.alphas[j]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b2</span><br><span class="line">		<span class="keyword">else</span>: oS.b = (b1 + b2) / <span class="number">2.0</span></span><br><span class="line">		<span class="comment">#成功返回1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="comment">#失败返回0</span></span><br><span class="line">	<span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoPK</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter, kTup = <span class="params">(<span class="string">'lin'</span>, <span class="number">0</span>)</span>)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	完整SMO算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据集</span></span><br><span class="line"><span class="string">				classLabels：类别标签</span></span><br><span class="line"><span class="string">				C：常数C</span></span><br><span class="line"><span class="string">				toler：容错率</span></span><br><span class="line"><span class="string">				maxIter：最大的循环次数</span></span><br><span class="line"><span class="string">				kTup：速度参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	b：常数项</span></span><br><span class="line"><span class="string">				alphas：数据向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#新建数据结构对象</span></span><br><span class="line">	oS = optStructK(mat(dataMatIn), mat(classLabels).transpose(), C, toler, kTup)</span><br><span class="line">	<span class="comment">#初始化迭代次数</span></span><br><span class="line">	iter = <span class="number">0</span></span><br><span class="line">	<span class="comment">#初始化标志位</span></span><br><span class="line">	entireSet = <span class="literal">True</span>; alphaPairsChanged = <span class="number">0</span></span><br><span class="line">	<span class="comment">#终止条件：迭代次数超限、遍历整个集合都未对alpha进行修改</span></span><br><span class="line">	<span class="keyword">while</span> (iter &lt; maxIter) <span class="keyword">and</span> ((alphaPairsChanged &gt; <span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">		alphaPairsChanged = <span class="number">0</span></span><br><span class="line">		<span class="comment">#根据标志位选择不同的遍历方式</span></span><br><span class="line">		<span class="keyword">if</span> entireSet:</span><br><span class="line">			<span class="comment">#遍历任意可能的alpha值</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):</span><br><span class="line">				<span class="comment">#选择第二个alpha值，并在可能时对其进行优化处理</span></span><br><span class="line">				alphaPairsChanged += innerLK(i, oS)</span><br><span class="line">				print(<span class="string">"fullSet, iter: %d i: %d, pairs changed %d"</span> % (iter, i, alphaPairsChanged))</span><br><span class="line">			<span class="comment">#迭代次数累加</span></span><br><span class="line">			iter += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment">#得出所有的非边界alpha值</span></span><br><span class="line">			nonBoundIs = nonzero((oS.alphas.A &gt; <span class="number">0</span>) * (oS.alphas.A &lt; C))[<span class="number">0</span>]</span><br><span class="line">			<span class="comment">#遍历所有的非边界alpha值</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">				<span class="comment">#选择第二个alpha值，并在可能时对其进行优化处理</span></span><br><span class="line">				alphaPairsChanged += innerLK(i, oS)</span><br><span class="line">				print(<span class="string">"non-bound, iter: %d i: %d, pairs changed %d"</span> % (iter, i, alphaPairsChanged))</span><br><span class="line">			<span class="comment">#迭代次数累加</span></span><br><span class="line">			iter += <span class="number">1</span></span><br><span class="line">		<span class="comment">#在非边界循环和完整遍历之间进行切换</span></span><br><span class="line">		<span class="keyword">if</span> entireSet: entireSet = <span class="literal">False</span></span><br><span class="line">		<span class="keyword">elif</span> (alphaPairsChanged == <span class="number">0</span>): entireSet =<span class="literal">True</span></span><br><span class="line">		print(<span class="string">"iteration number: %d"</span> % iter)</span><br><span class="line">	<span class="comment">#返回常数项和数据向量</span></span><br><span class="line">	<span class="keyword">return</span> oS.b, oS.alphas</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来我们写测试函数。整个代码中最重要的是for循环开始的那两行，他们给出了如何利用核函数进行分类。首先利用结构初始化方法中使用过的kernelTrans()函数，得到转换后的数据。然后，再用其与前面的alpha及类别标签值求积。特别需要注意观察的是，我们是如何做到只需要支持向量数据就可以进行分类的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testRbf</span><span class="params">(k1 = <span class="number">1.3</span>)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	利用核函数进行分类的径向基测试函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		k1：径向基函数的速度参数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	输出打印信息</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#导入数据集</span></span><br><span class="line">	dataArr, labelArr = loadDataSet(<span class="string">'testSetRBF.txt'</span>)</span><br><span class="line">	<span class="comment">#调用Platt SMO算法</span></span><br><span class="line">	b, alphas = smoPK(dataArr, labelArr, <span class="number">200</span>, <span class="number">0.00001</span>, <span class="number">10000</span>, (<span class="string">'rbf'</span>, k1))</span><br><span class="line">	<span class="comment">#初始化数据矩阵和标签向量</span></span><br><span class="line">	datMat = mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">	<span class="comment">#记录支持向量序号</span></span><br><span class="line">	svInd = nonzero(alphas.A &gt; <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#读取支持向量</span></span><br><span class="line">	sVs = datMat[svInd]</span><br><span class="line">	<span class="comment">#读取支持向量对应标签</span></span><br><span class="line">	labelSV = labelMat[svInd]</span><br><span class="line">	<span class="comment">#输出打印信息</span></span><br><span class="line">	print(<span class="string">"there are %d Support Vectors"</span> % shape(sVs)[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">#获取数据集行列值</span></span><br><span class="line">	m, n = shape(datMat)</span><br><span class="line">	<span class="comment">#初始化误差计数</span></span><br><span class="line">	errorCount = <span class="number">0</span></span><br><span class="line">	<span class="comment">#遍历每一行，利用核函数对训练集进行分类</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#利用核函数转换数据</span></span><br><span class="line">		kernelEval = kernelTrans(sVs, datMat[i,:], (<span class="string">'rbf'</span>, k1))</span><br><span class="line">		<span class="comment">#仅用支持向量预测分类</span></span><br><span class="line">		predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b</span><br><span class="line">		<span class="comment">#预测分类结果与标签不符则错误计数加一</span></span><br><span class="line">		<span class="keyword">if</span> sign(predict) != sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">	<span class="comment">#打印输出分类错误率</span></span><br><span class="line">	print(<span class="string">"the training error rate is: %f"</span> % (float(errorCount)/m))</span><br><span class="line">	<span class="comment">#导入测试数据集</span></span><br><span class="line">	dataArr, labelArr = loadDataSet(<span class="string">'testSetRBF2.txt'</span>)</span><br><span class="line">	<span class="comment">#初始化误差计数</span></span><br><span class="line">	errorCount = <span class="number">0</span></span><br><span class="line">	<span class="comment">#初始化数据矩阵和标签向量</span></span><br><span class="line">	datMat = mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">	<span class="comment">#获取数据集行列值</span></span><br><span class="line">	m, n = shape(datMat)</span><br><span class="line">	<span class="comment">#遍历每一行，利用核函数对测试集进行分类</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#利用核函数转换数据</span></span><br><span class="line">		kernelEval = kernelTrans(sVs, datMat[i,:], (<span class="string">'rbf'</span>, k1))</span><br><span class="line">		<span class="comment">#仅用支持向量预测分类</span></span><br><span class="line">		predict = kernelEval.T * multiply(labelSV, alphas[svInd]) + b</span><br><span class="line">		<span class="comment">#预测分类结果与标签不符则错误计数加一</span></span><br><span class="line">		<span class="keyword">if</span> sign(predict) != sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">	<span class="comment">#打印输出分类错误率</span></span><br><span class="line">	print(<span class="string">"the test error rate is: %f"</span> % (float(errorCount)/m))</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码分别在训练集和测试集上进行性能测试，打印输出如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(svmMLiA)</span><br><span class="line">&lt;module <span class="string">'svmMLiA'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>svmMLiA.testRbf()</span><br><span class="line">L==H</span><br><span class="line">fullSet, iter: <span class="number">0</span> i: <span class="number">0</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">0</span> i: <span class="number">1</span>, pairs changed <span class="number">1</span></span><br><span class="line">fullSet, iter: <span class="number">0</span> i: <span class="number">2</span>, pairs changed <span class="number">2</span></span><br><span class="line">fullSet, iter: <span class="number">0</span> i: <span class="number">3</span>, pairs changed <span class="number">3</span></span><br><span class="line">···</span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">96</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">97</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">98</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">99</span>, pairs changed <span class="number">0</span></span><br><span class="line">iteration number: <span class="number">7</span></span><br><span class="line">there are <span class="number">27</span> Support Vectors</span><br><span class="line">the training error rate <span class="keyword">is</span>: <span class="number">0.030000</span></span><br><span class="line">the test error rate <span class="keyword">is</span>: <span class="number">0.040000</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;当然，大家也可以尝试更换不同的k1参数以观察测试错误率、训练错误率、支持向量个数随k1的变化情况。下面个两张图是书上的举例。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171009221909966?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171009221934280?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;我们会发现，支持向量的数目存在一个最优值。SVM的优点在于它能对数据进行高效分类。如果支持向量太少，就可能会得到一个很差的决策边界；如果支持向量太多，也就是相当于每次都利用整个数据集进行分类，这种分类方法成为kNN（多么熟悉）。</p>
<h2 id="手写识别问题回顾"><a href="#手写识别问题回顾" class="headerlink" title="手写识别问题回顾"></a>手写识别问题回顾</h2><p>&emsp;&emsp;SVM对kNN的优点在于，SVM只需要保留支持向量就可以获得可比的效果，占用内存大大减小。下面，我们就用SVM来对手写数字进行分类识别（不加修改的SVM只能用于二分类问题，在这里，我们规定，如果是数字9，则为-1，否则为+1）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	32*32图像转换为1*1024向量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		filename：文件名称字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	returnVect：转换之后的1*1024向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化要返回的1*1024向量</span></span><br><span class="line">	returnVect = zeros((<span class="number">1</span>, <span class="number">1024</span>))</span><br><span class="line">	<span class="comment">#打开文件</span></span><br><span class="line">	fr = open(filename)</span><br><span class="line">	<span class="comment">#读取文件信息</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">		<span class="comment">#循环读取文件的前32行</span></span><br><span class="line">		lineStr = fr.readline()</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">			<span class="comment">#将每行的头32个字符存储到要返回的向量中</span></span><br><span class="line">			returnVect[<span class="number">0</span>, <span class="number">32</span>*i+j] = int(lineStr[j])</span><br><span class="line">	<span class="comment">#返回要输出的1*1024向量</span></span><br><span class="line">	<span class="keyword">return</span> returnVect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadImages</span><span class="params">(dirName)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	加载图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dirName：文件路径</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	trainingMat：训练数据集</span></span><br><span class="line"><span class="string">				hwLabels：数据标签</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line">	<span class="comment">#初始化数据标签</span></span><br><span class="line">	hwLabels = []</span><br><span class="line">	<span class="comment">#读取文件列表</span></span><br><span class="line">	trainingFileList = listdir(dirName)</span><br><span class="line">	<span class="comment">#读取文件个数</span></span><br><span class="line">	m = len(trainingFileList)</span><br><span class="line">	<span class="comment">#初始化训练数据集</span></span><br><span class="line">	trainingMat = zeros((m,<span class="number">1024</span>))</span><br><span class="line">	<span class="comment">#填充数据集</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#遍历所有文件</span></span><br><span class="line">		fileNameStr = trainingFileList[i]</span><br><span class="line">		<span class="comment">#提取文件名称</span></span><br><span class="line">		fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">		<span class="comment">#提取数字标识</span></span><br><span class="line">		classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#数字9记为-1类</span></span><br><span class="line">		<span class="keyword">if</span> classNumStr == <span class="number">9</span>: hwLabels.append(<span class="number">-1</span>)</span><br><span class="line">		<span class="comment">#其他数字记为+1类</span></span><br><span class="line">		<span class="keyword">else</span>: hwLabels.append(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">#提取图像向量，填充数据集</span></span><br><span class="line">		trainingMat[i,:] = img2vector(<span class="string">'%s/%s'</span> % (dirName, fileNameStr))</span><br><span class="line">	<span class="comment">#返回数据集和数据标签</span></span><br><span class="line">	<span class="keyword">return</span> trainingMat, hwLabels</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testDigits</span><span class="params">(kTup = <span class="params">(<span class="string">'rbf'</span>,<span class="number">10</span>)</span>)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	手写数字分类函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		kTup：核函数采用径向基函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	输出打印信息</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#导入数据集</span></span><br><span class="line">	dataArr, labelArr = loadImages(<span class="string">'trainingDigits'</span>)</span><br><span class="line">	<span class="comment">#调用Platt SMO算法</span></span><br><span class="line">	b, alphas = smoPK(dataArr, labelArr, <span class="number">200</span>, <span class="number">0.0001</span>, <span class="number">10000</span>, kTup)</span><br><span class="line">	<span class="comment">#初始化数据矩阵和标签向量</span></span><br><span class="line">	datMat = mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">	<span class="comment">#记录支持向量序号</span></span><br><span class="line">	svInd = nonzero(alphas.A &gt; <span class="number">0</span>)[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#读取支持向量</span></span><br><span class="line">	sVs = datMat[svInd]</span><br><span class="line">	<span class="comment">#读取支持向量对应标签</span></span><br><span class="line">	labelSV = labelMat[svInd]</span><br><span class="line">	<span class="comment">#输出打印信息</span></span><br><span class="line">	print(<span class="string">"there are %d Support Vectors"</span> % shape(sVs)[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">#获取数据集行列值</span></span><br><span class="line">	m, n = shape(datMat)</span><br><span class="line">	<span class="comment">#初始化误差计数</span></span><br><span class="line">	errorCount = <span class="number">0</span></span><br><span class="line">	<span class="comment">#遍历每一行，利用核函数对训练集进行分类</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#利用核函数转换数据</span></span><br><span class="line">		kernelEval = kernelTrans(sVs,datMat[i,:],kTup)</span><br><span class="line">		<span class="comment">#仅用支持向量预测分类</span></span><br><span class="line">		predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">		<span class="comment">#预测分类结果与标签不符则错误计数加一</span></span><br><span class="line">		<span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">	<span class="comment">#打印输出分类错误率</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"the training error rate is: %f"</span> % (float(errorCount)/m)</span><br><span class="line">	<span class="comment">#导入测试数据集</span></span><br><span class="line">	dataArr,labelArr = loadImages(<span class="string">'testDigits'</span>)</span><br><span class="line">	<span class="comment">#初始化误差计数</span></span><br><span class="line">	errorCount = <span class="number">0</span></span><br><span class="line">	<span class="comment">#初始化数据矩阵和标签向量</span></span><br><span class="line">	datMat=mat(dataArr); labelMat = mat(labelArr).transpose()</span><br><span class="line">	<span class="comment">#获取数据集行列值</span></span><br><span class="line">	m,n = shape(datMat)</span><br><span class="line">	<span class="comment">#遍历每一行，利用核函数对测试集进行分类</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#利用核函数转换数据</span></span><br><span class="line">		kernelEval = kernelTrans(sVs,datMat[i,:],kTup)</span><br><span class="line">		<span class="comment">#仅用支持向量预测分类</span></span><br><span class="line">		predict=kernelEval.T * multiply(labelSV,alphas[svInd]) + b</span><br><span class="line">		<span class="comment">#预测分类结果与标签不符则错误计数加一</span></span><br><span class="line">		<span class="keyword">if</span> sign(predict)!=sign(labelArr[i]): errorCount += <span class="number">1</span></span><br><span class="line">	<span class="comment">#打印输出分类错误率</span></span><br><span class="line">	<span class="keyword">print</span> <span class="string">"the test error rate is: %f"</span> % (float(errorCount)/m)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的大部分代码我们都已经很熟悉了，这里就不再赘述，直接进行测试。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(svmMLiA)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>svmMLiA.testDigits((<span class="string">'rbf'</span>, <span class="number">20</span>))</span><br><span class="line">L==H</span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">398</span>, pairs changed <span class="number">0</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">399</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">400</span>, pairs changed <span class="number">0</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">fullSet, iter: <span class="number">6</span> i: <span class="number">401</span>, pairs changed <span class="number">0</span></span><br><span class="line">iteration number: <span class="number">7</span></span><br><span class="line">there are <span class="number">58</span> Support Vectors</span><br><span class="line">the training error rate <span class="keyword">is</span>: <span class="number">0.000000</span></span><br><span class="line">the test error rate <span class="keyword">is</span>: <span class="number">0.021505</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;尝试不同的σ，并尝试了线性核函数，总结得到如图结果：</p>
<table>
<thead>
<tr>
<th>Kernel,settings</th>
<th>Training error (%)</th>
<th>Test error (%)</th>
<th># Support vectors</th>
</tr>
</thead>
<tbody><tr>
<td>RBF,0.1</td>
<td>0</td>
<td>52</td>
<td>402</td>
</tr>
<tr>
<td>RBF,5</td>
<td>0</td>
<td>3.2</td>
<td>402</td>
</tr>
<tr>
<td>RBF,10</td>
<td>0</td>
<td>0.5</td>
<td>99</td>
</tr>
<tr>
<td>RBF,50</td>
<td>0.2</td>
<td>2.2</td>
<td>41</td>
</tr>
<tr>
<td>RBF,100</td>
<td>1.5</td>
<td>4.3</td>
<td>26</td>
</tr>
<tr>
<td>Linear</td>
<td>2.7</td>
<td>2.2</td>
<td>28</td>
</tr>
</tbody></table>
<p>&emsp;&emsp;结果表明，当径向基函数的参数σ取10左右时，就可以得到最小的测试错误率。同时，最小的训练错误率，并不对应于最小的支持向量数目。另外，线性核函数的效果并不是特别糟糕，可以以牺牲线性核函数的错误率来换取分类速度的提高。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;支持向量机是一种分类器。之所以称为“机”是因为它会产生一个二值决策结果，即它是一种决策“机”。支持向量机的泛化错误率较低，具有良好的学习能力，且学到的结果具有很好的推广性。这些优点使得支持向量机十分流行，有些人认为他是监督学习中最好的定式算法。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之支持向量机（3）完整版SMO</title>
    <url>/folder/2019/11/08/2017-11-05-ml-16/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch06" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch06</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在小规模数据集上，上一篇文章中的简化版SMO是没有问题的，但是在更大的数据集上，运行速度就会变慢。</p>
<p>&emsp;&emsp;完整版SMO和简化版SMO，实现alpha的更改个代数运算的优化环节一模一样。在优化过程中，唯一的不同就是选择alpha的方式。完整版的SMO算法应用了一些能够提速的启发方法。</p>
<p>&emsp;&emsp;Platt SMO算法通过一个外循环来选择第一个alpha，并且其选择过程会在两种方式之间进行切换：一种是在所有数据集上进行单遍扫描，另一种则是在非边界alpha（不等于边界0或C的alpha值）中实现单遍扫描。对整个数据集的扫描很容易，前面已经实现了，而实现非边界alpha值的扫描时，需要建立这些alpha值得列表，然后再对这个表进行遍历。同时，该步骤会跳过那些已知的不会改变的alpha值。</p>
<p>&emsp;&emsp;在选择第一个alpha值之后，算法会通过一个内循环来选择第二个alpha。在优化过程中，会通过最大化步长的方式来获得第二个alpha值。在简化版SMO算法中，我们会在选择j之后计算错误率Ej。但在这里，我们会建立一个全局的缓存用于保存误差值，并从中选择使得步长或者Ei-Ej最大的alpha值。</p>
<h2 id="支持函数"><a href="#支持函数" class="headerlink" title="支持函数"></a>支持函数</h2><p>&emsp;&emsp;和简化版一样，完整版也需要一些支持函数。</p>
<ul>
<li>首要的事情就是建立一个数据结构来保存所有的重要值，而这个过程可以通过一个对象来完成；</li>
<li>对于给定的alpha值，第一个辅助函数calcEk()能够计算E值并返回（因为调用频繁，所以必须要单独拎出来）；</li>
<li>selectJ()用于选择第二个alpha或者说内循环的alpha值，选择合适的值以保证在每次优化中采用最大步长；</li>
<li>updateEk()用于计算误差值并将其存入缓存中。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''#######********************************</span></span><br><span class="line"><span class="string">Non-Kernel VErsions below</span></span><br><span class="line"><span class="string">'''</span><span class="comment">#######********************************</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">optStruct</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	存放运算中重要的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据集</span></span><br><span class="line"><span class="string">				classLabels：类别标签</span></span><br><span class="line"><span class="string">				C：常数C</span></span><br><span class="line"><span class="string">				toler：容错率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	X：数据集</span></span><br><span class="line"><span class="string">				labelMat：类别标签</span></span><br><span class="line"><span class="string">				C：常数C</span></span><br><span class="line"><span class="string">				tol：容错率</span></span><br><span class="line"><span class="string">				m：数据集行数</span></span><br><span class="line"><span class="string">				b：常数项</span></span><br><span class="line"><span class="string">				alphas：alphas矩阵</span></span><br><span class="line"><span class="string">				eCache：误差缓存</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dataMatIn, classLabels, C, toler)</span>:</span></span><br><span class="line">		self.X = dataMatIn</span><br><span class="line">		self.labelMat = classLabels</span><br><span class="line">		self.C = C</span><br><span class="line">		self.tol = toler</span><br><span class="line">		self.m = shape(dataMatIn)[<span class="number">0</span>]</span><br><span class="line">		self.alphas = mat(zeros((self.m, <span class="number">1</span>)))</span><br><span class="line">		self.b = <span class="number">0</span></span><br><span class="line">		self.eCache = mat(zeros((self.m, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcEk</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	计算误差值E</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		oS：数据结构</span></span><br><span class="line"><span class="string">				k：下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	Ek：计算的E值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#计算fXk，整个对应输出公式f(x)=w`x + b</span></span><br><span class="line">	fXk = float(multiply(oS.alphas, oS.labelMat).T * (oS.X * oS.X[k,:].T)) + oS.b	</span><br><span class="line">	<span class="comment">#计算E值</span></span><br><span class="line">	Ek = fXk - float(oS.labelMat[k])</span><br><span class="line">	<span class="comment">#返回计算的误差值E</span></span><br><span class="line">	<span class="keyword">return</span> Ek</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJ</span><span class="params">(i, oS, Ei)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	选择第二个alpha的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		i：第一个alpha的下标</span></span><br><span class="line"><span class="string">				oS：数据结构</span></span><br><span class="line"><span class="string">				Ei：计算出的第一个alpha的误差值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	j：第二个alpha的下标</span></span><br><span class="line"><span class="string">				Ej：计算出的第二个alpha的误差值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化参数值</span></span><br><span class="line">	maxK = <span class="number">-1</span>; maxDeltaE = <span class="number">0</span>; Ej = <span class="number">0</span></span><br><span class="line">	<span class="comment">#构建误差缓存</span></span><br><span class="line">	oS.eCache[i] = [<span class="number">1</span>, Ei]</span><br><span class="line">	<span class="comment">#构建一个非零列表，返回值是第一个非零E所对应的alpha值，而不是E本身</span></span><br><span class="line">	validEcacheList = nonzero(oS.eCache[:, <span class="number">0</span>].A)[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#如果列表长度大于1，说明不是第一次循环</span></span><br><span class="line">	<span class="keyword">if</span> (len(validEcacheList)) &gt; <span class="number">1</span>:</span><br><span class="line">		<span class="comment">#遍历列表中所有元素</span></span><br><span class="line">		<span class="keyword">for</span> k <span class="keyword">in</span> validEcacheList:</span><br><span class="line">			<span class="comment">#如果是第一个alpha的下标，就跳出本次循环</span></span><br><span class="line">			<span class="keyword">if</span> k == i: <span class="keyword">continue</span></span><br><span class="line">			<span class="comment">#计算k下标对应的误差值</span></span><br><span class="line">			Ek = calcEk(oS, k)</span><br><span class="line">			<span class="comment">#取两个alpha误差值的差值的绝对值</span></span><br><span class="line">			deltaE = abs(Ei - Ek)</span><br><span class="line">			<span class="comment">#最大值更新</span></span><br><span class="line">			<span class="keyword">if</span> (deltaE &gt; maxDeltaE):</span><br><span class="line">				maxK = k; maxDeltaE = deltaE; Ej = Ek</span><br><span class="line">		<span class="comment">#返回最大差值的下标maxK和误差值Ej</span></span><br><span class="line">		<span class="keyword">return</span> maxK, Ej</span><br><span class="line">	<span class="comment">#如果是第一次循环，则随机选择alpha，然后计算误差</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		j = selectJrand(i, oS.m)</span><br><span class="line">		Ej = calcEk(oS, j)</span><br><span class="line">	<span class="comment">#返回下标j和其对应的误差Ej</span></span><br><span class="line">	<span class="keyword">return</span> j, Ej</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateEk</span><span class="params">(oS, k)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	更新误差缓存</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		oS：数据结构</span></span><br><span class="line"><span class="string">				j：alpha的下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	无</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#计算下表为k的参数的误差</span></span><br><span class="line">	Ek = calcEk(oS, k)</span><br><span class="line">	<span class="comment">#将误差放入缓存</span></span><br><span class="line">	oS.eCache[k] = [<span class="number">1</span>, Ek]</span><br></pre></td></tr></table></figure>

<h2 id="优化例程"><a href="#优化例程" class="headerlink" title="优化例程"></a>优化例程</h2><p>&emsp;&emsp;接下来简单介绍一下用于寻找决策边界的优化例程。</p>
<p>&emsp;&emsp;大部分代码和之前的smoSimple()是一样的，区别在于：</p>
<ul>
<li>使用了自己的数据结构，该结构在oS中传递；</li>
<li>使用selectJ()而不是selectJrand()来选择第二个alpha的值；</li>
<li>在alpha值改变时更新Ecache。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">innerL</span><span class="params">(i, oS)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	完整SMO算法中的优化例程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		oS：数据结构</span></span><br><span class="line"><span class="string">				i：alpha的下标</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	无</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#计算误差</span></span><br><span class="line">	Ei = calcEk(oS, i)</span><br><span class="line">	<span class="comment">#如果标签与误差相乘之后在容错范围之外，且超过各自对应的常数值，则进行优化</span></span><br><span class="line">	<span class="keyword">if</span> ((oS.labelMat[i]*Ei &lt; -oS.tol) <span class="keyword">and</span> (oS.alphas[i] &lt; oS.C)) <span class="keyword">or</span> ((oS.labelMat[i]*Ei &gt; oS.tol) <span class="keyword">and</span> (oS.alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">		<span class="comment">#启发式选择第二个alpha值</span></span><br><span class="line">		j, Ej = selectJ(i, oS, Ei)</span><br><span class="line">		<span class="comment">#利用copy存储刚才的计算值，便于后期比较</span></span><br><span class="line">		alphaIold = oS.alphas[i].copy(); alpahJold = oS.alphas[j].copy();</span><br><span class="line">		<span class="comment">#保证alpha在0和C之间</span></span><br><span class="line">		<span class="keyword">if</span> (oS.labelMat[i] != oS.labelMat[j]):</span><br><span class="line">			L = max(<span class="number">0</span>, oS.alphas[j] - oS. alphas[i])</span><br><span class="line">			H = min(oS.C, oS.C + oS.alphas[j] - oS.alphas[i])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			L = max(<span class="number">0</span>, oS.alphas[j] + oS.alphas[i] - oS.C)</span><br><span class="line">			H = min(oS.C, oS.alphas[j] + oS.alphas[i])</span><br><span class="line">		<span class="comment">#如果界限值相同，则不做处理直接跳出本次循环</span></span><br><span class="line">		<span class="keyword">if</span> L == H: print(<span class="string">"L==H"</span>); <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="comment">#最优修改量，求两个向量的内积（核函数）</span></span><br><span class="line">		eta = <span class="number">2.0</span> * oS.X[i, :]*oS.X[j, :].T - oS.X[i, :]*oS.X[i, :].T - oS.X[j, :]*oS.X[j, :].T</span><br><span class="line">		<span class="comment">#如果最优修改量大于0，则不做处理直接跳出本次循环，这里对真实SMO做了简化处理</span></span><br><span class="line">		<span class="keyword">if</span> eta &gt;= <span class="number">0</span>: print(<span class="string">"eta&gt;=0"</span>); <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="comment">#计算新的alphas[j]的值</span></span><br><span class="line">		oS.alphas[j] -= oS.labelMat[j]*(Ei - Ej)/eta</span><br><span class="line">		<span class="comment">#对新的alphas[j]进行阈值处理</span></span><br><span class="line">		oS.alphas[j] = clipAlpha(oS.alphas[j], H, L)</span><br><span class="line">		<span class="comment">#更新误差缓存</span></span><br><span class="line">		updateEk(oS, j)</span><br><span class="line">		<span class="comment">#如果新旧值差很小，则不做处理跳出本次循环</span></span><br><span class="line">		<span class="keyword">if</span> (abs(oS.alphas[j] - alpahJold) &lt; <span class="number">0.00001</span>): print(<span class="string">"j not moving enough"</span>); <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		<span class="comment">#对i进行修改，修改量相同，但是方向相反</span></span><br><span class="line">		oS.alphas[i] += oS.labelMat[j] * oS.labelMat[i] * (alpahJold - oS.alphas[j])</span><br><span class="line">		<span class="comment">#更新误差缓存</span></span><br><span class="line">		updateEk(oS, i)</span><br><span class="line">		<span class="comment">#更新常数项</span></span><br><span class="line">		b1 = oS.b - Ei - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[i, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[i, :]*oS.X[j, :].T</span><br><span class="line">		b2 = oS.b - Ej - oS.labelMat[i] * (oS.alphas[i] - alphaIold) * oS.X[i, :]*oS.X[j, :].T - oS.labelMat[j] * (oS.alphas[j] - alpahJold) * oS.X[j, :]*oS.X[j, :].T</span><br><span class="line">		<span class="comment">#谁在0到C之间，就听谁的，否则就取平均值</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> &lt; oS.alphas[i]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b1</span><br><span class="line">		<span class="keyword">elif</span> (<span class="number">0</span> &lt; oS.alphas[j]) <span class="keyword">and</span> (oS.C &gt; oS.alphas[i]): oS.b = b2</span><br><span class="line">		<span class="keyword">else</span>: oS.b = (b1 + b2) / <span class="number">2.0</span></span><br><span class="line">		<span class="comment">#成功返回1</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="comment">#失败返回0</span></span><br><span class="line">	<span class="keyword">else</span>: <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="外循环代码"><a href="#外循环代码" class="headerlink" title="外循环代码"></a>外循环代码</h2><p>&emsp;&emsp;外循环代码的输入和函数smoSimple()完全一样。整个代码的主体是while循环，终止条件：当迭代次数超过指定的最大值，或者遍历整个集合都未对任意alpha对进行修改时，就退出循环。while循环内部与smoSimple()中有所不同，一开始的for循环在数据集上遍历任意可能的alpha。通过innerL()来选择第二个alpha，并在可能时对其进行优化处理。如果有任意一对alpha值发生改变，就会返回1.第二个for循环遍历所有的非边界alpha值，也就是不在边界0或C上的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoP</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	完整SMO算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据集</span></span><br><span class="line"><span class="string">				classLabels：类别标签</span></span><br><span class="line"><span class="string">				C：常数C</span></span><br><span class="line"><span class="string">				toler：容错率</span></span><br><span class="line"><span class="string">				maxIter：最大的循环次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	b：常数项</span></span><br><span class="line"><span class="string">				alphas：数据向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#新建数据结构对象</span></span><br><span class="line">	oS = optStruct(mat(dataMatIn), mat(classLabels).transpose(), C, toler)</span><br><span class="line">	<span class="comment">#初始化迭代次数</span></span><br><span class="line">	iter = <span class="number">0</span></span><br><span class="line">	<span class="comment">#初始化标志位</span></span><br><span class="line">	entireSet = <span class="literal">True</span>; alphaPairsChanged = <span class="number">0</span></span><br><span class="line">	<span class="comment">#终止条件：迭代次数超限、遍历整个集合都未对alpha进行修改</span></span><br><span class="line">	<span class="keyword">while</span> (iter &lt; maxIter) <span class="keyword">and</span> ((alphaPairsChanged &gt; <span class="number">0</span>) <span class="keyword">or</span> (entireSet)):</span><br><span class="line">		alphaPairsChanged = <span class="number">0</span></span><br><span class="line">		<span class="comment">#根据标志位选择不同的遍历方式</span></span><br><span class="line">		<span class="keyword">if</span> entireSet:</span><br><span class="line">			<span class="comment">#遍历任意可能的alpha值</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> range(oS.m):</span><br><span class="line">				<span class="comment">#选择第二个alpha值，并在可能时对其进行优化处理</span></span><br><span class="line">				alphaPairsChanged += innerL(i, oS)</span><br><span class="line">				print(<span class="string">"fullSet, iter: %d i: %d, pairs changed %d"</span> % (iter, i, alphaPairsChanged))</span><br><span class="line">			<span class="comment">#迭代次数累加</span></span><br><span class="line">			iter += <span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment">#得出所有的非边界alpha值</span></span><br><span class="line">			nonBoundIs = nonzero((oS.alphas.A &gt; <span class="number">0</span>) * (oS.alphas.A &lt; C))[<span class="number">0</span>]</span><br><span class="line">			<span class="comment">#遍历所有的非边界alpha值</span></span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> nonBoundIs:</span><br><span class="line">				<span class="comment">#选择第二个alpha值，并在可能时对其进行优化处理</span></span><br><span class="line">				alphaPairsChanged += innerL(i, oS)</span><br><span class="line">				print(<span class="string">"non-bound, iter: %d i: %d, pairs changed %d"</span> % (iter, i, alphaPairsChanged))</span><br><span class="line">			<span class="comment">#迭代次数累加</span></span><br><span class="line">			iter += <span class="number">1</span></span><br><span class="line">		<span class="comment">#在非边界循环和完整遍历之间进行切换</span></span><br><span class="line">		<span class="keyword">if</span> entireSet: entireSet = <span class="literal">False</span></span><br><span class="line">		<span class="keyword">elif</span> (alphaPairsChanged == <span class="number">0</span>): entireSet =<span class="literal">True</span></span><br><span class="line">		print(<span class="string">"iteration number: %d"</span> % iter)</span><br><span class="line">	<span class="comment">#返回常数项和数据向量</span></span><br><span class="line">	<span class="keyword">return</span> oS.b, oS.alphas</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试代码，大家有兴趣的话可以多次运行计算一下运行时间的平均值，看看和简化版相比快了多少。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(svmMLiA)</span><br><span class="line">&lt;module <span class="string">'svmMLiA'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dataArr, labelArr = svmMLiA.loadDataSet(<span class="string">'testSet.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, alphas = svmMLiA.smoP(dataArr, labelArr, <span class="number">0.6</span>, <span class="number">0.001</span>, <span class="number">40</span>)</span><br><span class="line">L==H</span><br><span class="line">fullSet, iter: <span class="number">0</span> i: <span class="number">0</span>, pairs changed <span class="number">0</span></span><br><span class="line">L==H</span><br><span class="line">fullSet, iter: <span class="number">0</span> i: <span class="number">1</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">0</span> i: <span class="number">2</span>, pairs changed <span class="number">1</span></span><br><span class="line">L==H</span><br><span class="line">···</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">fullSet, iter: <span class="number">2</span> i: <span class="number">97</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">2</span> i: <span class="number">98</span>, pairs changed <span class="number">0</span></span><br><span class="line">fullSet, iter: <span class="number">2</span> i: <span class="number">99</span>, pairs changed <span class="number">0</span></span><br><span class="line">iteration number: <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;像之前一样，打印b和alpha，得出的数据用来画图。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">matrix([[<span class="number">-2.89901748</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alphas[alphas &gt; <span class="number">0</span>]</span><br><span class="line">matrix([[ <span class="number">0.06961952</span>,  <span class="number">0.0169055</span> ,  <span class="number">0.0169055</span> ,  <span class="number">0.0272699</span> ,  <span class="number">0.04522972</span>,</span><br><span class="line">          <span class="number">0.0272699</span> ,  <span class="number">0.0243898</span> ,  <span class="number">0.06140181</span>,  <span class="number">0.06140181</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(alphas[alphas &gt; <span class="number">0</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">if</span> alphas[i] &gt; <span class="number">0.0</span>: print(dataArr[i], labelArr[i])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">[<span class="number">3.542485</span>, <span class="number">1.977398</span>] <span class="number">-1.0</span></span><br><span class="line">[<span class="number">2.114999</span>, <span class="number">-0.004466</span>] <span class="number">-1.0</span></span><br><span class="line">[<span class="number">8.127113</span>, <span class="number">1.274372</span>] <span class="number">1.0</span></span><br><span class="line">[<span class="number">4.658191</span>, <span class="number">3.507396</span>] <span class="number">-1.0</span></span><br><span class="line">[<span class="number">8.197181</span>, <span class="number">1.545132</span>] <span class="number">1.0</span></span><br><span class="line">[<span class="number">7.40786</span>, <span class="number">-0.121961</span>] <span class="number">1.0</span></span><br><span class="line">[<span class="number">6.960661</span>, <span class="number">-0.245353</span>] <span class="number">1.0</span></span><br><span class="line">[<span class="number">6.080573</span>, <span class="number">0.418886</span>] <span class="number">1.0</span></span><br><span class="line">[<span class="number">3.107511</span>, <span class="number">0.758367</span>] <span class="number">-1.0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;常数C一方面要保障所有样例的间隔不小于1.0，另一方面又要使得分类间隔要尽可能大，并且要在这两方面之间平衡。如果C很大，那么分类器就会将力图通过分隔超平面对多有的样例都正确分类。这种优化结果如下图，很明显，支持向量变多了。如果数据集非线性可分，就会发现支持向量会在超平面附近聚集成团。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171009201631147?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="分类测试"><a href="#分类测试" class="headerlink" title="分类测试"></a>分类测试</h2><p>好了，终于可以拿我们计算出来的alpha值进行分类了。首先必须基于alpha值得到超平面，这也包括了w的计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcWs</span><span class="params">(alphas, dataArr, classLabels)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	计算W</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		alphas：数据向量</span></span><br><span class="line"><span class="string">				dataArr：数据集</span></span><br><span class="line"><span class="string">				classLabels：类别标签</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	w：w*x+b中的w</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化参数</span></span><br><span class="line">	X = mat(dataArr); labelMat = mat(classLabels).transpose()</span><br><span class="line">	<span class="comment">#获取数据行列值</span></span><br><span class="line">	m,n = shape(X)</span><br><span class="line">	<span class="comment">#初始化w</span></span><br><span class="line">	w = zeros((n,<span class="number">1</span>))</span><br><span class="line">	<span class="comment">#遍历alpha，更新w</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		w += multiply(alphas[i]*labelMat[i],X[i,:].T)</span><br><span class="line">	<span class="comment">#返回w值</span></span><br><span class="line">	<span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码中最重要的就是for循环，实现多个数的乘积。虽然for循环遍历了数据集中的所有数据，但是最终起作用的只有支持向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(svmMLiA)</span><br><span class="line">&lt;module <span class="string">'svmMLiA'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws = svmMLiA.calcWs(alphas, dataArr, labelArr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ws</span><br><span class="line">array([[ <span class="number">0.65307162</span>],</span><br><span class="line">       [<span class="number">-0.17196128</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datMat = mat(dataArr)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datMat[<span class="number">0</span>]* mat(ws)+b</span><br><span class="line">matrix([[<span class="number">-0.92555695</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labelArr[<span class="number">0</span>]</span><br><span class="line"><span class="number">-1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datMat[<span class="number">1</span>]* mat(ws)+b</span><br><span class="line">matrix([[<span class="number">-1.36706674</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labelArr[<span class="number">1</span>]</span><br><span class="line"><span class="number">-1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datMat[<span class="number">2</span>]* mat(ws)+b</span><br><span class="line">matrix([[ <span class="number">2.30436336</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labelArr[<span class="number">2</span>]</span><br><span class="line"><span class="number">1.0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上面的测试中，计算值大于0属于1类，小于0属于-1类。</p>
<p>&emsp;&emsp;至此，线性分类器介绍完了，如果数据集非线性可分，那么我们就需要引入核函数的概念了，下一篇将进行介绍。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之支持向量机（2）简化版SMO</title>
    <url>/folder/2019/11/08/2017-11-05-ml-15/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch06" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch06</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;SVM有很多实现，但我们只关注其中最流行的一种实现，即序列最小优化（ Sequential MInimal Optimization，SMO ）算法。</p>
<p>&emsp;&emsp;下面我们就开始讨论SMO算法，本篇博文先给出一个简化的版本，以便我们能够正确理解它的工作流程。</p>
<h2 id="Platt的SMO算法"><a href="#Platt的SMO算法" class="headerlink" title="Platt的SMO算法"></a>Platt的SMO算法</h2><p>&emsp;&emsp;1996年，伟大的John Platt发布了一个称为SMO的强大算法，用于训练SVM。Platt的SMO算法是将大优化问题分解为多个小优化问题来求解的。这些小优化问题往往很容易求解，并且对它们进行顺序来求解的结果与将他们作为整体来求解的结果是完全一致的，但是求解时间却大大缩短。</p>
<p>&emsp;&emsp;SMO算法的目标是求出一系列alpha和b，一旦求出了这些alpha，就很容易计算出权重向量w并得到分隔超平面。</p>
<p>&emsp;&emsp;SMO的工作原理是：每次循环中选择两个alpha进行优化处理。一旦找到一对合适的alpha，那么就增大其中一个同时减小另一个。这里所谓的“合适”就是指两个alpha必须要符合一定的条件，条件之一就是这两个alpha必须要在间隔边界之外，另一个条件则是这两个alpha还没有进行过区间化处理或者不在边界上。</p>
<h2 id="应用简化版SMO算法处理小规模数据集"><a href="#应用简化版SMO算法处理小规模数据集" class="headerlink" title="应用简化版SMO算法处理小规模数据集"></a>应用简化版SMO算法处理小规模数据集</h2><p>&emsp;&emsp;Platt SMO算法中的外循环确定要优化的最佳alpha对。而简化版会跳过这一部分，首先在数据集上遍历每一个alpha，然后在剩下的alpha集合中随机选择另一个alpha来构成alpha对。这里有一点相当重要，就是我们要同时改变两个alpha，因为我们需要满足一个约束条件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\sum \alpha_i · label^&#123;(i)&#125; = 0</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于改变一个alpha可能会导致该约束条件失效，因为需要同时改变两个alpha，一增一减，改变的量相同。</p>
<p>&emsp;&emsp;在实现简化版SMO之前，我们需要先构造几个辅助函数。打开文本编辑器，将下面的代码加入svmMLiA.py中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Date    : 2017-09-21 21:02:51</span></span><br><span class="line"><span class="comment"># @Author  : WordZzzz (wordzzzz@foxmail.com)</span></span><br><span class="line"><span class="comment"># @Link    : http://blog.csdn.net/u011475210</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">(fileName)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	加载数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		fileName：数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	dataMat：数据矩阵</span></span><br><span class="line"><span class="string">				labelMat：类别标签矩阵</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化数据列表</span></span><br><span class="line">	dataMat = []</span><br><span class="line">	<span class="comment">#初始化标签列表</span></span><br><span class="line">	labelMat = []</span><br><span class="line">	<span class="comment">#打开文件</span></span><br><span class="line">	fr = open(fileName)</span><br><span class="line">	<span class="comment">#遍历每一行数据，读取数据和标签</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">		<span class="comment">#strip删除头尾空白字符，然后再进行分割</span></span><br><span class="line">		lineArr = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">		<span class="comment">#填充数据集</span></span><br><span class="line">		dataMat.append([float(lineArr[<span class="number">0</span>]), float(lineArr[<span class="number">1</span>])])</span><br><span class="line">		<span class="comment">#填充类别标签</span></span><br><span class="line">		labelMat.append(float(lineArr[<span class="number">2</span>]))</span><br><span class="line">	<span class="comment">#返回数据集和标签列表</span></span><br><span class="line">	<span class="keyword">return</span> dataMat, labelMat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectJrand</span><span class="params">(i, m)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	随机选择</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		i：alpha下标</span></span><br><span class="line"><span class="string">				m：alpha数目</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	j：随机选择的alpha下标</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化下标j</span></span><br><span class="line">	j = i</span><br><span class="line">	<span class="comment">#随机化产生j，直到不等于i</span></span><br><span class="line">	<span class="keyword">while</span> (j == i):</span><br><span class="line">		j = int(random.uniform(<span class="number">0</span>,m))</span><br><span class="line">	<span class="comment">#返回j的值</span></span><br><span class="line">	<span class="keyword">return</span> j</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clipAlpha</span><span class="params">(aj, H, L)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	设定alpha阈值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		aj：alpha的值</span></span><br><span class="line"><span class="string">				H：alpha的最大值</span></span><br><span class="line"><span class="string">				L：alpha的最小值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	aj：处理后的alpha的值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#如果输入alpha的值大于最大值，则令aj=H</span></span><br><span class="line">	<span class="keyword">if</span> aj &gt; H:</span><br><span class="line">		aj = H</span><br><span class="line">	<span class="comment">#如果输入alpha的值小于最小值，则令aj=L</span></span><br><span class="line">	<span class="keyword">if</span> L &gt; aj:</span><br><span class="line">		aj = L</span><br><span class="line">	<span class="comment">#返回处理后的alpha的值</span></span><br><span class="line">	<span class="keyword">return</span> aj</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先是我们熟悉的老哥loadDataSet()，用来打开文件并对其进行解析，从而得到每行的类别标签和整个数据矩阵；然后是selectJrand()，用来随机选择第二个alpha的下标（只要和第一个alpha下标不一样就行）；最后一个是clipAlpha()函数，用于设定阈值，限制alpha的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(svmMLiA)</span><br><span class="line">&lt;module <span class="string">'svmMLiA'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dataArr, labelArr = svmMLiA.loadDataSet(<span class="string">'testSet.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labelArr</span><br><span class="line">[<span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>, <span class="number">-1.0</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;简化版SMO伪代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建一个alpha向量并将其初始化为0向量</span><br><span class="line">当迭代次数小于最大迭代次数时（外循环）：</span><br><span class="line">    对数据集中的每个数据向量（内循环）：</span><br><span class="line">        如果该数据向量可以被优化：</span><br><span class="line">            随机选择另外一个数据向量</span><br><span class="line">            同时优化这两个向量</span><br><span class="line">            如果两个向量都不能被优化，退出内循环</span><br><span class="line">    如果所有向量都没被优化，则增加迭代数目，继续下一次循环</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下述代码是SMO算法中的一个有效版本，如果看不懂，可以先找SVM的公式推导看看。打开文本编辑器，将下面的代码加入svmMLiA.py中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smoSimple</span><span class="params">(dataMatIn, classLabels, C, toler, maxIter)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	简化版SMO算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据集</span></span><br><span class="line"><span class="string">				classLabels：类别标签</span></span><br><span class="line"><span class="string">				C：常数C</span></span><br><span class="line"><span class="string">				toler：容错率</span></span><br><span class="line"><span class="string">				maxIter：最大的循环次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	b：常数项</span></span><br><span class="line"><span class="string">				alphas：数据向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#将输入的数据集和类别标签转换为NumPy矩阵</span></span><br><span class="line">	dataMatrix = mat(dataMatIn); labelMat = mat(classLabels).transpose()</span><br><span class="line">	<span class="comment">#初始化常数项b，初始化行列数m、n</span></span><br><span class="line">	b = <span class="number">0</span>; m,n = shape(dataMatrix)</span><br><span class="line">	<span class="comment">#初始化alphas数据向量为0向量</span></span><br><span class="line">	alphas = mat(zeros((m,<span class="number">1</span>)))</span><br><span class="line">	<span class="comment">#初始化iter变量，存储的是在没有任何alpha改变的情况下遍历数据集的次数</span></span><br><span class="line">	iter = <span class="number">0</span></span><br><span class="line">	<span class="comment">#外循环，当迭代次数小于maxIter时执行</span></span><br><span class="line">	<span class="keyword">while</span> (iter &lt; maxIter):</span><br><span class="line">		<span class="comment">#alpha改变标志位每次都要初始化为0</span></span><br><span class="line">		alphaPairsChanged = <span class="number">0</span></span><br><span class="line">		<span class="comment">#内循环，遍历所有数据集</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">			<span class="comment">#multiply将alphas和labelMat进行矩阵相乘，求出法向量w(m,1),w`(1,m)</span></span><br><span class="line">			<span class="comment">#dataMatrix * dataMatrix[i,:].T，求出输入向量x(m,1)</span></span><br><span class="line">			<span class="comment">#整个对应输出公式f(x)=w`x + b</span></span><br><span class="line">			fXi = float(multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[i,:].T)) + b</span><br><span class="line">			<span class="comment">#计算误差</span></span><br><span class="line">			Ei = fXi - float(labelMat[i])</span><br><span class="line">			<span class="comment">#如果标签与误差相乘之后在容错范围之外，且超过各自对应的常数值，则进行优化</span></span><br><span class="line">			<span class="keyword">if</span> ((labelMat[i]*Ei &lt; -toler) <span class="keyword">and</span> (alphas[i] &lt; C)) <span class="keyword">or</span> ((labelMat[i] * Ei &gt; toler) <span class="keyword">and</span> (alphas[i] &gt; <span class="number">0</span>)):</span><br><span class="line">				<span class="comment">#随机化选择另一个数据向量</span></span><br><span class="line">				j = selectJrand(i, m)</span><br><span class="line">				<span class="comment">#对此向量进行同样的计算</span></span><br><span class="line">				fXj = float(multiply(alphas, labelMat).T * (dataMatrix * dataMatrix[j,:].T)) + b</span><br><span class="line">				<span class="comment">#计算误差</span></span><br><span class="line">				Ej = fXj - float(labelMat[j])</span><br><span class="line">				<span class="comment">#利用copy存储刚才的计算值，便于后期比较</span></span><br><span class="line">				alphaIold = alphas[i].copy(); alpahJold = alphas[j].copy()</span><br><span class="line">				<span class="comment">#保证alpha在0和C之间</span></span><br><span class="line">				<span class="keyword">if</span> (labelMat[i] != labelMat[j]):</span><br><span class="line">					L = max(<span class="number">0</span>, alphas[j] - alphas[i])</span><br><span class="line">					H = min(C, C + alphas[j] - alphas[i])</span><br><span class="line">				<span class="keyword">else</span>:</span><br><span class="line">					L = max(<span class="number">0</span>, alphas[j] + alphas[i] - C)</span><br><span class="line">					H = min(C, alphas[j] + alphas[i])</span><br><span class="line">				<span class="comment">#如果界限值相同，则不做处理直接跳出本次循环</span></span><br><span class="line">				<span class="keyword">if</span> L == H: print(<span class="string">"L == H"</span>); <span class="keyword">continue</span></span><br><span class="line">				<span class="comment">#最优修改量，求两个向量的内积（核函数）</span></span><br><span class="line">				eta = <span class="number">2.0</span> * dataMatrix[i,:] * dataMatrix[j,:].T - dataMatrix[i,:] * dataMatrix[i,:].T - dataMatrix[j,:] * dataMatrix[j,:].T</span><br><span class="line">				<span class="comment">#如果最优修改量大于0，则不做处理直接跳出本次循环，这里对真实SMO做了简化处理</span></span><br><span class="line">				<span class="keyword">if</span> eta &gt;= <span class="number">0</span>: print(<span class="string">"eta &gt;= 0"</span>); <span class="keyword">continue</span></span><br><span class="line">				<span class="comment">#计算新的alphas[j]的值</span></span><br><span class="line">				alphas[j] -= labelMat[j] * (Ei - Ej) / eta</span><br><span class="line">				<span class="comment">#对新的alphas[j]进行阈值处理</span></span><br><span class="line">				alphas[j] = clipAlpha(alphas[j], H, L)</span><br><span class="line">				<span class="comment">#如果新旧值差很小，则不做处理跳出本次循环</span></span><br><span class="line">				<span class="keyword">if</span> (abs(alphas[j] - alpahJold) &lt; <span class="number">0.00001</span>): print(<span class="string">"j not moving enough"</span>); <span class="keyword">continue</span></span><br><span class="line">				<span class="comment">#对i进行修改，修改量相同，但是方向相反</span></span><br><span class="line">				alphas[i] += labelMat[j] * labelMat[i] * (alpahJold - alphas[j])</span><br><span class="line">				<span class="comment">#新的常数项</span></span><br><span class="line">				b1 = b - Ei - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i,:] * dataMatrix[i,:].T - labelMat[i] * (alphas[j] - alpahJold) * dataMatrix[i,:] * dataMatrix[j,:].T</span><br><span class="line">				b2 = b - Ej - labelMat[i] * (alphas[i] - alphaIold) * dataMatrix[i,:] * dataMatrix[j,:].T - labelMat[j] * (alphas[j] - alpahJold) * dataMatrix[j,:] * dataMatrix[j,:].T</span><br><span class="line">				<span class="comment">#谁在0到C之间，就听谁的，否则就取平均值</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="number">0</span> &lt; alphas[i]) <span class="keyword">and</span> (C &gt; alphas[i]): b = b1</span><br><span class="line">				<span class="keyword">elif</span> (<span class="number">0</span> &lt; alphas[j]) <span class="keyword">and</span> (C &gt; alphas[j]): b = b2</span><br><span class="line">				<span class="keyword">else</span>: b = (b1 + b2) / <span class="number">2.0</span></span><br><span class="line">				<span class="comment">#标志位加1</span></span><br><span class="line">				alphaPairsChanged += <span class="number">1</span></span><br><span class="line">				<span class="comment">#输出迭代次数，alphas的标号以及标志位的值</span></span><br><span class="line">				print(<span class="string">"iter: %d i: %d, pairs changed %d"</span> % (iter, i, alphaPairsChanged))</span><br><span class="line">		<span class="comment">#如果标志位没变，即没有进行优化，那么迭代值加1</span></span><br><span class="line">		<span class="keyword">if</span> (alphaPairsChanged == <span class="number">0</span>): iter += <span class="number">1</span></span><br><span class="line">		<span class="comment">#否则迭代值为0</span></span><br><span class="line">		<span class="keyword">else</span>: iter = <span class="number">0</span></span><br><span class="line">		<span class="comment">#打印迭代次数</span></span><br><span class="line">		print(<span class="string">"iteration number: %d"</span> % iter)</span><br><span class="line">	<span class="comment">#返回常数项和alphas的数据向量</span></span><br><span class="line">	<span class="keyword">return</span> b, alphas</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(svmMLiA)</span><br><span class="line">&lt;module <span class="string">'svmMLiA'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch06\\svmMLiA.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, alphas = svmMLiA.smoSimple(dataArr, labelArr, <span class="number">0.6</span>, <span class="number">0.001</span>, <span class="number">40</span>)</span><br><span class="line">iter: <span class="number">0</span> i: <span class="number">0</span>, pairs changed <span class="number">1</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iter: <span class="number">0</span> i: <span class="number">5</span>, pairs changed <span class="number">2</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iter: <span class="number">0</span> i: <span class="number">17</span>, pairs changed <span class="number">3</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iter: <span class="number">0</span> i: <span class="number">54</span>, pairs changed <span class="number">4</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">L == H</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">L == H</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iteration number: <span class="number">0</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iter: <span class="number">0</span> i: <span class="number">5</span>, pairs changed <span class="number">1</span></span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">iteration number: <span class="number">0</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iteration number: <span class="number">1</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iteration number: <span class="number">39</span></span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">j <span class="keyword">not</span> moving enough</span><br><span class="line">iteration number: <span class="number">40</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述过程可能需要几分钟才会收敛，一旦运行结束，我们就可以对结果进行查看：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">matrix([[<span class="number">-3.87260031</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alphas[alphas &gt; <span class="number">0</span>]</span><br><span class="line">matrix([[ <span class="number">0.10195497</span>,  <span class="number">0.25933768</span>,  <span class="number">0.0240785</span> ,  <span class="number">0.33721415</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>shape(alphas[alphas &gt; <span class="number">0</span>])</span><br><span class="line">(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line"><span class="meta">... </span>	<span class="keyword">if</span> alphas[i] &gt; <span class="number">0.0</span>: print(dataArr[i], labelArr[i])</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">[<span class="number">4.658191</span>, <span class="number">3.507396</span>] <span class="number">-1.0</span></span><br><span class="line">[<span class="number">3.457096</span>, <span class="number">-0.082216</span>] <span class="number">-1.0</span></span><br><span class="line">[<span class="number">5.286862</span>, <span class="number">-2.358286</span>] <span class="number">1.0</span></span><br><span class="line">[<span class="number">6.080573</span>, <span class="number">0.418886</span>] <span class="number">1.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;由于SMO算法的随机性，每次运行之后得到的结果不尽相同。alphas[alphas &gt; 0]命令是数组过滤的一个实例，得到仅仅包含大于0的值的矩阵，而且它只对NumPy类型有用，却并不适用于Python中的正则表。</p>
<p>&emsp;&emsp;我们在数据集上把这些支持向量画出来：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171009160736671?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;希望通过本篇博文，大家对SMO的工作流程有了一定得了解，至于完成版的SMO，WordZzzz将会在下一篇博文介绍给大家。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之支持向量机（1）算法概述</title>
    <url>/folder/2019/11/08/2017-11-05-ml-14/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch06" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch06</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;这两周把之前落下的公式推导恶补了一下，导致博客更新不及时。本系列博客涉及到的公式推导目前来看就两部分，一部分是logistic回归（最大熵问题也算在这里面了），一部分就是SVM（重头戏）。这两部分的公式我是都自己推导完了，但是还没整理成博客内容进行发布。我的博客都是先在小书匠上面做笔记，整理之后再发布的，但是由于公式推导部分之前全是手稿，码到小书匠上需要花费一定时间，加之最近项目催得紧，所以公式推导部分更新可能会滞后相当长的一段时间。但是，《机器学习实战》这本书的内容还是打算按照原计划进度更新下去。</p>
<p>&emsp;&emsp;有人说，支持向量机（ Support Vector Machines， SVM ）是最好的现成分类器，这里所谓的“现成”指的是分类器不加修改即可直接使用。同时，这就意味着在数据上应用基本形式 SVM 分类器就可以得到低错误率的结果。 SVM 能够对训练集之外的数据点做出很好的分类决策。</p>
<p>&emsp;&emsp;本篇博文主要讲述SVM的基本概念。</p>
<h2 id="基于最大间隔分隔数据"><a href="#基于最大间隔分隔数据" class="headerlink" title="基于最大间隔分隔数据"></a>基于最大间隔分隔数据</h2><p>支持向量机：</p>
<ul>
<li>优点：泛化错误率低，计算开销不大，结果易解释。</li>
<li>缺点：对参数调节和核函数的选择敏感，原始分类器不加修饰仅适用于处理二分类问题。</li>
<li>试用数据类型：数值型和标称型数据。</li>
</ul>
<p>&emsp;&emsp;在介绍SVM之前，先解释几个概念。来看看下面这堆数据，我们能否画出一条直线将圆形点和方形点分开？</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171008224923812?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;有点复杂？没关系，我们先来看看下图A中的两组数据，它们之间已经分隔得足够开，因此很容易就可以在图中画出一条直线将两组数据点分开。在这种情况下，这种数据被称为线性可分（ linearly separable ）数据。稍后当直线不能将数据点分开时，我们会对上述假设做一些修改。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171008224940599?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;上述将数据集分隔开来的直线称为分隔超平面（ separating hyperplane ）。上面的数据是二维的，所以此时分隔超平面就萎缩成一条直线了。如果数据时1024维的，那么就需要一个1023维的某某对象来对数据进行分隔。这个1023维的某某对象被称为超平面（ hyperplane ），也就是分类的决策边界。分布在超平面一侧的所有数据都属于某个类别，而分布在另一侧的所有数据则属于另一个类别。</p>
<p>&emsp;&emsp;我们再来看框B到框D中的三条直线，它们都能将数据分隔开，但是其中哪一个更好呢？是否应该最小化数据点到分隔超平面的平均距离来求最佳直线？如果是那样，是不是就意味着框B和框C就真的比框D中的直线好呢？有木有感觉有点寻找最佳拟合直线的感觉？是的，上述做法确实有点像直线拟合，但并非最佳方案。我们希望找到离分隔超平面最近的点，确保它们离分割面的距离尽可能远。这里点到分割面的距离被称为间隔（ margin ）。我们希望这个距离尽可能地大，这样鲁棒性比较好。</p>
<p>&emsp;&emsp;支持向量（ support vector ）就是离分隔超平面最近的那些点。接下来要试着最大化支持向量到分隔面的距离，需要找到此问题的优化求解方法。</p>
<h2 id="寻找最大间隔"><a href="#寻找最大间隔" class="headerlink" title="寻找最大间隔"></a>寻找最大间隔</h2><p>&emsp;&emsp;分隔超平面的形式可以携程$ w^Tx + b $。要计算点A到分隔超平面的距离，就必须给出点到分隔面的法线或垂线的长度，该值为$ |w^Tx + b| / \begin{Vmatrix} w \end{Vmatrix} $。这里的常数b类似于Logistic回归中的截距$w_0$。这里的向量w和常数b一起描述了所给数据的分隔线或超平面。接下来我们讨论分类器。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20171008225002114?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h3 id="分类器求解的优化问题"><a href="#分类器求解的优化问题" class="headerlink" title="分类器求解的优化问题"></a>分类器求解的优化问题</h3><p>&emsp;&emsp;理解分类器工作原理将有助于理解基于优化问题的分类器求解过程。输入数据给分类器会输出一个类别标签，这相当于一个类似于Sigmoid的函数在作用。下面将使用类似单位阶跃函数对$ w^Tx + b $作用得到$ f(w^Tx + b) $，其中当u &lt; 0时f(u)输出-1，反之输出+1。Logistic那里的类别标签是0或1。</p>
<p>&emsp;&emsp;这里的类别标签之所以采用-1或+1，是因为它们仅仅相差一个符号，方便数学上的处理。我们可以通过一个统一公式来表示间隔或者数据点到分隔超平面的距离，而不必担心数据到底属于哪一类。间隔通过$ label · (w^Tx + b) $来计算，这时就能体现出-1和+1类的好处了。如果数据点处于正方向（+1类），并且离分隔超平面很远的位置时，$ w^Tx + b $会是一个很大的正数，同时$ label · (w^Tx + b) $也会是一个很大的正数；同理，当数据点处于负方向（-1类）并且离分隔超平面很远的位置时，$ label · (w^Tx + b) $仍然是一个很大的正数。</p>
<p>&emsp;&emsp;现在的目标就是要找出分类器定义中的w和b。那么，我们就需要找到具有最小间隔的数据点（支持向量），然后对该间隔最大化。可以写作：</p>
<p>$$ arg max_{w,b}{min_n(label · (w^Tx + b)) · \frac{1}{\begin{Vmatrix} w \end{Vmatrix}}}$$</p>
<p>&emsp;&emsp;直接求解上述问题相当困难呐，对乘积进行优化是一种很鸡肋的事情啊，因此我们要做的是固定其中一个因子而最大化其他因子。如果令所有支持向量的$ label · (w^Tx + b) $都为1，那么就可以通过求$ \begin{Vmatrix} w \end{Vmatrix}^{-1} $的最大值来得到最终解。但是，只有那些离分隔超平面最近的点得到的值才为1，而离超平面越远的数据点，其$ label · (w^Tx + b) $的值就越大。</p>
<p>&emsp;&emsp;上述问题是一个带约束条件的最优化问题，这里的约束条件就是$ label · (w^Tx + b) \geq 1.0 $。对于这类优化问题，有一个非常著名的求解方法，即拉格朗日乘子法。这里的约束条件都是基于数据点的，因此我们可以将超平面写成数据点的形式。于是，优化目标函数最后可以写成：</p>
<p>$$ max_\alpha[\sum^m_{i=1}\alpha - \frac{1}{2} \sum^m_{i,j=1}label^{(i)}·label^{(j)}· \alpha_i·\alpha_j \left\langle x_{(i)},x_{(j)} \right\rangle ] $$</p>
<p>&emsp;&emsp;其约束条件为：</p>
<p>$$ \alpha \geq 0, \sum^m_{i-1}\alpha_i·label^{(i)} = 0 $$</p>
<p>&emsp;&emsp;一切都是那么完美，但是这里有个假设：数据必须100%线性可分。数据如果不干净了，我们就需要引入所谓的松弛变量（ slack variable ），来允许有些数据点可以处于分隔面的错误一侧。这样我们的优化目标就能保持仍然不变，但是约束条件更改为：</p>
<p>$$ C \geq \alpha \geq 0, \sum^m_{i-1}\alpha_i·label^{(i)} = 0 $$</p>
<p>&emsp;&emsp;这里的常数C常用于控制“最大化间隔”和“保证大部分点的函数间隔小于1.0”这两个目标的权重。我们可以通过调节C来得到不同的结果。一旦求出了所有的alpha，那么分隔超平面就可以通过这些alpha来表达。这一结论非常直接，SVM中的主要工作就是求解这些alpha，从而求出w，然后利用$ w^Tx + b $来分类。</p>
<h3 id="SVM应用的一般框架"><a href="#SVM应用的一般框架" class="headerlink" title="SVM应用的一般框架"></a>SVM应用的一般框架</h3><p>&emsp;&emsp;在kNN中，我们定义了构建机器学习应用的一般步骤，但是这些步骤会随着机器学习任务或算法的不同而有所改变，因此有必要在此探讨如何在本章中实现他们。</p>
<p>Logistic回归的一般过程：</p>
<ul>
<li>收集数据：采用任意方法收集数据。</li>
<li>准备数据：需要数值型数据</li>
<li>分析数据：有助于可视化分隔超平面。</li>
<li>训练算法：SVM的大部分时间都源自训练，该过程主要实现两个参数的调优。</li>
<li>测试算法：十分简单的计算过程就可以实现。</li>
<li>使用算法：几乎所有分类问题都可以使用SVM，值得一提的是，SVM本身是一个二分类分类器，对多类问题应用SVM需要对代码做一些修改。</li>
</ul>
<p>&emsp;&emsp;到目前为止，我们已经了解了SVM相关的概念，我们当然希望能够通过编程，在数据集上将这些理论付诸实践。下一节将介绍一个简单而又强大的实现算法—序列最小优化（ Sequential MInimal Optimization，SMO ）算法。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之朴素贝叶斯（4）从个人广告中获取区域倾向</title>
    <url>/folder/2019/11/08/2017-11-04-ml-13/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch04" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch04</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;书中的最后一个例子，是分别从美国的两个城市中选取一些人，通过分析这些人发布的征婚广告信息，来比较这两个城市的人们在广告用词上是否不同。如果结论确实是不同，那么他们各自的常用词是哪些？从人们的用词当中，我们能否对不同城市的人所关心的内容有所了解？</p>
<p>示例：使用朴素贝叶斯来发现地域相关的用词。</p>
<ul>
<li>收集数据：从RSS源收集内容，这里需要对RSS创建一个接口。</li>
<li>准备数据：将文本文件解析成词条向量。</li>
<li>分析数据：检查词条确保解析的正确性。</li>
<li>训练算法：使用我们之间建立的trainNB0()函数。</li>
<li>测试算法：观察错误率，确保分类器可用，可以修改切分程序，以降低错误率，提高分类结果。</li>
<li>使用算法：构建一个完整的程序，封装所有内容，给定两个RSS源，该程序会显示最常用的公共词。</li>
</ul>
<p>&emsp;&emsp;下面我们将使用来自不同城市的广告训练一个分类器，然后观察分类器的效果。注意，我们并不是要使用该分类器进行分类，而是通过观察单词和条件概率值来发现与特定城市相关的内容。</p>
<h2 id="收集数据：导入RSS源"><a href="#收集数据：导入RSS源" class="headerlink" title="收集数据：导入RSS源"></a>收集数据：导入RSS源</h2><p>&emsp;&emsp;第一件事当然就是要准备数据，我们可以Python下载文本。利用RSS，这些文本很容易得到。现在所需要的是一个RSS阅读器。Universal Feed Parser是Python中最常用的RSS程序库。你可以在<a href="http://code.google.com/p/feedparser/下浏览相关文档，然后和其他Python包一样来安装feedparser，即" target="_blank" rel="noopener">http://code.google.com/p/feedparser/下浏览相关文档，然后和其他Python包一样来安装feedparser，即</a> pip3 install feedparse。</p>
<p>书中使用的是Craigslist上的个人广告，当然希望是在服务条款允许的条件下。</p>
<h2 id="测试算法：RSS源分类器"><a href="#测试算法：RSS源分类器" class="headerlink" title="测试算法：RSS源分类器"></a>测试算法：RSS源分类器</h2><p>&emsp;&emsp;我们还是先来构建一个类似于spamTest()的函数来对测试过程自动化吧。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcMostFreq</span><span class="params">(vocabList, fullText)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	计算出现频率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		vocabList：词汇表</span></span><br><span class="line"><span class="string">				fullText：全部词汇</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	sortedFreq[:30]：出现频率最高的30个词</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">import</span> operator</span><br><span class="line">	freqDict = &#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> token <span class="keyword">in</span> vocabList:</span><br><span class="line">		freqDict[token] = fullText.count(token)</span><br><span class="line">	sortedFreq = sorted(freqDict.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">	<span class="keyword">return</span> sortedFreq[:<span class="number">30</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">localWords</span><span class="params">(feed1, feed0)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	RSS源分类器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		feed1：RSS源</span></span><br><span class="line"><span class="string">				feed0：RSS源</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	vocabList：词汇表</span></span><br><span class="line"><span class="string">				p0V：类别概率向量</span></span><br><span class="line"><span class="string">				p1V：类别概率向量</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">import</span> feedparser</span><br><span class="line">	<span class="comment">#初始化数据列表</span></span><br><span class="line">	docList = []; classList = []; fullText = []</span><br><span class="line">	minLen = min(len(feed1[<span class="string">'entries'</span>]), len(feed0[<span class="string">'entries'</span>]))</span><br><span class="line">	<span class="comment">#导入文本文件</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(minLen):</span><br><span class="line">		<span class="comment">#切分文本</span></span><br><span class="line">		wordList = textParse(feed1[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">		<span class="comment">#切分后的文本以原始列表形式加入文档列表</span></span><br><span class="line">		docList.append(wordList)</span><br><span class="line">		<span class="comment">#切分后的文本直接合并到词汇列表</span></span><br><span class="line">		fullText.extend(wordList)</span><br><span class="line">		<span class="comment">#标签列表更新</span></span><br><span class="line">		classList.append(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">#切分文本</span></span><br><span class="line">		wordList = textParse(feed0[<span class="string">'entries'</span>][i][<span class="string">'summary'</span>])</span><br><span class="line">		<span class="comment">#切分后的文本以原始列表形式加入文档列表</span></span><br><span class="line">		docList.append(wordList)</span><br><span class="line">		<span class="comment">#切分后的文本直接合并到词汇列表</span></span><br><span class="line">		fullText.extend(wordList)</span><br><span class="line">		<span class="comment">#标签列表更新</span></span><br><span class="line">		classList.append(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">#获得词汇表</span></span><br><span class="line">	vocabList = createVocabList(docList)</span><br><span class="line">	<span class="comment">#获得30个频率最高的词汇</span></span><br><span class="line">	top30Words = calcMostFreq(vocabList, fullText)</span><br><span class="line">	<span class="comment">#去掉出现次数最高的那些词</span></span><br><span class="line">	<span class="keyword">for</span> pairW <span class="keyword">in</span> top30Words:</span><br><span class="line">		<span class="keyword">if</span> pairW[<span class="number">0</span>] <span class="keyword">in</span> vocabList: vocabList.remove(pairW[<span class="number">0</span>])</span><br><span class="line">	trainingSet = range(<span class="number">2</span>*minLen); testSet = []</span><br><span class="line">	<span class="comment">#随机构建测试集，随机选取二十个样本作为测试样本，并从训练样本中剔除</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>):</span><br><span class="line">		<span class="comment">#随机得到Index</span></span><br><span class="line">		randIndex = int(random.uniform(<span class="number">0</span>, len(trainingSet)))</span><br><span class="line">		<span class="comment">#将该样本加入测试集中</span></span><br><span class="line">		testSet.append(trainingSet[randIndex])</span><br><span class="line">		<span class="comment">#同时将该样本从训练集中剔除</span></span><br><span class="line">		<span class="keyword">del</span>(trainingSet[randIndex])</span><br><span class="line">	<span class="comment">#初始化训练集数据列表和标签列表</span></span><br><span class="line">	trainMat = []; trainClasses = []</span><br><span class="line">	<span class="comment">#遍历训练集</span></span><br><span class="line">	<span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</span><br><span class="line">		<span class="comment">#词表转换到向量，并加入到训练数据列表中</span></span><br><span class="line">		trainMat.append(setOfWords2Vec(vocabList, docList[docIndex]))</span><br><span class="line">		<span class="comment">#相应的标签也加入训练标签列表中</span></span><br><span class="line">		trainClasses.append(classList[docIndex])</span><br><span class="line">	<span class="comment">#朴素贝叶斯分类器训练函数</span></span><br><span class="line">	p0V, p1V, pSpam = trainNB0(array(trainMat), array(trainClasses))</span><br><span class="line">	<span class="comment">#初始化错误计数</span></span><br><span class="line">	errorCount = <span class="number">0</span></span><br><span class="line">	<span class="comment">#遍历测试集进行测试</span></span><br><span class="line">	<span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">		<span class="comment">#词表转换到向量</span></span><br><span class="line">		wordVector = setOfWords2Vec(vocabList, docList[docIndex])</span><br><span class="line">		<span class="comment">#判断分类结果与原标签是否一致</span></span><br><span class="line">		<span class="keyword">if</span> classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]:</span><br><span class="line">			<span class="comment">#如果不一致则错误计数加1</span></span><br><span class="line">			errorCount += <span class="number">1</span></span><br><span class="line">			<span class="comment">#并且输出出错的文档</span></span><br><span class="line">			print(<span class="string">"classification error"</span>,docList[docIndex])</span><br><span class="line">	<span class="comment">#打印输出信息</span></span><br><span class="line">	print(<span class="string">'the erroe rate is: '</span>, float(errorCount)/len(testSet))</span><br><span class="line">	<span class="comment">#返回词汇表和两个类别概率向量</span></span><br><span class="line">	<span class="keyword">return</span> vocabList, p0V, p1V</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;上述代码类似于spamTest()，只不过添加了新的功能，引入calcMostFreq()来返回出现频率最高的30个单词，再狠心将他们剔除。当我们注释掉移除高频词的三行代码，会发现错误率提高了百分之二十左右。有趣的是，vocalList的大小约为3000个词，前30个高频词却占了30%，也就是说词汇表中的这一小部分单词，占据了所有文本用词的一大部分。产生这种现象的原因是语言中大部分都是冗余和结构辅助性内容，另一个常用的方法不仅移除高频词，同时从某个预定词表中移除结构上的辅助词。该词表为停用词表（stop word list），网上可以找到很多，例如<a href="http://www.ranks.nl/resources/stopwords.html。" target="_blank" rel="noopener">http://www.ranks.nl/resources/stopwords.html。</a></p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(bayes)</span><br><span class="line">&lt;module <span class="string">'bayes'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ny = feedparser.parse(<span class="string">'http://newyork.craiglist.org/stp/index.rss'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sf = feedparser.parse(<span class="string">'http://sfbay.craiglist.org/stp/index.rss'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vocabList, pSF, pNY = bayes.localWords(ny, sf)</span><br><span class="line">the erroe rate <span class="keyword">is</span>:  <span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vocabList, pSF, pNY = bayes.localWords(ny, sf)</span><br><span class="line">the erroe rate <span class="keyword">is</span>:  <span class="number">0.35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vocabList, pSF, pNY = bayes.localWords(ny, sf)</span><br><span class="line">the erroe rate <span class="keyword">is</span>:  <span class="number">0.5</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要注意的是RSS源要在函数外导入，因为网站上的RSS源会随着时间而改变。<br>&emsp;&emsp;为了得到错误率的精确估计，应该多次进行上述实验，然后取平均值。这里的错误率很高，但是我们关注的是单词概率而不是实际分类，因此这个问题倒不严重，可以改变要移除的单词数目，然后观察错误率的变化。</p>
<h2 id="分析数据：显示地域性相关单词"><a href="#分析数据：显示地域性相关单词" class="headerlink" title="分析数据：显示地域性相关单词"></a>分析数据：显示地域性相关单词</h2><p>&emsp;&emsp;可以先对pSF和pNY进行排序，然后按照顺序将词打印出来。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTopWords</span><span class="params">(ny, sf)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	最具表征性的词汇显示函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		ny：RSS源</span></span><br><span class="line"><span class="string">				sf：RSS源</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	打印信息</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">import</span> operator</span><br><span class="line">	<span class="comment">#RSS源分类器返回概率</span></span><br><span class="line">	vocabList, p0V, p1V=localWords(ny, sf)</span><br><span class="line">	<span class="comment">#初始化列表</span></span><br><span class="line">	topNY = []; topSF = []</span><br><span class="line">	<span class="comment">#设定阈值，返回大于阈值的所有词，如果输出信息很多，就提高一下阈值</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(len(p0V)):</span><br><span class="line">		<span class="keyword">if</span> p0V[i] &gt; <span class="number">-4.5</span> : topSF.append((vocabList[i], p0V[i]))</span><br><span class="line">		<span class="keyword">if</span> p1V[i] &gt; <span class="number">-4.5</span> : topNY.append((vocabList[i], p1V[i]))</span><br><span class="line">	<span class="comment">#排序</span></span><br><span class="line">	sortedSF = sorted(topSF, key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">	print(<span class="string">"SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**"</span>)</span><br><span class="line">	<span class="comment">#打印</span></span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> sortedSF:</span><br><span class="line">		print(item[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">#排序</span></span><br><span class="line">	sortedNY = sorted(topNY, key=<span class="keyword">lambda</span> pair: pair[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">	print(<span class="string">"NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**"</span>)</span><br><span class="line">	<span class="comment">#打印</span></span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> sortedNY:</span><br><span class="line">		print(item[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以通过调节阈值的大小来改变输出量的多少，记住这里的阈值时取自然对数之后的概率哦，所以是负数。</p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(bayes)</span><br><span class="line">&lt;module <span class="string">'bayes'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.getTopWords(ny,sf)</span><br><span class="line">the erroe rate <span class="keyword">is</span>:  <span class="number">0.45</span></span><br><span class="line">SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**SF**</span><br><span class="line">very</span><br><span class="line">let</span><br><span class="line">hello</span><br><span class="line">email</span><br><span class="line">sure</span><br><span class="line">was</span><br><span class="line">enjoy</span><br><span class="line">new</span><br><span class="line">well</span><br><span class="line">dates</span><br><span class="line">walk</span><br><span class="line">NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**NY**</span><br><span class="line">down</span><br><span class="line">them</span><br><span class="line">girl</span><br><span class="line">times</span><br><span class="line">great</span><br><span class="line">what</span><br><span class="line">feet</span><br><span class="line">most</span><br><span class="line">been</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;值得注意的是程序输出了大量的停用词，有兴趣的同学可以试着把停用词去掉，然后看看分类错误率会不会降低。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>&emsp;&emsp;对于分类而言，使用概率有时要比使用硬规则更为有效，贝叶斯概率及贝叶斯准则提供了一种利用已知值来估计未知概率的有效方法。尽管条件独立性假设并不正确，但是朴素贝叶斯仍然是一种有效的分类器。</p>
<p>&emsp;&emsp;朴素贝叶斯：</p>
<ul>
<li>优点：在数据较少的情况下仍然有效，可以处理多类别问题。</li>
<li>缺点：对于输入数据的准备方式较为敏感。</li>
<li>适用数据类型：标称型数据。</li>
</ul>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之朴素贝叶斯（3）过滤垃圾邮件</title>
    <url>/folder/2019/11/08/2017-11-04-ml-12/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch04" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch04</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;使用朴素贝叶斯解决一些现实生活的问题时，需要先从文本内容得到字符串列表，然后生成词向量。下面这个例子中，我们将了解朴素贝叶斯的一个最著名的应用：电子邮件垃圾过滤。</p>
<p>示例：使用朴素贝叶斯对电子邮件进行分类</p>
<ul>
<li>收集数据：提供文本文件。</li>
<li>准备数据：将文本文件解析成词条向量。</li>
<li>分析数据：检查词条确保解析的正确性。</li>
<li>训练算法：使用我们之前建立的trainNB0()函数。</li>
<li>测试算法：使用calssifyNB()，并且构建一个新的测试函数来计算文档集的错误率。</li>
<li>使用算法：构建一个完整的程序对一组文档进行分类，将错分的文档输出。</li>
</ul>
<h2 id="准备数据：切分文本"><a href="#准备数据：切分文本" class="headerlink" title="准备数据：切分文本"></a>准备数据：切分文本</h2><p>&emsp;&emsp;先前的次向量都是我们预先给定的，这次将介绍如何从文本文档中构建自己的词列表。对于一个文本字符串，可以使用Python的string.split()方法将其切分。</p>
<p>string.split()的使用详解，请打开传送门：<a href="http://blog.csdn.net/u011475210/article/details/77925994" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/77925994</a></p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">textParse</span><span class="params">(bigString)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	切分文本</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		bigString：输入字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	[*]：切分后的字符串列表</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="keyword">import</span> re</span><br><span class="line">	<span class="comment">#利用正则表达式，来切分句子，其中分隔符是除单词、数字外的任意字符串</span></span><br><span class="line"></span><br><span class="line">	listOfTokens = re.split(<span class="string">r'\W*'</span>, bigString)</span><br><span class="line">	<span class="comment">#返回切分后的字符串列表</span></span><br><span class="line">	<span class="keyword">return</span> [tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Python中有一些内嵌的方法，可以将字符串全部转换成小写（.lower()）或者大写（.upper()），借助这些方法可以达到目的。程序的最后一行就是用的这种方法。同时，如果某些文件包含一些URL（<a href="http://docs.google.com/support/bin/answer.py?hl=en&amp;answer=66343），例如ham下的6.txt，那么切分文本时就会出现很多单词，如py、hl，很显然这些都是没用的，所以我们在程序最后一行只输出长度大于2的词条，好机智哦！" target="_blank" rel="noopener">http://docs.google.com/support/bin/answer.py?hl=en&amp;answer=66343），例如ham下的6.txt，那么切分文本时就会出现很多单词，如py、hl，很显然这些都是没用的，所以我们在程序最后一行只输出长度大于2的词条，好机智哦！</a></p>
<h2 id="测试算法：使用朴素贝叶斯进行交叉验证"><a href="#测试算法：使用朴素贝叶斯进行交叉验证" class="headerlink" title="测试算法：使用朴素贝叶斯进行交叉验证"></a>测试算法：使用朴素贝叶斯进行交叉验证</h2><p>&emsp;&emsp;下面我们将文本解析器集成到一个完整的分类器中。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spamTest</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	贝叶斯垃圾邮件分类器</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	float(errorCount)/len(testSet)：错误率</span></span><br><span class="line"><span class="string">				vocabList：词汇表</span></span><br><span class="line"><span class="string">				fullText：文档中全部单词</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#初始化数据列表</span></span><br><span class="line">	docList = []; classList = []; fullText = []</span><br><span class="line">	<span class="comment">#导入文本文件</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">26</span>):</span><br><span class="line">		<span class="comment">#切分文本</span></span><br><span class="line">		wordList = textParse(open(<span class="string">'email/spam/%d.txt'</span> % i).read())</span><br><span class="line">		<span class="comment">#切分后的文本以原始列表形式加入文档列表</span></span><br><span class="line">		docList.append(wordList)</span><br><span class="line">		<span class="comment">#切分后的文本直接合并到词汇列表</span></span><br><span class="line">		fullText.extend(wordList)</span><br><span class="line">		<span class="comment">#标签列表更新</span></span><br><span class="line">		classList.append(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">#切分文本</span></span><br><span class="line">		<span class="comment">#print('i = :', i)</span></span><br><span class="line">		wordList = textParse(open(<span class="string">'email/ham/%d.txt'</span> % i).read())</span><br><span class="line">		<span class="comment">#切分后的文本以原始列表形式加入文档列表</span></span><br><span class="line">		docList.append(wordList)</span><br><span class="line">		<span class="comment">#切分后的文本直接合并到词汇列表</span></span><br><span class="line">		fullText.extend(wordList)</span><br><span class="line">		<span class="comment">#标签列表更新</span></span><br><span class="line">		classList.append(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">#创建一个包含所有文档中出现的不重复词的列表</span></span><br><span class="line">	vocabList = createVocabList(docList)</span><br><span class="line">	<span class="comment">#初始化训练集和测试集列表</span></span><br><span class="line">	trainingSet = list(range(<span class="number">50</span>)); testSet = []</span><br><span class="line">	<span class="comment">#随机构建测试集，随机选取十个样本作为测试样本，并从训练样本中剔除</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">		<span class="comment">#随机得到Index</span></span><br><span class="line">		randIndex = int(random.uniform(<span class="number">0</span>, len(trainingSet)))</span><br><span class="line">		<span class="comment">#将该样本加入测试集中</span></span><br><span class="line">		testSet.append(trainingSet[randIndex])</span><br><span class="line">		<span class="comment">#同时将该样本从训练集中剔除</span></span><br><span class="line">		<span class="keyword">del</span>(trainingSet[randIndex])</span><br><span class="line">	<span class="comment">#初始化训练集数据列表和标签列表</span></span><br><span class="line">	trainMat = []; trainClasses = []</span><br><span class="line">	<span class="comment">#遍历训练集</span></span><br><span class="line">	<span class="keyword">for</span> docIndex <span class="keyword">in</span> trainingSet:</span><br><span class="line">		<span class="comment">#词表转换到向量，并加入到训练数据列表中</span></span><br><span class="line">		trainMat.append(setOfWords2Vec(vocabList, docList[docIndex]))</span><br><span class="line">		<span class="comment">#相应的标签也加入训练标签列表中</span></span><br><span class="line">		trainClasses.append(classList[docIndex])</span><br><span class="line">	<span class="comment">#朴素贝叶斯分类器训练函数</span></span><br><span class="line">	p0V, p1V, pSpam = trainNB0(array(trainMat), array(trainClasses))</span><br><span class="line">	<span class="comment">#初始化错误计数</span></span><br><span class="line">	errorCount = <span class="number">0</span></span><br><span class="line">	<span class="comment">#遍历测试集进行测试</span></span><br><span class="line">	<span class="keyword">for</span> docIndex <span class="keyword">in</span> testSet:</span><br><span class="line">		<span class="comment">#词表转换到向量</span></span><br><span class="line">		wordVector = setOfWords2Vec(vocabList, docList[docIndex])</span><br><span class="line">		<span class="comment">#判断分类结果与原标签是否一致</span></span><br><span class="line">		<span class="keyword">if</span> classifyNB(array(wordVector), p0V, p1V, pSpam) != classList[docIndex]:</span><br><span class="line">			<span class="comment">#如果不一致则错误计数加1</span></span><br><span class="line">			errorCount += <span class="number">1</span></span><br><span class="line">			<span class="comment">#并且输出出错的文档</span></span><br><span class="line">			print(<span class="string">"classification error"</span>,docList[docIndex])</span><br><span class="line">	<span class="comment">#打印输出信息</span></span><br><span class="line">	print(<span class="string">'the erroe rate is: '</span>, float(errorCount)/len(testSet))</span><br><span class="line">	<span class="comment">#返回词汇表和全部单词列表</span></span><br><span class="line">	<span class="comment">#return vocabList, fullText</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.spamTest()</span><br><span class="line">the erroe rate <span class="keyword">is</span>:  <span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.spamTest()</span><br><span class="line">the erroe rate <span class="keyword">is</span>:  <span class="number">0.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.spamTest()</span><br><span class="line">classification error [<span class="string">'home'</span>, <span class="string">'based'</span>, <span class="string">'business'</span>, <span class="string">'opportunity'</span>, <span class="string">'knocking'</span>, <span class="string">'your'</span>, <span class="string">'door'</span>, <span class="string">'don抰'</span>, <span class="string">'rude'</span>, <span class="string">'and'</span>, <span class="string">'let'</span>, <span class="string">'this'</span>, <span class="string">'chance'</span>, <span class="string">'you'</span>, <span class="string">'can'</span>, <span class="string">'earn'</span>, <span class="string">'great'</span>, <span class="string">'income'</span>, <span class="string">'and'</span>, <span class="string">'find'</span>, <span class="string">'your'</span>, <span class="string">'financial'</span>, <span class="string">'life'</span>, <span class="string">'transformed'</span>, <span class="string">'learn'</span>, <span class="string">'more'</span>, <span class="string">'here'</span>, <span class="string">'your'</span>, <span class="string">'success'</span>, <span class="string">'work'</span>, <span class="string">'from'</span>, <span class="string">'home'</span>, <span class="string">'finder'</span>, <span class="string">'experts'</span>]</span><br><span class="line">classification error [<span class="string">'scifinance'</span>, <span class="string">'now'</span>, <span class="string">'automatically'</span>, <span class="string">'generates'</span>, <span class="string">'gpu'</span>, <span class="string">'enabled'</span>, <span class="string">'pricing'</span>, <span class="string">'risk'</span>, <span class="string">'model'</span>, <span class="string">'source'</span>, <span class="string">'code'</span>, <span class="string">'that'</span>, <span class="string">'runs'</span>, <span class="string">'300x'</span>, <span class="string">'faster'</span>, <span class="string">'than'</span>, <span class="string">'serial'</span>, <span class="string">'code'</span>, <span class="string">'using'</span>, <span class="string">'new'</span>, <span class="string">'nvidia'</span>, <span class="string">'fermi'</span>, <span class="string">'class'</span>, <span class="string">'tesla'</span>, <span class="string">'series'</span>, <span class="string">'gpu'</span>, <span class="string">'scifinance'</span>, <span class="string">'derivatives'</span>, <span class="string">'pricing'</span>, <span class="string">'and'</span>, <span class="string">'risk'</span>, <span class="string">'model'</span>, <span class="string">'development'</span>, <span class="string">'tool'</span>, <span class="string">'that'</span>, <span class="string">'automatically'</span>, <span class="string">'generates'</span>, <span class="string">'and'</span>, <span class="string">'gpu'</span>, <span class="string">'enabled'</span>, <span class="string">'source'</span>, <span class="string">'code'</span>, <span class="string">'from'</span>, <span class="string">'concise'</span>, <span class="string">'high'</span>, <span class="string">'level'</span>, <span class="string">'model'</span>, <span class="string">'specifications'</span>, <span class="string">'parallel'</span>, <span class="string">'computing'</span>, <span class="string">'cuda'</span>, <span class="string">'programming'</span>, <span class="string">'expertise'</span>, <span class="string">'required'</span>, <span class="string">'scifinance'</span>, <span class="string">'automatic'</span>, <span class="string">'gpu'</span>, <span class="string">'enabled'</span>, <span class="string">'monte'</span>, <span class="string">'carlo'</span>, <span class="string">'pricing'</span>, <span class="string">'model'</span>, <span class="string">'source'</span>, <span class="string">'code'</span>, <span class="string">'generation'</span>, <span class="string">'capabilities'</span>, <span class="string">'have'</span>, <span class="string">'been'</span>, <span class="string">'significantly'</span>, <span class="string">'extended'</span>, <span class="string">'the'</span>, <span class="string">'latest'</span>, <span class="string">'release'</span>, <span class="string">'this'</span>, <span class="string">'includes'</span>]</span><br><span class="line">the erroe rate <span class="keyword">is</span>:  <span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;函数spamTest()会输出在10封随机选择的电子邮件上的分类错误率。因为是随机的，所以每次输出结果可能有些差别。所以如果想要更好的估计错误率，就需要多次重复求平均值。</p>
<h2 id="报错信息汇总"><a href="#报错信息汇总" class="headerlink" title="报错信息汇总"></a>报错信息汇总</h2><p>运行报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(bayes)</span><br><span class="line">&lt;module <span class="string">'bayes'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.spamTest()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"E:\机器学习实战\mycode\Ch04\bayes.py"</span>, line <span class="number">221</span>, <span class="keyword">in</span> spamTest</span><br><span class="line">    wordList = textParse(open(<span class="string">'email/ham/%d.txt'</span> % i).read())</span><br><span class="line">UnicodeDecodeError: <span class="string">'gbk'</span> codec can<span class="string">'t decode byte 0xae in position 199: illegal multibyte sequence</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;一看就是编码问题，所以在程序中加入了打印信息，想看看是哪个文档读取出了问题，最后发现数据集ham下第23个文本中有不能识别的字符（®），修改之后程序运转正常。如果从我的github上下载的数据集，那就大可放心，不会出现这种问题的。</p>
<p>报错文档：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SciFinance now automatically generates GPU-enabled pricing &amp; risk model source code that runs up to <span class="number">50</span><span class="number">-300</span>x faster than serial code using a new NVIDIA Fermi-<span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> 20-<span class="title">Series</span> <span class="title">GPU</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">SciFinance® is a derivatives pricing and risk model development tool that automatically generates C/C++ and GPU-enabled source code from concise, high-level model specifications. No parallel computing or CUDA programming expertise is required.</span><br><span class="line"></span><br><span class="line">SciFinance<span class="string">'s automatic, GPU-enabled Monte Carlo pricing model source code generation capabilities have been significantly extended in the latest release. This includes:</span></span><br></pre></td></tr></table></figure>

<p>运行报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(bayes)</span><br><span class="line">&lt;module <span class="string">'bayes'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.spamTest()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"E:\机器学习实战\mycode\Ch04\bayes.py"</span>, line <span class="number">239</span>, <span class="keyword">in</span> spamTest</span><br><span class="line">    <span class="keyword">del</span>(trainingSet[randIndex])</span><br><span class="line">TypeError: <span class="string">'range'</span> object doesn<span class="string">'t support item deletion</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;range()函数报错，这里主要涉及到python版本问题，详情请打开传送门：<a href="http://blog.csdn.net/u011475210/article/details/77925697" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/77925697</a></p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之朴素贝叶斯（2）使用Python进行文本分类</title>
    <url>/folder/2019/11/08/2017-11-04-ml-11/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch04" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch04</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;要从文本中获取特征，需要先拆分文本。这里的特征是来自文本的词条（token），一个词条是字符的任意组合。可以把词条想象为单词，也可以使用非单词词条，如URL、IP地址或者任意其他字符串。然后将一个文本片段表示为一个词向量，其中值为1表示词条出现，0表示词条未出现。</p>
<p>&emsp;&emsp;以在线社区的留言板为例，为了不影响社区的发展，我们要屏蔽侮辱性的言论，所以要构建一个快速过滤器，如果某条留言使用了负面或者侮辱性的言语，那么就将该留言表示为内容不当。过滤这类内容是一个很常见的需求。对此问题建立两个类别：侮辱类和非侮辱类，使用1和0分别表示。</p>
<p>&emsp;&emsp;本文主要利用Python实现文本分类。</p>
<h2 id="准备数据：从文本中构建词向量"><a href="#准备数据：从文本中构建词向量" class="headerlink" title="准备数据：从文本中构建词向量"></a>准备数据：从文本中构建词向量</h2><p>&emsp;&emsp;我们将把文本看成单词向量或者词条向量，也就是说将句子转换为向量。打开文本编辑器，创建一个叫bayes.py的新文件，用如下代码实现构建词向量。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Sep 08, 2017</span></span><br><span class="line"><span class="string">Naive Bayes</span></span><br><span class="line"><span class="string">@author: wordzzzz</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	创建实验样本</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	postingList：词条切分后的文档集合</span></span><br><span class="line"><span class="string">				classVec：类别标签的集合</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#词条切分后的文档集合</span></span><br><span class="line">	postingList=[[<span class="string">'my'</span>, <span class="string">'dog'</span>, <span class="string">'has'</span>, <span class="string">'flea'</span>, <span class="string">'problems'</span>, <span class="string">'help'</span>, <span class="string">'please'</span>],</span><br><span class="line">				[<span class="string">'maybe'</span>, <span class="string">'not'</span>, <span class="string">'take'</span>, <span class="string">'him'</span>, <span class="string">'to'</span>, <span class="string">'dog'</span>, <span class="string">'park'</span>, <span class="string">'stupid'</span>],</span><br><span class="line">				[<span class="string">'my'</span>, <span class="string">'dalmation'</span>, <span class="string">'is'</span>, <span class="string">'so'</span>, <span class="string">'cute'</span>, <span class="string">'I'</span>, <span class="string">'love'</span>, <span class="string">'him'</span>],</span><br><span class="line">				[<span class="string">'stop'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'worthless'</span>, <span class="string">'garbage'</span>],</span><br><span class="line">				[<span class="string">'mr'</span>, <span class="string">'licks'</span>, <span class="string">'ate'</span>, <span class="string">'my'</span>, <span class="string">'steak'</span>, <span class="string">'how'</span>, <span class="string">'to'</span>, <span class="string">'stop'</span>, <span class="string">'him'</span>],</span><br><span class="line">				[<span class="string">'quit'</span>, <span class="string">'buying'</span>, <span class="string">'worthless'</span>, <span class="string">'dog'</span>, <span class="string">'food'</span>, <span class="string">'stupid'</span>]]</span><br><span class="line">	<span class="comment">#类别标签的集合</span></span><br><span class="line">	classVec = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]    <span class="comment">#1 is abusive, 0 not</span></span><br><span class="line">	<span class="comment">#词条切分后的文档集合和类别标签结合</span></span><br><span class="line">	<span class="keyword">return</span> postingList,classVec</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createVocabList</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	创建一个包含所有文档中出现的不重复词的列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		dataSet：数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	list(vocabSet)：返回一个包含所有文档中出现的不重复词的列表</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#创建一个空集</span></span><br><span class="line">	vocabSet = set([])</span><br><span class="line">	<span class="comment">#将新词集合添加到创建的集合中</span></span><br><span class="line">	<span class="keyword">for</span> document <span class="keyword">in</span>  dataSet:</span><br><span class="line">		<span class="comment">#操作符 | 用于求两个集合的并集</span></span><br><span class="line">		vocabSet = vocabSet | set(document)</span><br><span class="line">	<span class="comment">#返回一个包含所有文档中出现的不重复词的列表</span></span><br><span class="line">	<span class="keyword">return</span> list(vocabSet)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setOfWords2Vec</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	词表到向量的转换</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		vocabList：词汇表</span></span><br><span class="line"><span class="string">				inputSet：某个文档</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	returnVec：文档向量</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#创建一个所含元素都为0的向量</span></span><br><span class="line">	returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">	<span class="comment">#遍历文档中词汇</span></span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">		<span class="comment">#如果文档中的单词在词汇表中，则相应向量位置置1</span></span><br><span class="line">		<span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">			returnVec[vocabList.index(word)] = <span class="number">1</span></span><br><span class="line">		<span class="comment">#否则输出打印信息</span></span><br><span class="line">		<span class="keyword">else</span>: print(<span class="string">"the word: %s is not in my Vocablary!"</span> % word)</span><br><span class="line">	<span class="comment">#向量的每一个元素为1或0，表示词汇表中的单词在文档中是否出现</span></span><br><span class="line">	<span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先命令行生成词汇表，程序中巧妙地运用了Python的set数据类型，通过并集运算，可以生成一个包含所有文档中出现的不重复词的列表。</p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bayes</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listOPosts, listClasses = bayes.loadDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myVocabList = bayes.createVocabList(listOPosts)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myVocabList</span><br><span class="line">[<span class="string">'mr'</span>, <span class="string">'cute'</span>, <span class="string">'please'</span>, <span class="string">'to'</span>, <span class="string">'steak'</span>, <span class="string">'worthless'</span>, <span class="string">'not'</span>, <span class="string">'how'</span>, <span class="string">'so'</span>, <span class="string">'I'</span>, <span class="string">'stop'</span>, <span class="string">'ate'</span>, <span class="string">'buying'</span>, <span class="string">'help'</span>, <span class="string">'has'</span>, <span class="string">'maybe'</span>, <span class="string">'dog'</span>, <span class="string">'him'</span>, <span class="string">'flea'</span>, <span class="string">'posting'</span>, <span class="string">'stupid'</span>, <span class="string">'is'</span>, <span class="string">'food'</span>, <span class="string">'garbage'</span>, <span class="string">'take'</span>, <span class="string">'park'</span>, <span class="string">'my'</span>, <span class="string">'quit'</span>, <span class="string">'licks'</span>, <span class="string">'dalmation'</span>, <span class="string">'love'</span>, <span class="string">'problems'</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;检查上述词表，就会发现这里不会出现重复的单词。目前该词表并没有进行排序，需要的话稍后可以对其排序。<br>然后看一下setOfWords2Vec的运行效果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.setOfWords2Vec(myVocabList, listOPosts[<span class="number">0</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.setOfWords2Vec(myVocabList, listOPosts[<span class="number">3</span>])</span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;该函数使用词汇表或者想要检查的所有单词作为输入，然后为其中每一个单词构建一个特征。我们来看对listOPosts[0]（[‘my’, ‘dog’, ‘has’, ‘flea’, ‘problems’, ‘help’, ‘please’]）进行词条转换输出的结果，可以看到第三个元素值为1，即词汇表中对应的please这个单词在listOPosts[0]中，事实也确实如此。</p>
<h2 id="训练算法：从词向量计算概率"><a href="#训练算法：从词向量计算概率" class="headerlink" title="训练算法：从词向量计算概率"></a>训练算法：从词向量计算概率</h2><p>&emsp;&emsp;前面介绍了如何将一组单词转换为一组数字，现在我们就开始使用这些数字计算概率。我们把上篇文章的贝叶斯准则再掏出来，讲之前的x、y替换为w。w表示这是一个向量，即它由多个数值组成。在这个例子中，数值个数与词汇表中的词个数相同。</p>
<p>$$ P(c_i | w) = \frac {P(w | c_i)P(c_i)} {P(w)} $$</p>
<p>&emsp;&emsp;使用上述公式，对每个类计算该值，然后比较这两个概率值的大小。首先通过类别i（侮辱性留言或者非侮辱性留言）中文档数除以总的文档数来计算概率$ P(c_i) $。接下来计算$ P(w | c_i) $，这里就用到了贝叶斯假设。如果将w展开为一个个独立特征，那么就可以将上述概率写作$P(w_0, w_1, w_2, ···w_N|c_i)$。这里假设所有词都互相独立，就是我们之前提到的naive的条件独立性假设，这意味着我们可以使用$P(w_0|c_i)P(w_1|c_i)P(w_2|c_i)…P(w_N|c_i)$来计算上述概率，就算起来so easy!</p>
<p>&emsp;&emsp;写个伪代码大概就是这么个意思：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算每个类别中的文档数目</span><br><span class="line">对每篇训练文档：</span><br><span class="line">    对每个类别：</span><br><span class="line">        如果词条出现在文档中，则增加该词条的计数</span><br><span class="line">        增加所有词条的计数值</span><br><span class="line">对每个类别：</span><br><span class="line">    对每个词条：</span><br><span class="line">        将该词条的数目除以总词条数目得到条件概率</span><br><span class="line">返回每个类别的条件概率</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面的代码使用了NumPy的一些函数，故应确保将from numpy import *语句添加到bayes.py文件的最前面。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">trainNB0</span><span class="params">(trainMatrix, trainCategory)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	朴素贝叶斯分类器训练函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		trainMatrix：文档矩阵</span></span><br><span class="line"><span class="string">				trainCategory：类别标签向量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	p0Vect：非侮辱性词汇概率向量</span></span><br><span class="line"><span class="string">				p1Vect：侮辱性词汇概率向量</span></span><br><span class="line"><span class="string">				pAbusive：侮辱性文档概率</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#获得训练集中文档个数</span></span><br><span class="line">	numTrainDocs = len(trainMatrix)</span><br><span class="line">	<span class="comment">#获得训练集中单词个数</span></span><br><span class="line">	numWords = len(trainMatrix[<span class="number">0</span>])</span><br><span class="line">	<span class="comment">#计算文档属于侮辱性文档的概率</span></span><br><span class="line">	pAbusive = sum(trainCategory)/float(numTrainDocs)</span><br><span class="line">	<span class="comment">#初始化概率的分子变量</span></span><br><span class="line">	p0Num = zeros(numWords); p1Num = zeros(numWords)</span><br><span class="line">	<span class="comment">#初始化概率的分母变量</span></span><br><span class="line">	p0Denom = <span class="number">0.0</span>; p1Denom = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">#遍历训练集trainMatrix中所有文档</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(numTrainDocs):</span><br><span class="line">		<span class="comment">#如果侮辱性词汇出现，则侮辱词汇计数加一，且文档的总词数加一</span></span><br><span class="line">		<span class="keyword">if</span> trainCategory[i] ==<span class="number">1</span>:</span><br><span class="line">			p1Num += trainMatrix[i]</span><br><span class="line">			p1Denom += sum(trainMatrix[i])</span><br><span class="line">		<span class="comment">#如果非侮辱性词汇出现，则非侮辱词汇计数加一，且文档的总词数加一</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			p0Num += trainMatrix[i]</span><br><span class="line">			p0Denom += sum(trainMatrix[i])</span><br><span class="line">	<span class="comment">#对每个元素做除法求概率</span></span><br><span class="line">	p1Vect = p1Num/p1Denom</span><br><span class="line">	p0Vect = p0Num/p0Denom</span><br><span class="line">	<span class="comment">#返回两个类别概率向量和一个概率</span></span><br><span class="line">	<span class="keyword">return</span> p0Vect, p1Vect, pAbusive</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(bayes)</span><br><span class="line">&lt;module <span class="string">'bayes'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listOPosts, listClasses = bayes.loadDataSet()       <span class="comment">#从预先加载值中调入数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myVocabList = bayes.createVocabList(listOPosts)     <span class="comment">#构建一个包含所有值得词汇表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trainMat = []                                       <span class="comment">#利用for循环来填充trainMat列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line"><span class="meta">... </span>    trainMat.append(bayes.setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p0V, p1V, pAb = bayes.trainNB0(trainMat, listClasses)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pAb                                                 <span class="comment">#任意侮辱性文档的概率</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p0V</span><br><span class="line">array([ <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,</span><br><span class="line">        <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,  <span class="number">0.</span>        ,  <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.04166667</span>,  <span class="number">0.08333333</span>,  <span class="number">0.04166667</span>,  <span class="number">0.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.04166667</span>,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.125</span>     ,  <span class="number">0.</span>        ,  <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>,</span><br><span class="line">        <span class="number">0.04166667</span>,  <span class="number">0.04166667</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1V</span><br><span class="line">array([ <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.05263158</span>,  <span class="number">0.</span>        ,</span><br><span class="line">        <span class="number">0.10526316</span>,  <span class="number">0.05263158</span>,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,</span><br><span class="line">        <span class="number">0.05263158</span>,  <span class="number">0.</span>        ,  <span class="number">0.05263158</span>,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,</span><br><span class="line">        <span class="number">0.05263158</span>,  <span class="number">0.10526316</span>,  <span class="number">0.05263158</span>,  <span class="number">0.</span>        ,  <span class="number">0.05263158</span>,</span><br><span class="line">        <span class="number">0.15789474</span>,  <span class="number">0.</span>        ,  <span class="number">0.05263158</span>,  <span class="number">0.05263158</span>,  <span class="number">0.05263158</span>,</span><br><span class="line">        <span class="number">0.05263158</span>,  <span class="number">0.</span>        ,  <span class="number">0.05263158</span>,  <span class="number">0.</span>        ,  <span class="number">0.</span>        ,</span><br><span class="line">        <span class="number">0.</span>        ,  <span class="number">0.</span>        ])</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;首先，我们发现文档属于侮辱类的概率pAb为0.5，该值是正确定。词汇表中的第一个词是cute，其在类别0中出现一次，在类别1中从未出现，对应的条件概率分别为0.44166667和0.0。该计算是正确的。</p>
<h2 id="测试算法：根据现实情况修改分类器"><a href="#测试算法：根据现实情况修改分类器" class="headerlink" title="测试算法：根据现实情况修改分类器"></a>测试算法：根据现实情况修改分类器</h2><p>&emsp;&emsp;利用贝叶斯分类器对文档进行分类时，要计算过个概率的乘积以获得文档属于某个类别的概率，如果其中一个概率值为0，那么最后的乘积也为0。为降低这种影响，可以将所有词的出现数初始化为1，并将分母初始化为2。所以需要修改一下trainNB()中的分母分子初始化代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#初始化概率的分子变量</span><br><span class="line">p0Num = ones(numWords); p1Num = ones(numWords)</span><br><span class="line">#初始化概率的分母变量</span><br><span class="line">p0Denom = 2.0; p1Denom = 2.0</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;另一个遇到的问题就是下溢出，太多的很小数相乘，导致程序向下溢出或者得不到正确的答案（比如四舍五入后乘积为0）。一种解决办法就是对乘积取自然对数。即<code>!$ln(a*b) = ln(a) + ln(b)$</code>，于是通过求对数可以避免下溢出或者浮点数舍入导致的错误。我们可以放心的是，采用自然对数处理不会有任何损失。下图给出了函数f(x)和ln(f(x))的曲线。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170910153516173?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&emsp;&emsp;检查这两条曲线，就会发现他们在相同区域内同时增加或者减少，并且在相同点上取到极值。取值虽然不同，但是不影响最终结果。所以需要修改一下trainNB()中的求概率代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#对每个元素做除法求概率</span><br><span class="line">p1Vect = log(p1Num/p1Denom)</span><br><span class="line">p0Vect = log(p0Num/p0Denom)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面构建朴素贝叶斯分类函数和测试函数：</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyNB</span><span class="params">(vec2Classify, p0Vec, p1Vec, pClass1)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	朴素贝叶斯分类函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		vec2Classify：文档矩阵</span></span><br><span class="line"><span class="string">				p0Vec：非侮辱性词汇概率向量</span></span><br><span class="line"><span class="string">				p1Vec：侮辱性词汇概率向量</span></span><br><span class="line"><span class="string">				pClass1：侮辱性文档概率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	1：侮辱性文档</span></span><br><span class="line"><span class="string">				0：非侮辱性文档</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#向量元素相乘后求和再加到类别的对数概率上，等价于概率相乘</span></span><br><span class="line">	p1 = sum(vec2Classify * p1Vec) + log(pClass1)</span><br><span class="line">	p0 = sum(vec2Classify * p0Vec) + log(<span class="number">1.0</span> - pClass1)</span><br><span class="line">	<span class="comment">#分类结果</span></span><br><span class="line">	<span class="keyword">if</span> p1 &gt; p0:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">testingNB</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	朴素贝叶斯分类器测试函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	testEntry：测试词汇列表</span></span><br><span class="line"><span class="string">				classifyNB(thisDoc, p0V, p1V, pAb)：分类结果</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#从预先加载中调入数据</span></span><br><span class="line">	listOPosts, listClasses = loadDataSet()</span><br><span class="line">	<span class="comment">#构建一个包含所有词的列表</span></span><br><span class="line">	myVocabList = createVocabList(listOPosts)</span><br><span class="line">	<span class="comment">#初始化训练数据列表</span></span><br><span class="line">	trainMat = []</span><br><span class="line">	<span class="comment">#填充训练数据列表</span></span><br><span class="line">	<span class="keyword">for</span> postinDoc <span class="keyword">in</span> listOPosts:</span><br><span class="line">		trainMat.append(setOfWords2Vec(myVocabList, postinDoc))</span><br><span class="line">	<span class="comment">#训练</span></span><br><span class="line">	p0V, p1V, pAb = trainNB0(trainMat, listClasses)</span><br><span class="line">	<span class="comment">#测试</span></span><br><span class="line">	testEntry = [<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>]</span><br><span class="line">	thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">	print(testEntry,<span class="string">'classified as: '</span>, classifyNB(thisDoc, p0V, p1V, pAb))</span><br><span class="line">	<span class="comment">#测试</span></span><br><span class="line">	testEntry = [<span class="string">'stupid'</span>, <span class="string">'garbage'</span>]</span><br><span class="line">	thisDoc = array(setOfWords2Vec(myVocabList, testEntry))</span><br><span class="line">	print(testEntry,<span class="string">'classified as: '</span>, classifyNB(thisDoc, p0V, p1V, pAb))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(bayes)</span><br><span class="line">&lt;module <span class="string">'bayes'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch04\\bayes.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bayes.testingNB()</span><br><span class="line">[<span class="string">'love'</span>, <span class="string">'my'</span>, <span class="string">'dalmation'</span>] classified <span class="keyword">as</span>:  <span class="number">0</span></span><br><span class="line">[<span class="string">'stupid'</span>, <span class="string">'garbage'</span>] classified <span class="keyword">as</span>:  <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;大家可以对输入文本做一下修改，看看分类器会输出什么结果。这个例子非常简单，但是它展示了朴素贝叶斯分类器的工作原理。接下来我们可以对代码做一些修改，使分类器工作得更好。</p>
<h2 id="准备数据：文档词袋模型"><a href="#准备数据：文档词袋模型" class="headerlink" title="准备数据：文档词袋模型"></a>准备数据：文档词袋模型</h2><p>&emsp;&emsp;我们将每个词的出现与否作为一个特征，可以被描述为词集模型（set-of-words model）。如果一个词在文档中出现不止一次，这可能意味着包含该词是否出现在文档中所不能表达的某些信息，这种方法被称为词袋模型（bag-of-words model）。词袋中的单词可以出现多次，而在词集中，每个单词只能出现一次。下面的程序给出了基于词袋模型的朴素贝叶斯代码，。它与函数setOfWords2Vec()几乎完全相同，唯一不同的是每当遇到一个单词时，它会增加词向量中的对应值，而不只是将对应的数值设为1。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bagOfWords2VecMN</span><span class="params">(vocabList, inputSet)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	词袋到向量的转换</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		vocabList：词袋</span></span><br><span class="line"><span class="string">				inputSet：某个文档</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	returnVec：文档向量</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#创建一个所含元素都为0的向量</span></span><br><span class="line">	returnVec = [<span class="number">0</span>]*len(vocabList)</span><br><span class="line">	<span class="comment">#将新词集合添加到创建的集合中</span></span><br><span class="line">	<span class="keyword">for</span> word <span class="keyword">in</span> inputSet:</span><br><span class="line">		<span class="comment">#如果文档中的单词在词汇表中，则相应向量位置加1</span></span><br><span class="line">		<span class="keyword">if</span> word <span class="keyword">in</span> vocabList:</span><br><span class="line">			returnVec[vocabList.index(word)] += <span class="number">1</span></span><br><span class="line">	<span class="comment">#返回一个包含所有文档中出现的词的列表</span></span><br><span class="line">	<span class="keyword">return</span> returnVec</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之朴素贝叶斯（1）算法概述</title>
    <url>/folder/2019/11/08/2017-11-04-ml-10/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch04" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch04</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;本周WordZzzz学习了朴素贝叶斯（naive Bayes）。朴素贝叶斯是基于贝叶斯定理与特征条件独立假设的分类方法，对于给定的训练数据集，首先基于特征条件独立假设学习输入/输出的联合概率分布，然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。朴素贝叶斯发实现简单，学习与预测的效率都很高，是一种常用的方法。</p>
<h2 id="基于贝叶斯决策理论的分类方法"><a href="#基于贝叶斯决策理论的分类方法" class="headerlink" title="基于贝叶斯决策理论的分类方法"></a>基于贝叶斯决策理论的分类方法</h2><p>&emsp;&emsp;朴素贝叶斯：</p>
<ul>
<li>优点：在数据较少的情况下仍然有效，可以处理多类别问题。</li>
<li>缺点：对于输入数据的准备方式较为敏感。</li>
<li>适用数据类型：标称型数据。</li>
</ul>
<p>&emsp;&emsp;朴素贝叶斯是贝叶斯决策理论的一部分，所以在此之前我们有必要快速了解一下贝叶斯决策理论。</p>
<p>&emsp;&emsp;假设现在我们有一个数据集，它由两类数据组成，数据分布如下图所示。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170909224840023?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&emsp;&emsp;假设WordZzzz找到了描述图中两类数据的统计参数。现在用P1(x,y)表示数据点(x,y)属于类别1（图中用原点表示的类别）的概率，用P2(x,y)表示数据点(x,y)属于类别2（图中用三角形表示的类别）的概率，那么对于一个新数据点(x,y)，可以用下面的规则来判断它的类别：</p>
<ul>
<li>如果P1(x,y) &gt; P2(x,y)，那么类别为1.</li>
<li>如果P1(x,y) &lt; P2(x,y)，那么类别为2.</li>
</ul>
<p>&emsp;&emsp;也即是说，我们会选择该概率对应的类别。这就是贝叶斯决策理论的核心思想，即选择具有最高概率的决策。</p>
<p>&emsp;&emsp;回到上图，如果图中的整个数据使用6个浮点数来表示，并且计算类别概率的Python代码只有两行，那么你会更加倾向于使用下面哪种方法来对该数据点进行分类？</p>
<ul>
<li>(1)使用第一章的kNN，进行1000次距离计算；</li>
<li>(2)使用第二章的决策树，分别沿x轴、y轴划分数据；</li>
<li>(3)计算数据点属于每个类别的概率，并进行比较。</li>
</ul>
<p>&emsp;&emsp;使用决策树不会非常成功；而和简单的概率计算相比，kNN的计算量太大。因此，对于上述问题，最佳选择是使用刚才提到的概率比较方法。</p>
<p>&emsp;&emsp;这里使用的概率解释属于贝叶斯概率理论的范畴，该理论非常流行且效果良好，贝叶斯概率以18世纪的以为神学家Thomas Bayes的名字命名。贝叶斯概率引入先验知识和逻辑推理来处理不确定命题。另一种概率解释称为频数概率，他只从数据本身获得结论，并不考虑逻辑推理及先验知识。</p>
<h2 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h2><p>&emsp;&emsp;接下来讲讲概率和条件概率。还好，就一两个公式。</p>
<p>&emsp;&emsp;假设现在有一个装了7块石头的罐子，其中3块是灰色的，4块是黑色的，如下图所示。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170909224900451?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="400" height="200" /></div>
<p></p>

<p>&emsp;&emsp;如果从罐子里随机抽取一块石头，那么是灰色石头的可能性是多少？很显然，灰色石头概率3/7，黑色石头概率4/7。我们使用P(gray)来表示取到灰色石头的概率，其概率值可以通过灰色石头数目除以总数目来得到。</p>
<p>&emsp;&emsp;如果这7块石头放在两个桶里，如下图所示，那么上述概率如何计算？</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170909224951714?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="300" /></div>
<p></p>

<p>&emsp;&emsp;要计算$P(gray)$或者$P(black)$，事先得到石头所在桶的信息会不会改变结果？假定计算的是从B桶中取到灰色石头的概率，这个概率记作$P(gray | bucketB)$，我们称之为“在已知石头出自B桶的条件下，取出灰色石头的概率”。不难的到$P(gray | bucketA)$的值为2/4，$P(gray | bucketB)$的值为1/3。</p>
<p>&emsp;&emsp;条件概率的计算公式如下所示：</p>
<p>$$P(gray | bucketB) = P(gray and bucketB)/P(bucketB)$$</p>
<p>&emsp;&emsp;首先，用B桶中灰色石头的个数除以两个桶中的总石头数，得到$P(gray and bucketB)=1/7$。其次，由于B桶中有三块石头，而总石头数为7，于是$P(bucketB)=3/7$。于是有$P(gray|bucketB) = P(gray and bucketB)/P(bucketB) = (1/7)/(3/7) = 1/3$。这个公式虽然对于简单例子来说有点复杂，因为像WordZzzz一样的大部分明眼人一眼就能看出结果而没必要使用公式，但是当存在更多特征时，这个公式是非常有效的。用代数方法计算条件概率时，该公式也很有用。</p>
<p>&emsp;&emsp;另一种有效计算条件概率的方法被称为贝叶斯准则。贝叶斯准则告诉我们如何交换条件概率中的条件和结果，即如果已知P(x|c)，要求P(x|c)，那么可以使用下面的计算方法：</p>
<p>$$ P(c|x) = \frac {p(x|c)p(c)} {p(x)} $$</p>
<p>&emsp;&emsp;知道条件概率怎么算之后，接下来的问题就是如何将其应用到分类器中。接下来，我们将讨论如何结合贝叶斯决策理论使用条件概率。</p>
<h2 id="使用条件概率来分类"><a href="#使用条件概率来分类" class="headerlink" title="使用条件概率来分类"></a>使用条件概率来分类</h2><p>&emsp;&emsp;贝叶斯决策理论要求计算两个概率P1(x,y)和P2(x,y)：</p>
<ul>
<li><input disabled="" type="checkbox"> 如果$P1(x,y) &gt; P2(x,y)$，那么属于类别1；</li>
<li><input disabled="" type="checkbox"> 如果$P1(x,y) &lt; P2(x,y)$，那么属于类别2。</li>
</ul>
<p>&emsp;&emsp;但这两个准则并不是贝叶斯决策理论的所有内容，使用P1()和P2()只是为了尽可能简化描述，而真正需要计算和比较的是$P(c_1|x,y)$和$P(c_2|x,y)$。这些符号所代表的具体意义是：给定某个由x、y表示的数据点，那么该数据点来自类别$c_1$的概率是多少？数据点来自类别$c_2$的概率又是多少？注意这些概率与刚才给出的概率$P(x,y|c_1)$并不一样，不过可以使用贝叶斯准则来交换概率中条件与结果。具体地，应用贝叶斯准则得到：</p>
<p>$$ P(c_i|x,y) = \frac {p(x,y|c_i)p(c_i)} {p(x,y)} $$</p>
<p>&emsp;&emsp;使用这些定义，可以定义贝叶斯分类准则为：</p>
<ul>
<li><input disabled="" type="checkbox"> 如果$P1(c_i|x,y) &gt; P2(c_i|x,y)$，那么属于类别1；</li>
<li><input disabled="" type="checkbox"> 如果$P1(c_i|x,y) &lt; P2(c_i|x,y)$，那么属于类别2。</li>
</ul>
<p>&emsp;&emsp;使用贝叶斯准则，可以通过已知的三个概率值来计算未知的概率值。下一篇就会给出利用贝叶斯准则来计算概率并对数据进行分类的代码。</p>
<h2 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h2><p>&emsp;&emsp;大家要是对贝叶斯定理不是很理解的话，可以看看这部分内容（摘自中文维基百科：<a href="https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86）。" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86）。</a></p>
<p>&emsp;&emsp;贝叶斯定理是关于随机事件A和B的条件概率的一则定理。<br>$${\displaystyle P(A|B)={\frac {P(B|A),P(A)}{P(B)}}}$$<br>其中P(A|B)是在B发生的情况下A发生的可能性。<br>&emsp;&emsp;在贝叶斯定理中，每个名词都有约定俗成的名称：</p>
<ul>
<li>[  ] P(A|B)是已知B发生后A的条件概率，也由于得自B的取值而被称作A的后验概率。</li>
<li><input disabled="" type="checkbox"> P(B|A)是已知A发生后B的条件概率，也由于得自A的取值而被称作B的后验概率。</li>
<li><input disabled="" type="checkbox"> P(A)是A的先验概率（或边缘概率）。之所以称为”先验”是因为它不考虑任何B方面的因素。</li>
<li><input disabled="" type="checkbox"> P(B)是B的先验概率或边缘概率。</li>
</ul>
<p>&emsp;&emsp;按这些术语，贝叶斯定理可表述为：</p>
<ul>
<li><input disabled="" type="checkbox"> 后验概率 = (相似度*先验概率)/标准化常量</li>
</ul>
<p>&emsp;&emsp;也就是说，后验概率与先验概率和相似度的乘积成正比。<br>&emsp;&emsp;另外，比例P(B|A)/P(B)也有时被称作标准相似度（standardised likelihood），贝叶斯定理可表述为：</p>
<ul>
<li><input disabled="" type="checkbox"> 后验概率 = 标准相似度*先验概率</li>
</ul>
<p>胰腺癌检测：</p>
<p>&emsp;&emsp;基于贝叶斯定理：即使100%的胰腺癌症患者都有某症状，而某人有同样的症状，绝对不代表该人有100%的概率得胰腺癌，还需要考虑先验概率，假设胰腺癌的发病率是十万分之一，而全球有同样症状的人有万分之一，则此人得胰腺癌的概率只有十分之一，90%的可能是是假阳性。</p>
<p>恐怖分子检测：</p>
<p>&emsp;&emsp;基于贝叶斯定理：假设100%的恐怖分子都相信A宗教，而某人相信A宗教，并不代表此人100%是恐怖分子，还需要考虑先验概率，假设全球有6万恐怖分子，在人类中的概率是十万分之一（假设人类有60亿人），假设全球有1/3的人口相信A宗教（20亿人信A宗教），则此人是恐怖分子的概率只有十万分之三。</p>
<h2 id="使用朴素贝叶斯进行文档分类"><a href="#使用朴素贝叶斯进行文档分类" class="headerlink" title="使用朴素贝叶斯进行文档分类"></a>使用朴素贝叶斯进行文档分类</h2><p>&emsp;&emsp;机器学习的一个重要应用就是文档的自动分类。在文档分类中，整个文档是实例，而电子邮件中的某些元素则构成特征。虽然电子邮件是一种会不断增加的文本，但我们同样可以对新闻报道、用户留言、政府公文等其他任意类型的文本进行分类。朴素贝叶斯是贝叶斯分类器的一个扩展，是用于文档分类的常用算法。</p>
<p>朴素贝叶斯的一般流程：</p>
<ul>
<li>收集数据：可以使用任何方法，本章使用RSS源。</li>
<li>准备数据：准备数值型或者布尔型数据。</li>
<li>分析数据：有大量特征时，绘制特征作用不大，此时使用直方图效果更好。</li>
<li>训练算法：计算不同的独立特征的条件概率。</li>
<li>测试算法：计算错误率。</li>
<li>使用算法：一个常见的朴素贝叶斯应用是文档分类。可以在任意的分类场景中使用朴素贝叶斯分类器，不一定非要是文本。</li>
</ul>
<p>&emsp;&emsp;由统计学知，如果每个特征需要N个样本，那么对于10个特征将需要$N^{10}$个样本，对于包含1000个特征的词汇表将需要$N^{1000}$个样本。吓我一跳，所需要的样本数会随着特征数目增大而迅速增长。</p>
<p>&emsp;&emsp;如果特征之间相互独立，那么样本数就可以减少到1000*N，所谓独立指的是统计意义上的独立，即一个特征或者单词出现的可能性与它和其他单词相邻没有关系，但是我们知道这种假设并不正确。这个假设正式朴素贝叶斯分类器中朴素（naive，天真！）一词的含义。朴素贝叶斯分类器中的另一个假设是，每个特征同等重要。其实这个假设也有问题。如果要判断留言是否得当，那么可能不需要看完所有的1000个单词，而只需要看10-20个就够了。尽管上述假设存在一些瑕疵，但朴素贝叶斯的实际效果却很好。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之决策树算法（3）预测隐形眼镜类型</title>
    <url>/folder/2019/11/08/2017-11-03-ml-9/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch03" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch03</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;本博文先介绍在实际应用中如何存储分类器，然后在实际数据上使用决策树分类算法，验证它是否可以正确预测出患者应该使用的隐形眼镜类型。</p>
<h2 id="测试和存储算法"><a href="#测试和存储算法" class="headerlink" title="测试和存储算法"></a>测试和存储算法</h2><h3 id="测试算法：使用决策树执行分类"><a href="#测试算法：使用决策树执行分类" class="headerlink" title="测试算法：使用决策树执行分类"></a>测试算法：使用决策树执行分类</h3><p>&emsp;&emsp;在执行数据分类时，需要使用决策树以及用于构造决策树的标签向量。然后，程序比较测试数据与决策树上的数值，递归执行该过程知道进入叶子结点；最后将测试数据定义为叶子节点所属的类型。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(inputTree, featLabels, testVec)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	使用决策树的分类函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		inputTree：树信息</span></span><br><span class="line"><span class="string">				featLabels：标签列表</span></span><br><span class="line"><span class="string">				testVec：测试数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	classLabel：分类标签</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值</span></span><br><span class="line">	firstStr = list(inputTree.keys())[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#新的树，相当于脱了一层皮</span></span><br><span class="line">	secondDict = inputTree[firstStr]</span><br><span class="line">	<span class="comment">#将标签字符串转为索引</span></span><br><span class="line">	featIndex = featLabels.index(firstStr)</span><br><span class="line">	<span class="comment">#遍历整棵树</span></span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">		<span class="comment">#比较testVec变量中的值与树节点的值</span></span><br><span class="line">		<span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">			<span class="comment">#判断子节点是否为字典类型，进而得知是否到达叶子结点</span></span><br><span class="line">			<span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</span><br><span class="line">				<span class="comment">#没到达叶子结点，则递归调用classify()</span></span><br><span class="line">				classLabel = classify(secondDict[key], featLabels, testVec)</span><br><span class="line">			<span class="keyword">else</span>:</span><br><span class="line">				<span class="comment">#到达叶子结点，则分类结果为当前节点的分类标签</span></span><br><span class="line">				classLabel = secondDict[key]</span><br><span class="line">	<span class="comment">#返回分类标签</span></span><br><span class="line">	<span class="keyword">return</span> classLabel</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(trees)</span><br><span class="line">&lt;module <span class="string">'trees'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch03\\trees.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat, labels = trees.createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labels</span><br><span class="line">[<span class="string">'no surfacing'</span>, <span class="string">'flippers'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree = treePlotter.retrieveTree(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree</span><br><span class="line">&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.classify(myTree, labels, [<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"><span class="string">'no'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.classify(myTree, labels, [<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line"><span class="string">'yes'</span></span><br></pre></td></tr></table></figure>

<h3 id="使用算法：决策树的存储"><a href="#使用算法：决策树的存储" class="headerlink" title="使用算法：决策树的存储"></a>使用算法：决策树的存储</h3><p>&emsp;&emsp;构造决策树是很耗时的任务，及时处理很小的数据集。如果使用创建好的决策树解决分类问题，则可以很快完成。因此，为了节省计算时间，我们使用Python模块pickle序列化对象，以便在硬盘上保存和读取字典。</p>
<p>代码实现：：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">storeTree</span><span class="params">(inputTree, filename)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	存储决策树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		inputTree：树信息</span></span><br><span class="line"><span class="string">				filename：文件名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	无</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#导入模块</span></span><br><span class="line">	<span class="keyword">import</span> pickle</span><br><span class="line">	<span class="comment">#新建文件，一定要加b属性，否则可能报错：</span></span><br><span class="line">	<span class="comment">#TypeError: write() argument must be str, not bytes</span></span><br><span class="line">	fw = open(filename, <span class="string">'wb'</span>)</span><br><span class="line">	<span class="comment">#写入数据</span></span><br><span class="line">	pickle.dump(inputTree, fw)</span><br><span class="line">	<span class="comment">#关闭文件</span></span><br><span class="line">	fw.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grabTree</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	读取决策树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		filename：文件名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	pickle.load(fr)：树信息</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#导入模块</span></span><br><span class="line">	<span class="keyword">import</span> pickle</span><br><span class="line">	<span class="comment">#打开文件，写入属性一致，否则可能报错：</span></span><br><span class="line">	<span class="comment">#UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position 0: illegal multibyte sequence</span></span><br><span class="line">	fr = open(filename, <span class="string">'rb'</span>)</span><br><span class="line">	<span class="comment">#导出数据</span></span><br><span class="line">	<span class="keyword">return</span> pickle.load(fr)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(trees)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.storeTree(myTree, <span class="string">'classifierStorage.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.grabTree(<span class="string">'classifierStorage.txt'</span>)</span><br><span class="line">&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;通过上面的代码，我们可以将分类器存储在硬盘上，而不用每次对数据分类时重新学习一遍，这也是决策树的优点之一，而k-近邻算法却无法持久化分类器。</p>
<h2 id="使用决策树预测隐形眼镜类型："><a href="#使用决策树预测隐形眼镜类型：" class="headerlink" title="使用决策树预测隐形眼镜类型："></a>使用决策树预测隐形眼镜类型：</h2><p>示例：使用决策树预测隐形眼镜类型：</p>
<ul>
<li>收集数据：提供的文本文件。</li>
<li>准备数据：解析tab键分割的数据行。</li>
<li>分析数据：快速检查数据，确保正确地解析数据内容，使用createPlot()函数绘制最终的树形图。</li>
<li>训练算法：使用前面编写好的createTree()函数。</li>
<li>测试算法：编写测试函数验证决策树科一正确分类给定的数据实例。</li>
<li>使用算法：存储树的数据结构，以便下次使用时无需重新构造树。</li>
</ul>
<p>&emsp;&emsp;隐形眼镜数据集是非常著名的数据集，它包含很多患者眼部状况的观察条件以及医生推荐的隐形眼镜类型，数据来源于UCI数据库，为了更容易显示数据，书中对数据做了简单的更改，即lenses.txt文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fr = open(<span class="string">'lenses.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lensesLabels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> trees</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lensesTree = trees.createTree(lenses, lensesLabels)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lensesTree</span><br><span class="line">&#123;<span class="string">'tearRate'</span>: &#123;<span class="string">'reduced'</span>: <span class="string">'no lenses'</span>, <span class="string">'normal'</span>: &#123;<span class="string">'astigmatic'</span>: &#123;<span class="string">'yes'</span>: &#123;<span class="string">'prescript'</span>: &#123;<span class="string">'myope'</span>: <span class="string">'hard'</span>, <span class="string">'hyper'</span>: &#123;<span class="string">'age'</span>: &#123;<span class="string">'pre'</span>: <span class="string">'no lenses'</span>, <span class="string">'young'</span>: <span class="string">'hard'</span>, <span class="string">'presbyopic'</span>: <span class="string">'no lenses'</span>&#125;&#125;&#125;&#125;, <span class="string">'no'</span>: &#123;<span class="string">'age'</span>: &#123;<span class="string">'pre'</span>: <span class="string">'soft'</span>, <span class="string">'young'</span>: <span class="string">'soft'</span>, <span class="string">'presbyopic'</span>: &#123;<span class="string">'prescript'</span>: &#123;<span class="string">'myope'</span>: <span class="string">'no lenses'</span>, <span class="string">'hyper'</span>: <span class="string">'soft'</span>&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> treePlotter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.createPlot(lensesTree)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;本渣渣将上述代码包装成函数，方便大家直接调用。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Aug 31, 2017</span></span><br><span class="line"><span class="string">Test on the modules</span></span><br><span class="line"><span class="string">@author: wordzzzz</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> trees</span><br><span class="line"><span class="keyword">import</span> treePlotter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	主函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	无</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#打开文件</span></span><br><span class="line">	fr = open(<span class="string">'lenses.txt'</span>)</span><br><span class="line">	<span class="comment">#读取文件信息</span></span><br><span class="line">	lenses = [inst.strip().split(<span class="string">'\t'</span>) <span class="keyword">for</span> inst <span class="keyword">in</span> fr.readlines()]</span><br><span class="line">	<span class="comment">#定义标签</span></span><br><span class="line">	lensesLabels = [<span class="string">'age'</span>, <span class="string">'prescript'</span>, <span class="string">'astigmatic'</span>, <span class="string">'tearRate'</span>]</span><br><span class="line">	<span class="comment">#创建树</span></span><br><span class="line">	lensesTree = trees.createTree(lenses, lensesLabels)</span><br><span class="line">	<span class="comment">#打印树信息</span></span><br><span class="line">	print(lensesTree)</span><br><span class="line">	<span class="comment">#绘制树信息</span></span><br><span class="line">	treePlotter.createPlot(lensesTree)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	main()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">E:\机器学习实战\mycode\Ch03&gt;python3 test.py</span><br><span class="line">&#123;<span class="string">'tearRate'</span>: &#123;<span class="string">'reduced'</span>: <span class="string">'no lenses'</span>, <span class="string">'normal'</span>: &#123;<span class="string">'astigmatic'</span>: &#123;<span class="string">'no'</span>: &#123;<span class="string">'age'</span>: &#123;<span class="string">'presbyopic'</span>: &#123;<span class="string">'prescript'</span>: &#123;<span class="string">'myope'</span>: <span class="string">'no lenses'</span>, <span class="string">'hyper'</span>: <span class="string">'soft'</span>&#125;&#125;, <span class="string">'young'</span>: <span class="string">'soft'</span>, <span class="string">'pre'</span>: <span class="string">'soft'</span>&#125;&#125;, <span class="string">'yes'</span>: &#123;<span class="string">'prescript'</span>: &#123;<span class="string">'myope'</span>: <span class="string">'hard'</span>, <span class="string">'hyper'</span>: &#123;<span class="string">'age'</span>: &#123;<span class="string">'presbyopic'</span>: <span class="string">'no lenses'</span>, <span class="string">'young'</span>: <span class="string">'hard'</span>, <span class="string">'pre'</span>: <span class="string">'no lenses'</span>&#125;&#125;&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903220008361?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;隐形眼睛的例子表明决策树可能会产生过多的数据集划分，从而产生过度匹配数据集的问题。我们可以通过裁剪决策树，合并相邻的无法产生大量信息增益的叶节点，消除过度匹配问题。淡然还有很多决策树构造算法，最流行的是C4.5和CART。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之决策树算法（2）画个儿时的树</title>
    <url>/folder/2019/11/08/2017-11-03-ml-8/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch03" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch03</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;上一篇博文已经介绍了如何从数据集中创建树，然而字典的表示形式非常不易理解，而且直接绘制图形也比较困难。决策树的主要优点就是直观易于理解，如果不能将其直观的显示出来，优势便无从谈起，所以本片博文就介绍一下如何利用Matplotlib库来创建树形图。</p>
<h2 id="Matplotlib注解："><a href="#Matplotlib注解：" class="headerlink" title="Matplotlib注解："></a>Matplotlib注解：</h2><p>&emsp;&emsp;Matplotlib提供了一个非常有用的注解工具annotations，它可以在数据图像上添加文本注解。由于数据上面直接存在文本描述非常丑陋，因此工具内嵌支持带尖头的画线工具，使得我们可以在其他前挡的地方指向数据位置，并在此处添加描述信息，解释数据内容，如下图：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903212749701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;打开文本编辑器，创建名为treePlotter.py的新文件，输入下面的程序代码。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Created on Aug 14, 2017</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: WordZzzz</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义文本框和箭头格式</span></span><br><span class="line">decisionNode = dict(boxstyle=<span class="string">"sawtooth"</span>, fc=<span class="string">"0.8"</span>)</span><br><span class="line">leafNode = dict(boxstyle=<span class="string">"round4"</span>, fc=<span class="string">"0.8"</span>)</span><br><span class="line">arrow_args = dict(arrowstyle=<span class="string">"&lt;-"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotNode</span><span class="params">(nodeTxt, centerPt, parentPt, nodeType)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	绘制带箭头的注解</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		nodeTxt：文本注解</span></span><br><span class="line"><span class="string">				centerPt：箭头终点坐标</span></span><br><span class="line"><span class="string">				parentPt：箭头起始坐标</span></span><br><span class="line"><span class="string">				nodeType：文本框类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	无</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#在全局变量createPlot0.ax1中绘图</span></span><br><span class="line">	createPlot0.ax1.annotate(nodeTxt, xy=parentPt,  xycoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">			 xytext=centerPt, textcoords=<span class="string">'axes fraction'</span>,</span><br><span class="line">			 va=<span class="string">"center"</span>, ha=<span class="string">"center"</span>, bbox=nodeType, arrowprops=arrow_args )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot0</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	使用文本注解绘制树节点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	无</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#创建一个新图形</span></span><br><span class="line">	fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)</span><br><span class="line">	<span class="comment">#清空绘图区</span></span><br><span class="line">	fig.clf()</span><br><span class="line">	<span class="comment">#给全局变量createPlot0.ax1赋值</span></span><br><span class="line">	createPlot0.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>) <span class="comment">#ticks for demo puropses </span></span><br><span class="line">	<span class="comment">#绘制第一个文本注解</span></span><br><span class="line">	plotNode(<span class="string">'a decision node'</span>, (<span class="number">0.5</span>, <span class="number">0.1</span>), (<span class="number">0.1</span>, <span class="number">0.5</span>), decisionNode)</span><br><span class="line">	<span class="comment">#绘制第二个文本注解</span></span><br><span class="line">	plotNode(<span class="string">'a leaf node'</span>, (<span class="number">0.8</span>, <span class="number">0.1</span>), (<span class="number">0.3</span>, <span class="number">0.8</span>), leafNode)</span><br><span class="line">	<span class="comment">#显示最终绘制结果</span></span><br><span class="line">	plt.show()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> treePlotter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.createPlot0()</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序结果如图所示，我们也可以改变函数plotNode()，观察图中x、y的位置如何变化。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903212820529?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h2 id="构造注解树："><a href="#构造注解树：" class="headerlink" title="构造注解树："></a>构造注解树：</h2><p>&emsp;&emsp;绘制一颗完整的树需要技巧，虽然我们有坐标，但是如何放置所有的树节点却是个问题。所以我们需要知道有多少个叶节点来确定x轴长度；haixuyao知道有多少层来确定y轴的高度。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getNumLeafs</span><span class="params">(myTree)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	获取叶节点的数目</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		myTree：树信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	numLeafs：叶节点的数目</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#初始化叶节点数目</span></span><br><span class="line">	numLeafs = <span class="number">0</span></span><br><span class="line">	<span class="comment">#第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值</span></span><br><span class="line">	firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#新的树，相当于脱了一层皮</span></span><br><span class="line">	secondDict = myTree[firstStr]</span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">		<span class="comment">#判断子节点是否为字典类型</span></span><br><span class="line">		<span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</span><br><span class="line">			<span class="comment">#是的话表明该节点也是一个判断节点，递归调用getNumLeafs()函数</span></span><br><span class="line">			numLeafs += getNumLeafs(secondDict[key])</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			numLeafs += <span class="number">1</span></span><br><span class="line">	<span class="comment">#返回叶节点数目</span></span><br><span class="line">	<span class="keyword">return</span> numLeafs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getTreeDepth</span><span class="params">(myTree)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	获取树的层数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		myTree：树信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	maxDepth：最大层数</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#初始化最大层数</span></span><br><span class="line">	maxDepth = <span class="number">0</span></span><br><span class="line">	<span class="comment">#第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值</span></span><br><span class="line">	firstStr = myTree.keys()[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#新的树，相当于脱了一层皮</span></span><br><span class="line">	secondDict = myTree[firstStr]</span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">		<span class="comment">#判断子节点是否为字典类型</span></span><br><span class="line">		<span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</span><br><span class="line">			<span class="comment">#是的话表明该节点也是一个判断节点，递归调用getTreeDepth()函数</span></span><br><span class="line">			thisDepth = <span class="number">1</span> + getTreeDepth(secondDict[key])</span><br><span class="line">		<span class="keyword">else</span>:   </span><br><span class="line">			thisDepth = <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> thisDepth &gt; maxDepth: maxDepth = thisDepth</span><br><span class="line">	<span class="comment">#返回最大层数</span></span><br><span class="line">	<span class="keyword">return</span> maxDepth</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;retrieveTree()主要用于测试，返回预定义的树结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retrieveTree</span><span class="params">(i)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	创建树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		i：要输出的树在里列表中的位置</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	listOfTrees[i]：输出预先存储的树</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	listOfTrees =[&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;,</span><br><span class="line">				  &#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: &#123;<span class="string">'head'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;, <span class="number">1</span>: <span class="string">'no'</span>&#125;&#125;&#125;&#125;</span><br><span class="line">				  ]</span><br><span class="line">	<span class="keyword">return</span> listOfTrees[i]</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(treePlotter)</span><br><span class="line">&lt;module <span class="string">'treePlotter'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch03\\treePlotter.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.retrieveTree(<span class="number">1</span>)</span><br><span class="line">&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: &#123;<span class="string">'head'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;, <span class="number">1</span>: <span class="string">'no'</span>&#125;&#125;&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.retrieveTree(<span class="number">0</span>)</span><br><span class="line">&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree = treePlotter.retrieveTree(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.getNumLeafs(myTree)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.getTreeDepth(myTree)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>报（python2.x与python3.x的差异）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">TypeError: <span class="string">'dict_keys'</span> object does <span class="keyword">not</span> support indexing</span><br></pre></td></tr></table></figure>

<p>解决（强制类型转换）：<br>Probably this was written with python2.x (when d.keys() returned a list). With python3.x, d.keys() returns a dict_keys object which behaves a lot more like a set than a list. As such, it can’t be indexed.</p>
<p>The solution is to pass list(d.keys()) (or simply list(d)) to shuffle.</p>
<p>&emsp;&emsp;我们需要重新编写createPlot()函数，在createPlot0()的基础上进行完善。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotMidText</span><span class="params">(cntrPt, parentPt, txtString)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	在父子节点间填充文本信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		cntrPt：树信息</span></span><br><span class="line"><span class="string">				parentPt：父节点坐标</span></span><br><span class="line"><span class="string">				txtString：文本注解</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	无</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	xMid = (parentPt[<span class="number">0</span>]-cntrPt[<span class="number">0</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">0</span>]</span><br><span class="line">	yMid = (parentPt[<span class="number">1</span>]-cntrPt[<span class="number">1</span>])/<span class="number">2.0</span> + cntrPt[<span class="number">1</span>]</span><br><span class="line">	createPlot.ax1.text(xMid, yMid, txtString, va=<span class="string">"center"</span>, ha=<span class="string">"center"</span>, rotation=<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotTree</span><span class="params">(myTree, parentPt, nodeTxt)</span>:</span><span class="comment">#if the first key tells you what feat was split on</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	创建数据集和标签</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		myTree：树信息</span></span><br><span class="line"><span class="string">				parentPt：箭头起始坐标</span></span><br><span class="line"><span class="string">				nodeTxt：文本注解</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	无</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#计算树的宽</span></span><br><span class="line">	numLeafs = getNumLeafs(myTree)  <span class="comment">#this determines the x width of this tree</span></span><br><span class="line">	<span class="comment">#计算树的高</span></span><br><span class="line">	depth = getTreeDepth(myTree)</span><br><span class="line">	<span class="comment">#第一个关键字为第一次划分数据集的类别标签，附带的取值表示子节点的取值</span></span><br><span class="line">	firstStr = list(myTree.keys())[<span class="number">0</span>]     <span class="comment">#the text label for this node should be this</span></span><br><span class="line">	<span class="comment">#下一个节点的位置</span></span><br><span class="line">	cntrPt = (plotTree.xOff + (<span class="number">1.0</span> + float(numLeafs))/<span class="number">2.0</span>/plotTree.totalW, plotTree.yOff)</span><br><span class="line">	<span class="comment">#计算父节点和子节点的中间位置，并在此处添加简单的文本信息</span></span><br><span class="line">	plotMidText(cntrPt, parentPt, nodeTxt)</span><br><span class="line">	<span class="comment">#绘制此节点带箭头的注解</span></span><br><span class="line">	plotNode(firstStr, cntrPt, parentPt, decisionNode)</span><br><span class="line">	<span class="comment">#新的树，相当于脱了一层皮</span></span><br><span class="line">	secondDict = myTree[firstStr]</span><br><span class="line">	<span class="comment">#按比例减少全局变量plotTree.yOff</span></span><br><span class="line">	plotTree.yOff = plotTree.yOff - <span class="number">1.0</span>/plotTree.totalD</span><br><span class="line">	<span class="comment">#</span></span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">		<span class="comment">#判断子节点是否为字典类型</span></span><br><span class="line">		<span class="keyword">if</span> type(secondDict[key]).__name__==<span class="string">'dict'</span>:</span><br><span class="line">			<span class="comment">#是的话表明该节点也是一个判断节点，递归调用plotTree()函数 </span></span><br><span class="line">			plotTree(secondDict[key],cntrPt,str(key))</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="comment">#不是的话更新x坐标值</span></span><br><span class="line">			plotTree.xOff = plotTree.xOff + <span class="number">1.0</span>/plotTree.totalW</span><br><span class="line">			<span class="comment">#绘制此节点带箭头的注解</span></span><br><span class="line">			plotNode(secondDict[key], (plotTree.xOff, plotTree.yOff), cntrPt, leafNode)</span><br><span class="line">			<span class="comment">#绘制此节点带箭头的注解</span></span><br><span class="line">			plotMidText((plotTree.xOff, plotTree.yOff), cntrPt, str(key))</span><br><span class="line">	<span class="comment">#按比例增加全局变量plotTree.yOff</span></span><br><span class="line">	plotTree.yOff = plotTree.yOff + <span class="number">1.0</span>/plotTree.totalD</span><br><span class="line"><span class="comment">#if you do get a dictonary you know it's a tree, and the first element will be another dict</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createPlot</span><span class="params">(inTree)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	使用文本注解绘制树节点</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		inTree：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	无</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#创建一个新图形</span></span><br><span class="line">	fig = plt.figure(<span class="number">1</span>, facecolor=<span class="string">'white'</span>)</span><br><span class="line">	<span class="comment">#清空绘图区</span></span><br><span class="line">	fig.clf()</span><br><span class="line">	<span class="comment">#创建一个字典</span></span><br><span class="line">	axprops = dict(xticks=[], yticks=[])</span><br><span class="line">	<span class="comment">#给全局变量createPlot.ax1赋值</span></span><br><span class="line">	createPlot.ax1 = plt.subplot(<span class="number">111</span>, frameon=<span class="literal">False</span>, **axprops)    <span class="comment">#no ticks</span></span><br><span class="line">	<span class="comment">#createPlot.ax1 = plt.subplot(111, frameon=False) #ticks for demo puropses </span></span><br><span class="line">	<span class="comment">#取得叶节点数目</span></span><br><span class="line">	plotTree.totalW = float(getNumLeafs(inTree))</span><br><span class="line">	<span class="comment">#取得树最大层</span></span><br><span class="line">	plotTree.totalD = float(getTreeDepth(inTree))</span><br><span class="line">	<span class="comment">#设置起点值</span></span><br><span class="line">	plotTree.xOff = <span class="number">-0.5</span>/plotTree.totalW; plotTree.yOff = <span class="number">1.0</span>;</span><br><span class="line">	<span class="comment">#绘制数</span></span><br><span class="line">	plotTree(inTree, (<span class="number">0.5</span>,<span class="number">1.0</span>), <span class="string">''</span>)</span><br><span class="line">	<span class="comment">#显示最终绘制结果</span></span><br><span class="line">	plt.show()</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(treePlotter)</span><br><span class="line">&lt;module <span class="string">'treePlotter'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch03\\treePlotter.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree = treePlotter.retrieveTree(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.createPlot(myTree)</span><br></pre></td></tr></table></figure>

<p>输出效果如下图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903212906679?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;接着按照命令更改字典，重新绘制树形图。</p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree[<span class="string">'no surfacing'</span>][<span class="number">3</span>] = <span class="string">'maybe'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree</span><br><span class="line">&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;, <span class="number">3</span>: <span class="string">'maybe'</span>&#125;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>treePlotter.createPlot(myTree)</span><br></pre></td></tr></table></figure>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903212924420?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>


<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之决策树算法（1）算法概述</title>
    <url>/folder/2019/11/08/2017-11-03-ml-7/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch03" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch03</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;本渣渣（WordZzzz直接被舍友叫成了“我的渣”，所以以后我在博客中就以此自居了！），最近在学习Peter Harrington的<em>Machine Learning in Action</em>，一边看书一边用Python3.6实现课本中的算法（原书中使用的是Python2.x）。好记性不如烂笔头，奈何本渣渣连烂笔头都买不起，所以就来这不费笔墨的地方费尽心思写博客。本渣渣记性不是一般的差，在此记下每个算法的学习要点及Python代码实现，一方面方便自己以后复习，另一方面贴出来和大家一起学习，共同进步<del>~</del></p>
<p><strong><font color="red">注意：python3.x与python2.x的部分函数库有较大差异，针对这个问题，本渣渣会将代码版本升级中遇到的问题在每篇博文的最后列出来，并加以解释说明，帮助大家区分理解。</font></strong></p>
<p>原著代码（python2.x）地址：<a href="https://www.manning.com/books/machine-learning-in-action" target="_blank" rel="noopener">https://www.manning.com/books/machine-learning-in-action</a><br>本渣渣代码（python3.x）地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch03" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch03</a></p>
<p>&emsp;&emsp;博客中的代码都会在本渣渣的GitHub上贴出，欢迎<em>Watch、Star、Fork</em>。</p>
<h2 id="一、算法介绍："><a href="#一、算法介绍：" class="headerlink" title="一、算法介绍："></a>一、算法介绍：</h2><p>&emsp;&emsp;上一个算法介绍的是k-近邻算法，它可以完成很多分类任务，但是它最大的缺点就是无法给出数据的内在含义，决策树的主要优势就在于数据形式非常容易理解。决策树的一个重要任务就是为了理解数据中所蕴含的知识信息，所以决策树可以使用不熟悉的数据集合，并从中提取出一系列规则，这些机器根据数据集创建规则的过程就是机器学习的过程。专家系统中经常食用决策树，而且决策树给出结果往往可以匹敌在当前领域具有几十年工作经验的人类专家。流程图形式的决策树如下：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903204144014?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<h3 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h3><ul>
<li>优点：计算复杂度不高，输出结果易于理解，对中间值的缺失不敏感，可以处理不相关特征数据。</li>
<li>缺点：可能会产生过度匹配问题。</li>
<li>适用数据类型：数值型和标称型。</li>
</ul>
<p>&emsp;&emsp;在构造决策树之前，我们需要解决一个问题：当前数据集上哪个特征在划分数据分类时起决定性作用。为了找到决定性的特征，划分出最好的结果，我们必须评估每个特征。完成测试之后，原始数据集就被划分为几个数据子集。这些数据子集会分布在第一个决策点的所有分支上，如果某个分支下的数据属于同一类型，则无需进一步对数据进行分割，如果数据子集内的数据不属于同一类型，则需要重复划分数据子集的过程。</p>
<h3 id="决策树的一般流程"><a href="#决策树的一般流程" class="headerlink" title="决策树的一般流程"></a>决策树的一般流程</h3><ul>
<li>收集数据：可以使用任何方法。</li>
<li>准备数据：树构造算法只适用于标称型数据，因此数值型数据必须离散化。</li>
<li>分析数据：可以使用任何方法，构造树完成之后，我们应该检查图形是否否和预测。</li>
<li>训练算法：构造树的数据结构。</li>
<li>测试算法：使用经验树计算错误率。</li>
<li>使用算法：此步骤可以适用于任何监督学习算法，而使用决策树可以更好的理解数据的内在含义。</li>
</ul>
<h2 id="二、代码实现与详解："><a href="#二、代码实现与详解：" class="headerlink" title="二、代码实现与详解："></a>二、代码实现与详解：</h2><p>&emsp;&emsp;一些决策树算法采用二分法划分数据，书里面采用的是ID3算法划分数据集，该算法处理如何划分数据集，何时停止划分数据集。<br>&emsp;&emsp;前面提了个问题，这么多特征，我们每次之选一个特征值进行划分，那这个特征要如何选择呢？下面将进行讲解。</p>
<h3 id="信息增益："><a href="#信息增益：" class="headerlink" title="信息增益："></a>信息增益：</h3><p>&emsp;&emsp;划分数据集的最大原则是：将无序的数据变得更加有序。组织杂乱无章数据的一种方法是使用信息论度量信息，信息论是量化处理信息的分支科学。我们可以在划分数据之前或者之后使用信息论量化信息的内容。</p>
<p>&emsp;&emsp;在划分数据集之前之后信息发生的变化称之为信息增益，获得信息增益最高的特征就是最好的选择。几何信息的度量方式称为香农熵或者简称为熵（其他学科也有熵这个定义，意思都差不多），这个名字来源于信息论之父克劳德·香农。</p>
<p>&emsp;&emsp;熵定义为信息的期望值，如果待分类的事物可能划分在多类分类中，则符号$x_i$的信息论定义为：</p>
<p>$$l(x_i) = -log_2p(x_i)$$</p>
<p>其中$p(x_i)$是选择该分类的概率。</p>
<p>&emsp;&emsp;为了计算熵，我们需要计算所有类别可能值包含的信息期望值，通过下面的公式得到：</p>
<p>$$H = - \sum{^n_{i-1}p(x_i)log_2p(x_i)}$$</p>
<p>其中n是分类的数目。创建trees.py文件，我们来使用python计算信息熵。</p>
<p>&emsp;&emsp;为了后续测试方便，我们先编写createDataSet()函数，创建数据集。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Aug 18, 2017</span></span><br><span class="line"><span class="string">Decision Tree Source Code</span></span><br><span class="line"><span class="string">@author: wordzzzz</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> log</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDataSet</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	创建数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	dataSet：数据集</span></span><br><span class="line"><span class="string">				labels：标签</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#创建数据集</span></span><br><span class="line">	dataSet = [[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">				[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>],</span><br><span class="line">				[<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>],</span><br><span class="line">				[<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>],</span><br><span class="line">				[<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">    <span class="comment">#创建标签</span></span><br><span class="line">	labels = [<span class="string">'no surfacing'</span>,<span class="string">'flippers'</span>]</span><br><span class="line">    <span class="comment">#返回创建的数据集和标签</span></span><br><span class="line">	<span class="keyword">return</span> dataSet, labels</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> trees</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat, labels = trees.createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;接下来编写calcShannonEnt(dataSet)函数，计算给定数据集的香农熵。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calcShannonEnt</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	计算给定数据集的香农熵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		dataSet：数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	shannonEnt：香农熵</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#计算数据集中实例的总数</span></span><br><span class="line">	numEntries = len(dataSet)</span><br><span class="line">	<span class="comment">#创建一个数据字典</span></span><br><span class="line">	labelCounts = &#123;&#125;</span><br><span class="line">	<span class="comment">#为所有可能的分类创建字典</span></span><br><span class="line">	<span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">		<span class="comment">#字典的键值等于最后一列的数值</span></span><br><span class="line">		currentLabel = featVec[<span class="number">-1</span>]</span><br><span class="line">		<span class="comment">#如果当前键值不存在，则扩展字典并将当前键值加入字典</span></span><br><span class="line">		<span class="keyword">if</span> currentLabel <span class="keyword">not</span> <span class="keyword">in</span> labelCounts.keys():</span><br><span class="line">			labelCounts[currentLabel] = <span class="number">0</span></span><br><span class="line">		<span class="comment">#每个键值都记录下当前类别出现的次数</span></span><br><span class="line">		labelCounts[currentLabel] += <span class="number">1</span></span><br><span class="line">	<span class="comment">#初始化香农熵</span></span><br><span class="line">	shannonEnt = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">#计算香农熵</span></span><br><span class="line">	<span class="keyword">for</span> key <span class="keyword">in</span> labelCounts:</span><br><span class="line">		<span class="comment">#利用所有类别标签发生频率计算类别出现的概率</span></span><br><span class="line">		prob = float(labelCounts[key])/numEntries</span><br><span class="line">		<span class="comment">#计算香农熵，log(prob, 2)是以2为底求prob的对数</span></span><br><span class="line">		shannonEnt -=  prob * log(prob, <span class="number">2</span>)</span><br><span class="line">	<span class="comment">#返回香农熵计算结果</span></span><br><span class="line">	<span class="keyword">return</span> shannonEnt</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.calcShannonEnt(myDat)</span><br><span class="line"><span class="number">0.9709505944546686</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;熵越高，则混合的数据也越多，我们可以在数据集中添加更多的分类，观察熵是如何变化的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat[<span class="number">0</span>][<span class="number">-1</span>]=<span class="string">'maybe'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'maybe'</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.calcShannonEnt(myDat)</span><br><span class="line"><span class="number">1.3709505944546687</span></span><br></pre></td></tr></table></figure>

<h3 id="划分数据集："><a href="#划分数据集：" class="headerlink" title="划分数据集："></a>划分数据集：</h3><p>&emsp;&emsp;分类算法除了需要测量信息熵，还需要划分数据集，度量划分数据集的熵，以判断当前是否正确划分了数据集。我们将对每个特征划分数据集的结果计算一次信息熵，然后判断按照哪个特征划分数据集是最好的划分方式。</p>
<p>&emsp;&emsp;编写splitDataSet(dataSet, axis, value)函数，按照给定特征划分数据集。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">splitDataSet</span><span class="params">(dataSet, axis, value)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	按照给定特征划分数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		dataSet：带划分的数据集</span></span><br><span class="line"><span class="string">				axis：划分数据集的特征</span></span><br><span class="line"><span class="string">				value：需要返回的特征的值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	retDataSet：符合特征的数据集</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#创建新的list对象  </span></span><br><span class="line">	retDataSet = []</span><br><span class="line">	<span class="comment">#抽取数据集</span></span><br><span class="line">	<span class="keyword">for</span> featVec <span class="keyword">in</span> dataSet:</span><br><span class="line">		<span class="comment">#将符合特征的数据抽取出来</span></span><br><span class="line">		<span class="keyword">if</span> featVec[axis] == value:</span><br><span class="line">			<span class="comment">#截取列表中第axis+1个之前的数据</span></span><br><span class="line">			reducedFeatVec = featVec[:axis]</span><br><span class="line">			<span class="comment">#将第axis+2之后的数据接入到上述数据集</span></span><br><span class="line">			reducedFeatVec.extend(featVec[axis+<span class="number">1</span>:])</span><br><span class="line">			<span class="comment">#将处理结果作为列表接入到返回数据集</span></span><br><span class="line">			retDataSet.append(reducedFeatVec)</span><br><span class="line">	<span class="comment">#返回符合特征的数据集</span></span><br><span class="line">	<span class="keyword">return</span> retDataSet</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(trees)</span><br><span class="line">&lt;module <span class="string">'trees'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch03\\trees.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat, labels = trees.createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.splitDataSet(myDat,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">[[<span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">0</span>, <span class="string">'no'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.splitDataSet(myDat,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">[[<span class="number">1</span>, <span class="string">'no'</span>], [<span class="number">1</span>, <span class="string">'no'</span>]]</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ul>
<li>Python语言不用考虑内存分配问题，在函数中传递的是列表的引用，在函数内部对列表对象的更改，将会影响该列表对象的整个生存周期。为了消除这个不良影响，我们需要在函数的开始创建一个新列表。</li>
<li>代码中使用了extend()和append()来抽取符合要求的元素，这两个方法功能类似，但是在处理多个列表时，这两个方法的处理结果是完全不同的。</li>
</ul>
<p>append</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]</span><br></pre></td></tr></table></figure>
<p>extend</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.extend(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编写chooseBestFeatureToSplit(dataSet)函数，    选择最好的数据集划分方式。该函数调用的数据需要满足一定的要求：第一个要求是，数据必须是一种由列表元素组成的列表，而且所有的列表元素都要具有相同的数据长度；第二个要求是，数据的最后一列或者每个实例的最后一个元素是当前实例的类别标签。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chooseBestFeatureToSplit</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	选择最好的数据集划分方式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		dataSet：待划分的数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	bestFeature：划分数据集最好的特征</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化特征数量</span></span><br><span class="line">	numFeatures = len(dataSet[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">	<span class="comment">#计算原始香农熵</span></span><br><span class="line">	baseEntropy = calcShannonEnt(dataSet)</span><br><span class="line">	<span class="comment">#初始化信息增益和最佳特征</span></span><br><span class="line">	bestInfoGain = <span class="number">0.0</span>; bestFeature = <span class="number">-1</span></span><br><span class="line">	<span class="comment">#选出最好的划分数据集的特征</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(numFeatures):</span><br><span class="line">		<span class="comment">#创建唯一的分类标签列表</span></span><br><span class="line">		featList = [example[i] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">		<span class="comment">#从列表中创建集合，以得到列表中唯一元素值</span></span><br><span class="line">		uniqueVals = set(featList)</span><br><span class="line">		<span class="comment">#初始化香农熵</span></span><br><span class="line">		newEntropy = <span class="number">0.0</span></span><br><span class="line">		<span class="comment">#计算每种划分方式的信息熵</span></span><br><span class="line">		<span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">			subDataSet = splitDataSet(dataSet, i, value)</span><br><span class="line">			prob = len(subDataSet)/float(len(dataSet))</span><br><span class="line">			newEntropy += prob * calcShannonEnt(subDataSet)</span><br><span class="line">		<span class="comment">#得到信息增益</span></span><br><span class="line">		infoGain = baseEntropy - newEntropy</span><br><span class="line">		<span class="comment">#计算最好的信息增益</span></span><br><span class="line">		<span class="keyword">if</span> (infoGain &gt; bestInfoGain):</span><br><span class="line">			bestInfoGain = infoGain</span><br><span class="line">			bestFeature = i</span><br><span class="line">	<span class="comment">#返回最好的特征</span></span><br><span class="line">	<span class="keyword">return</span> bestFeature</span><br></pre></td></tr></table></figure>

<p>note：从列表中创建集合是Python语言得到列表中唯一元素值的最快方法。</p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(trees)</span><br><span class="line">&lt;module <span class="string">'trees'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch03\\trees.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat, labels = trees.createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>trees.chooseBestFeatureToSplit(myDat)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat</span><br><span class="line">[[<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="string">'yes'</span>], [<span class="number">1</span>, <span class="number">0</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="string">'no'</span>]]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="递归构建决策树："><a href="#递归构建决策树：" class="headerlink" title="递归构建决策树："></a>递归构建决策树：</h3><p>&emsp;&emsp;从数据集构造决策树算法的工作原理如下：得到原始数据，然后基于最好的属性值划分数据集。第一次划分之后，数据将被向下传递到树分支的下一个节点，在这个节点上，可以再次划分数据（递归）。</p>
<p>&emsp;&emsp;递归结束的条件：程序遍历完所有划分数据集的属性，或者每个分支下的所有实例都具有相同的分类。如果所欲实例都具有相同的分类，则得到一个叶子节点或者终止块。任何到达叶子节点的数据必须属于叶子节点的分类，如下图：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903204044451?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;如果数据集已经处理了所有的属性，但是类标签依然不是唯一的，此时我们需要决定如何定义该叶子节点，在这种情况下，书中采用的是多数表决的方法决定该叶子节点的分类。</p>
<p>&emsp;&emsp;编写majorityCnt(classList)函数，进行多数表决，这里和k-近邻算法里面的classify0部分的投票表决代码非常类似。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityCnt</span><span class="params">(classList)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	决定叶子结点的分类</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		classList：分类列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	sortedClassCount[0][0]：叶子结点分类结果</span></span><br><span class="line"><span class="string">	"""</span>		</span><br><span class="line">	<span class="comment">#创建字典</span></span><br><span class="line">	classCount=&#123;&#125;</span><br><span class="line">	<span class="comment">#给字典赋值</span></span><br><span class="line">	<span class="keyword">for</span> vote <span class="keyword">in</span> classList:</span><br><span class="line">		<span class="comment">#如果字典中没有该键值，则创建</span></span><br><span class="line">		<span class="keyword">if</span> vote <span class="keyword">not</span> <span class="keyword">in</span> classCount.keys():</span><br><span class="line">			classCount[vote] = <span class="number">0</span></span><br><span class="line">		<span class="comment">#为每个键值计数</span></span><br><span class="line">		classCount[vote] += <span class="number">1</span></span><br><span class="line">	<span class="comment">#对classCount进行排序</span></span><br><span class="line">	sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(<span class="number">1</span>), reverse=<span class="literal">True</span>)</span><br><span class="line">	<span class="comment">#返回叶子结点分类结果</span></span><br><span class="line">	<span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;编写createTree(dataSet, labels)函数，创建树</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, labels)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	创建树</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		dataSet：数据集</span></span><br><span class="line"><span class="string">				labels：标签列表</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	myTree：创建的树的信息</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#创建分类列表</span></span><br><span class="line">	classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">	<span class="comment">#类别完全相同则停止划分</span></span><br><span class="line">	<span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">		<span class="keyword">return</span> classList[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#遍历完所有特征时返回出现次数最多的类别</span></span><br><span class="line">	<span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">		<span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">	<span class="comment">#选取最好的分类特征</span></span><br><span class="line">	bestFeat = chooseBestFeatureToSplit(dataSet)</span><br><span class="line">	bestFeatLabel = labels[bestFeat]</span><br><span class="line">	<span class="comment">#创建字典存储树的信息</span></span><br><span class="line">	myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">	<span class="keyword">del</span>(labels[bestFeat])</span><br><span class="line">	<span class="comment">#得到列表包含的所有属性值</span></span><br><span class="line">	featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">	<span class="comment">#从列表中创建集合</span></span><br><span class="line">	uniqueVals = set(featValues)</span><br><span class="line">	<span class="comment">#遍历当前选择特征包含的所有属性值</span></span><br><span class="line">	<span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">		<span class="comment">#复制类标签</span></span><br><span class="line">		subLabels =labels[:]</span><br><span class="line">		<span class="comment">#递归调用函数createTree()，返回值将被插入到字典变量myTree中</span></span><br><span class="line">		myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)</span><br><span class="line">	<span class="comment">#返回字典变量myTree</span></span><br><span class="line">	<span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(trees)</span><br><span class="line">&lt;module <span class="string">'trees'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch03\\trees.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myDat, labels = trees.createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree = trees.createTree(myDat, labels)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myTree</span><br><span class="line">&#123;<span class="string">'no surfacing'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: &#123;<span class="string">'flippers'</span>: &#123;<span class="number">0</span>: <span class="string">'no'</span>, <span class="number">1</span>: <span class="string">'yes'</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;变量myTree包含了很多代表树结构信息的嵌套字典，从左边开始，第一个关键字no surfacing是第一个划分数据集的特征名称，该关键字的值也是另一个数据字典。第二个关键字是no surfacing特征划分的数据集，这些关键字的值是no surfacing节点的子节点。这些值可能是类标签，也可能是另一个数据字典，如果值是标签，则该子节点是叶子结点；如果是另一个数据字典，则子节点是一个判断节点，这种格式结构不断重复就构成了整棵树。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之Logistic回归（3）预测病马死亡率</title>
    <url>/folder/2019/11/08/2017-11-02-ml-6/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch05" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch05</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;本节将使用Logistic会归来预测还有疝病的马的存货问题。智力的数据包含368个样本和28个特征。疝病逝描述马胃肠痛的术语，然而这种病不一定来源于马的肠胃问题，其他问题也可能引发该病。</p>
<p>&emsp;&emsp;示例：使用Logistic回归估计马疝病的死亡率</p>
<ul>
<li>收集数据：给定数据文件。</li>
<li>准备数据：用Python解析文本文件并填充缺失值。</li>
<li>分析数据：可视化并观察数据。</li>
<li>训练算法：使用优化算法，找到最佳的系数。</li>
<li>测试算法：为了量化回归效果，需要观察错误率，根据错误率决定是否回退到训练阶段，通过改变迭代的次数和步长等参数来得到更好的回归系数。</li>
<li>使用算法：实现一个简单的命令行程序来收集马的症状并输出预测结果并非难事，这可以作为留给读者的一道习题。</li>
</ul>
<p>&emsp;&emsp;另外需要说明的是，除了部分指标主观和难以测量外，该数据还存在一个问题，数据集中有30%的值是缺失的。下面将首先介绍如何处理数据集中的数据缺失问题，然后利用Logistic回归和随机梯度上升算法来预测病马的生死。</p>
<h2 id="准备数据；处理数据中的缺失值"><a href="#准备数据；处理数据中的缺失值" class="headerlink" title="准备数据；处理数据中的缺失值"></a>准备数据；处理数据中的缺失值</h2><p>&emsp;&emsp;数据中的缺失值是个非常棘手的问题，有很多文献都致力于解决这个问题。下面给出一些可选的做法：</p>
<ul>
<li><input disabled="" type="checkbox"> 使用可用特征的均值来填补缺失值；</li>
<li><input disabled="" type="checkbox"> 使用特殊值来填补缺失值，如-1；</li>
<li><input disabled="" type="checkbox"> 忽略所有缺失的样本；</li>
<li><input disabled="" type="checkbox"> 使用相似样本的均值添补缺失值；</li>
<li><input disabled="" type="checkbox"> 使用另外的机器学习算法预测缺失值。</li>
</ul>
<p>&emsp;&emsp;现在，我们对后面用到的数据集进行预处理，使其可以顺利地使用分类算法。在预处理阶段需要做两件事：第一，所有的缺失值必须用一个实数值来替换，因为我们使用的Numpy数组不允许包含缺失值。这里选择实数0来替换所有缺失值，恰好能适用于Lodistic回归。这样做的原因在于，我们需要一个在更新时不会影响系数的值。回归系数的更新公式如下：</p>
<p>$$weights = weights + alpha * error * dataMatrix[ranIndex]$$</p>
<p>&emsp;&emsp;很明显，如果dataMatrix的某特征对应值为0，那么该特征的系数将不做更新，即$weights = weights$。另外，由于sigmoid(0)=0.5对结果的预测不具有任何倾向性，因为上述做法也不会对误差项造成任何影响，完美！</p>
<p>&emsp;&emsp;预处理的第二件事是，如果发现一条数据的类别标签已经缺失，纳闷我们的简单做法就是将该条数据丢弃。这是因为类别标签和特征不同，很难确定采用某个合适的值来替换。采用Logistic回归进行分类时，这种做法是合理的，而如果采用类似kNN的方法就可能不太可行。</p>
<p>&emsp;&emsp;原始数据经过预处理之后保存成两个文件：horseColicTest.txt和horseColicTraining.txt。如果相对原始数据和预处理数据进行比较，可以在<a href="http://archive.ics.uci.edu/ml/dataset/Horse+Colic浏览这些数据。" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/dataset/Horse+Colic浏览这些数据。</a></p>
<h2 id="预测算法：用Logistic回归进行分类"><a href="#预测算法：用Logistic回归进行分类" class="headerlink" title="预测算法：用Logistic回归进行分类"></a>预测算法：用Logistic回归进行分类</h2><p>&emsp;&emsp;使用Logistic回归方法进行分类并不需要做很多工作，所需要做的只是把测试集上每个特征向量乘以最优化方法得来的回归系数，再将该乘积结果求和，最后输入到Sigmoid函数即可。实现代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyVector</span><span class="params">(inX, weights)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	分类函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		inX：计算得出的矩阵100*1</span></span><br><span class="line"><span class="string">				weights：权重参数矩阵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	分类结果</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#计算sigmoid值</span></span><br><span class="line">	prob = sigmoid(sum(inX*weights))</span><br><span class="line">	<span class="comment">#返回分类结果</span></span><br><span class="line">	<span class="keyword">if</span> prob &gt; <span class="number">0.5</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">colicTest</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	训练和测试函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		训练集和测试集文本文档</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	分类错误率</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#打开训练集</span></span><br><span class="line">	frTrain = open(<span class="string">'horseColicTraining.txt'</span>)</span><br><span class="line">	<span class="comment">#打开测试集</span></span><br><span class="line">	frTest = open(<span class="string">'horseColicTest.txt'</span>)</span><br><span class="line">	<span class="comment">#初始化训练集数据列表</span></span><br><span class="line">	trainingSet = []</span><br><span class="line">	<span class="comment">#初始化训练集标签列表</span></span><br><span class="line">	trainingLabels = []</span><br><span class="line">	<span class="comment">#遍历训练集数据</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> frTrain.readlines():</span><br><span class="line">		<span class="comment">#切分数据集</span></span><br><span class="line">		currLine = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">		<span class="comment">#初始化临时列表</span></span><br><span class="line">		lineArr = []</span><br><span class="line">		<span class="comment">#遍历21项数据重新生成列表，因为后面格式要求，这里必须重新生成一下。</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">			lineArr.append(float(currLine[i]))</span><br><span class="line">		<span class="comment">#添加数据列表</span></span><br><span class="line">		trainingSet.append(lineArr)</span><br><span class="line">		<span class="comment">#添加分类标签</span></span><br><span class="line">		trainingLabels.append(float(currLine[<span class="number">21</span>]))</span><br><span class="line">	<span class="comment">#获得权重参数矩阵</span></span><br><span class="line">	trainWeights = stocGradAscent1(array(trainingSet), trainingLabels, <span class="number">500</span>)</span><br><span class="line">	<span class="comment">#初始化错误分类计数</span></span><br><span class="line">	errorCount = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	numTestVec = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">#遍历测试集数据</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> frTest.readlines():</span><br><span class="line">		<span class="comment">#</span></span><br><span class="line">		numTestVec += <span class="number">1.0</span></span><br><span class="line">		<span class="comment">#切分数据集</span></span><br><span class="line">		currLine =line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">		<span class="comment">#初始化临时列表</span></span><br><span class="line">		lineArr = []</span><br><span class="line">		<span class="comment">#遍历21项数据重新生成列表，因为后面格式要求，这里必须重新生成一下。</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">			lineArr.append(float(currLine[i]))</span><br><span class="line">		<span class="comment">#如果分类结果和分类标签不符，则错误计数+1</span></span><br><span class="line">		<span class="keyword">if</span> int(classifyVector(array(lineArr), trainWeights)) != int(currLine[<span class="number">21</span>]):</span><br><span class="line">			errorCount += <span class="number">1</span></span><br><span class="line">	<span class="comment">#计算分类错误率</span></span><br><span class="line">	errorRate = (float(errorCount)/numTestVec)</span><br><span class="line">	<span class="comment">#打印分类错误率</span></span><br><span class="line">	print(<span class="string">"the error rate of this test is: %f"</span> % errorRate)</span><br><span class="line">	<span class="comment">#返回分类错误率</span></span><br><span class="line">	<span class="keyword">return</span> errorRate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiTest</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	求均值函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	十次分类结果的平均值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#迭代次数</span></span><br><span class="line">	numTests = <span class="number">10</span></span><br><span class="line">	<span class="comment">#初始错误率和</span></span><br><span class="line">	errorSum = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">#调用十次colicTest()，累加错误率</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(numTests):</span><br><span class="line">		errorSum += colicTest()</span><br><span class="line">	<span class="comment">#打印平均分类结果</span></span><br><span class="line">	print(<span class="string">"after %d iterations the average error rate is: %f"</span> % (numTests, errorSum/float(numTests)))</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;打开终端，输入命令行进行测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(logRegres)</span><br><span class="line">&lt;module <span class="string">'logRegres'</span> <span class="keyword">from</span> <span class="string">'E:\\机器学习实战\\mycode\\Ch05\\logRegres.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logRegres.multiTest()</span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.358209</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.402985</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.388060</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.328358</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.388060</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.313433</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.283582</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.313433</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.298507</span></span><br><span class="line">the error rate of this test <span class="keyword">is</span>: <span class="number">0.343284</span></span><br><span class="line">after <span class="number">10</span> iterations the average error rate <span class="keyword">is</span>: <span class="number">0.341791</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;从上面的结果可以看出，10次迭代之后的平均错误率为35%左右。事实上，这个结果并不差，因为哦我们有30%的数据缺失。当然，如果调整colicTest中迭代次数和stocGradAscent1中的步长，平均错误率科一降到20%左右。</p>
<p>&emsp;&emsp;对于这一章的内容，还计划写一篇博文《机器学习实战》之Logistic回归（4）Logisitc回归与最大熵模型，主要是公式推导，预计两周后更新。《机器学习实战》的Python3代码实现还是每周日进行更新，相应章节对应的公式推导和拓展预计有两周延迟。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Logistic</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之Logistic回归（2）最佳回归系数确定</title>
    <url>/folder/2019/11/08/2017-11-02-ml-5/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch05" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch05</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;Sigmoid函数的输入记为z，有下面公式得出：</p>
<p>$$z = w_0x_0 + w_1x_1 + w_2x_2 +···+ w_nx_n$$</p>
<p>&emsp;&emsp;如果采用向量的写法，上述公式可以写成$$z = w^Tx$$，它表示将这两个数值向量对应元素相乘然后全部加起来即得到z值。其中的向量x是分类器的输入数据，向量w也就是我们要找到的最佳参数系数，从而使得分类器尽可能的精确。为了寻找最佳参数，我们需要用到最优化理论的一些知识。</p>
<p>&emsp;&emsp;下面首先介绍梯度上升这一优化算法，我们将学习到如何使用该方法求得数据集的最佳参数。接下来，展示如何绘制梯度上升法产生的决策变截图，该图能将梯度上升法的分类效果可视化地呈现出来。最后，我们将学习随机梯度上升算法，以及如何对其进行修改以获得更好的效果。</p>
<h2 id="梯度上升算法"><a href="#梯度上升算法" class="headerlink" title="梯度上升算法"></a>梯度上升算法</h2><p>&emsp;&emsp;梯度上升算法基于的思想是：要找到某函数的最大值，最好的办法就是沿着该函数的梯度方向探寻。如果梯度记为$\nabla$，则函数f(x,y)的梯度由下式表示：</p>
<p>$$\nabla f(x,y) = \begin{pmatrix} \frac {\partial f(x,y)} {\partial x} \ \frac {\partial f(x,y)} {\partial y} \ \end{pmatrix}$$</p>
<p>&emsp;&emsp;这是机器学习中最容易造成混淆的一个地方，但在数学上并不难，需要做的只是牢记这些符号的含义。这个梯度意味着要沿x的方向移动$\frac {\partial f(x,y)} {\partial x}$，沿y的方向移动$\frac {\partial f(x,y)} {\partial y}$。其中，函数f(x,y)必须要在待计算的点上有定义并且可微。一个具体的函数例子见下图。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917195011708?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;图中的梯度上升算法沿梯度方向移动了一步。乐意看到，梯度算子总是指向函数值增长最快的方向。这里说到移动方向，而未提及移动量的大小。该量值称为步长，记作α。用向量来表示的话，梯度上升算法的迭代公式如下：</p>
<p>$$w: = w + \alpha \nabla_w f(w)$$</p>
<p>&emsp;&emsp;该公式将一直被迭代执行，直到达到某个停止条件为止，比如设定的迭代次数或者达到某个允许的误差范围。</p>
<p>&emsp;&emsp;如果我没记错的话，Andrew在course的machine learning第三周的课程中使用的是梯度下降算法，它的公式为：</p>
<p>$$w: = w - \alpha \nabla_w f(w)$$</p>
<p>&emsp;&emsp;我们可以看到，两个算法其实是一样的，只是公式中的加减法不同而已。梯度上升算法用来求函数的最大值，而梯度下降算法用来求函数的最小值。</p>
<h2 id="训练算法：使用梯度上升找到最佳参数"><a href="#训练算法：使用梯度上升找到最佳参数" class="headerlink" title="训练算法：使用梯度上升找到最佳参数"></a>训练算法：使用梯度上升找到最佳参数</h2><p>&emsp;&emsp;基于上面的内容，我们来看一个Logistic回归分类器的应用例子，从下图可以看到我们采集的数据集。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917195117794?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;上图中有100个样本点，每个点包含两个数值型特征：X1和X2。在此数据集上，我们将通过使用梯度上升法找到最佳回归系数，也就是拟合出Logistic回归模型的最佳参数。</p>
<p>&emsp;&emsp;梯度上升法的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个回归系数初始化为1</span><br><span class="line">重复R次：</span><br><span class="line">    计算整个数据集的梯度</span><br><span class="line">    使用alpha 下gradient 更新回归系数的向量</span><br><span class="line">返回回归系数</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;下面的代码是梯度上升算法的具体实现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*- #</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Created on Sep 15, 2017</span></span><br><span class="line"><span class="string">Logistic Regression Working Module</span></span><br><span class="line"><span class="string">@author: WordZzzz</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadDataSet</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	加载数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		testSet.txt：数据集</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	dataMat：数据矩阵100*3</span></span><br><span class="line"><span class="string">				labelMat：类别标签矩阵1*100</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化数据列表和标签列表</span></span><br><span class="line">	dataMat = []; labelMat = []</span><br><span class="line">	<span class="comment">#打开数据集</span></span><br><span class="line">	fr = open(<span class="string">'testSet.txt'</span>)</span><br><span class="line">	<span class="comment">#遍历每一行</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">		<span class="comment">#删除空白符之后进行切分</span></span><br><span class="line">		lineArr = line.strip().split()</span><br><span class="line">		<span class="comment">#数据加入数据列表</span></span><br><span class="line">		dataMat.append([<span class="number">1.0</span>, float(lineArr[<span class="number">0</span>]), float(lineArr[<span class="number">1</span>])])</span><br><span class="line">		<span class="comment">#标签加入数据列表</span></span><br><span class="line">		labelMat.append(int(lineArr[<span class="number">2</span>]))</span><br><span class="line">	<span class="comment">#返回数据列表和标签列表</span></span><br><span class="line">	<span class="keyword">return</span> dataMat, labelMat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(inX)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	sigmoid函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		inX：矩阵运算结果100*1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	1.0/(1+exp(-inX))：计算结果</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#返回计算结果</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+exp(-inX))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradAscent</span><span class="params">(dataMatIn, classLabels)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	logistic回归梯度上升函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据列表100*3</span></span><br><span class="line"><span class="string">				classLabels：标签列表1*100</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	weights：权重参数矩阵</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#转换为numpy矩阵dataMatrix：100*3</span></span><br><span class="line">	dataMatrix = mat(dataMatIn)</span><br><span class="line">	<span class="comment">#转换为numpy矩阵并转置为labelMat：100*1</span></span><br><span class="line">	labelMat = mat(classLabels).transpose()</span><br><span class="line">	<span class="comment">#获得矩阵行列数</span></span><br><span class="line">	m,n = shape(dataMatrix)</span><br><span class="line">	<span class="comment">#初始化移动步长</span></span><br><span class="line">	alpha = <span class="number">0.001</span></span><br><span class="line">	<span class="comment">#初始化地带次数</span></span><br><span class="line">	maxCycles = <span class="number">500</span></span><br><span class="line">	<span class="comment">#初始化权重参数矩阵，初始值都为1</span></span><br><span class="line">	weights = ones((n,<span class="number">1</span>))</span><br><span class="line">	<span class="comment">#开始迭代计算参数</span></span><br><span class="line">	<span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):</span><br><span class="line">		<span class="comment">#100*3 * 3*1 =&gt; 100*1</span></span><br><span class="line">		h = sigmoid(dataMatrix * weights)</span><br><span class="line">		<span class="comment">#计算误差100*1</span></span><br><span class="line">		error = (labelMat - h)</span><br><span class="line">		<span class="comment">#更新参数值</span></span><br><span class="line">		weights = weights + alpha * dataMatrix.transpose() * error</span><br><span class="line">	<span class="comment">#返回权重参数矩阵</span></span><br><span class="line">	<span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;需要强调的是，gradAscent函数中的for循环部分中的运算是矩阵运算。变量h不是一个数而是一个列向量，列向量的元素个数等于样本个数，这里是100.对应的运算dataMatrix * weights代表不止一次乘积计算，实际上该运算包含了300次的乘积。</p>
<p>&emsp;&emsp;接下来我们看看实际效果，打开终端，输入命令行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> logRegres</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dataArr, labelMat = logRegres.loadDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logRegres.gradAscent(dataArr, labelMat)</span><br><span class="line">matrix([[ <span class="number">4.12414349</span>],</span><br><span class="line">        [ <span class="number">0.48007329</span>],</span><br><span class="line">        [<span class="number">-0.6168482</span> ]])</span><br></pre></td></tr></table></figure>

<h2 id="分析数据：画出决策边界"><a href="#分析数据：画出决策边界" class="headerlink" title="分析数据：画出决策边界"></a>分析数据：画出决策边界</h2><p>&emsp;&emsp;分析数据，当然离不开可视化模块matplotlib，代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plotBestFit</span><span class="params">(weights)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	画出数据集和最佳拟合直线</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		weights：权重参数矩阵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	包含数据集和拟合直线的图像</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#加载matplotlib中的pyplot模块</span></span><br><span class="line">	<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">	<span class="comment">#导入数据</span></span><br><span class="line">	dataMat, labelMat = loadDataSet()</span><br><span class="line">	<span class="comment">#创建数组</span></span><br><span class="line">	dataArr =array(dataMat)</span><br><span class="line">	<span class="comment">#获取数组行数</span></span><br><span class="line">	n = shape(dataArr)[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#初始化坐标</span></span><br><span class="line">	xcord1 = []; ycord1 = []</span><br><span class="line">	xcord2 = []; ycord2 = []</span><br><span class="line">	<span class="comment">#遍历每一行数据</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">		<span class="comment">#如果对应的类别标签对应数值1，就添加到xcord1，ycord1中</span></span><br><span class="line">		<span class="keyword">if</span> int(labelMat[i]) == <span class="number">1</span>:</span><br><span class="line">			xcord1.append(dataArr[i,<span class="number">1</span>]); ycord1.append(dataArr[i,<span class="number">2</span>])</span><br><span class="line">		<span class="comment">#如果对应的类别标签对应数值0，就添加到xcord2，ycord2中</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			xcord2.append(dataArr[i,<span class="number">1</span>]); ycord2.append(dataArr[i,<span class="number">2</span>])</span><br><span class="line">	<span class="comment">#创建空图</span></span><br><span class="line">	fig = plt.figure()</span><br><span class="line">	<span class="comment">#添加subplot，三种数据都画在一张图上</span></span><br><span class="line">	ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">	<span class="comment">#1类用红色标识，marker='s'形状为正方形</span></span><br><span class="line">	ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">	<span class="comment">#0类用绿色标识，弄认marker='o'为圆形</span></span><br><span class="line">	ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">	<span class="comment">#设置x取值，arange支持浮点型</span></span><br><span class="line">	x = arange(<span class="number">-3.0</span>, <span class="number">3.0</span>, <span class="number">0.1</span>)</span><br><span class="line">	<span class="comment">#配计算y的值</span></span><br><span class="line">	y = (-weights[<span class="number">0</span>]-weights[<span class="number">1</span>]*x)/weights[<span class="number">2</span>]</span><br><span class="line">	<span class="comment">#画拟合直线</span></span><br><span class="line">	ax.plot(x, y)</span><br><span class="line">	<span class="comment">#贴坐标表头</span></span><br><span class="line">	plt.xlabel(<span class="string">'X1'</span>); plt.ylabel(<span class="string">'X2'</span>)</span><br><span class="line">	<span class="comment">#显示结果</span></span><br><span class="line">	plt.show()</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;打开终端，输入命令行进行测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(logRegres)</span><br><span class="line">&lt;module <span class="string">'logRegres'</span> <span class="keyword">from</span> <span class="string">'logRegres.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weights = logRegres.gradAscent(dataArr, labelMat)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logRegres.plotBestFit(weights.getA())</span><br></pre></td></tr></table></figure>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917195213466?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;这个分类效果相当不错，从图上看之分错了两到四个点。但是，尽管例子简单并且数据集很小，这个方法却很需要大量的计算（300次乘积）。下面我们将对该算法进行改进，从而使它可以用到真实数据上。</p>
<h2 id="训练算法：随机梯度上升"><a href="#训练算法：随机梯度上升" class="headerlink" title="训练算法：随机梯度上升"></a>训练算法：随机梯度上升</h2><p>&emsp;&emsp;梯度上升算法在每次更新回归系数时都需要遍历整个数据集，计算复杂度太高了。一种改进方法就是一次仅用一个样本点来更新回归系数，该方法称为随机梯度上升算法。由于可以在新样本到来时对分类器进行增量式更新，因而随机梯度上升算法是一个在线学习方法。与“在线学习”相对应的，一次处理所有数据被称为是“批处理”。</p>
<p>&emsp;&emsp;随机梯度上升算法伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">所有回归系数初始化为1</span><br><span class="line">对数据集中每个样本</span><br><span class="line">    计算该样本的梯度</span><br><span class="line">    使用alpha x gradient 更新回归系数值</span><br><span class="line">返回回归系数值</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stocGradAscent0</span><span class="params">(dataMatrix, classLabels)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	随机梯度上升算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据列表100*3</span></span><br><span class="line"><span class="string">				classLabels：标签列表1*100</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	weights：权重参数矩阵</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#获取数据列表大小</span></span><br><span class="line">	m,n = shape(dataMatrix)</span><br><span class="line">	<span class="comment">#步长设置为0.01</span></span><br><span class="line">	alpha = <span class="number">0.01</span></span><br><span class="line">	<span class="comment">#初始化权重参数矩阵，初始值都为1</span></span><br><span class="line">	weights = ones(n)</span><br><span class="line">	<span class="comment">#遍历每一行数据</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#1*3 * 3*1</span></span><br><span class="line">		h = sigmoid(sum(dataMatrix[i]*weights))</span><br><span class="line">		<span class="comment">#计算误差</span></span><br><span class="line">		error = classLabels[i] - h</span><br><span class="line">		<span class="comment">#更新权重值</span></span><br><span class="line">		weights = weights + alpha * error * dataMatrix[i]</span><br><span class="line">	<span class="comment">#返回权重参数矩阵</span></span><br><span class="line">	<span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以看到，随机梯度上升算法与梯度上升算法在代码上很相似，但也有一些区别：第一，后者的变量h和误差error都是向量，而前者则全是数值；第二，前者没有矩阵的转换过程，所有变量的数据类型都是Numpy数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(logRegres)</span><br><span class="line">&lt;module <span class="string">'logRegres'</span> <span class="keyword">from</span> <span class="string">'logRegres.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dataArr, labelMat = logRegres.loadDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weights=logRegres.stocGradAscent0(array(dataArr), labelMat)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logRegres.plotBestFit(weights)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;执行完毕之后，效果如下图所示，该图与上一张图有一些相似之处。可以看到，拟合出来的直线比上次差了点，但是你要知道，这次的随机梯度上升算法，我们只是在整个数据集上迭代了一次而已（算成100次也是和500次差很多）。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917195237593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;一个判断优化算法优劣的可靠算法是看它是否收敛，也就是说参数是否达到了稳定值。随机梯度上升算法迭代200次，三个回归系数的变化如下图所示。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917195307000?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;从上图中我们可以看到，X2迭代50次左右就稳定了，但是其他两个则需要过多次的迭代。同时我们发现在大的波动停止之后，还会有一些小的周期性波动，产生这种现象的原因是因为存在一些不能正确分类的样本点（数据集并非线性可分），在每次迭代时会引发系数的剧烈改变。我们期望算法能避免来回波动，并且收敛也要足够快。</p>
<h2 id="改进的随机梯度上升算法"><a href="#改进的随机梯度上升算法" class="headerlink" title="改进的随机梯度上升算法"></a>改进的随机梯度上升算法</h2><p>&emsp;&emsp;先上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stocGradAscent1</span><span class="params">(dataMatrix, classLabels, numIter=<span class="number">150</span>)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	改进的随机梯度上升算法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Input：		dataMatIn：数据列表100*3</span></span><br><span class="line"><span class="string">				classLabels：标签列表1*100</span></span><br><span class="line"><span class="string">				numIter：迭代次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Output：	weights：权重参数矩阵</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#获取数据列表大小</span></span><br><span class="line">	m, n = shape(dataMatrix)</span><br><span class="line">	<span class="comment">#初始化权重参数矩阵，初始值都为1</span></span><br><span class="line">	weights = ones(n)</span><br><span class="line">	<span class="comment">#开始迭代，迭代次数为numIter</span></span><br><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(numIter):</span><br><span class="line">		<span class="comment">#初始化index列表，这里要注意将range输出转换成list</span></span><br><span class="line">		dataIndex = list(range(m))</span><br><span class="line">		<span class="comment">#遍历每一行数据，这里要注意将range输出转换成list</span></span><br><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> list(range(m)):</span><br><span class="line">			<span class="comment">#更新alpha值，缓解数据高频波动</span></span><br><span class="line">			alpha = <span class="number">4</span>/(<span class="number">1.0</span>+j+i)+<span class="number">0.0001</span></span><br><span class="line">			<span class="comment">#随机生成序列号，从而减少随机性的波动</span></span><br><span class="line">			randIndex = int(random.uniform(<span class="number">0</span>, len(dataIndex)))</span><br><span class="line">			<span class="comment">#序列号对应的元素与权重矩阵相乘，求和后再求sigmoid</span></span><br><span class="line">			h = sigmoid(sum(dataMatrix[randIndex]*weights))</span><br><span class="line">			<span class="comment">#求误差，和之前一样的操作</span></span><br><span class="line">			error = classLabels[randIndex] - h</span><br><span class="line">			<span class="comment">#更新权重矩阵</span></span><br><span class="line">			weights = weights + alpha * error * dataMatrix[randIndex]</span><br><span class="line">			<span class="comment">#删除这次计算的数据</span></span><br><span class="line">			<span class="keyword">del</span>(dataIndex[randIndex])</span><br><span class="line">	<span class="comment">#返回权重参数矩阵</span></span><br><span class="line">	<span class="keyword">return</span> weights</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;改进：</p>
<ul>
<li>一方面，alpha在每次迭代的时候都会调整，这会缓解上一张图中的数据高频波动。另外，虽然alpha会随着迭代次数不断减小，但永远不会减小到0，这是因为alpha更新公式中存在一个常数项，必须这样做的原因是为了保证在多次迭代之后新数据仍然具有一定得影响。如果要处理的问题是动态变化的，那么可以适当加大上述常数项，来确保新的值获得更大的回归系数。另一点值得注意的是，在降低alpha的函数中，alpha每次减少i/(j+i)时，alpha就不是严格下降的。便面参数的严格下降也常见于模拟退火算法等其他优化算法中。</li>
<li>另一方面，通过随机选取样本来更新回归系数，可以减少周期性的波动。</li>
</ul>
<p>&emsp;&emsp;同样的，下图反映了stocGradAscent1函数中，每次迭代时各个回归系数的变化情况。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917195327393?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;我们可以看到，除了周期性波动的减少，上图的水平轴也少了很多（只迭代了40次），这是因为该函数可以收敛的更快。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(logRegres)</span><br><span class="line">&lt;module <span class="string">'logRegres'</span> <span class="keyword">from</span> <span class="string">'logRegres.py'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dataArr, labelMat = logRegres.loadDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>weights=logRegres.stocGradAscent1(array(dataArr), labelMat)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>logRegres.plotBestFit(weights)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;分类效果如图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917195345825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;迄今为止我们分析了回归系数的变化情况，但还没有达到本章的最终目标，即完成具体的分类任务。下一届将使用随机梯度上升算法来解决病马的生死预测问题。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Logistic</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之Logistic回归（1）算法概述</title>
    <url>/folder/2019/11/08/2017-11-02-ml-4/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch05" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch05</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;其实从贝叶斯那一章开始，公式推导就渐渐多了起来，当然我在这里不是特指《机器学习实战》这本书，而是指整个机器学习的学习过程。但是为了按照原计划按时推博客（每周末推送《机器学习实战》一章的内容），所以公式推导部分相对于《机器学习实战》中对应的章节，会滞后两到三周发布。</p>
<h2 id="Logistic回归"><a href="#Logistic回归" class="headerlink" title="Logistic回归"></a>Logistic回归</h2><p>&emsp;&emsp;Andrew在course的machine learning第三周的课程中，讲的就是logistic回归，感兴趣的朋友们可以去看看。</p>
<p>&emsp;&emsp;首先介绍一下什么是回归。假设现在有一些数据点，我们用一条直线对这些点进行拟合（该线称为最佳拟合直线），这个拟合过程就称作回归。利用logistic回归进行分类的主要思想是：根据现有数据对分类边界线建立回归公式，以此进行分类。这里的“回归”一词源于最佳拟合，表示要找到最佳拟合参数集。训练分类器时的做大就是寻找最佳拟合参数，实用的是最优化方法，这也是我们首次接触最优化算法。</p>
<p>Logistic回归的一般过程：</p>
<ul>
<li>收集数据：采用任意方法收集数据。</li>
<li>准备数据：由于需要进行距离计算，因此要求数据类型为数值型。另外，结构化数据格式则最佳。</li>
<li>分析数据：采用任意方法对数据进行分析。</li>
<li>训练算法：大部分时间将用于训练，训练的目的是为了找到最佳的分类回归系数。</li>
<li>测试算法：一旦训练步骤完成，分类将会很快。</li>
<li>使用算法：首先，我们需要输入一些数据，并将其转换成对应的结构化数值；接着，基于训练好的回归系数就可以对这些数值进行简单的回归计算，判定他们属于哪个类别；在这之后，我们就可以在输出的类别上做一些其他分析工作。</li>
</ul>
<h2 id="基于Logistic回归和Sigmoid函数的分类"><a href="#基于Logistic回归和Sigmoid函数的分类" class="headerlink" title="基于Logistic回归和Sigmoid函数的分类"></a>基于Logistic回归和Sigmoid函数的分类</h2><p>Logistic回归：</p>
<ul>
<li>优点：计算代价不高，易于理解和实现。</li>
<li>缺点：容易欠拟合，分类精度可能不高。</li>
<li>适用数据类型：数值型和标称型数据。</li>
</ul>
<p>&emsp;&emsp;我们想要的函数，应该是能接受所有的输入然后预测出类别。例如，在两个类的情况下，预测结果输出0或1。我们之前应该接触过类似的函数：单位阶跃函数。我的天，看书之前，我都没想起来单位阶跃函数还有个高大上的名字：海维塞德阶跃函数（Heaviside step function）。然而，单位阶跃函数的问题在于这个函数在跳跃点上从0瞬间跳跃到1，这个瞬间跳跃过程很难处理。还好，Sigmoid函数挺身而出，用于和单位阶跃函数类似的性质，但在数学上更易处理。公式如下：</p>
<p>$$\sigma(z) = \frac{1}{(1 + e_{-z})}$$</p>
<p>&emsp;&emsp;下图给出了Sigmoid函数在不同坐标尺度下的两条曲线图。当x为0时，Sigmoid函数值为0.5.随着x的增大，对应的Sigmoid值将逼近与1；而随着x的减小，Sigmoid的值将逼近于0.如果横坐标刻度足够大，Sigmoid函数看起来很像一个单位阶跃函数。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170917165302047?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;因此，为了实现Lgistic回归分类器，我们可以在每个特征上都乘以一个回归系数，然后把所有的结果值都相加，将这个总和都带入Sigmoid()函数中，进而得到一个范围在0~1之间的数值。大于0.5则被分入1类，小于0.5则被分入0类。所以，Logistic回归也可以被看成是一种概率估计。</p>
<p>&emsp;&emsp;确定了分类器的函数形式之后，现在的问题成了：最佳回归系数是多少？如何确定他的大小？这些问题我们将在下一篇博文中进行讲解，包括基本的梯度上升法和一个改进的随机梯度上升法，这些最优化算法将被用于分类器的训练。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>Logistic</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之k近邻算法（3）识别手写数字</title>
    <url>/folder/2019/11/08/2017-11-01-ml-3/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch02" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch02</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;在这篇博文里，本渣渣将带领大家一步一步构造出使用k-近邻分类器的手写识别系统。书中提供了数据集，从0到9，如图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903093739108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="300" /></div>
<p></p>

<p>&emsp;&emsp;这些数字已经经过处理，统一变成32像素*32像素的黑白图像（文本格式）。</p>
<p>&emsp;&emsp;下面我们列出算法流程：</p>
<ul>
<li>(1)收集数据：提供文本文件。</li>
<li>(2)准备数据：编写函数img2vector(),将图像格式装还未分类器实用的向量格式。</li>
<li>(3)分析数据：在Python命令提示符中检擦数据，确保它符合要求。</li>
<li>(4)训练算法：此步骤不适用于k-近邻算法。</li>
<li>(5)测试算法：编写函数使用提供的部分数据集作为测试样本，测试样本与非测试样本的区别在于测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。</li>
<li>(6)使用算法：没有精力写应用程序了，爱折腾的大神们可以试试，自己以后复习的时候再写写这块。主要就是从图像中提取数字，并完成数字识别。</li>
</ul>
<p>##一、准备数据：</p>
<p>&emsp;&emsp;世纪图像存储在源代码的两个子目录里：目录trainingDigits中包含了大约2000个例子，每个例子的内容如下图所示，每个数字大约有200个样本；目录testDigits中包含了大约900个测试数据。两组数据没有重叠。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170903093739108?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="300" /></div>
<p></p>

<p>&emsp;&emsp;我们首先需要将图像转换成测试向量：即用一个1 * 1024的NumPy数组存储32 * 32的图像信息。</p>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Aug 18, 2017</span></span><br><span class="line"><span class="string">kNN: k Nearest Neighbors</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input:      inX: vector to compare to existing dataset (1xN)</span></span><br><span class="line"><span class="string">            dataSet: size m data set of known vectors (NxM)</span></span><br><span class="line"><span class="string">            labels: data set labels (1xM vector)</span></span><br><span class="line"><span class="string">            k: number of neighbors to use for comparison (should be an odd number)</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">Output:     the most popular class label</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: wordzzzz</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img2vector</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	32*32图像转换为1*1024向量</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		filename：文件名称字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	returnVect：转换之后的1*1024向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化要返回的1*1024向量</span></span><br><span class="line">	returnVect = zeros((<span class="number">1</span>, <span class="number">1024</span>))</span><br><span class="line">	<span class="comment">#打开文件</span></span><br><span class="line">	fr = open(filename)</span><br><span class="line">	<span class="comment">#读取文件信息</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">		<span class="comment">#循环读取文件的前32行</span></span><br><span class="line">		lineStr = fr.readline()</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">32</span>):</span><br><span class="line">			<span class="comment">#将每行的头32个字符存储到要返回的向量中</span></span><br><span class="line">			returnVect[<span class="number">0</span>, <span class="number">32</span>*i+j] = int(lineStr[j])</span><br><span class="line">	<span class="comment">#返回要输出的1*1024向量</span></span><br><span class="line">	<span class="keyword">return</span> returnVect</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(kNN)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testVector = kNN.img2vector(<span class="string">'testDigits/0_13.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testVector[<span class="number">0</span>,<span class="number">0</span>:<span class="number">31</span>]</span><br><span class="line">array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,</span><br><span class="line">        <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,</span><br><span class="line">        <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testVector[<span class="number">0</span>,<span class="number">32</span>:<span class="number">63</span>]</span><br><span class="line">array([ <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">1.</span>,</span><br><span class="line">        <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,</span><br><span class="line">        <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>,  <span class="number">0.</span>])</span><br></pre></td></tr></table></figure>

<p>##二、测试算法：</p>
<p>&emsp;&emsp;在之前的kNN.py代码中加入from os import listdir，然后编写下列测试程序即可测试算法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handwritingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	手写数字测试程序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	returnVect：转换之后的1*1024向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#初始化手写数字标签列表</span></span><br><span class="line">	hwLabels = []</span><br><span class="line">	<span class="comment">#获取训练目录信息</span></span><br><span class="line">	trainingFileList = listdir(<span class="string">'trainingDigits'</span>)</span><br><span class="line">	<span class="comment">#获取训练文件数目</span></span><br><span class="line">	m = len(trainingFileList)</span><br><span class="line">	<span class="comment">#初始化训练矩阵</span></span><br><span class="line">	trainingMat = zeros((m,<span class="number">1024</span>))</span><br><span class="line">	<span class="comment">#开始提取训练集</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">		<span class="comment">#从文件名解析出分类数字</span></span><br><span class="line">		fileNameStr = trainingFileList[i]</span><br><span class="line">		fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">		classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#存储解析出的分类数字到标签中</span></span><br><span class="line">		hwLabels.append(classNumStr)</span><br><span class="line">		<span class="comment">#载入图像</span></span><br><span class="line">		trainingMat[i, :] = img2vector(<span class="string">'trainingDigits/%s'</span> % fileNameStr)</span><br><span class="line">	<span class="comment">#获取测试目录信息</span></span><br><span class="line">	testFileList = listdir(<span class="string">'testDigits'</span>)</span><br><span class="line">	<span class="comment">#初始化错误计数</span></span><br><span class="line">	errorCount = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">#获取测试文件数目</span></span><br><span class="line">	mTest = len(testFileList)</span><br><span class="line">	<span class="comment">#开始测试</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(mTest):</span><br><span class="line">		<span class="comment">#从文件名解析出分类数字</span></span><br><span class="line">		fileNameStr = testFileList[i]</span><br><span class="line">		fileStr = fileNameStr.split(<span class="string">'.'</span>)[<span class="number">0</span>]</span><br><span class="line">		classNumStr = int(fileStr.split(<span class="string">'_'</span>)[<span class="number">0</span>])</span><br><span class="line">		<span class="comment">#载入图像</span></span><br><span class="line">		vectorUnderTest = img2vector(<span class="string">'trainingDigits/%s'</span> % fileNameStr)</span><br><span class="line">		<span class="comment">#参数传入分类器进行分类</span></span><br><span class="line">		classifierResult = classify0(vectorUnderTest, trainingMat, hwLabels, <span class="number">3</span>)</span><br><span class="line">		<span class="comment">#打印输出分类结果和真实结果</span></span><br><span class="line">		print(<span class="string">"the classifier came back with: %d, the real answer is: %d"</span> %(classifierResult, classNumStr))</span><br><span class="line">		<span class="comment">#如果分类结果不等于真实结果，错误计数加一</span></span><br><span class="line">		<span class="keyword">if</span> (classifierResult != classNumStr): errorCount += <span class="number">1.0</span></span><br><span class="line">	<span class="comment">#输出错误技术</span></span><br><span class="line">	print(<span class="string">"\nthe total number of errors is: %d"</span> % errorCount)</span><br><span class="line">	<span class="comment">#输出错误率</span></span><br><span class="line">	print(<span class="string">"\nthe total error rate is: %f"</span> % (errorCount/float(mTest)))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(kNN)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kNN.handwritingClassTest()</span><br><span class="line">the classifier came back <span class="keyword">with</span>: <span class="number">0</span>, the real answer <span class="keyword">is</span>: <span class="number">0</span></span><br><span class="line">the classifier came back <span class="keyword">with</span>: <span class="number">0</span>, the real answer <span class="keyword">is</span>: <span class="number">0</span></span><br><span class="line">the classifier came back <span class="keyword">with</span>: <span class="number">0</span>, the real answer <span class="keyword">is</span>: <span class="number">0</span></span><br><span class="line">······</span><br><span class="line">the classifier came back <span class="keyword">with</span>: <span class="number">9</span>, the real answer <span class="keyword">is</span>: <span class="number">9</span></span><br><span class="line">the classifier came back <span class="keyword">with</span>: <span class="number">9</span>, the real answer <span class="keyword">is</span>: <span class="number">9</span></span><br><span class="line">the classifier came back <span class="keyword">with</span>: <span class="number">9</span>, the real answer <span class="keyword">is</span>: <span class="number">9</span></span><br><span class="line"></span><br><span class="line">the total number of errors <span class="keyword">is</span>: <span class="number">13</span></span><br><span class="line"></span><br><span class="line">the total error rate <span class="keyword">is</span>: <span class="number">0.013742</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;k-近邻算法识别手写数字数据集，错误率为1.2%。依赖于分类算法、数据集和程序设置，分类器的输出结果可能有很大的不同。大家可以自行修改变量hoRatio和变量k的数值，看看检测错误率是否会发生变化。</p>
<p>&emsp;&emsp;实际使用这个算法时，算法的执行效率并不高。因为算法需要为每个测试向量做2000次距离计算，而每个距离计算包括了1024个维度浮点运算，总计执行900次，此外，还需要为测试向量准备2MB的存储空间。以后要讲的k决策树科一节省大量的计算开销。</p>
<h2 id="三、k-近邻算法总结："><a href="#三、k-近邻算法总结：" class="headerlink" title="三、k-近邻算法总结："></a>三、k-近邻算法总结：</h2><p>优点：</p>
<ul>
<li>k-近邻算法是分类数据最简单有效的算法，是基于实例的学习，使用算法时我们必须有接近实际数据的训练样本数据。</li>
</ul>
<p>缺点：</p>
<ul>
<li>k-近邻算法必须保存全部数据集，并对数据集中的每个数据计算距离值，实际使用时耗时耗存储。</li>
<li>而且，它无法给出任何数据的基础结构信息，所以我们不知道平均实例样本与典型实例样本具有什么特征（概率测量方法处理分类问题时可以解决这个问题）。</li>
</ul>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之k近邻算法（2）我们约会吧</title>
    <url>/folder/2019/11/08/2017-11-01-ml-2/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch02" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch02</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;在本篇博文中，本渣渣要通过约会网站给自己找个满意的妹纸，嘿嘿嘿！当然，一切都只是模拟，数据什么都是现成的······</p>
<p>&emsp;&emsp;下面我们列出算法流程：</p>
<ul>
<li>(1)收集数据：提供文本文件。</li>
<li>(2)准备数据：使用Python解析文本文件。</li>
<li>(3)分析数据：使用Matplotlib画二维扩散图。</li>
<li>(4)训练算法：此步骤不适用于k-近邻算法。</li>
<li>(5)测试算法：使用提供的部分数据作为测试样本。<pre><code>测试样本和非测试样本的区别在于：测试样本是已经完成分类的数据，如果预测分类与实际类别不同，则标记为一个错误。</code></pre></li>
<li>(6)使用算法：产生简单的命令行程序，然后可以输入一些特征数据以判断对方是否为自己喜欢的类型。</li>
</ul>
<h2 id="一、准备数据"><a href="#一、准备数据" class="headerlink" title="一、准备数据"></a>一、准备数据</h2><p>&emsp;&emsp;datingTestSet2.txt中，每个样本数据占据一行，总共有1000行。主要包含以下3种特征：</p>
<ul>
<li>每年获得的飞行常客里程数</li>
<li>玩视频游戏所耗时间百分比</li>
<li>每周消费的冰淇淋公升数</li>
</ul>
<p>&emsp;&emsp;在将上述特征数据输入到分类器之前，必须将待处理数据的格式改变为分类器可以接受的格式。在kNN.py中创建名为file2matrix的函数，以此来处理输入格式问题。该函数的输入为文件名字符串，输出为训练样本矩阵和类标签向量。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Created on Aug 18, 2017</span></span><br><span class="line"><span class="string">kNN: k Nearest Neighbors</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input:      inX: vector to compare to existing dataset (1xN)</span></span><br><span class="line"><span class="string">            dataSet: size m data set of known vectors (NxM)</span></span><br><span class="line"><span class="string">            labels: data set labels (1xM vector)</span></span><br><span class="line"><span class="string">            k: number of neighbors to use for comparison (should be an odd number)</span></span><br><span class="line"><span class="string">            </span></span><br><span class="line"><span class="string">Output:     the most popular class label</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@author: wordzzzz</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> listdir</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file2matrix</span><span class="params">(filename)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	从文本文件中解析数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		filename：文件名称字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	returnMat：训练样本矩阵</span></span><br><span class="line"><span class="string">				classLabelVector：类标签向量</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#打开文件</span></span><br><span class="line">	fr = open(filename)</span><br><span class="line">	<span class="comment">#得到文件行数</span></span><br><span class="line">	numberOFLines = len(fr.readlines())</span><br><span class="line">	<span class="comment">#创建返回的NumPy矩阵</span></span><br><span class="line">	returnMat = zeros((numberOFLines, <span class="number">3</span>))</span><br><span class="line">	<span class="comment">#创建返回的向量列表</span></span><br><span class="line">	classLabelVector = []</span><br><span class="line">	fr = open(filename)</span><br><span class="line">	index = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">		<span class="comment">#使用line.strip()截取掉多有的回车符</span></span><br><span class="line">		line = line.strip()</span><br><span class="line">		<span class="comment">#使用tab字符将上一步得到的整行数据分割成一个元素列表</span></span><br><span class="line">		listFromLine = line.split(<span class="string">'\t'</span>)</span><br><span class="line">		<span class="comment">#选取前三个元素，存储到特征矩阵中</span></span><br><span class="line">		returnMat[index, :] = listFromLine[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">		<span class="comment">#将列表最后一列存储到向量classLabelVector中</span></span><br><span class="line">		classLabelVector.append(int(listFromLine[<span class="number">-1</span>]))</span><br><span class="line">		index += <span class="number">1</span></span><br><span class="line">	<span class="comment">#返回训练样本矩阵和类标签向量</span></span><br><span class="line">	<span class="keyword">return</span> returnMat, classLabelVector</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意我们要打开的文本文件是datingTestSet2.txt，而不是datingTestSet.txt，否则会出现如下报错：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datingDataMat, datingLabels = kNN.file2matrix(<span class="string">'datingTestSet.txt'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"E:\机器学习实战\mycode\Ch02\kNN.py"</span>, line <span class="number">105</span>, <span class="keyword">in</span> file2matrix</span><br><span class="line">    classLabelVector.append(int(listFromLine[<span class="number">-1</span>]))</span><br><span class="line">ValueError: invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'largeDoses'</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kNN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datingDataMat,datingLabels = kNN.file2matrix(<span class="string">'datingTestSet2.txt'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datingDataMat</span><br><span class="line">array([[  <span class="number">4.09200000e+04</span>,   <span class="number">8.32697600e+00</span>,   <span class="number">9.53952000e-01</span>],</span><br><span class="line">       [  <span class="number">1.44880000e+04</span>,   <span class="number">7.15346900e+00</span>,   <span class="number">1.67390400e+00</span>],</span><br><span class="line">       [  <span class="number">2.60520000e+04</span>,   <span class="number">1.44187100e+00</span>,   <span class="number">8.05124000e-01</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [  <span class="number">2.65750000e+04</span>,   <span class="number">1.06501020e+01</span>,   <span class="number">8.66627000e-01</span>],</span><br><span class="line">       [  <span class="number">4.81110000e+04</span>,   <span class="number">9.13452800e+00</span>,   <span class="number">7.28045000e-01</span>],</span><br><span class="line">       [  <span class="number">4.37570000e+04</span>,   <span class="number">7.88260100e+00</span>,   <span class="number">1.33244600e+00</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datingLabels[<span class="number">0</span>:<span class="number">20</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h2 id="二、分析数据"><a href="#二、分析数据" class="headerlink" title="二、分析数据"></a>二、分析数据</h2><p>&emsp;&emsp;首先我们使用Matplotlib制作原始数据的散点图，在Python命令行环境中输入如下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fig = plt.figure()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(datingDataMat[:,<span class="number">1</span>], datingDataMat[:,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.show()</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;输出效果如图2-3所示。散点图使用datingDataMat数据矩阵中的第二、第三列数据，分别表示特征值“玩视频游戏所耗时间百分比”和“每周所消费的冰淇淋公升数”。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170901205709316?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&emsp;&emsp;本渣渣在上图中看不出任何规律，因为没加标签信息。Matplotlib库提供的scatter函数支持个性化标记散点图上的点。重新输入上面的代码，并加上下面这段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ax.scatter(datingDataMat[:,<span class="number">1</span>], datingDataMat[:,<span class="number">2</span>],</span><br><span class="line"><span class="number">15.0</span>*array(datingLabels), <span class="number">15.0</span>*array(datingLabels))</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;输出效果如图2-4所示。带有样本分类标签的约会数据散点图虽然能够比较容易地区分数据点从属类别，但依然很难根据这张图得出结论性信息。运行createFirstPlot.py可以直接得到该图。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170901205727981?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&emsp;&emsp;createDist2.py则使用数据矩阵中的第一、第二列数据，分别表示特征值“每年获得的飞行常客里程数”和“玩视频游戏所耗时间百分比”，展示效果更好：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170901205746408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&emsp;&emsp;表2-3给出了提取的四组数据，如果想要极端样本3和样本4之间的距离，可以使用下面的方法：<br><code>!$\sqrt{(0-67)^2+(20000-32000)^2+(1.1-0.1)^2} $</code><br>&emsp;&emsp;本渣渣发现，数字差值最大的特征对计算结果的影响最大。但是三种特征对我们来说是同等重要的，所以，我们需要对数值进行归一化，将取值范围处理为0到1之间（当然-1到1之间也可以）。下面是归一化的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">autoNorm</span><span class="params">(dataSet)</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	归一化特征值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		dataSet：训练验本矩阵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	normDataSet：归一化矩阵</span></span><br><span class="line"><span class="string">				ranges：每一列的差值</span></span><br><span class="line"><span class="string">				minVals：每一列的最小值</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#求取列的最小值</span></span><br><span class="line">	minVals = dataSet.min(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">#求取列的最大值</span></span><br><span class="line">	maxVals = dataSet.max(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">#最大值与最小值做差</span></span><br><span class="line">	ranges = maxVals - minVals</span><br><span class="line">	<span class="comment">#创建输出矩阵normDataSet</span></span><br><span class="line">	normDataSet = zeros(shape(dataSet))</span><br><span class="line">	<span class="comment">#m设定为矩阵dataSet的行数</span></span><br><span class="line">	m = dataSet.shape[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#对矩阵dataSet每个元素求差</span></span><br><span class="line">	normDataSet = dataSet - tile(minVals, (m, <span class="number">1</span>))</span><br><span class="line">	<span class="comment">#对矩阵dataSet每个元素归一化</span></span><br><span class="line">	normDataSet = normDataSet/tile(ranges, (m, <span class="number">1</span>))</span><br><span class="line">	<span class="comment">#返回归一化矩阵、差值向量和最小值向量</span></span><br><span class="line">	<span class="keyword">return</span> normDataSet, ranges, minVals</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>normMat, ranges, minVals = kNN.autoNorm(datingDataMat)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>normMat</span><br><span class="line">array([[ <span class="number">0.44832535</span>,  <span class="number">0.39805139</span>,  <span class="number">0.56233353</span>],</span><br><span class="line">       [ <span class="number">0.15873259</span>,  <span class="number">0.34195467</span>,  <span class="number">0.98724416</span>],</span><br><span class="line">       [ <span class="number">0.28542943</span>,  <span class="number">0.06892523</span>,  <span class="number">0.47449629</span>],</span><br><span class="line">       ...,</span><br><span class="line">       [ <span class="number">0.29115949</span>,  <span class="number">0.50910294</span>,  <span class="number">0.51079493</span>],</span><br><span class="line">       [ <span class="number">0.52711097</span>,  <span class="number">0.43665451</span>,  <span class="number">0.4290048</span> ],</span><br><span class="line">       [ <span class="number">0.47940793</span>,  <span class="number">0.3768091</span> ,  <span class="number">0.78571804</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ranges</span><br><span class="line">array([  <span class="number">9.12730000e+04</span>,   <span class="number">2.09193490e+01</span>,   <span class="number">1.69436100e+00</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>minVals</span><br><span class="line">array([ <span class="number">0.</span>      ,  <span class="number">0.</span>      ,  <span class="number">0.001156</span>])</span><br></pre></td></tr></table></figure>

<p>##三、测试算法</p>
<p>&emsp;&emsp;机器学习算法一个很重要的工作就是评估算法的正确率，通常我们只提供已有数据的90%作为训练样本来训练分类器，而使用其余的10%数据去测试分类器，检测分类器的正确率。需要注意的是，10%的测试数据应该是随机选择的，由于我们的数据并没有按照特定目的来排序，所以我们可以随意选择10%数据而不影响其随机性。</p>
<p>&emsp;&emsp;代码里我们定义一个计数器变量，每次分类器错误的分类数据，计数器就加1，程序执行完成之后计数器的结果除以数据点总数即是错误率。为了测试分类器效果，在kNN.py文件中创建函数datingClassTest，该函数是自包含的，你可以在任何时候在Python运行环境中使用该函数测试分类器效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">datingClassTest</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	分类器测试代码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		无</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	classifierResult：分类器分类结果</span></span><br><span class="line"><span class="string">				datingLabels[i]：真实结果</span></span><br><span class="line"><span class="string">				errorCount：分类误差</span></span><br><span class="line"><span class="string">	"""</span>	</span><br><span class="line">	<span class="comment">#测试集比例设定：10%</span></span><br><span class="line">	hoRatio = <span class="number">0.1</span></span><br><span class="line">	<span class="comment">#从文本文件中解析数据</span></span><br><span class="line">	datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)</span><br><span class="line">	<span class="comment">#归一化特征值</span></span><br><span class="line">	normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">	<span class="comment">#计算normMat矩阵行数并赋值给m</span></span><br><span class="line">	m = normMat.shape[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">#初始化测试向量个数</span></span><br><span class="line">	numTestVecs = int(m*hoRatio)</span><br><span class="line">	<span class="comment">#初始化错误计数</span></span><br><span class="line">	errorCount = <span class="number">0.0</span></span><br><span class="line">	<span class="comment">#对测试集分类，返回分类结果并打印</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(numTestVecs):</span><br><span class="line">		<span class="comment">#传参给分类器进行分类，每个for循环改变的参数只有第一项的测试数据而已</span></span><br><span class="line">		classifierResult = classify0(normMat[i,:], normMat[numTestVecs:m, :], datingLabels[numTestVecs:m], <span class="number">3</span>)</span><br><span class="line">		<span class="comment">#打印当前测试数据的分类结果个真实结果</span></span><br><span class="line">		print(<span class="string">"the classfier came back with: %d, the real answer is: %d"</span> % (classifierResult, datingLabels[i]))</span><br><span class="line">		<span class="comment">#如果分类结果不等于真是结果，错误计数加一</span></span><br><span class="line">		<span class="keyword">if</span> (classifierResult != datingLabels[i]): errorCount += <span class="number">1.0</span></span><br><span class="line">	<span class="comment">#输出测试错误率</span></span><br><span class="line">	print(<span class="string">"the total error rate is: %f"</span> % (errorCount/float(numTestVecs)))</span><br><span class="line">	<span class="comment">#输出测试错误数</span></span><br><span class="line">	print(errorCount)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kNN.datingClassTest()</span><br><span class="line">the classfier came back <span class="keyword">with</span>: <span class="number">3</span>, the real answer <span class="keyword">is</span>: <span class="number">3</span></span><br><span class="line">the classfier came back <span class="keyword">with</span>: <span class="number">2</span>, the real answer <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line">the classfier came back <span class="keyword">with</span>: <span class="number">1</span>, the real answer <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">······</span><br><span class="line">the classfier came back <span class="keyword">with</span>: <span class="number">2</span>, the real answer <span class="keyword">is</span>: <span class="number">2</span></span><br><span class="line">the classfier came back <span class="keyword">with</span>: <span class="number">1</span>, the real answer <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">the classfier came back <span class="keyword">with</span>: <span class="number">3</span>, the real answer <span class="keyword">is</span>: <span class="number">1</span></span><br><span class="line">the total error rate <span class="keyword">is</span>: <span class="number">0.050000</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;分类器处理约会数据集的错误率为5%，这是一个很不错的结果。依赖于分类算法、数据集和程序设置，分类器的输出结果可能有很大的不同。大家可以自行修改变量hoRatio和变量k的数值，看看检测错误率是否会发生变化。</p>
<p>&emsp;&emsp;这个例子表明我们可以正确的预测分类，错误率仅为5%。我们完全可以输入未知对象的属性信息，由分类软件来帮助让判定某一对象的可交往程度。</p>
<h2 id="四、使用算法"><a href="#四、使用算法" class="headerlink" title="四、使用算法"></a>四、使用算法</h2><p>&emsp;&emsp;我们把我们的代码封装一下，并加入输入捕捉函数input()进行输入捕捉。该函数允许用户输入文本命令行并返回用户所输入的命令。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classifyPerson</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="string">"""</span></span><br><span class="line"><span class="string">	Function：	约会网站测试函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Args：		percentTats：玩视频游戏消耗时间百分比</span></span><br><span class="line"><span class="string">				ffMiles：每年获得的飞行常客里程数</span></span><br><span class="line"><span class="string">				iceCream：每周消费的冰淇淋公升数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	Returns：	resultList：可交往程度</span></span><br><span class="line"><span class="string">	"""</span></span><br><span class="line">	<span class="comment">#建立输出列表</span></span><br><span class="line">	resultList = [<span class="string">'not at all'</span>, <span class="string">'in small doses'</span>, <span class="string">'in large doses'</span>]</span><br><span class="line">	<span class="comment">#读取键盘输入的数值</span></span><br><span class="line">	percentTats = float(input(<span class="string">"percentage of time spent playing video games?"</span>))</span><br><span class="line">	ffMiles = float(input(<span class="string">"frequent flier miles earned per year?"</span>))</span><br><span class="line">	iceCream = float(input(<span class="string">"liters of ice cream consumed per week?"</span>))</span><br><span class="line">	<span class="comment">#从文本文件中解析数据</span></span><br><span class="line">	datingDataMat, datingLabels = file2matrix(<span class="string">'datingTestSet2.txt'</span>)</span><br><span class="line">	<span class="comment">#归一化特征值</span></span><br><span class="line">	normMat, ranges, minVals = autoNorm(datingDataMat)</span><br><span class="line">	<span class="comment">#将先前读取的键盘输入填入数组</span></span><br><span class="line">	inArr = array([ffMiles, percentTats, iceCream])</span><br><span class="line">	<span class="comment">#分类：这里也对输入数据进行了归一化</span></span><br><span class="line">	classifierResult = classify0((inArr - minVals) / ranges, normMat, datingLabels, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">#打印分类信息</span></span><br><span class="line">	print(<span class="string">"You wil probably like this person: "</span>, resultList[classifierResult - <span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>kNN.classifyPerson()</span><br><span class="line">percentage of time spent playing video games?10</span><br><span class="line">frequent flier miles earned per year?10000</span><br><span class="line">liters of ice cream consumed per year?0.5</span><br><span class="line">You wil probably like this person:  <span class="keyword">in</span> small doses</span><br></pre></td></tr></table></figure>

<h2 id="五、主要区分函数："><a href="#五、主要区分函数：" class="headerlink" title="五、主要区分函数："></a>五、主要区分函数：</h2><p>详解：<br>raw_input( )和input( )：<br><a href="http://blog.csdn.net/u011475210/article/details/77777482" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/77777482</a></p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>《机器学习实战》之k近邻算法（1）算法概述</title>
    <url>/folder/2019/11/08/2017-11-01-ml-1/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>代码地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch02" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch02</a></strong></li>
<li><strong>操作系统：WINDOWS 10</strong></li>
<li><strong>软件版本：python-3.6.2-amd64</strong></li>
<li><strong>编&emsp;&emsp;者：WordZzzz</strong></li>
</ul>
<hr>
<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>&emsp;&emsp;本渣渣（WordZzzz直接被舍友叫成了“我的渣”，所以以后我在博客中就以此自居了！），最近在学习Peter Harrington的<em>Machine Learning in Action</em>，一边看书一边用Python3.6实现课本中的算法（原书中使用的是Python2.x）。好记性不如烂笔头，奈何本渣渣连烂笔头都买不起，所以就来这不费笔墨的地方费尽心思写博客。本渣渣记性不是一般的差，在此记下每个算法的学习要点及Python代码实现，一方面方便自己以后复习，另一方面贴出来和大家一起学习，共同进步<del>~</del></p>
<p><strong><font color="red">注意：python3.x与python2.x的部分函数库有较大差异，针对这个问题，本渣渣会将代码版本升级中遇到的问题在每篇博文的最后列出来，并加以解释说明，帮助大家区分理解。</font></strong></p>
<p>原著代码（python2.x）地址：<a href="https://www.manning.com/books/machine-learning-in-action" target="_blank" rel="noopener">https://www.manning.com/books/machine-learning-in-action</a><br>本渣渣代码（python3.x）地址：<a href="https://github.com/WordZzzz/ML/tree/master/Ch02" target="_blank" rel="noopener">https://github.com/WordZzzz/ML/tree/master/Ch02</a></p>
<p>&emsp;&emsp;博客中的代码都会在本渣渣的GitHub上贴出，欢迎<em>Watch、Star、Fork</em>。</p>
<h2 id="一、算法介绍："><a href="#一、算法介绍：" class="headerlink" title="一、算法介绍："></a>一、算法介绍：</h2><p>&emsp;&emsp;k-近邻算法（kNN）的工作原理是：存在一个样本数据集合，也称作训练样本集，并且样本集中每个数据都存在标签，即我们知道样本集中每一数据所属分类的对应关系。输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行比较，然后算法提取样本集中特征最相似数据（最近邻）的分类标签。一般来说，我们只选择样本数据集中前k个最相似的数据，这就是k-近邻算法的中k的出处，通常k是不大于20的整数。最后，选择k个最相似数据中出现次数最多的分类，作为新数据的分类。<br>&emsp;&emsp;简单的说，k-近邻算法采用测量不同特征值之间的距离方法进行分类。</p>
<h3 id="k-近邻算法："><a href="#k-近邻算法：" class="headerlink" title="k-近邻算法："></a>k-近邻算法：</h3><ul>
<li>优点：精度高、对异常值不敏感、无数据输入假定。</li>
<li>缺点：计算复杂度高、空间复杂度高。</li>
<li>使用数据范围：数值型和标称型。</li>
</ul>
<p>&emsp;&emsp;书上有个电影分类的例子，使用k-近邻算法分类爱情片和工作片。书中给出了6部电影的打斗镜头数和接吻镜头数，如图2-1所示。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170901152654187?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>&emsp;&emsp;假如有一部未看过的电影，如何确定它是爱情片还是动作片呢？下面我们将使用kNN来解决这个问题。</p>
<p>&emsp;&emsp;首先，我们需要数据，即这个未知电影存在多少个打斗镜头和接吻镜头，图2-1中间问号位置是该电影出现的镜头数图像化的结果，具体数字参见表2-1。</p>
<table>
<thead>
<tr>
<th align="center">电影名称</th>
<th align="center">打斗镜头</th>
<th align="center">接吻镜头</th>
<th align="center">电影类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">California Man</td>
<td align="center">3</td>
<td align="center">104</td>
<td align="center">爱情片</td>
</tr>
<tr>
<td align="center">He is Not Really into Dudes</td>
<td align="center">2</td>
<td align="center">100</td>
<td align="center">爱情片</td>
</tr>
<tr>
<td align="center">Beautiful Woman</td>
<td align="center">1</td>
<td align="center">81</td>
<td align="center">爱情片</td>
</tr>
<tr>
<td align="center">Kevin Longblade</td>
<td align="center">101</td>
<td align="center">10</td>
<td align="center">动作片</td>
</tr>
<tr>
<td align="center">Robo Slayer 3000</td>
<td align="center">99</td>
<td align="center">5</td>
<td align="center">动作片</td>
</tr>
<tr>
<td align="center">Amped Ⅱ</td>
<td align="center">98</td>
<td align="center">2</td>
<td align="center">动作片</td>
</tr>
<tr>
<td align="center">？</td>
<td align="center">18</td>
<td align="center">90</td>
<td align="center">未知型</td>
</tr>
<tr>
<td align="center">[表2-1 每部电影的镜头统计及电影评估类型]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>&emsp;&emsp;计算未知电影和样本集中其他电影的距离，如表2-2所示。我们暂且不关心如何计算得到这些距离值，后面会提供具体的计算方法。</p>
<table>
<thead>
<tr>
<th align="center">电影名称</th>
<th align="center">与未知电影的距离</th>
</tr>
</thead>
<tbody><tr>
<td align="center">California Man</td>
<td align="center">20.5</td>
</tr>
<tr>
<td align="center">He is Not Really into Dudes</td>
<td align="center">18.7</td>
</tr>
<tr>
<td align="center">Beautiful Woman</td>
<td align="center">19.2</td>
</tr>
<tr>
<td align="center">Kevin Longblade</td>
<td align="center">115.3</td>
</tr>
<tr>
<td align="center">Robo Slayer 3000</td>
<td align="center">117.4</td>
</tr>
<tr>
<td align="center">Amped Ⅱ</td>
<td align="center">9118.9</td>
</tr>
<tr>
<td align="center">[表2-2 已知电影与未知电影的距离]</td>
<td align="center"></td>
</tr>
</tbody></table>
<p>&emsp;&emsp;现在我们得到了样本集中所有电影与未知电影的距离，按照距离递增排序，可以找到k个距离最近的电影。假定<code>k = 3</code>，则三个最靠近的电影依次是<em>He is Not Really into Dudes</em>、<em>Beautiful Woman</em>、<em>California Man</em>。k-近邻算法按照距离最近的三部电影的类型，决定位置电影的类型，而这三部电影全是爱情片，所以我们判定未知电影为爱情片。</p>
<h3 id="一般流程："><a href="#一般流程：" class="headerlink" title="一般流程："></a>一般流程：</h3><ul>
<li>收集数据：可以使用任何方法。</li>
<li>准备数据：距离计算所需要的数值，最好是结构化的数据格式。</li>
<li>分析数据：可以使用任何方法。</li>
<li>训练算法：此步骤不适用于k-近邻算法。</li>
<li>测试算法：计算错误率。</li>
<li>使用算法：首先需要输入样本数据和结构化的输出结果，然后运行k-近邻算法判定输入数据分别属于哪个分类，最后应用对计算出的分类执行后续处理。</li>
</ul>
<h2 id="二、代码实现与详解："><a href="#二、代码实现与详解：" class="headerlink" title="二、代码实现与详解："></a>二、代码实现与详解：</h2><p>&emsp;&emsp;首先，创建名为kNN.py的Python模块。所有代码都已做出详细注释，所以不再赘述，如有疑问可以在下方评论哦~</p>
<p>2.1 创建数据集和标签：</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">Created on Aug 18, 2017</span><br><span class="line">kNN: k Nearest Neighbors</span><br><span class="line"></span><br><span class="line">Input:      inX: vector to compare to existing dataset (1xN)</span><br><span class="line">            dataSet: size m data set of known vectors (NxM)</span><br><span class="line">            labels: data set labels (1xM vector)</span><br><span class="line">            k: number of neighbors to use for comparison (should be an odd number)</span><br><span class="line">            </span><br><span class="line">Output:     the most popular class label</span><br><span class="line"></span><br><span class="line">@author: wordzzzz</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">from numpy import *</span><br><span class="line">import operator</span><br><span class="line"></span><br><span class="line">def createDataSet():</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	Function：	创建数据集和标签</span><br><span class="line"></span><br><span class="line">	Args：		无</span><br><span class="line"></span><br><span class="line">	Returns：	group：创建的数据集</span><br><span class="line">				labels：创建的标签</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">	#创建数据集</span><br><span class="line">	group = array([[1.0, 1.1], [1.0, 1.0], [0, 0], [0, 0.1]])</span><br><span class="line">	#创建标签</span><br><span class="line">	labels = [&apos;A&apos;, &apos;A&apos;, &apos;B&apos;, &apos;B&apos;]</span><br><span class="line">	#返回创建的数据集和标签						</span><br><span class="line">	return group, labels</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;保存编写好的kNN.py模块，在Windows下打开命令提示符。如果不想在终端通过命令行一步一步敲到当前目录，可以直接在当前文件夹按住shift+右键，这个时候便会出现命令提示符的选项，单击后终端内直接显示当前文件夹。然后输入python，进入python编译开发环境。</p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> kNN</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group,labels = kNN.createDataSet()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>group</span><br><span class="line">array([[ <span class="number">1.</span> ,  <span class="number">1.1</span>],</span><br><span class="line">       [ <span class="number">1.</span> ,  <span class="number">1.</span> ],</span><br><span class="line">       [ <span class="number">0.</span> ,  <span class="number">0.</span> ],</span><br><span class="line">       [ <span class="number">0.</span> ,  <span class="number">0.1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>labels</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;向量labels包含了每个数据点的标签信息，labels包含的元素个数等于group矩阵行数。这里我们将数据点(1, 1.1)定义为类A，数据点(0, 0.1)定义为类B。为了说明方便，例子中的数值是任意选择的，并没有给出轴标签，图2-2是带有标签信息的四个数据点。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170901152735031?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>2.2 实施kNN分类算法：</p>
<p>伪代码：<br>&emsp;&emsp;对未知类别属性的数据集中的每个点依次执行以下操作：</p>
<ul>
<li>(1).计算已知类别数据集中的点与当前点之间的距离；</li>
<li>(2).按照距离递增次序排序；</li>
<li>(3).选取与当前点距离最小的k个点；</li>
<li>(4).确定前k个点所在类别的出现频率；</li>
<li>(5).返回前k个点出现频率最高的类别作为当前点的预测分类。</li>
</ul>
<p>&emsp;&emsp;这里我们使用欧氏距离公式，计算两个向量点xA和xB之间的距离：<br>$$ d = \sqrt{(xA_0-xB_0)^2+(xA_1-xB_1)^2}  $$</p>
<p>&emsp;&emsp;如果特征值有多个，那公式就变成了这个样子：<br>$$ d = \sqrt{\sum_{i=0}^N{(xA_i-xB_i)^2}}  $$</p>
<p>代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def classify0(inX, dataSet, labels, k):</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	Function：	创建数据集和标签</span><br><span class="line"></span><br><span class="line">	Args：		inX：用于分类的输入向量 (1xN)</span><br><span class="line">            	dataSet：输入的训练样本集 (NxM)</span><br><span class="line">            	labels：标签向量 (1xM vector)</span><br><span class="line">            	k：用于比较的近邻数量 (should be an odd number)</span><br><span class="line"></span><br><span class="line">	Returns：	sortedClassCount[0][0]：分类结果</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	#dataSet.shape[0]：求dataSet矩阵的行数</span><br><span class="line">	#dataSet.shape[1]：求dataSet矩阵的列数</span><br><span class="line">	#dataSet.shape：元组形式输出矩阵行数、列数</span><br><span class="line">	dataSetSize = dataSet.shape[0]</span><br><span class="line">	#tile(A, B)：将A重复B次，其中B可以是int类型也可以是元组类型</span><br><span class="line">	#这句话相当于向量inX与矩阵dataSet里面的每组数据做差</span><br><span class="line">	diffMat = tile(inX, (dataSetSize, 1)) - dataSet</span><br><span class="line">	#对求差后的矩阵求平方</span><br><span class="line">	sqDiffMat = diffMat**2</span><br><span class="line">	#sqDiffMat.sum(axis=0)：对矩阵的每一列求和</span><br><span class="line">	#sqDiffMat.sum(axis=1)：对矩阵的每一行求和</span><br><span class="line">	#sqDiffMat.sum()：对整个矩阵求和</span><br><span class="line">	sqDistances = sqDiffMat.sum(axis=1)</span><br><span class="line">	#求平方根</span><br><span class="line">	distances = sqDistances**0.5</span><br><span class="line">	#对上式结果进行排序</span><br><span class="line">	sortedDistIndicies = distances.argsort()</span><br><span class="line">	#创建字典</span><br><span class="line">	classCount = &#123;&#125;</span><br><span class="line">	#给字典赋值</span><br><span class="line">	for i in range(k):</span><br><span class="line">		#字典的key</span><br><span class="line">		voteIlabel = labels[sortedDistIndicies[i]]</span><br><span class="line">		#classCount.get(voteIlabel,0)：如果字典键的值中有voteIlabel，则返回0（第二个参数的值）</span><br><span class="line">		classCount[voteIlabel] = classCount.get(voteIlabel,0) + 1</span><br><span class="line">	#对classCount进行排序，sroted、items以及itermgetter随后讲解@1</span><br><span class="line">	sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1), reverse=True)</span><br><span class="line">	#返回分类结果</span><br><span class="line">	return sortedClassCount[0][0]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;保存编写好的kNN.py模块，此时如果你不重新加载模块，你的命令提示符里面已经加载过的模块是不会自动更新的。所以我们需要调用imp模块中的reload来重新加载新保存的模块。我们输入两个不同的例子[0.9, 0.9][0.1, 0.1]，得到相应的分类结果并输出。</p>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> imp <span class="keyword">import</span> reload</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(kNN)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kNN.classify0([<span class="number">0.9</span>,<span class="number">0.9</span>], group, labels, <span class="number">3</span>)</span><br><span class="line"><span class="string">'A'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kNN.classify0([<span class="number">0.1</span>,<span class="number">0.1</span>], group, labels, <span class="number">3</span>)</span><br><span class="line"><span class="string">'B'</span></span><br></pre></td></tr></table></figure>

<h2 id="三、主要区分函数："><a href="#三、主要区分函数：" class="headerlink" title="三、主要区分函数："></a>三、主要区分函数：</h2><p>详解：<br>1.sorted,sort以及argsort：</p>
<p><a href="http://blog.csdn.net/u011475210/article/details/77769245" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/77769245</a></p>
<p><a href="http://blog.csdn.net/u011475210/article/details/77770751" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/77770751</a></p>
<p>2.items等：</p>
<p><a href="http://blog.csdn.net/u011475210/article/details/77770145" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/77770145</a></p>
<p>3.itemgetter等：</p>
<p><a href="http://blog.csdn.net/u011475210/article/details/77770772" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/77770772</a></p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>机器学习实战</category>
      </categories>
      <tags>
        <tag>ML</tag>
        <tag>python3</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之十四：YOLO安装与优化加速</title>
    <url>/folder/2019/11/08/2017-10-01-tx-14/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="red" size=3 face="仿宋">&emsp;&emsp;系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;下周甲方要来查看项目进行，我着急忙慌的在刚刷完机的板子上编译YOLO，然而，webcom不好用······记性真是差的不行，赶紧打开markdown，把先前的笔记都整理出来。</p>
<p>&emsp;&emsp;本篇文章分为两个部分，第一部分是YOLO安装，第二部分是YOLO的优化加速。</p>
<h2 id="YOLO安装"><a href="#YOLO安装" class="headerlink" title="YOLO安装"></a>YOLO安装</h2><p>&emsp;&emsp;YOLO官网：<a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">https://pjreddie.com/darknet/yolo/</a></p>
<p>&emsp;&emsp;不说废话，就是干。</p>
<p>1.获取源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/pjreddie/darknet</span><br><span class="line">cd darknet</span><br></pre></td></tr></table></figure>

<p>2.修改Makefile</p>
<p>&emsp;&emsp;我们打开MakeFile文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim Makefile</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;Makefile内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPU=0</span><br><span class="line">CUDNN=0</span><br><span class="line">OPENCV=0</span><br><span class="line">OPENMP=0</span><br><span class="line">DEBUG=0</span><br><span class="line"></span><br><span class="line">ARCH= -gencode arch=compute_20,code=[sm_20,sm_21] \</span><br><span class="line">      -gencode arch=compute_30,code=sm_30 \</span><br><span class="line">      -gencode arch=compute_35,code=sm_35 \</span><br><span class="line">      -gencode arch=compute_50,code=[sm_50,compute_50] \</span><br><span class="line">      -gencode arch=compute_52,code=[sm_52,compute_52]</span><br><span class="line"></span><br><span class="line"># This is what I use, uncomment if you know your arch and want to specify</span><br><span class="line"># ARCH= -gencode arch=compute_52,code=compute_52</span><br><span class="line"></span><br><span class="line">VPATH=./src/:./examples</span><br><span class="line">SLIB=libdarknet.so</span><br><span class="line">ALIB=libdarknet.a</span><br><span class="line">EXEC=darknet</span><br><span class="line">OBJDIR=./obj/</span><br><span class="line"></span><br><span class="line">CC=gcc</span><br><span class="line">NVCC=nvcc </span><br><span class="line">AR=ar</span><br><span class="line">ARFLAGS=rcs</span><br><span class="line">OPTS=-Ofast</span><br><span class="line">LDFLAGS= -lm -pthread </span><br><span class="line">COMMON= -Iinclude/ -Isrc/</span><br><span class="line">CFLAGS=-Wall -Wno-unknown-pragmas -Wfatal-errors -fPIC</span><br><span class="line"></span><br><span class="line">ifeq ($(OPENMP), 1) </span><br><span class="line">CFLAGS+= -fopenmp</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(DEBUG), 1) </span><br><span class="line">OPTS=-O0 -g</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">CFLAGS+=$(OPTS)</span><br><span class="line"></span><br><span class="line">ifeq ($(OPENCV), 1) </span><br><span class="line">COMMON+= -DOPENCV</span><br><span class="line">CFLAGS+= -DOPENCV</span><br><span class="line">LDFLAGS+= `pkg-config --libs opencv` </span><br><span class="line">COMMON+= `pkg-config --cflags opencv` </span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(GPU), 1) </span><br><span class="line">COMMON+= -DGPU -I/usr/local/cuda/include/</span><br><span class="line">CFLAGS+= -DGPU</span><br><span class="line">LDFLAGS+= -L/usr/local/cuda/lib64 -lcuda -lcudart -lcublas -lcurand</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">ifeq ($(CUDNN), 1) </span><br><span class="line">COMMON+= -DCUDNN </span><br><span class="line">CFLAGS+= -DCUDNN</span><br><span class="line">LDFLAGS+= -lcudnn</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">OBJ=gemm.o utils.o cuda.o deconvolutional_layer.o convolutional_layer.o list.o image.o activations.o im2col.o col2im.o blas.o crop_layer.o dropout_layer.o maxpool_layer.o softmax_layer.o data.o matrix.o network.o connected_layer.o cost_layer.o parser.o option_list.o detection_layer.o route_layer.o box.o normalization_layer.o avgpool_layer.o layer.o local_layer.o shortcut_layer.o activation_layer.o rnn_layer.o gru_layer.o crnn_layer.o demo.o batchnorm_layer.o region_layer.o reorg_layer.o tree.o  lstm_layer.o</span><br><span class="line">EXECOBJA=captcha.o lsd.o super.o voxel.o art.o tag.o cifar.o go.o rnn.o rnn_vid.o compare.o segmenter.o regressor.o classifier.o coco.o dice.o yolo.o detector.o  writing.o nightmare.o swag.o darknet.o </span><br><span class="line">ifeq ($(GPU), 1) </span><br><span class="line">LDFLAGS+= -lstdc++ </span><br><span class="line">OBJ+=convolutional_kernels.o deconvolutional_kernels.o activation_kernels.o im2col_kernels.o col2im_kernels.o blas_kernels.o crop_layer_kernels.o dropout_layer_kernels.o maxpool_layer_kernels.o network_kernels.o avgpool_layer_kernels.o</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">EXECOBJ = $(addprefix $(OBJDIR), $(EXECOBJA))</span><br><span class="line">OBJS = $(addprefix $(OBJDIR), $(OBJ))</span><br><span class="line">DEPS = $(wildcard src/*.h) Makefile include/darknet.h</span><br><span class="line"></span><br><span class="line">#all: obj backup results $(SLIB) $(ALIB) $(EXEC)</span><br><span class="line">all: obj  results $(SLIB) $(ALIB) $(EXEC)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$(EXEC): $(EXECOBJ) $(ALIB)</span><br><span class="line">	$(CC) $(COMMON) $(CFLAGS) $^ -o $@ $(LDFLAGS) $(ALIB)</span><br><span class="line"></span><br><span class="line">$(ALIB): $(OBJS)</span><br><span class="line">	$(AR) $(ARFLAGS) $@ $^</span><br><span class="line"></span><br><span class="line">$(SLIB): $(OBJS)</span><br><span class="line">	$(CC) $(CFLAGS) -shared $^ -o $@ $(LDFLAGS)</span><br><span class="line"></span><br><span class="line">$(OBJDIR)%.o: %.c $(DEPS)</span><br><span class="line">	$(CC) $(COMMON) $(CFLAGS) -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">$(OBJDIR)%.o: %.cu $(DEPS)</span><br><span class="line">	$(NVCC) $(ARCH) $(COMMON) --compiler-options &quot;$(CFLAGS)&quot; -c $&lt; -o $@</span><br><span class="line"></span><br><span class="line">obj:</span><br><span class="line">	mkdir -p obj</span><br><span class="line">backup:</span><br><span class="line">	mkdir -p backup</span><br><span class="line">results:</span><br><span class="line">	mkdir -p results</span><br><span class="line"></span><br><span class="line">.PHONY: clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -rf $(OBJS) $(SLIB) $(ALIB) $(EXEC) $(EXECOBJ)</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;我们只需要关注前几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPU=0</span><br><span class="line">CUDNN=0</span><br><span class="line">OPENCV=0</span><br><span class="line">OPENMP=0</span><br><span class="line">DEBUG=0</span><br><span class="line"></span><br><span class="line">ARCH= -gencode arch=compute_20,code=[sm_20,sm_21] \</span><br><span class="line">      -gencode arch=compute_30,code=sm_30 \</span><br><span class="line">      -gencode arch=compute_35,code=sm_35 \</span><br><span class="line">      -gencode arch=compute_50,code=[sm_50,compute_50] \</span><br><span class="line">      -gencode arch=compute_52,code=[sm_52,compute_52]</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;前五行的这些类似于宏定义，在make的时候会导致某些程序功能的开启与关闭，0代表关闭，1代表开启。我直接把前四个都打开了。想用GPU，那么前两行就得打开；想用webcom等OpenCV实现的程序，那么就需要打开OPENCV；至于OPENCMP，我只知道它是用来实现多线程优化加速的，所以我干脆也打开了。</p>
<ul>
<li>TX1计算能力是53，对应的配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPU=1</span><br><span class="line">CUDNN=1</span><br><span class="line">OPENCV=1</span><br><span class="line">OPENMP=1</span><br><span class="line">DEBUG=0</span><br><span class="line"></span><br><span class="line">ARCH= -gencode arch=compute_53,code=[sm_53,sm_53]</span><br></pre></td></tr></table></figure>

<ul>
<li>TX1计算能力是53，对应的配置：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GPU=1</span><br><span class="line">CUDNN=1</span><br><span class="line">OPENCV=1</span><br><span class="line">OPENMP=1</span><br><span class="line">DEBUG=0</span><br><span class="line"></span><br><span class="line">ARCH= -gencode arch=compute_62,code=[sm_62,sm_62]</span><br></pre></td></tr></table></figure>

<p>3.保存Makefile之后，开始编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>

<p>4.下载预训练好的模型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://pjreddie.com/media/files/yolo.weights</span><br><span class="line">wget https://pjreddie.com/media/files/tiny-yolo-voc.weights</span><br><span class="line">wget https://pjreddie.com/media/files/tiny-yolo.weights</span><br></pre></td></tr></table></figure>

<p>5.测试：</p>
<p>&emsp;&emsp;我直接用webcom来测试。注意，必须使用支持V4L2的摄像头，板载的摄像头是不支持的，当然，如果你在Makefile里面没打开Opencv，这里是会报错的。</p>
<ul>
<li>COCO数据集训练的YOLO（干跑3帧左右）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./darknet detector demo cfg/coco.data cfg/yolo.cfg yolo.weights</span><br></pre></td></tr></table></figure>

<ul>
<li>COCO数据集训练的TINY-YOLO（干跑15帧左右）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./darknet detector demo cfg/coco.data cfg/tiny-yolo.cfg tiny-yolo.weights</span><br></pre></td></tr></table></figure>

<ul>
<li>COCO数据集训练的TINY-YOLO（干跑15帧左右）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./darknet detector demo cfg/voc.data cfg/tiny-yolo-voc.cfg tiny-yolo-voc.weights</span><br></pre></td></tr></table></figure>

<p>注：大家如果想看看不开GPU跑成什么样子，可以加入参数-nogpu。举个栗子：</p>
<ul>
<li>COCO数据集训练的TINY-YOLO（关掉GPU）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./darknet -nogpu detector demo cfg/voc.data cfg/tiny-yolo-voc.cfg tiny-yolo-voc.weights</span><br></pre></td></tr></table></figure>

<ul>
<li>查看GPU使用情况：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo ~/tegrastats</span><br></pre></td></tr></table></figure>

<h2 id="YOLO的优化加速"><a href="#YOLO的优化加速" class="headerlink" title="YOLO的优化加速"></a>YOLO的优化加速</h2><p>&emsp;&emsp;大家是不是不满足上面的帧率，别着急，WordZzzz带着你搞优化啊。正经说来，也不算优化，就是调调参数，让代码跑的快点。</p>
<h3 id="修改网络模型输入图像尺寸大小"><a href="#修改网络模型输入图像尺寸大小" class="headerlink" title="修改网络模型输入图像尺寸大小"></a>修改网络模型输入图像尺寸大小</h3><p>&emsp;&emsp;YOLOv2做了很多优化，其中就有为了提高小物体检测准确率而增加的多尺度训练（这里说的不够专业，后面有时间了专门写篇讲解YOLO的文章）。</p>
<p>&emsp;&emsp;原来的YOLO网络使用固定的448 * 448的图片作为输入，现在加入anchor boxes后，输入变成了416 * 416。目前的网络只用到了卷积层和池化层，那么就可以进行动态调整（意思是可检测任意大小图片）。作者希望YOLOv2具有不同尺寸图片的鲁棒性，因此在训练的时候也考虑了这一点。</p>
<p>&emsp;&emsp;不同于固定输入网络的图片尺寸的方法，作者在几次迭代后就会微调网络。没经过10次训练（10 epoch），就会随机选择新的图片尺寸。YOLO网络使用的降采样参数为32，那么就使用32的倍数进行尺度池化{320,352，…，608}。最终最小的尺寸为320 * 320，最大的尺寸为608 * 608。接着按照输入尺寸调整网络进行训练。</p>
<p>&emsp;&emsp;这种机制使得网络可以更好地预测不同尺寸的图片，意味着同一个网络可以进行不同分辨率的检测任务，在小尺寸图片上YOLOv2运行更快，在速度和精度上达到了平衡。</p>
<p>&emsp;&emsp;所以，我们可以修改输入尺寸大小，来提高YOLO运行速度。</p>
<p>&emsp;&emsp;随便打开一个cfg下的cfg文件，如“tiny-yolo.cfg”,内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[net]</span><br><span class="line"># Training</span><br><span class="line"># batch=64</span><br><span class="line"># subdivisions=2</span><br><span class="line"># Testing</span><br><span class="line">batch=1</span><br><span class="line">subdivisions=1</span><br><span class="line">width=416</span><br><span class="line">height=416</span><br><span class="line">channels=3</span><br><span class="line">momentum=0.9</span><br><span class="line">decay=0.0005</span><br><span class="line">angle=0</span><br><span class="line">saturation = 1.5</span><br><span class="line">exposure = 1.5</span><br><span class="line">hue=.1</span><br><span class="line"></span><br><span class="line">learning_rate=0.001</span><br><span class="line">burn_in=1000</span><br><span class="line">max_batches = 500200</span><br><span class="line">policy=steps</span><br><span class="line">steps=400000,450000</span><br><span class="line">scales=.1,.1</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">filters=16</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size=2</span><br><span class="line">stride=2</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">filters=32</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size=2</span><br><span class="line">stride=2</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">filters=64</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size=2</span><br><span class="line">stride=2</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">filters=128</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size=2</span><br><span class="line">stride=2</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">filters=256</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size=2</span><br><span class="line">stride=2</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">filters=512</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">[maxpool]</span><br><span class="line">size=2</span><br><span class="line">stride=1</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">filters=1024</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">###########</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">batch_normalize=1</span><br><span class="line">size=3</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">filters=512</span><br><span class="line">activation=leaky</span><br><span class="line"></span><br><span class="line">[convolutional]</span><br><span class="line">size=1</span><br><span class="line">stride=1</span><br><span class="line">pad=1</span><br><span class="line">filters=425</span><br><span class="line">activation=linear</span><br><span class="line"></span><br><span class="line">[region]</span><br><span class="line">anchors =  0.57273, 0.677385, 1.87446, 2.06253, 3.33843, 5.47434, 7.88282, 3.52778, 9.77052, 9.16828</span><br><span class="line">bias_match=1</span><br><span class="line">classes=80</span><br><span class="line">coords=4</span><br><span class="line">num=5</span><br><span class="line">softmax=1</span><br><span class="line">jitter=.2</span><br><span class="line">rescore=0</span><br><span class="line"></span><br><span class="line">object_scale=5</span><br><span class="line">noobject_scale=1</span><br><span class="line">class_scale=1</span><br><span class="line">coord_scale=1</span><br><span class="line"></span><br><span class="line">absolute=1</span><br><span class="line">thresh = .6</span><br><span class="line">random=1</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;同样的，我们只需要看前面几行就行，把width和height修改成最小尺度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">width=288</span><br><span class="line">height=288</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时再次使用COCO数据集训练的TINY-YOLO进行测试，帧率可以提高到20左右：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./darknet detector demo cfg/coco.data cfg/tiny-yolo.cfg tiny-yolo.weights</span><br></pre></td></tr></table></figure>

<h3 id="修改预览分辨率"><a href="#修改预览分辨率" class="headerlink" title="修改预览分辨率"></a>修改预览分辨率</h3><p>&emsp;&emsp;可以直接X掉预览窗口，这样，预览窗口减小后，速度也会提升，只不过有时候效果不明显。</p>
<p>&emsp;&emsp;当然，大家也可以修改源码然后重新编译。源码中预览窗口大小的代码在src/demo.c中的第279行。我把预览分辨率改成了1280 * 720，当然你还可以改的更小。改完之后重新编译。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(!prefix)&#123;</span><br><span class="line">    cvNamedWindow(&quot;Demo&quot;, CV_WINDOW_NORMAL);</span><br><span class="line">    if(fullscreen)&#123;</span><br><span class="line">        cvSetWindowProperty(&quot;Demo&quot;, CV_WND_PROP_FULLSCREEN, CV_WINDOW_FULLSCREEN);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        cvMoveWindow(&quot;Demo&quot;, 0, 0);</span><br><span class="line">        cvResizeWindow(&quot;Demo&quot;, 1280, 720);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改摄像头分辨率"><a href="#修改摄像头分辨率" class="headerlink" title="修改摄像头分辨率"></a>修改摄像头分辨率</h3><p>&emsp;&emsp;一开始就让摄像头采集到的分辨率低点，也是有效果的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./darknet detector demo cfg/coco.data cfg/tiny-yolo.cfg tiny-yolo.weights -w 640 -h 480</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;经过上述三步的优化之后，我用COCO数据集，帧率峰值都能到30（TX2，TX1慢5帧左右）。</p>
<hr>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
<hr>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>YOLO</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之十三：使用OpenCV在图像上添加汉字</title>
    <url>/folder/2019/11/08/2017-10-01-tx-13/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="red" size=4 face="仿宋">&emsp;&emsp;各位看客注意了，本章教程无关硬件平台，在ubuntu下具有通用性，别被标题赶跑了哦。我踩过的坑，您就不要再踩了，枪在手，跟我走。有问题欢迎评论区留言~</font></strong></p>
<p><strong><font color="red" size=4 face="仿宋">&emsp;&emsp;系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;同样的，由于项目需要，WordZzzz最近尝试在TX1上实现使用Opencv将解析json后得到的信息添加到图片上，其中包括汉字。然而，事情并没我想象的那么简单，主要还是自己对编码格式这块不太熟悉。下面将分两部分进行介绍。</p>
<h2 id="安装freetype"><a href="#安装freetype" class="headerlink" title="安装freetype"></a>安装freetype</h2><p>&emsp;&emsp;首先我们要检查一下自己的系统下面有没有freetype这个软件包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg-config --cflags --libs freetype2</span><br><span class="line">-I/usr/include/freetype2 -lfreetype</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;如果有上述第二行的打印信息，那么这部分可以跳过，如果没有，就需要按照下面的步骤进行安装了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打开终端，添加PPA源:</span><br><span class="line"></span><br><span class="line">$ sudo add-apt-repository ppa:no1wantdthisname/ppa</span><br><span class="line">$ freetype-ppa</span><br><span class="line"></span><br><span class="line">#安装freetype有两种方式：</span><br><span class="line"></span><br><span class="line">$ upgrade freetype</span><br><span class="line"></span><br><span class="line">#或者：</span><br><span class="line"></span><br><span class="line">$ sudo apt update &amp;&amp; sudo apt install libfreetype6</span><br><span class="line"></span><br><span class="line">#如果你想卸载，科一进行如下操作：</span><br><span class="line"></span><br><span class="line">$ sudo apt install ppa-purge &amp;&amp; sudo ppa-purge ppa:no1wantdthisname/ppa</span><br></pre></td></tr></table></figure>

<h2 id="UTF-8与GBK的转换"><a href="#UTF-8与GBK的转换" class="headerlink" title="UTF-8与GBK的转换"></a>UTF-8与GBK的转换</h2><p>ubuntu下系统默认的各种编码格式都是UTF-8，我们想要系统支持GBK，想让程序支持GBK，需要进行如下操作，我采用的方案二。</p>
<h3 id="方案一：iconv函数族"><a href="#方案一：iconv函数族" class="headerlink" title="方案一：iconv函数族"></a>方案一：iconv函数族</h3><p>&emsp;&emsp;iconv函数族的头文件是iconv.h,使用前需包含。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iconv.h&gt;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;iconv函数族有三个函数,原型如下:</p>
<ul>
<li>(1) iconv_t iconv_open(const char *tocode, const char *fromcode);<br>此函数说明将要进行哪两种编码的转换,tocode是目标编码,fromcode是原编码,该函数返回一个转换句柄,供以下两个函数使用。</li>
<li>(2) size_t iconv(iconv_t cd,char *<em>inbuf,size_t *inbytesleft,char *</em>outbuf,size_t *outbytesleft);<br>此函数从inbuf中读取字符,转换后输出到outbuf中,inbytesleft用以记录还未转换的字符数,outbytesleft用以记录输出缓冲的剩余空间。</li>
<li>(3) int iconv_close(iconv_t cd);<br>此函数用于关闭转换句柄,释放资源。</li>
</ul>
<p>&emsp;&emsp;实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iconv.h&gt;  </span><br><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">  </span><br><span class="line">int code_convert(char *from_charset, char *to_charset, char *inbuf, size_t inlen,  </span><br><span class="line">        char *outbuf, size_t outlen) &#123;  </span><br><span class="line">    iconv_t cd;  </span><br><span class="line">    char **pin = &amp;inbuf;  </span><br><span class="line">    char **pout = &amp;outbuf;  </span><br><span class="line">  </span><br><span class="line">    cd = iconv_open(to_charset, from_charset);  </span><br><span class="line">    if (cd == 0)  </span><br><span class="line">        return -1;  </span><br><span class="line">    memset(outbuf, 0, outlen);  </span><br><span class="line">    if (iconv(cd, pin, &amp;inlen, pout, &amp;outlen) == -1)  </span><br><span class="line">        return -1;  </span><br><span class="line">    iconv_close(cd);  </span><br><span class="line">    *pout = &apos;\0&apos;;  </span><br><span class="line">  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int u2g(char *inbuf, size_t inlen, char *outbuf, size_t outlen) &#123;  </span><br><span class="line">    return code_convert(&quot;utf-8&quot;, &quot;gb2312&quot;, inbuf, inlen, outbuf, outlen);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int g2u(char *inbuf, size_t inlen, char *outbuf, size_t outlen) &#123;  </span><br><span class="line">    return code_convert(&quot;gb2312&quot;, &quot;utf-8&quot;, inbuf, inlen, outbuf, outlen);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(void) &#123;  </span><br><span class="line">    char *s = &quot;中国&quot;;  </span><br><span class="line">    int fd = open(&quot;test.txt&quot;, O_RDWR|O_CREAT, S_IRUSR | S_IWUSR);  </span><br><span class="line">    char buf[10];  </span><br><span class="line">    u2g(s, strlen(s), buf, sizeof(buf));  </span><br><span class="line">    write(fd, buf, strlen(buf));  </span><br><span class="line">    close(fd);  </span><br><span class="line">  </span><br><span class="line">    fd = open(&quot;test.txt2&quot;, O_RDWR|O_CREAT, S_IRUSR | S_IWUSR);  </span><br><span class="line">    char buf2[10];  </span><br><span class="line">    g2u(buf, strlen(buf), buf2, sizeof(buf2));  </span><br><span class="line">    write(fd, buf2, strlen(buf2));  </span><br><span class="line">    close(fd);  </span><br><span class="line">    return 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方案二：使用mbstowcs和wcstombs"><a href="#方案二：使用mbstowcs和wcstombs" class="headerlink" title="方案二：使用mbstowcs和wcstombs"></a>方案二：使用mbstowcs和wcstombs</h3><p>&emsp;&emsp;mbstowcs将多字节编码转换为宽字节编码；wcstombs将宽字节编码转换为多字节编码<br>注意，需要系统编码的支持，可以通过locale -a 查看系统支持的。若不支持zh_CN.gbk, 需要安装，在ubuntu上的安装步骤如下：</p>
<p>&emsp;&emsp;编辑配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$sudo vim /var/lib/locales/supported.d/zh-hans</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;加入下面几行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zh_CN.UTF-8 UTF-8</span><br><span class="line">zh_SG.UTF-8 UTF-8</span><br><span class="line">zh_CN.GBK GBK</span><br><span class="line">zh_CN.GB18030 GB18030</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;保存后更新：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo locale-gen</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;查看:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ locale -a</span><br><span class="line">C</span><br><span class="line">POSIX</span><br><span class="line">···</span><br><span class="line">zh_CN.gb18030</span><br><span class="line">zh_CN.gbk</span><br><span class="line">zh_CN.utf8</span><br><span class="line">zh_SG.utf8</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;  </span><br><span class="line">#include &lt;stdio.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;unistd.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">#include &lt;sys/stat.h&gt;  </span><br><span class="line">#include &lt;locale.h&gt;  </span><br><span class="line">  </span><br><span class="line">/** </span><br><span class="line"> * DESCRIPTION: 实现由utf8编码到gbk编码的转换 </span><br><span class="line"> * </span><br><span class="line"> * Input: gbkStr,转换后的字符串;  srcStr,待转换的字符串; maxGbkStrlen, gbkStr的最 </span><br><span class="line"> 大长度 </span><br><span class="line"> * Output: gbkStr </span><br><span class="line"> * Returns: -1,fail;&gt;0,success </span><br><span class="line"> * </span><br><span class="line"> */  </span><br><span class="line">int utf82gbk(char *gbkStr, const char *srcStr, int maxGbkStrlen) &#123;  </span><br><span class="line">    if (NULL == srcStr) &#123;  </span><br><span class="line">        printf(&quot;Bad Parameter：srcStr\n&quot;);  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    //首先先将utf8编码转换为unicode编码  </span><br><span class="line">    if (NULL == setlocale(LC_ALL, &quot;zh_CN.utf8&quot;)) //设置转换为unicode前的码,当前为utf8编码  </span><br><span class="line">            &#123;  </span><br><span class="line">        printf(&quot;Bad Parameter：zh_CN.utf8\n&quot;);  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    int unicodeLen = mbstowcs(NULL, srcStr, 0); //计算转换后的长度  </span><br><span class="line">    if (unicodeLen &lt;= 0) &#123;  </span><br><span class="line">        printf(&quot;Can not Transfer!!!\n&quot;);  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    wchar_t *unicodeStr = (wchar_t *) calloc(sizeof(wchar_t), unicodeLen + 1);  </span><br><span class="line">    mbstowcs(unicodeStr, srcStr, strlen(srcStr)); //将utf8转换为unicode  </span><br><span class="line">  </span><br><span class="line">    //将unicode编码转换为gbk编码  </span><br><span class="line">    if (NULL == setlocale(LC_ALL, &quot;zh_CN.gbk&quot;)) //设置unicode转换后的码,当前为gbk  </span><br><span class="line">            &#123;  </span><br><span class="line">        printf(&quot;Bad Parameter：zh_CN.gbk\n&quot;);  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    int gbkLen = wcstombs(NULL, unicodeStr, 0); //计算转换后的长度  </span><br><span class="line">    if (gbkLen &lt;= 0) &#123;  </span><br><span class="line">        printf(&quot;Can not Transfer!!!\n&quot;);  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125; else if (gbkLen &gt;= maxGbkStrlen) //判断空间是否足够  </span><br><span class="line">            &#123;  </span><br><span class="line">        printf(&quot;Dst Str memory not enough\n&quot;);  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">    wcstombs(gbkStr, unicodeStr, gbkLen);  </span><br><span class="line">    gbkStr[gbkLen] = 0; //添加结束符  </span><br><span class="line">    free(unicodeStr);  </span><br><span class="line">    return gbkLen;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main(void) &#123;  </span><br><span class="line">    char *s = &quot;我爱WordZzzz&quot;;  </span><br><span class="line">    int fd = open(&quot;test.txt&quot;, O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);  </span><br><span class="line">    char buf[10];  </span><br><span class="line">    utf82gbk(buf, s, sizeof(buf));  </span><br><span class="line">    write(fd, buf, strlen(buf));  </span><br><span class="line">    close(fd);  </span><br><span class="line">  </span><br><span class="line">    return 1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OpenCV的中文支持"><a href="#OpenCV的中文支持" class="headerlink" title="OpenCV的中文支持"></a>OpenCV的中文支持</h2><p>&emsp;&emsp;OpenCV想要支持中文显示，需要添加额外的文件。网上参考的都是这两个文件，2007年的，历史悠久。</p>
<p>&emsp;&emsp;头文件CvxText.h：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef OPENCV_CVX_TEXT_2007_08_31_H</span><br><span class="line">#define OPENCV_CVX_TEXT_2007_08_31_H</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* \file CvxText.h</span><br><span class="line">* \brief OpenCV汉字输出接口</span><br><span class="line">*</span><br><span class="line">* 实现了汉字输出功能。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">#include &lt;ft2build.h&gt;</span><br><span class="line">#include FT_FREETYPE_H</span><br><span class="line"></span><br><span class="line">#include&lt;opencv2/opencv.hpp&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* \class CvxText</span><br><span class="line">* \brief OpenCV中输出汉字</span><br><span class="line">*</span><br><span class="line">* OpenCV中输出汉字。字库提取采用了开源的FreeFype库。由于FreeFype是</span><br><span class="line">* GPL版权发布的库，和OpenCV版权并不一致，因此目前还没有合并到OpenCV</span><br><span class="line">* 扩展库中。</span><br><span class="line">*</span><br><span class="line">* 显示汉字的时候需要一个汉字字库文件，字库文件系统一般都自带了。</span><br><span class="line">* 这里采用的是一个开源的字库：“文泉驿正黑体”。</span><br><span class="line">*</span><br><span class="line">* 关于&quot;OpenCV扩展库&quot;的细节请访问</span><br><span class="line">* http://code.google.com/p/opencv-extension-library/</span><br><span class="line">*</span><br><span class="line">* 关于FreeType的细节请访问</span><br><span class="line">* http://www.freetype.org/</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CvxText</span><br><span class="line">&#123;</span><br><span class="line">	// 禁止copy</span><br><span class="line"></span><br><span class="line">	CvxText&amp; operator=(const CvxText&amp;);</span><br><span class="line"></span><br><span class="line">	//================================================================</span><br><span class="line">	//================================================================</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 装载字库文件</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	CvxText(const char *freeType);</span><br><span class="line">	virtual ~CvxText();</span><br><span class="line"></span><br><span class="line">	//================================================================</span><br><span class="line">	//================================================================</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 获取字体。目前有些参数尚不支持。</span><br><span class="line">	*</span><br><span class="line">	* \param font        字体类型, 目前不支持</span><br><span class="line">	* \param size        字体大小/空白比例/间隔比例/旋转角度</span><br><span class="line">	* \param underline   下画线</span><br><span class="line">	* \param diaphaneity 透明度</span><br><span class="line">	*</span><br><span class="line">	* \sa setFont, restoreFont</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	void getFont(int *type,</span><br><span class="line">		CvScalar *size = NULL, bool *underline = NULL, float *diaphaneity = NULL);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 设置字体。目前有些参数尚不支持。</span><br><span class="line">	*</span><br><span class="line">	* \param font        字体类型, 目前不支持</span><br><span class="line">	* \param size        字体大小/空白比例/间隔比例/旋转角度</span><br><span class="line">	* \param underline   下画线</span><br><span class="line">	* \param diaphaneity 透明度</span><br><span class="line">	*</span><br><span class="line">	* \sa getFont, restoreFont</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	void setFont(int *type,</span><br><span class="line">		CvScalar *size = NULL, bool *underline = NULL, float *diaphaneity = NULL);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 恢复原始的字体设置。</span><br><span class="line">	*</span><br><span class="line">	* \sa getFont, setFont</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	void restoreFont();</span><br><span class="line"></span><br><span class="line">	//================================================================</span><br><span class="line">	//================================================================</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 输出汉字(颜色默认为黑色)。遇到不能输出的字符将停止。</span><br><span class="line">	*</span><br><span class="line">	* \param img  输出的影象</span><br><span class="line">	* \param text 文本内容</span><br><span class="line">	* \param pos  文本位置</span><br><span class="line">	*</span><br><span class="line">	* \return 返回成功输出的字符长度，失败返回-1。</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	int putText(IplImage *img, const char    *text, CvPoint pos);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 输出汉字(颜色默认为黑色)。遇到不能输出的字符将停止。</span><br><span class="line">	*</span><br><span class="line">	* \param img  输出的影象</span><br><span class="line">	* \param text 文本内容</span><br><span class="line">	* \param pos  文本位置</span><br><span class="line">	*</span><br><span class="line">	* \return 返回成功输出的字符长度，失败返回-1。</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	int putText(IplImage *img, const wchar_t *text, CvPoint pos);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 输出汉字。遇到不能输出的字符将停止。</span><br><span class="line">	*</span><br><span class="line">	* \param img   输出的影象</span><br><span class="line">	* \param text  文本内容</span><br><span class="line">	* \param pos   文本位置</span><br><span class="line">	* \param color 文本颜色</span><br><span class="line">	*</span><br><span class="line">	* \return 返回成功输出的字符长度，失败返回-1。</span><br><span class="line">	*/</span><br><span class="line"></span><br><span class="line">	int putText(IplImage *img, const char    *text, CvPoint pos, CvScalar color);</span><br><span class="line"></span><br><span class="line">	/**</span><br><span class="line">	* 输出汉字。遇到不能输出的字符将停止。</span><br><span class="line">	*</span><br><span class="line">	* \param img   输出的影象</span><br><span class="line">	* \param text  文本内容</span><br><span class="line">	* \param pos   文本位置</span><br><span class="line">	* \param color 文本颜色</span><br><span class="line">	*</span><br><span class="line">	* \return 返回成功输出的字符长度，失败返回-1。</span><br><span class="line">	*/</span><br><span class="line">	int putText(IplImage *img, const wchar_t *text, CvPoint pos, CvScalar color);</span><br><span class="line"></span><br><span class="line">	//================================================================</span><br><span class="line">	//================================================================</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	// 输出当前字符, 更新m_pos位置</span><br><span class="line"></span><br><span class="line">	void putWChar(IplImage *img, wchar_t wc, CvPoint &amp;pos, CvScalar color);</span><br><span class="line"></span><br><span class="line">	//================================================================</span><br><span class="line">	//================================================================</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">	FT_Library   m_library;   // 字库</span><br><span class="line">	FT_Face      m_face;      // 字体</span><br><span class="line"></span><br><span class="line">	//================================================================</span><br><span class="line">	//================================================================</span><br><span class="line"></span><br><span class="line">	// 默认的字体输出参数</span><br><span class="line"></span><br><span class="line">	int         m_fontType;</span><br><span class="line">	CvScalar   m_fontSize;</span><br><span class="line">	bool      m_fontUnderline;</span><br><span class="line">	float      m_fontDiaphaneity;</span><br><span class="line"></span><br><span class="line">	//================================================================</span><br><span class="line">	//================================================================</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // OPENCV_CVX_TEXT_2007_08_31_H</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;源文件cvText.cpp：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * cvText.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Sep 20, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;wchar.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;locale.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line"></span><br><span class="line">#include &quot;CvxText.h&quot;</span><br><span class="line"></span><br><span class="line">//====================================================================</span><br><span class="line">//====================================================================</span><br><span class="line"></span><br><span class="line">// 打开字库</span><br><span class="line"></span><br><span class="line">CvxText::CvxText(const char *freeType)</span><br><span class="line">&#123;</span><br><span class="line">	assert(freeType != NULL);</span><br><span class="line"></span><br><span class="line">	// 打开字库文件, 创建一个字体</span><br><span class="line"></span><br><span class="line">	if (FT_Init_FreeType(&amp;m_library)) throw;</span><br><span class="line">	if (FT_New_Face(m_library, freeType, 0, &amp;m_face)) throw;</span><br><span class="line"></span><br><span class="line">	// 设置字体输出参数</span><br><span class="line"></span><br><span class="line">	restoreFont();</span><br><span class="line"></span><br><span class="line">	// 设置C语言的字符集环境</span><br><span class="line"></span><br><span class="line">	setlocale(LC_ALL, &quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放FreeType资源</span><br><span class="line"></span><br><span class="line">CvxText::~CvxText()</span><br><span class="line">&#123;</span><br><span class="line">	FT_Done_Face(m_face);</span><br><span class="line">	FT_Done_FreeType(m_library);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 设置字体参数:</span><br><span class="line">//</span><br><span class="line">// font         - 字体类型, 目前不支持</span><br><span class="line">// size         - 字体大小/空白比例/间隔比例/旋转角度</span><br><span class="line">// underline   - 下画线</span><br><span class="line">// diaphaneity   - 透明度</span><br><span class="line"></span><br><span class="line">void CvxText::getFont(int *type, CvScalar *size, bool *underline, float *diaphaneity)</span><br><span class="line">&#123;</span><br><span class="line">	if (type) *type = m_fontType;</span><br><span class="line">	if (size) *size = m_fontSize;</span><br><span class="line">	if (underline) *underline = m_fontUnderline;</span><br><span class="line">	if (diaphaneity) *diaphaneity = m_fontDiaphaneity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void CvxText::setFont(int *type, CvScalar *size, bool *underline, float *diaphaneity)</span><br><span class="line">&#123;</span><br><span class="line">	// 参数合法性检查</span><br><span class="line"></span><br><span class="line">	if (type)</span><br><span class="line">	&#123;</span><br><span class="line">		if (type &gt;= 0) m_fontType = *type;</span><br><span class="line">	&#125;</span><br><span class="line">	if (size)</span><br><span class="line">	&#123;</span><br><span class="line">		m_fontSize.val[0] = fabs(size-&gt;val[0]);</span><br><span class="line">		m_fontSize.val[1] = fabs(size-&gt;val[1]);</span><br><span class="line">		m_fontSize.val[2] = fabs(size-&gt;val[2]);</span><br><span class="line">		m_fontSize.val[3] = fabs(size-&gt;val[3]);</span><br><span class="line">	&#125;</span><br><span class="line">	if (underline)</span><br><span class="line">	&#123;</span><br><span class="line">		m_fontUnderline = *underline;</span><br><span class="line">	&#125;</span><br><span class="line">	if (diaphaneity)</span><br><span class="line">	&#123;</span><br><span class="line">		m_fontDiaphaneity = *diaphaneity;</span><br><span class="line">	&#125;</span><br><span class="line">	//FT_Set_Pixel_Sizes(m_face, (int)m_fontSize.val[0], 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 恢复原始的字体设置</span><br><span class="line"></span><br><span class="line">void CvxText::restoreFont()</span><br><span class="line">&#123;</span><br><span class="line">	m_fontType = 0;            // 字体类型(不支持)</span><br><span class="line"></span><br><span class="line">	m_fontSize.val[0] = 20;      // 字体大小</span><br><span class="line">	m_fontSize.val[1] = 0.5;   // 空白字符大小比例</span><br><span class="line">	m_fontSize.val[2] = 0.1;   // 间隔大小比例</span><br><span class="line">	m_fontSize.val[3] = 0;      // 旋转角度(不支持)</span><br><span class="line"></span><br><span class="line">	m_fontUnderline = false;   // 下画线(不支持)</span><br><span class="line"></span><br><span class="line">	m_fontDiaphaneity = 1.0;   // 色彩比例(可产生透明效果)</span><br><span class="line"></span><br><span class="line">	// 设置字符大小</span><br><span class="line"></span><br><span class="line">	FT_Set_Pixel_Sizes(m_face, (int)m_fontSize.val[0], 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出函数(颜色默认为黑色)</span><br><span class="line"></span><br><span class="line">int CvxText::putText(IplImage *img, const char    *text, CvPoint pos)</span><br><span class="line">&#123;</span><br><span class="line">	return putText(img, text, pos, CV_RGB(255, 255, 255));</span><br><span class="line">&#125;</span><br><span class="line">int CvxText::putText(IplImage *img, const wchar_t *text, CvPoint pos)</span><br><span class="line">&#123;</span><br><span class="line">	return putText(img, text, pos, CV_RGB(255, 255, 255));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">int CvxText::putText(IplImage *img, const char    *text, CvPoint pos, CvScalar color)</span><br><span class="line">&#123;</span><br><span class="line">	if (img == NULL) return -1;</span><br><span class="line">	if (text == NULL) return -1;</span><br><span class="line"></span><br><span class="line">	//</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; text[i] != &apos;\0&apos;; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		wchar_t wc = text[i];</span><br><span class="line"></span><br><span class="line">		// 解析双字节符号</span><br><span class="line"></span><br><span class="line">		if (!isascii(wc)) mbtowc(&amp;wc, &amp;text[i++], 2);</span><br><span class="line"></span><br><span class="line">		// 输出当前的字符</span><br><span class="line"></span><br><span class="line">		putWChar(img, wc, pos, color);</span><br><span class="line">	&#125;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line">int CvxText::putText(IplImage *img, const wchar_t *text, CvPoint pos, CvScalar color)</span><br><span class="line">&#123;</span><br><span class="line">	if (img == NULL) return -1;</span><br><span class="line">	if (text == NULL) return -1;</span><br><span class="line"></span><br><span class="line">	//</span><br><span class="line"></span><br><span class="line">	int i;</span><br><span class="line">	for (i = 0; text[i] != &apos;\0&apos;; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		// 输出当前的字符</span><br><span class="line"></span><br><span class="line">		putWChar(img, text[i], pos, color);</span><br><span class="line">	&#125;</span><br><span class="line">	return i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出当前字符, 更新m_pos位置</span><br><span class="line"></span><br><span class="line">void CvxText::putWChar(IplImage *img, wchar_t wc, CvPoint &amp;pos, CvScalar color)</span><br><span class="line">&#123;</span><br><span class="line">	// 根据unicode生成字体的二值位图</span><br><span class="line"></span><br><span class="line">	FT_UInt glyph_index = FT_Get_Char_Index(m_face, wc);</span><br><span class="line">	FT_Load_Glyph(m_face, glyph_index, FT_LOAD_DEFAULT);</span><br><span class="line">	FT_Render_Glyph(m_face-&gt;glyph, FT_RENDER_MODE_MONO);</span><br><span class="line"></span><br><span class="line">	//</span><br><span class="line"></span><br><span class="line">	FT_GlyphSlot slot = m_face-&gt;glyph;</span><br><span class="line"></span><br><span class="line">	// 行列数</span><br><span class="line"></span><br><span class="line">	int rows = slot-&gt;bitmap.rows;</span><br><span class="line">	int cols = slot-&gt;bitmap.width;</span><br><span class="line"></span><br><span class="line">	//</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; rows; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		for (int j = 0; j &lt; cols; ++j)</span><br><span class="line">		&#123;</span><br><span class="line">			int off = ((img-&gt;origin == 0) ? i : (rows - 1 - i))</span><br><span class="line">				* slot-&gt;bitmap.pitch + j / 8;</span><br><span class="line"></span><br><span class="line">			if (slot-&gt;bitmap.buffer[off] &amp; (0xC0 &gt;&gt; (j % 8)))</span><br><span class="line">			&#123;</span><br><span class="line">				int r = (img-&gt;origin == 0) ? pos.y - (rows - 1 - i) : pos.y + i;;</span><br><span class="line">				int c = pos.x + j;</span><br><span class="line"></span><br><span class="line">				if (r &gt;= 0 &amp;&amp; r &lt; img-&gt;height</span><br><span class="line">					&amp;&amp; c &gt;= 0 &amp;&amp; c &lt; img-&gt;width)</span><br><span class="line">				&#123;</span><br><span class="line">					CvScalar scalar = cvGet2D(img, r, c);</span><br><span class="line"></span><br><span class="line">					// 进行色彩融合</span><br><span class="line"></span><br><span class="line">					float p = m_fontDiaphaneity;</span><br><span class="line">					for (int k = 0; k &lt; 4; ++k)</span><br><span class="line">					&#123;</span><br><span class="line">						scalar.val[k] = scalar.val[k] * (1 - p) + color.val[k] * p;</span><br><span class="line">					&#125;</span><br><span class="line"></span><br><span class="line">					cvSet2D(img, r, c, scalar);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; // end for</span><br><span class="line">	&#125; // end for</span><br><span class="line"></span><br><span class="line">	// 修改下一个字的输出位置</span><br><span class="line"></span><br><span class="line">	double space = m_fontSize.val[0] * m_fontSize.val[1];</span><br><span class="line">	double sep = m_fontSize.val[0] * m_fontSize.val[2];</span><br><span class="line"></span><br><span class="line">	pos.x += (int)((cols ? cols : space) + sep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;opencv/highgui.h&gt;  </span><br><span class="line">#include &lt;assert.h&gt;  </span><br><span class="line">#include &quot;CvxText.h&quot;  </span><br><span class="line">using namespace cv;  </span><br><span class="line">  </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    // 打开一幅  </span><br><span class="line">    IplImage *img = cvLoadImage(&quot;lena.jpg&quot;);  </span><br><span class="line">    // 输出汉字  </span><br><span class="line">    &#123;  </span><br><span class="line">        CvxText text(&quot;simhei.ttf&quot;); // &quot;zenhei.ttf&quot;为黑体常规  </span><br><span class="line">        const char *msg = &quot;在OpenCV中输出汉字！&quot;;  </span><br><span class="line">        float p = 0.5;  </span><br><span class="line">        text.setFont(NULL, NULL, NULL, &amp;p);   // 透明处理  </span><br><span class="line">        text.putText(img, msg, cvPoint(100, 150), CV_RGB(255, 0, 0));  </span><br><span class="line">    &#125;  </span><br><span class="line">    // 定义窗口，并显示影象  </span><br><span class="line">    cvShowImage(&quot;test&quot;, img); cvWaitKey(-1);  </span><br><span class="line">    cvReleaseImage(&amp;img);  </span><br><span class="line">    return 0;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;代码里面的simhei.tff是字体名称，需要拷贝到你程序的执行目录下，当然也可以直接在代码中写字体的路径。window下一般都有这个字体，ubuntu的话，来windows下拷贝一下就好，windows的的字体目录：C:\Windows\Fonts。</p>
<h2 id="敲重点"><a href="#敲重点" class="headerlink" title="敲重点"></a>敲重点</h2><p><strong><font color="red" size=4 face="仿宋">&emsp;&emsp;如果你的代码的编码格式本身就是GBK，那么你就不需要UTF-8转GBK这个过程，即第二个部分就可以略过；但是，如果你进行第三部分的时候，发现部分汉字能显示，部分不能显示，那就是编码问题，需要调用第二部分的UTF-8转GBK的函数。/font&gt;</strong></p>
<hr>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
<hr>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之十二：libcurl、RapidJSON安装</title>
    <url>/folder/2019/11/08/2017-10-01-tx-12/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="red" size=4 face="仿宋">&emsp;&emsp;各位看客注意了，本章教程无关硬件平台，在ubuntu下具有通用性，别被标题赶跑了哦。我踩过的坑，您就不要再踩了，枪在手，跟我走。有问题欢迎评论区留言~</font></strong></p>
<p><strong><font color="red" size=4 face="仿宋">&emsp;&emsp;系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;由于项目需要，WordZzzz最近尝试在TX1上解析服务器端传回json信息。先用Python3进行了测试，Python作为一门脚本语言，用来做测试简直棒极了。但是，我们最终还是要把代码移植到linux C上来进行实现。</p>
<p>&emsp;&emsp;虽说大家能看到这篇文章一般都是想直接解决问题的，但是我还是在此啰嗦几句，做个小小的科普。</p>
<p>&emsp;&emsp;JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。</p>
<p>JSON建构于两种结构：</p>
<ul>
<li>“名称/值”对的集合（A collection of name/value pairs）。不同的语言中，它被理解为对象（object），纪录（record），结构（struct），字典（dictionary），哈希表（hash table），有键列表（keyed list），或者关联数组 （associative array）。</li>
<li>值的有序列表（An ordered list of values）。在大部分语言中，它被理解为数组（array）。<br>这些都是常见的数据结构。事实上大部分现代计算机语言都以某种形式支持它们。这使得一种数据格式在同样基于这些结构的编程语言之间交换成为可能。</li>
<li>再详细点的话，就请进入传送门吧：<a href="http://www.json.org/json-zh.html。" target="_blank" rel="noopener">http://www.json.org/json-zh.html。</a></li>
</ul>
<p>&emsp;&emsp;用c在linux下实现json解析，需要两个工具，一个是可以实现http通信的工具，这里WordZzzz用的是libcurl（当然也可以用curl或者wget来模拟http的post和get）；另一个是可以解析json信息的工具，这里WordZzzz用的是腾讯开源的RapidJSON（当然大家也可以尝试json-c等）。</p>
<h2 id="libcurl"><a href="#libcurl" class="headerlink" title="libcurl"></a>libcurl</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>cURL是一个利用URL语法在命令行下工作的文件传输工具，1997年首次发行。它支持文件上传和下载，所以是综合传输工具，但按传统，习惯称cURL为下载工具。cURL还包含了用于程序开发的libcurl。</li>
<li>cURL支持的通信协议有FTP、FTPS、HTTP、HTTPS、TFTP、SFTP、Gopher、SCP、Telnet、DICT、FILE、LDAP、LDAPS、IMAP、POP3、SMTP和RTSP。</li>
<li>libcurl支持的平台有Solaris、NetBSD、FreeBSD、OpenBSD、Darwin、HP-UX、IRIX、AIX、Tru64、Linux、UnixWare、HURD、Windows、Symbian、Amiga、OS/2、BeOS、Mac OS X、Ultrix、QNX、BlackBerry Tablet OS、OpenVMS、RISC OS、Novell NetWare、DOS等。</li>
<li>想要了解更多信息，官网传送门：<a href="https://curl.haxx.se/" target="_blank" rel="noopener">https://curl.haxx.se/</a></li>
</ul>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.下载libcurl源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/curl/curl.git</span><br></pre></td></tr></table></figure>
<p>2.配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./buidconf</span><br><span class="line">$ ./configure --enable-debug</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;第一步用于生成configure配置文件，第二步进行配置。可以./configure –help查看其他可选参数。我是默认安装openssl的，所以没有出现找不到openssl库的问题。如果遇到了就装一个，选择默认安装省事，自己指定安装目录比较麻烦。具体查看工程目录下的README。</p>
<p>3.编译&amp;安装：</p>
<p>&emsp;&emsp;默认库文件安装在/usr/local/lib 头文件安装在/usr/local/include  —&gt;安装要root权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>4.测试代码：<br>&emsp;&emsp;接下来写个测试代码来使用libcurl库(此测试代码下载指定URL的页面)。<br>&emsp;&emsp;测试代码摘自网络，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 采用CURLOPT_WRITEFUNCTION 实现网页下载保存功能  </span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;;  </span><br><span class="line">#include &lt;stdlib.h&gt;;  </span><br><span class="line">#include &lt;unistd.h&gt;;  </span><br><span class="line">   </span><br><span class="line">#include &lt;curl/curl.h&gt;;  </span><br><span class="line">#include &lt;curl/types.h&gt;;  </span><br><span class="line">#include &lt;curl/easy.h&gt;;  </span><br><span class="line">   </span><br><span class="line">FILE *fp;  //定义FILE类型指针  </span><br><span class="line">//这个函数是为了符合CURLOPT_WRITEFUNCTION而构造的  </span><br><span class="line">//完成数据保存功能  </span><br><span class="line">size_t write_data(void *ptr, size_t size, size_t nmemb, void *stream)    </span><br><span class="line">&#123;  </span><br><span class="line">    int written = fwrite(ptr, size, nmemb, (FILE *)fp);  </span><br><span class="line">    return written;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line">int main(int argc, char *argv[])  </span><br><span class="line">&#123;  </span><br><span class="line">    CURL *curl;  </span><br><span class="line">    if (argc != 3)  </span><br><span class="line">    &#123;  </span><br><span class="line">        fprintf(stderr, &quot;usage: %s url filename\n&quot;, argv[0]);  </span><br><span class="line">        exit(-1);  </span><br><span class="line">    &#125;  </span><br><span class="line">    curl_global_init(CURL_GLOBAL_ALL);    </span><br><span class="line">    curl = curl_easy_init();  </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, argv[1]);    </span><br><span class="line">   </span><br><span class="line">    if((fp = fopen(argv[2],&quot;w&quot;)) == NULL)  </span><br><span class="line">    &#123;  </span><br><span class="line">        curl_easy_cleanup(curl);  </span><br><span class="line">        exit(1);  </span><br><span class="line">    &#125;  </span><br><span class="line">  //CURLOPT_WRITEFUNCTION 将后继的动作交给write_data函数处理  </span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);    </span><br><span class="line">    curl_easy_perform(curl);  </span><br><span class="line">    curl_easy_cleanup(curl);  </span><br><span class="line">    exit(0);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.查看库链接信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg-config --cflags --libs libcurl</span><br><span class="line">-I/usr/local/include -L/usr/local/lib -lcurl</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;返回信息如上，其中-I后面的是头文件路径，-L后面的是链接库路径，链接库名称为curl。</p>
<p>6.编译测试代码：</p>
<p>&emsp;&emsp;可以直接用nsight进行配置（详情参考我之前的nsight基础教程：<a href="http://blog.csdn.net/u011475210/article/details/72853170、nsight进阶教程：http://blog.csdn.net/u011475210/article/details/72860277），也可以直接手写gcc命令进行编译。" target="_blank" rel="noopener">http://blog.csdn.net/u011475210/article/details/72853170、nsight进阶教程：http://blog.csdn.net/u011475210/article/details/72860277），也可以直接手写gcc命令进行编译。</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -L/usr/local/lib -o test test.c -lcurl</span><br></pre></td></tr></table></figure>

<p>7.编译完成，运行程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./test</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;程序会将百度首页下载下来，存为index.html。</p>
<h2 id="RapidJSON"><a href="#RapidJSON" class="headerlink" title="RapidJSON"></a>RapidJSON</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;RapidJSON 是一个 C++ 的 JSON 解析器及生成器。它的灵感来自 RapidXml。</p>
<ul>
<li>RapidJSON 小而全。它同时支持 SAX 和 DOM 风格的 API。SAX 解析器只有约 500 行代码。</li>
<li>RapidJSON 快。它的性能可与 strlen() 相比。可支持 SSE2/SSE4.2 加速。</li>
<li>RapidJSON 独立。它不依赖于 BOOST 等外部库。它甚至不依赖于 STL。</li>
<li>RapidJSON 对内存友好。在大部分 32/64 位机器上，每个 JSON 值只占 16 字节（除字符串外）。它预设使用一个快速的内存分配器，令分析器可以紧凑地分配内存。</li>
<li>RapidJSON 对 Unicode 友好。它支持 UTF-8、UTF-16、UTF-32 (大端序／小端序)，并内部支持这些编码的检测、校验及转码。例如，RapidJSON 可以在分析一个 UTF-8 文件至 DOM 时，把当中的 JSON 字符串转码至 UTF-16。它也支持代理对（surrogate pair）及 “\u0000”（空字符）。</li>
<li>想要了解更多信息，官网传送门：<a href="http://rapidjson.org/zh-cn/" target="_blank" rel="noopener">http://rapidjson.org/zh-cn/</a></li>
</ul>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>1.cmake：<br>&emsp;&emsp;采用cmake方式进行安装，所以cmake命令得有。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install cmake</span><br></pre></td></tr></table></figure>

<p>2.下载源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/Tencent/rapidjson.git</span><br></pre></td></tr></table></figure>

<p>3.编译&amp;安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd rapidjson/</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake ..</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure>

<p>4.查看库链接信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pkg-config --cflags --libs RapidJSON</span><br><span class="line">-I/usr/local/include</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;可以发现只有头文件信息，我们只需要调用头文件而不需要链接库，所以很方便。</p>
<p>5.官方例程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// rapidjson/example/simpledom/simpledom.cpp`</span><br><span class="line">#include &quot;rapidjson/document.h&quot;</span><br><span class="line">#include &quot;rapidjson/writer.h&quot;</span><br><span class="line">#include &quot;rapidjson/stringbuffer.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace rapidjson;</span><br><span class="line">int main() &#123;</span><br><span class="line">    // 1. 把 JSON 解析至 DOM。</span><br><span class="line">    const char* json = &quot;&#123;\&quot;project\&quot;:\&quot;rapidjson\&quot;,\&quot;stars\&quot;:10&#125;&quot;;</span><br><span class="line">    Document d;</span><br><span class="line">    d.Parse(json);</span><br><span class="line">    // 2. 利用 DOM 作出修改。</span><br><span class="line">    Value&amp; s = d[&quot;stars&quot;];</span><br><span class="line">    s.SetInt(s.GetInt() + 1);</span><br><span class="line">    // 3. 把 DOM 转换（stringify）成 JSON。</span><br><span class="line">    StringBuffer buffer;</span><br><span class="line">    Writer&lt;StringBuffer&gt; writer(buffer);</span><br><span class="line">    d.Accept(writer);</span><br><span class="line">    // Output &#123;&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11&#125;</span><br><span class="line">    std::cout &lt;&lt; buffer.GetString() &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;注意此例子并没有处理潜在错误。</p>
<p>6.编译例程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ g++ -o simpledom simpledom.cpp</span><br></pre></td></tr></table></figure>

<p>7.运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./simpledom</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;图解过程：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170924171738668?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"/></div>
<p></p>

<p>&emsp;&emsp;输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
<hr>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>libcurl</tag>
        <tag>RapidJSON</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之十一：TCP IP文件传输</title>
    <url>/folder/2019/11/08/2017-10-01-tx-11/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">写在前面：</font></strong><br>本篇博文设计的内容是TCP/IP文件传输，只是简单的实现文档、图片等二进制文件的传输，并将大包进行分包发送，不涉及select等机制。</p>
<p><strong><font color="black" size=5 face="仿宋">一、服务端程序：</font></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * common.h</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Aug 11, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef COMMON_H_</span><br><span class="line">#define COMMON_H_</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;sys/socket.h&gt;</span><br><span class="line">#include &lt;netinet/in.h&gt;</span><br><span class="line"></span><br><span class="line">#define PORT 6000</span><br><span class="line">#define LISTENQ 20</span><br><span class="line">#define BUFFSIZE 4096</span><br><span class="line">#define FILE_NAME_MAX_SIZE 512</span><br><span class="line"></span><br><span class="line">#endif /* COMMON_H_ */</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fileserver.c</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Aug 11, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv[])</span><br><span class="line">&#123;</span><br><span class="line">    //Create socket</span><br><span class="line">    int sockfd,connfd;</span><br><span class="line">    struct sockaddr_in svraddr,clientaddr;</span><br><span class="line">    bzero(&amp;svraddr,sizeof(svraddr));</span><br><span class="line">    bzero(&amp;clientaddr,sizeof(clientaddr));</span><br><span class="line"></span><br><span class="line">    svraddr.sin_family=AF_INET;</span><br><span class="line">    svraddr.sin_addr.s_addr=htonl(INADDR_ANY);</span><br><span class="line">    svraddr.sin_port=htons(PORT);</span><br><span class="line"></span><br><span class="line">    sockfd=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line">    if(sockfd&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //bind</span><br><span class="line">    if(bind(sockfd,(struct sockaddr*)&amp;svraddr,sizeof(svraddr))&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //listen</span><br><span class="line">    if(listen(sockfd,LISTENQ)&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;listen&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        socklen_t clientaddrlen=sizeof(clientaddr);</span><br><span class="line"></span><br><span class="line">        //accept</span><br><span class="line">        connfd=accept(sockfd,(struct sockaddr*)&amp;clientaddr,&amp;clientaddrlen);</span><br><span class="line">        if(connfd&lt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(&quot;connect&quot;);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //recv file imformation</span><br><span class="line">		char buff[BUFFSIZE];</span><br><span class="line">		char filename[FILE_NAME_MAX_SIZE];</span><br><span class="line">		int count;</span><br><span class="line">		bzero(buff,BUFFSIZE);</span><br><span class="line"></span><br><span class="line">		count=recv(connfd,buff,BUFFSIZE,0);</span><br><span class="line">		if(count&lt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(&quot;recv&quot;);</span><br><span class="line">			exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">		strncpy(filename,buff,strlen(buff)&gt;FILE_NAME_MAX_SIZE?FILE_NAME_MAX_SIZE:strlen(buff));</span><br><span class="line"></span><br><span class="line">		printf(&quot;Preparing recv file : %s\n&quot;,filename);</span><br><span class="line"></span><br><span class="line">		//recv file</span><br><span class="line">		FILE *fd=fopen(filename,&quot;wb+&quot;);</span><br><span class="line">		if(NULL==fd)</span><br><span class="line">		&#123;</span><br><span class="line">			perror(&quot;open&quot;);</span><br><span class="line">			exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">		bzero(buff,BUFFSIZE);</span><br><span class="line"></span><br><span class="line">		int length=0;</span><br><span class="line">		while(length=recv(connfd,buff,BUFFSIZE,0))</span><br><span class="line">		&#123;</span><br><span class="line">			if(length&lt;0)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(&quot;recv&quot;);</span><br><span class="line">				exit(1);</span><br><span class="line">			&#125;</span><br><span class="line">			int writelen=fwrite(buff,sizeof(char),length,fd);</span><br><span class="line">			if(writelen&lt;length)</span><br><span class="line">			&#123;</span><br><span class="line">				perror(&quot;write&quot;);</span><br><span class="line">				exit(1);</span><br><span class="line">			&#125;</span><br><span class="line">			bzero(buff,BUFFSIZE);</span><br><span class="line">		&#125;</span><br><span class="line">		printf(&quot;Receieved file:%s finished!\n&quot;,filename);</span><br><span class="line"></span><br><span class="line">		fclose(fd);</span><br><span class="line">        close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="black" size=5 face="仿宋">二、客户端程序：</font></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * fileclient.c</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Aug 11, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;common.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int clientfd;</span><br><span class="line"></span><br><span class="line">    if(argc!=3)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,&quot;Usage:./fileclient &lt;IP_Address&gt; &lt;filename&gt;\n&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //Input the file name</span><br><span class="line">    char filename[FILE_NAME_MAX_SIZE];</span><br><span class="line">    bzero(filename,FILE_NAME_MAX_SIZE);</span><br><span class="line">    strcpy(filename, argv[2]);</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in clientaddr;</span><br><span class="line">    bzero(&amp;clientaddr,sizeof(clientaddr));</span><br><span class="line"></span><br><span class="line">    clientaddr.sin_family=AF_INET;</span><br><span class="line">    clientaddr.sin_addr.s_addr=htons(INADDR_ANY);</span><br><span class="line">    clientaddr.sin_port=htons(0);</span><br><span class="line"></span><br><span class="line">    clientfd=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line"></span><br><span class="line">    if(clientfd&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;socket&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //bind</span><br><span class="line">    if(bind(clientfd,(struct sockaddr*)&amp;clientaddr,sizeof(clientaddr))&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;bind&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct sockaddr_in svraddr;</span><br><span class="line">    bzero(&amp;svraddr,sizeof(svraddr));</span><br><span class="line">    if(inet_aton(argv[1],&amp;svraddr.sin_addr)==0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;inet_aton&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line">    svraddr.sin_family=AF_INET;</span><br><span class="line">    svraddr.sin_port=htons(PORT);</span><br><span class="line"></span><br><span class="line">    socklen_t svraddrlen=sizeof(svraddr);</span><br><span class="line">    if(connect(clientfd,(struct sockaddr*)&amp;svraddr,svraddrlen)&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;connect&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //send file imformation</span><br><span class="line">    char buff[BUFFSIZE];</span><br><span class="line">    int count;</span><br><span class="line">    bzero(buff,BUFFSIZE);</span><br><span class="line">    strncpy(buff,filename,strlen(filename)&gt;FILE_NAME_MAX_SIZE?FILE_NAME_MAX_SIZE:strlen(filename));</span><br><span class="line">    count=send(clientfd,buff,BUFFSIZE,0);</span><br><span class="line">    if(count&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(&quot;Send file information&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //read file</span><br><span class="line">    FILE *fd=fopen(filename,&quot;rb&quot;);</span><br><span class="line">    if(fd==NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;File :%s not found!\n&quot;,filename);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(buff,BUFFSIZE);</span><br><span class="line">        int file_block_length=0;</span><br><span class="line">        while((file_block_length=fread(buff,sizeof(char),BUFFSIZE,fd))&gt;0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;file_block_length:%d\n&quot;,file_block_length);</span><br><span class="line">            if(send(clientfd,buff,file_block_length,0)&lt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                perror(&quot;Send&quot;);</span><br><span class="line">                exit(1);</span><br><span class="line">            &#125;</span><br><span class="line">            bzero(buff,BUFFSIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(fd);</span><br><span class="line">        printf(&quot;Transfer file finished !\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(clientfd);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>TCP IP</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之十：V4L2+OpenCV2.4.13实现预览、拍照功能</title>
    <url>/folder/2019/11/08/2017-10-01-tx-10/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">写在前面：</font></strong><br>本篇博文主要用来讲解上篇博文中关于V4L2框架的程序部分，并在其基础上实现预览和拍照功能的实现.其中，预览分辨率640<em>480，用键盘检测来改变标志位，当标志位改变时进行拍照，拍照分辨率1920</em>1080，随后自动切换回预览模式，肉眼基本看不出切换卡顿。</p>
<p><strong><font color="black" size=5 face="仿宋">一、V4L2框架：</font></strong><br>V4L2程序是基于标准的V4L2框架来写的，大部分程序注释都已给出，如果还有什么不清楚的地方，可以评论、私信或自行查阅V4L2开发手册。</p>
<p>下图是标准V4L2程序流程图。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170817103503714?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>博客中的程序，在标准V4L2程序的基础上进一步进行了封装，主要是为了实现拍照与预览模式的切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * v4l2cap.h</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef V4L2CAP_H_</span><br><span class="line">#define V4L2CAP_H_</span><br><span class="line"></span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">class V4L2Capture &#123;</span><br><span class="line">public:</span><br><span class="line">	V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap);</span><br><span class="line">	virtual ~V4L2Capture();</span><br><span class="line"></span><br><span class="line">	int openDevice();</span><br><span class="line">	int closeDevice();</span><br><span class="line">	int initDevice();</span><br><span class="line">	int initDeviceCap();</span><br><span class="line">	int startCapture();</span><br><span class="line">	int stopCapture();</span><br><span class="line">	int freeBuffers();</span><br><span class="line">	int getFrame(void **,size_t *);</span><br><span class="line">	int backFrame();</span><br><span class="line">	int pre2cap();</span><br><span class="line">	int cap2pre();</span><br><span class="line">	int preBegin();</span><br><span class="line">	int preEnd();</span><br><span class="line"></span><br><span class="line">	int initBuffers();</span><br><span class="line"></span><br><span class="line">	struct cam_buffer</span><br><span class="line">	&#123;</span><br><span class="line">		void* start;</span><br><span class="line">		unsigned int length;</span><br><span class="line">	&#125;;</span><br><span class="line">	char *devName;</span><br><span class="line">	int widthCap;</span><br><span class="line">	int heightCap;</span><br><span class="line">	int width;</span><br><span class="line">	int height;</span><br><span class="line">	int fd_cam;</span><br><span class="line">	cam_buffer *buffers;</span><br><span class="line">	unsigned int n_buffers;</span><br><span class="line">	int frameIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* V4L2CAP_H_ */</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * v4l2cap.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;v4l2cap.h&quot;</span><br><span class="line"></span><br><span class="line">V4L2Capture::V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap) &#123;</span><br><span class="line">	// TODO Auto-generated constructor stub</span><br><span class="line">	this-&gt;devName = devName;</span><br><span class="line">	this-&gt;fd_cam = -1;</span><br><span class="line">	this-&gt;buffers = NULL;</span><br><span class="line">	this-&gt;n_buffers = 0;</span><br><span class="line">	this-&gt;frameIndex = -1;</span><br><span class="line">	this-&gt;width=width;</span><br><span class="line">	this-&gt;height=height;</span><br><span class="line">	this-&gt;widthCap=width_cap;</span><br><span class="line">	this-&gt;heightCap=height_cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V4L2Capture::~V4L2Capture() &#123;</span><br><span class="line">	// TODO Auto-generated destructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********打开设备**********/</span><br><span class="line">int V4L2Capture::openDevice() &#123;</span><br><span class="line">	/*设备的打开*/</span><br><span class="line">	printf(&quot;video dev : %s\n&quot;, devName);</span><br><span class="line">	fd_cam = open(devName, O_RDWR);</span><br><span class="line">	if (fd_cam &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t open video device&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********关闭设备**********/</span><br><span class="line">int V4L2Capture::closeDevice() &#123;</span><br><span class="line">	if (fd_cam &gt; 0) &#123;</span><br><span class="line">		int ret = 0;</span><br><span class="line">		if ((ret = close(fd_cam)) &lt; 0) &#123;</span><br><span class="line">			perror(&quot;Can&apos;t close video device&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********初始化设备（预览模式）**********/</span><br><span class="line">int V4L2Capture::initDevice() &#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct v4l2_capability cam_cap;		//显示设备信息</span><br><span class="line">	struct v4l2_cropcap cam_cropcap;	//设置摄像头的捕捉能力</span><br><span class="line">	struct v4l2_fmtdesc cam_fmtdesc;	//查询所有支持的格式：VIDIOC_ENUM_FMT</span><br><span class="line">	struct v4l2_crop cam_crop;		    //图像的缩放</span><br><span class="line">	struct v4l2_format cam_format;		//设置摄像头的视频制式、帧格式等</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_QUERYCAP，获取摄像头的基本信息*/</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_QUERYCAP, &amp;cam_cap);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t get device information: VIDIOCGCAP&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(</span><br><span class="line">			&quot;Driver Name:%s\nCard Name:%s\nBus info:%s\nDriver Version:%u.%u.%u\n&quot;,</span><br><span class="line">			cam_cap.driver, cam_cap.card, cam_cap.bus_info,</span><br><span class="line">			(cam_cap.version &gt;&gt; 16) &amp; 0XFF, (cam_cap.version &gt;&gt; 8) &amp; 0XFF,</span><br><span class="line">			cam_cap.version &amp; 0XFF);</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_ENUM_FMT，获取摄像头所有支持的格式*/</span><br><span class="line">	cam_fmtdesc.index = 0;</span><br><span class="line">	cam_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	printf(&quot;Support format:\n&quot;);</span><br><span class="line">	while (ioctl(fd_cam, VIDIOC_ENUM_FMT, &amp;cam_fmtdesc) != -1) &#123;</span><br><span class="line">		printf(&quot;\t%d.%s\n&quot;, cam_fmtdesc.index + 1, cam_fmtdesc.description);</span><br><span class="line">		cam_fmtdesc.index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_CROPCAP，获取摄像头的捕捉能力*/</span><br><span class="line">	cam_cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	if (0 == ioctl(fd_cam, VIDIOC_CROPCAP, &amp;cam_cropcap)) &#123;</span><br><span class="line">		printf(&quot;Default rec:\n\tleft:%d\n\ttop:%d\n\twidth:%d\n\theight:%d\n&quot;,</span><br><span class="line">				cam_cropcap.defrect.left, cam_cropcap.defrect.top,</span><br><span class="line">				cam_cropcap.defrect.width, cam_cropcap.defrect.height);</span><br><span class="line">		/* 使用IOCTL命令VIDIOC_S_CROP，获取摄像头的窗口取景参数*/</span><br><span class="line">		cam_crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		cam_crop.c = cam_cropcap.defrect;		//默认取景窗口大小</span><br><span class="line">		if (-1 == ioctl(fd_cam, VIDIOC_S_CROP, &amp;cam_crop)) &#123;</span><br><span class="line">			//printf(&quot;Can&apos;t set crop para\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		printf(&quot;Can&apos;t set cropcap para\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	cam_format.fmt.pix.width = width;</span><br><span class="line">	cam_format.fmt.pix.height = height;</span><br><span class="line">	cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;		//要和摄像头支持的类型对应</span><br><span class="line">	cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t set frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	/* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t get frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;,</span><br><span class="line">			cam_format.fmt.pix.width, cam_format.fmt.pix.height);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********初始化设备（拍照模式）**********/</span><br><span class="line">int V4L2Capture::initDeviceCap() &#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct v4l2_format cam_format;		//设置摄像头的视频制式、帧格式等</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	cam_format.fmt.pix.width = widthCap;</span><br><span class="line">	cam_format.fmt.pix.height = heightCap;</span><br><span class="line">	cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;		//要和摄像头支持的类型对应</span><br><span class="line">	cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t set frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	/* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t get frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;,</span><br><span class="line">			cam_format.fmt.pix.width, cam_format.fmt.pix.height);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********申请缓存**********/</span><br><span class="line">int V4L2Capture::initBuffers() &#123;</span><br><span class="line">	int ret;</span><br><span class="line">	/* 使用IOCTL命令VIDIOC_REQBUFS，申请帧缓冲*/</span><br><span class="line">	struct v4l2_requestbuffers req;</span><br><span class="line">	CLEAR(req);</span><br><span class="line">	req.count = 4;</span><br><span class="line">	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	req.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_REQBUFS, &amp;req);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Request frame buffers failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (req.count &lt; 2) &#123;</span><br><span class="line">		perror(&quot;Request frame buffers while insufficient buffer memory&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	buffers = (struct cam_buffer*) calloc(req.count, sizeof(*buffers));</span><br><span class="line">	if (!buffers) &#123;</span><br><span class="line">		perror(&quot;Out of memory&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	for (n_buffers = 0; n_buffers &lt; req.count; n_buffers++) &#123;</span><br><span class="line">		struct v4l2_buffer buf;</span><br><span class="line">		CLEAR(buf);</span><br><span class="line">		// 查询序号为n_buffers 的缓冲区，得到其起始物理地址和大小</span><br><span class="line">		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">		buf.index = n_buffers;</span><br><span class="line">		ret = ioctl(fd_cam, VIDIOC_QUERYBUF, &amp;buf);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			printf(&quot;VIDIOC_QUERYBUF %d failed\n&quot;, n_buffers);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		buffers[n_buffers].length = buf.length;</span><br><span class="line">		//printf(&quot;buf.length= %d\n&quot;,buf.length);</span><br><span class="line">		// 映射内存</span><br><span class="line">		buffers[n_buffers].start = mmap(</span><br><span class="line">				NULL, // start anywhere</span><br><span class="line">				buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd_cam,</span><br><span class="line">				buf.m.offset);</span><br><span class="line">		if (MAP_FAILED == buffers[n_buffers].start) &#123;</span><br><span class="line">			printf(&quot;mmap buffer%d failed\n&quot;, n_buffers);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********释放缓存**********/</span><br><span class="line">int V4L2Capture::freeBuffers() &#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	for (i = 0; i &lt; n_buffers; ++i) &#123;</span><br><span class="line">		if (-1 == munmap(buffers[i].start, buffers[i].length)) &#123;</span><br><span class="line">			printf(&quot;munmap buffer%d failed\n&quot;, i);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	free(buffers);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********开始采集**********/</span><br><span class="line">int V4L2Capture::startCapture() &#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	for (i = 0; i &lt; n_buffers; i++) &#123;</span><br><span class="line">		struct v4l2_buffer buf;</span><br><span class="line">		CLEAR(buf);</span><br><span class="line">		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">		buf.index = i;</span><br><span class="line">		if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;buf)) &#123;</span><br><span class="line">			printf(&quot;VIDIOC_QBUF buffer%d failed\n&quot;, i);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enum v4l2_buf_type type;</span><br><span class="line">	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	if (-1 == ioctl(fd_cam, VIDIOC_STREAMON, &amp;type)) &#123;</span><br><span class="line">		printf(&quot;VIDIOC_STREAMON error&quot;);</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**********停止采集**********/</span><br><span class="line">int V4L2Capture::stopCapture() &#123;</span><br><span class="line">	enum v4l2_buf_type type;</span><br><span class="line">	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	if (-1 == ioctl(fd_cam, VIDIOC_STREAMOFF, &amp;type)) &#123;</span><br><span class="line">		printf(&quot;VIDIOC_STREAMOFF error\n&quot;);</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********获取图像**********/</span><br><span class="line">int V4L2Capture::getFrame(void **frame_buf, size_t* len) &#123;</span><br><span class="line">	struct v4l2_buffer queue_buf;</span><br><span class="line">	CLEAR(queue_buf);</span><br><span class="line">	queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	queue_buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">	if (-1 == ioctl(fd_cam, VIDIOC_DQBUF, &amp;queue_buf)) &#123;</span><br><span class="line">		printf(&quot;VIDIOC_DQBUF error\n&quot;);</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	//printf(&quot;queue_buf.index=%d\n&quot;,queue_buf.index);</span><br><span class="line">	//pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">	*frame_buf = buffers[queue_buf.index].start;</span><br><span class="line">	*len = buffers[queue_buf.index].length;</span><br><span class="line">	frameIndex = queue_buf.index;</span><br><span class="line">	//pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********返回队列**********/</span><br><span class="line">int V4L2Capture::backFrame() &#123;</span><br><span class="line">	if (frameIndex != -1) &#123;</span><br><span class="line">		struct v4l2_buffer queue_buf;</span><br><span class="line">		CLEAR(queue_buf);</span><br><span class="line">		queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		queue_buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">		queue_buf.index = frameIndex;</span><br><span class="line">		if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;queue_buf)) &#123;</span><br><span class="line">			printf(&quot;VIDIOC_QBUF error\n&quot;);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********预览切换至拍照**********/</span><br><span class="line">int V4L2Capture::pre2cap() &#123;</span><br><span class="line">	if(V4L2Capture::stopCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StopCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::freeBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;FreeBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::closeDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;CloseDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::openDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;OpenDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initDeviceCap() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitDeviceCap fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::startCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StartCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********拍照切换至预览**********/</span><br><span class="line">int V4L2Capture::cap2pre() &#123;</span><br><span class="line">	if(V4L2Capture::stopCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StopCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::freeBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;FreeBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::closeDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;CloseDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::openDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;OpenDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::startCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StartCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********预览开启**********/</span><br><span class="line">int V4L2Capture::preBegin() &#123;</span><br><span class="line">	if(V4L2Capture::openDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;OpenDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;first~~\n&quot;);</span><br><span class="line">	if(V4L2Capture::initDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;second~~\n&quot;);</span><br><span class="line">	if(V4L2Capture::initBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;third~~\n&quot;);</span><br><span class="line">	if(V4L2Capture::startCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StartCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;fourth~~\n&quot;);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********预览结束**********/</span><br><span class="line">int V4L2Capture::preEnd() &#123;</span><br><span class="line">	if(V4L2Capture::stopCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StopCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::freeBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;FreeBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::closeDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;CloseDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><font color="black" size=5 face="仿宋">二、键盘检测：</font></strong><br>主要实现的功能是通过模拟kbhit功能，实现在线程中完成对键盘的检测功能（检测到‘c’时标志位置1）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * pthread.h</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 27, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef PTHREAD_H_</span><br><span class="line">#define PTHREAD_H_</span><br><span class="line"></span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">static __inline</span><br><span class="line">int tty_reset(void);</span><br><span class="line"></span><br><span class="line">static __inline</span><br><span class="line">int tty_set(void);</span><br><span class="line"></span><br><span class="line">static __inline</span><br><span class="line">int kbhit(void);</span><br><span class="line"></span><br><span class="line">void *thread(void *arg);</span><br><span class="line"></span><br><span class="line">static struct termios ori_attr, cur_attr;</span><br><span class="line"></span><br><span class="line">extern uchar flag;</span><br><span class="line"></span><br><span class="line">#endif /* PTHREAD_H_ */</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * pthread.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 27, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;thread.h&quot;</span><br><span class="line"></span><br><span class="line">static __inline</span><br><span class="line">int tty_reset(void)</span><br><span class="line">&#123;</span><br><span class="line">        if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;ori_attr) != 0)</span><br><span class="line">                return -1;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static __inline</span><br><span class="line">int tty_set(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        if ( tcgetattr(STDIN_FILENO, &amp;ori_attr) )</span><br><span class="line">                return -1;</span><br><span class="line"></span><br><span class="line">        memcpy(&amp;cur_attr, &amp;ori_attr, sizeof(cur_attr) );</span><br><span class="line">        cur_attr.c_lflag &amp;= ~ICANON;</span><br><span class="line">//        cur_attr.c_lflag |= ECHO;</span><br><span class="line">        cur_attr.c_lflag &amp;= ~ECHO;</span><br><span class="line">        cur_attr.c_cc[VMIN] = 1;</span><br><span class="line">        cur_attr.c_cc[VTIME] = 0;</span><br><span class="line"></span><br><span class="line">        if (tcsetattr(STDIN_FILENO, TCSANOW, &amp;cur_attr) != 0)</span><br><span class="line">                return -1;</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static __inline</span><br><span class="line">int kbhit(void)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">        fd_set rfds;</span><br><span class="line">        struct timeval tv;</span><br><span class="line">        int retval;</span><br><span class="line"></span><br><span class="line">        /* Watch stdin (fd 0) to see when it has input. */</span><br><span class="line">        FD_ZERO(&amp;rfds);</span><br><span class="line">        FD_SET(0, &amp;rfds);</span><br><span class="line">        /* Wait up to five seconds. */</span><br><span class="line">        tv.tv_sec  = 0;</span><br><span class="line">        tv.tv_usec = 0;</span><br><span class="line"></span><br><span class="line">        retval = select(1, &amp;rfds, NULL, NULL, &amp;tv);</span><br><span class="line">        /* Don&apos;t rely on the value of tv now! */</span><br><span class="line"></span><br><span class="line">        if (retval == -1) &#123;</span><br><span class="line">                perror(&quot;select()&quot;);</span><br><span class="line">                return 0;</span><br><span class="line">        &#125; else if (retval)</span><br><span class="line">                return 1;</span><br><span class="line">        /* FD_ISSET(0, &amp;rfds) will be true. */</span><br><span class="line">        else</span><br><span class="line">                return 0;</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *thread(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    int tty_set_flag;</span><br><span class="line">    tty_set_flag = tty_set();</span><br><span class="line">    while(1) &#123;</span><br><span class="line"></span><br><span class="line">		if( kbhit() ) &#123;</span><br><span class="line">			const int key = getchar();</span><br><span class="line">			printf(&quot;%c pressed\n&quot;, key);</span><br><span class="line">			//检测到&apos;c&apos;则标志位置1</span><br><span class="line">			if(key == &apos;c&apos;)</span><br><span class="line">				flag=1;</span><br><span class="line">			//检测到&apos;q&apos;则退出程序</span><br><span class="line">			if(key == &apos;q&apos;)</span><br><span class="line">				exit(0);</span><br><span class="line">				break;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">//              fprintf(stderr, &quot;&lt;no key detected&gt;\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(tty_set_flag == 0)</span><br><span class="line">            tty_reset();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><font color="black" size=5 face="仿宋">三、主函数：</font></strong><br>include.h里面包含我们所有用到的头文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * include.h</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef INCLUDE_H_</span><br><span class="line">#define INCLUDE_H_</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;error.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;termios.h&gt;</span><br><span class="line">#include &lt;linux/videodev2.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;opencv2/core/core.hpp&gt;</span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#endif /* INCLUDE_H_ */</span><br></pre></td></tr></table></figure>
<p>主函数主要实现预览模式的开启、键盘检测线程开启，预览和拍照模式的切换等功能，总体程序比较简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * main.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line">#include &quot;v4l2cap.h&quot;</span><br><span class="line">#include &quot;thread.h&quot;</span><br><span class="line"></span><br><span class="line">#define IMAGEWIDTH_CAP 1920 //拍照分辨率</span><br><span class="line">#define IMAGEHEIGHT_CAP 1080//拍照分辨率</span><br><span class="line"></span><br><span class="line">#define IMAGEWIDTH 640      //预览分辨率</span><br><span class="line">#define IMAGEHEIGHT 480     //预览分辨率</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">uchar flag;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage* img,* img_cap;</span><br><span class="line">	CvMat cvmat,cvmat_cap;</span><br><span class="line">	double t;</span><br><span class="line">	flag=0;</span><br><span class="line">	unsigned char *frame = NULL;</span><br><span class="line">	unsigned long frameSize = 0;</span><br><span class="line">	string videoDev=&quot;/dev/video1&quot;;//制定设备号</span><br><span class="line"></span><br><span class="line">	V4L2Capture *vcap = new V4L2Capture(const_cast&lt;char*&gt;(videoDev.c_str()),</span><br><span class="line">			IMAGEWIDTH, IMAGEHEIGHT, IMAGEWIDTH_CAP, IMAGEHEIGHT_CAP);</span><br><span class="line">	vcap-&gt;preBegin();//预览模式开启</span><br><span class="line"></span><br><span class="line">	cvNamedWindow(&quot;one&quot;,CV_WINDOW_AUTOSIZE);//创建显示窗口</span><br><span class="line"></span><br><span class="line">	pthread_t id;</span><br><span class="line">	printf(&quot;Main thread id is %d \n&quot;,pthread_self());</span><br><span class="line">	if(!pthread_create(&amp;id,NULL,thread,NULL))</span><br><span class="line">	&#123;</span><br><span class="line">	printf(&quot;succeed!\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;printf(&quot;Fail to Create Thread&quot;);</span><br><span class="line">	return -1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	while(1)&#123;</span><br><span class="line">		//如果flag为1，则抓取一张照片</span><br><span class="line">		if(flag == 1)&#123;</span><br><span class="line">			vcap-&gt;pre2cap();                      //预览模式切换至拍照模式</span><br><span class="line">			//这里多获取几次图像队列，以便得到更高的图像质量（刚打开设备时图像模糊）</span><br><span class="line">			vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);vcap-&gt;backFrame();</span><br><span class="line">			vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);vcap-&gt;backFrame();</span><br><span class="line">			vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);</span><br><span class="line">			cvmat_cap = cvMat(IMAGEHEIGHT_CAP,IMAGEWIDTH_CAP,CV_8UC3,frame);//CV_8UC3</span><br><span class="line">			img_cap = cvDecodeImage(&amp;cvmat_cap,1);//OpenCV图像解码</span><br><span class="line"></span><br><span class="line">			if(!img_cap)    printf(&quot;No img_cap\n&quot;);</span><br><span class="line">			cvSaveImage(&quot;cap.jpg&quot;,img_cap);       //保存图片</span><br><span class="line">			cvReleaseImage(&amp;img_cap);             //释放img_cap</span><br><span class="line">			vcap-&gt;backFrame();                    //返回队列</span><br><span class="line"></span><br><span class="line">			vcap-&gt;cap2pre();                      //拍照模式切换至预览模式</span><br><span class="line"></span><br><span class="line">			flag = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		t = (double)cvGetTickCount();</span><br><span class="line">		vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);</span><br><span class="line">		cvmat = cvMat(IMAGEHEIGHT,IMAGEWIDTH,CV_8UC3,frame);//CV_8UC3</span><br><span class="line">		img = cvDecodeImage(&amp;cvmat,1);           //OpenCV图像解码</span><br><span class="line">		if(!img)    printf(&quot;No img\n&quot;);</span><br><span class="line">		cvShowImage(&quot;one&quot;,img);                  //显示图片</span><br><span class="line">		cvReleaseImage(&amp;img);                    //释放img</span><br><span class="line">		vcap-&gt;backFrame();                       //返回队列</span><br><span class="line">        cvWaitKey(1);                            //没有这句话图像无法显示</span><br><span class="line">		t=(double)cvGetTickCount()-t;</span><br><span class="line">		printf(&quot;used time is %gms\n&quot;,(t/(cvGetTickFrequency()*1000)));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pthread_exit(0);                            //退出键盘检测线程</span><br><span class="line"></span><br><span class="line">	vcap-&gt;preEnd();                             //预览模式结束</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>V4L2</tag>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之九：USB摄像头MJPEG格式图像采集</title>
    <url>/folder/2019/11/08/2017-10-01-tx-9/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">写在前面：</font></strong><br>NVIDIA Jetson TX1开发套件包括一个CSI接口的500W摄像头，其官方多媒体例程基于此摄像头详细介绍了图像采集与编解码的种种操作。整个多媒体例程是基于gstreamer框架来写的，如果大家只是想把摄像头用起来，大可不必研究gstreamer框架，直接看接口就行。</p>
<p>由于项目需求，考虑到接线问题，我们放弃了CSI接口的摄像头，转而采用USB摄像头。而且最新的官方例程已经给出了基于V4L2的USB摄像头图像采集与编码例程。（12_camera_v4l2_cuda_video_encode）。</p>
<p>本博客将介绍三种在TX1上实现USB摄像头图像采集与显示的方法，分别基于gstreamer、ffmpeg和V4L2来实现USB摄像头的图像实时采集与显示。博主在项目中实现拍照和预览模式切换，最终采用的是V4L2+OpenCV2.4.13的方案，因为博主对V4L2比较熟悉，而对于gstreamer和ffmpeg只接触到了皮毛，对其理解也不是很到位。</p>
<p>注意：博主所用的USB摄像头输出图像格式为mjpeg，所以所有的程序中都是以jpeg为例进行编写的，如果想改成YUYV格式的，只需要改一下format设置，并把相应的解码程序去掉即可。</p>
<p><strong><font color="black" size=5 face="仿宋">一、Gstreamer：</font></strong></p>
<p>博主只是直接把测试好的gstreamer命令行写入到程序中，并不能对数据流做更多的操作，在多次尝试无果后放弃······</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * main.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: May 31, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	//花括号内输入测试号的命令行即可</span><br><span class="line">	char cmd_cap[] = &#123;&quot;gst-launch-1.0 v4l2src device= /dev/video1 ! &apos;image/jpeg, width=640, height=480&apos; ! jpegdec ! xvimagesink -e &amp;&quot;&#125;;</span><br><span class="line"></span><br><span class="line">	char *cmdstring = cmd_cap;</span><br><span class="line"></span><br><span class="line">	if(*argv[1] == &apos;1&apos;)</span><br><span class="line">		cmdstring = cmd_cap;</span><br><span class="line"></span><br><span class="line">	int status;</span><br><span class="line">	if(NULL == cmdstring) //如果cmdstring为空趁早闪退吧，尽管system()函数也能处理空指针</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	status = system(cmdstring);</span><br><span class="line">	if(status &lt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;cmd: %s\t error: %s&quot;, cmdstring, strerror(errno)); // 这里务必要把errno信息输出或</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if(WIFEXITED(status))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;normal termination, exit status = %d\n&quot;, WEXITSTATUS(status)); //取得cmdstring执行结果</span><br><span class="line">	&#125;</span><br><span class="line">		else if(WIFSIGNALED(status))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;abnormal termination,signal number =%d\n&quot;, WTERMSIG(status)); //如果cmdstring被信号中断，取得信号值</span><br><span class="line">	&#125;</span><br><span class="line">	else if(WIFSTOPPED(status))</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;process stopped, signal number =%d\n&quot;, WSTOPSIG(status)); //如果cmdstring被信号暂停执行，取得信号值</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><font color="black" size=5 face="仿宋">二、Ffmpeg：</font></strong><br>ffmpeg程序参考雷神博客，并在其基础上进行修改，ffmpeg编解码+SDL多线程定时刷新显示，程序详解还是看雷神的吧，打开传送门：<a href="http://blog.csdn.net/leixiaohua1020/article/details/38868499" target="_blank" rel="noopener">http://blog.csdn.net/leixiaohua1020/article/details/38868499</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * ffm_cap.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 19, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define __STDC_CONSTANT_MACROS</span><br><span class="line"></span><br><span class="line">//Linux...</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#endif</span><br><span class="line">#include &lt;libavcodec/avcodec.h&gt;</span><br><span class="line">#include &lt;libavformat/avformat.h&gt;</span><br><span class="line">#include &lt;libswscale/swscale.h&gt;</span><br><span class="line">#include &lt;libavdevice/avdevice.h&gt;</span><br><span class="line">#include &lt;SDL/SDL.h&gt;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//Output YUV420P</span><br><span class="line">#define OUTPUT_YUV420P 0</span><br><span class="line">//&apos;1&apos; Use Dshow</span><br><span class="line">//&apos;0&apos; Use VFW</span><br><span class="line">#define USE_DSHOW 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Refresh Event</span><br><span class="line">#define SFM_REFRESH_EVENT  (SDL_USEREVENT + 1)</span><br><span class="line"></span><br><span class="line">#define SFM_BREAK_EVENT  (SDL_USEREVENT + 2)</span><br><span class="line"></span><br><span class="line">int thread_exit=0;</span><br><span class="line"></span><br><span class="line">//SDL线程40ms刷新一次</span><br><span class="line">int sfp_refresh_thread(void *opaque)</span><br><span class="line">&#123;</span><br><span class="line">	thread_exit=0;</span><br><span class="line">	while (!thread_exit) &#123;</span><br><span class="line">		SDL_Event event;</span><br><span class="line">		event.type = SFM_REFRESH_EVENT;</span><br><span class="line">		SDL_PushEvent(&amp;event);</span><br><span class="line">		SDL_Delay(40);</span><br><span class="line">	&#125;</span><br><span class="line">	thread_exit=0;</span><br><span class="line">	//Break</span><br><span class="line">	SDL_Event event;</span><br><span class="line">	event.type = SFM_BREAK_EVENT;</span><br><span class="line">	SDL_PushEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	AVFormatContext	*pFormatCtx;</span><br><span class="line">	int				i, videoindex;</span><br><span class="line">	AVCodecContext	*pCodecCtx;</span><br><span class="line">	AVCodec			*pCodec;</span><br><span class="line"></span><br><span class="line">	av_register_all();</span><br><span class="line">	avformat_network_init();</span><br><span class="line">	pFormatCtx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line">	//Open File</span><br><span class="line">	//char filepath[]=&quot;src01_480x272_22.h265&quot;;</span><br><span class="line">	//avformat_open_input(&amp;pFormatCtx,filepath,NULL,NULL)</span><br><span class="line"></span><br><span class="line">	//Register Device</span><br><span class="line">	avdevice_register_all();</span><br><span class="line"></span><br><span class="line">    //Linux：参数设置</span><br><span class="line">	AVDictionary* options = NULL;</span><br><span class="line">	av_dict_set(&amp;options, &quot;input_format&quot;, &quot;mjpeg&quot;, 0); //输入格式</span><br><span class="line">	av_dict_set(&amp;options, &quot;framerate&quot;, &quot;30&quot;, 0);       //帧率</span><br><span class="line">	av_dict_set(&amp;options, &quot;video_size&quot;, &quot;1280x720&quot;, 0);//图像像素</span><br><span class="line">	AVInputFormat *ifmt=av_find_input_format(&quot;video4linux2&quot;);</span><br><span class="line">	if(avformat_open_input(&amp;pFormatCtx,&quot;/dev/video1&quot;,ifmt,&amp;options)!=0)&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t open input stream.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	av_dict_free(&amp;options);</span><br><span class="line"></span><br><span class="line">	if(avformat_find_stream_info(pFormatCtx,NULL)&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t find stream information.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	videoindex=-1;</span><br><span class="line">	for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++)</span><br><span class="line">		if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO)</span><br><span class="line">		&#123;</span><br><span class="line">			videoindex=i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	if(videoindex==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t find a video stream.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pCodecCtx=pFormatCtx-&gt;streams[videoindex]-&gt;codec;</span><br><span class="line">	pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">	if(pCodec==NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Codec not found.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(avcodec_open2(pCodecCtx, pCodec,NULL)&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Could not open codec.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;pCodecCtx-&gt;codec_id %d\n&quot;, pCodecCtx-&gt;codec_id);</span><br><span class="line">	printf(&quot;pCodecCtx-&gt;width %d\n&quot;, pCodecCtx-&gt;width);</span><br><span class="line">	printf(&quot;pCodecCtx-&gt;height %d\n&quot;, pCodecCtx-&gt;height);</span><br><span class="line">	printf(&quot;pCodecCtx-&gt;pix_fmt %d\n&quot;, pCodecCtx-&gt;pix_fmt);</span><br><span class="line">	AVFrame	*pFrame,*pFrameYUV;</span><br><span class="line">	pFrame=av_frame_alloc();</span><br><span class="line">	pFrameYUV=av_frame_alloc();</span><br><span class="line">	//unsigned char *out_buffer=(unsigned char *)av_malloc(avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height));</span><br><span class="line">	//avpicture_fill((AVPicture *)pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">	//SDL----------------------------</span><br><span class="line">	if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">		printf( &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError());</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	int screen_w=0,screen_h=0;</span><br><span class="line">	SDL_Surface *screen;</span><br><span class="line">	screen_w = pCodecCtx-&gt;width;</span><br><span class="line">	screen_h = pCodecCtx-&gt;height;</span><br><span class="line">	screen = SDL_SetVideoMode(screen_w, screen_h, 0,0);</span><br><span class="line"></span><br><span class="line">	if(!screen) &#123;</span><br><span class="line">		printf(&quot;SDL: could not set video mode - exiting:%s\n&quot;,SDL_GetError());</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	SDL_Overlay *bmp;</span><br><span class="line">	bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,SDL_YV12_OVERLAY, screen);</span><br><span class="line">	SDL_Rect rect;</span><br><span class="line">	rect.x = 0;</span><br><span class="line">	rect.y = 0;</span><br><span class="line">	rect.w = screen_w;</span><br><span class="line">	rect.h = screen_h;</span><br><span class="line">	//SDL End------------------------</span><br><span class="line">	int ret, got_picture;</span><br><span class="line"></span><br><span class="line">	AVPacket *packet=(AVPacket *)av_malloc(sizeof(AVPacket));</span><br><span class="line"></span><br><span class="line">#if OUTPUT_YUV420P</span><br><span class="line">    FILE *fp_yuv=fopen(&quot;output.yuv&quot;,&quot;wb+&quot;);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	struct SwsContext *img_convert_ctx;</span><br><span class="line">	img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUVJ420P, SWS_BICUBIC, NULL, NULL, NULL);</span><br><span class="line">	//------------------------------</span><br><span class="line">	SDL_Thread *video_tid = SDL_CreateThread(sfp_refresh_thread,NULL);</span><br><span class="line">	//</span><br><span class="line">	SDL_WM_SetCaption(&quot;Simplest FFmpeg Read Camera&quot;,NULL);</span><br><span class="line">	//Event Loop</span><br><span class="line">	SDL_Event event;</span><br><span class="line"></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		//Wait</span><br><span class="line">		SDL_WaitEvent(&amp;event);</span><br><span class="line">		if(event.type==SFM_REFRESH_EVENT)&#123;</span><br><span class="line">			//------------------------------</span><br><span class="line">			if(av_read_frame(pFormatCtx, packet)&gt;=0)&#123;</span><br><span class="line">				printf(&quot;packet-&gt;stream_index = %d\n&quot;, packet-&gt;stream_index);</span><br><span class="line">				if(packet-&gt;stream_index==videoindex)&#123;</span><br><span class="line">					printf(&quot;videoindex = %d\n&quot;, videoindex);</span><br><span class="line">					ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line">					if(ret &lt; 0)&#123;</span><br><span class="line">						printf(&quot;Decode Error.\n&quot;);</span><br><span class="line">						return -1;</span><br><span class="line">					&#125;</span><br><span class="line">					if(got_picture)&#123;</span><br><span class="line">						SDL_LockYUVOverlay(bmp);</span><br><span class="line">						pFrameYUV-&gt;data[0]=bmp-&gt;pixels[0];</span><br><span class="line">						pFrameYUV-&gt;data[1]=bmp-&gt;pixels[2];</span><br><span class="line">						pFrameYUV-&gt;data[2]=bmp-&gt;pixels[1];</span><br><span class="line">						pFrameYUV-&gt;linesize[0]=bmp-&gt;pitches[0];</span><br><span class="line">						pFrameYUV-&gt;linesize[1]=bmp-&gt;pitches[2];</span><br><span class="line">						pFrameYUV-&gt;linesize[2]=bmp-&gt;pitches[1];</span><br><span class="line">						sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line">#if OUTPUT_YUV420P</span><br><span class="line">						int y_size=pCodecCtx-&gt;width*pCodecCtx-&gt;height;</span><br><span class="line">						fwrite(pFrameYUV-&gt;data[0],1,y_size,fp_yuv);    //Y</span><br><span class="line">						fwrite(pFrameYUV-&gt;data[1],1,y_size/4,fp_yuv);  //U</span><br><span class="line">						fwrite(pFrameYUV-&gt;data[2],1,y_size/4,fp_yuv);  //V</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">						SDL_UnlockYUVOverlay(bmp);</span><br><span class="line"></span><br><span class="line">						SDL_DisplayYUVOverlay(bmp, &amp;rect);</span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				av_free_packet(packet);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				//Exit Thread</span><br><span class="line">				thread_exit=1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if(event.type==SDL_QUIT)&#123;</span><br><span class="line">			thread_exit=1;</span><br><span class="line">		&#125;else if(event.type==SFM_BREAK_EVENT)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	sws_freeContext(img_convert_ctx);</span><br><span class="line"></span><br><span class="line">#if OUTPUT_YUV420P</span><br><span class="line">    fclose(fp_yuv);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">	SDL_Quit();</span><br><span class="line"></span><br><span class="line">	//av_free(out_buffer);</span><br><span class="line">	av_free(pFrameYUV);</span><br><span class="line">	avcodec_close(pCodecCtx);</span><br><span class="line">	avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong><font color="black" size=5 face="仿宋">三、V4L2+OpenCV2.4.13：</font></strong></p>
<p>这里贴出自己的代码，其中V4L2各功能函数是按照标准的V4L2框架进行编写的。本篇博客只贴出摄像头图像采集程序代码，下一篇将针对拍照+预览程序进行代码讲解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * include.h</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef INCLUDE_H_</span><br><span class="line">#define INCLUDE_H_</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;error.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;termios.h&gt;</span><br><span class="line">#include &lt;linux/videodev2.h&gt;</span><br><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line">#include &lt;sys/time.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;opencv2/core/core.hpp&gt;</span><br><span class="line">#include &lt;opencv2/highgui/highgui.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#endif /* INCLUDE_H_ */</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * v4l2cap.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;v4l2cap.h&quot;</span><br><span class="line"></span><br><span class="line">V4L2Capture::V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap) &#123;</span><br><span class="line">	// TODO Auto-generated constructor stub</span><br><span class="line">	this-&gt;devName = devName;</span><br><span class="line">	this-&gt;fd_cam = -1;</span><br><span class="line">	this-&gt;buffers = NULL;</span><br><span class="line">	this-&gt;n_buffers = 0;</span><br><span class="line">	this-&gt;frameIndex = -1;</span><br><span class="line">	this-&gt;width=width;</span><br><span class="line">	this-&gt;height=height;</span><br><span class="line">	this-&gt;widthCap=width_cap;</span><br><span class="line">	this-&gt;heightCap=height_cap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V4L2Capture::~V4L2Capture() &#123;</span><br><span class="line">	// TODO Auto-generated destructor stub</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********打开设备**********/</span><br><span class="line">int V4L2Capture::openDevice() &#123;</span><br><span class="line">	/*设备的打开*/</span><br><span class="line">	printf(&quot;video dev : %s\n&quot;, devName);</span><br><span class="line">	fd_cam = open(devName, O_RDWR);</span><br><span class="line">	if (fd_cam &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t open video device&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********关闭设备**********/</span><br><span class="line">int V4L2Capture::closeDevice() &#123;</span><br><span class="line">	if (fd_cam &gt; 0) &#123;</span><br><span class="line">		int ret = 0;</span><br><span class="line">		if ((ret = close(fd_cam)) &lt; 0) &#123;</span><br><span class="line">			perror(&quot;Can&apos;t close video device&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********初始化设备（预览模式）**********/</span><br><span class="line">int V4L2Capture::initDevice() &#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct v4l2_capability cam_cap;		//显示设备信息</span><br><span class="line">	struct v4l2_cropcap cam_cropcap;	//设置摄像头的捕捉能力</span><br><span class="line">	struct v4l2_fmtdesc cam_fmtdesc;	//查询所有支持的格式：VIDIOC_ENUM_FMT</span><br><span class="line">	struct v4l2_crop cam_crop;		    //图像的缩放</span><br><span class="line">	struct v4l2_format cam_format;		//设置摄像头的视频制式、帧格式等</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_QUERYCAP，获取摄像头的基本信息*/</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_QUERYCAP, &amp;cam_cap);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t get device information: VIDIOCGCAP&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(</span><br><span class="line">			&quot;Driver Name:%s\nCard Name:%s\nBus info:%s\nDriver Version:%u.%u.%u\n&quot;,</span><br><span class="line">			cam_cap.driver, cam_cap.card, cam_cap.bus_info,</span><br><span class="line">			(cam_cap.version &gt;&gt; 16) &amp; 0XFF, (cam_cap.version &gt;&gt; 8) &amp; 0XFF,</span><br><span class="line">			cam_cap.version &amp; 0XFF);</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_ENUM_FMT，获取摄像头所有支持的格式*/</span><br><span class="line">	cam_fmtdesc.index = 0;</span><br><span class="line">	cam_fmtdesc.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	printf(&quot;Support format:\n&quot;);</span><br><span class="line">	while (ioctl(fd_cam, VIDIOC_ENUM_FMT, &amp;cam_fmtdesc) != -1) &#123;</span><br><span class="line">		printf(&quot;\t%d.%s\n&quot;, cam_fmtdesc.index + 1, cam_fmtdesc.description);</span><br><span class="line">		cam_fmtdesc.index++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_CROPCAP，获取摄像头的捕捉能力*/</span><br><span class="line">	cam_cropcap.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	if (0 == ioctl(fd_cam, VIDIOC_CROPCAP, &amp;cam_cropcap)) &#123;</span><br><span class="line">		printf(&quot;Default rec:\n\tleft:%d\n\ttop:%d\n\twidth:%d\n\theight:%d\n&quot;,</span><br><span class="line">				cam_cropcap.defrect.left, cam_cropcap.defrect.top,</span><br><span class="line">				cam_cropcap.defrect.width, cam_cropcap.defrect.height);</span><br><span class="line">		/* 使用IOCTL命令VIDIOC_S_CROP，获取摄像头的窗口取景参数*/</span><br><span class="line">		cam_crop.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		cam_crop.c = cam_cropcap.defrect;		//默认取景窗口大小</span><br><span class="line">		if (-1 == ioctl(fd_cam, VIDIOC_S_CROP, &amp;cam_crop)) &#123;</span><br><span class="line">			//printf(&quot;Can&apos;t set crop para\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		printf(&quot;Can&apos;t set cropcap para\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	cam_format.fmt.pix.width = width;</span><br><span class="line">	cam_format.fmt.pix.height = height;</span><br><span class="line">	cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;		//要和摄像头支持的类型对应</span><br><span class="line">	cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t set frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	/* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t get frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;,</span><br><span class="line">			cam_format.fmt.pix.width, cam_format.fmt.pix.height);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********初始化设备（拍照模式）**********/</span><br><span class="line">int V4L2Capture::initDeviceCap() &#123;</span><br><span class="line">	int ret;</span><br><span class="line">	struct v4l2_format cam_format;		//设置摄像头的视频制式、帧格式等</span><br><span class="line"></span><br><span class="line">	/* 使用IOCTL命令VIDIOC_S_FMT，设置摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	cam_format.fmt.pix.width = widthCap;</span><br><span class="line">	cam_format.fmt.pix.height = heightCap;</span><br><span class="line">	cam_format.fmt.pix.pixelformat = V4L2_PIX_FMT_MJPEG;		//要和摄像头支持的类型对应</span><br><span class="line">	cam_format.fmt.pix.field = V4L2_FIELD_INTERLACED;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_S_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t set frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	/* 使用IOCTL命令VIDIOC_G_FMT，获取摄像头帧信息*/</span><br><span class="line">	cam_format.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_G_FMT, &amp;cam_format);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Can&apos;t get frame information&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;Current data format information:\n\twidth:%d\n\theight:%d\n&quot;,</span><br><span class="line">			cam_format.fmt.pix.width, cam_format.fmt.pix.height);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********申请缓存**********/</span><br><span class="line">int V4L2Capture::initBuffers() &#123;</span><br><span class="line">	int ret;</span><br><span class="line">	/* 使用IOCTL命令VIDIOC_REQBUFS，申请帧缓冲*/</span><br><span class="line">	struct v4l2_requestbuffers req;</span><br><span class="line">	CLEAR(req);</span><br><span class="line">	req.count = 4;</span><br><span class="line">	req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	req.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">	ret = ioctl(fd_cam, VIDIOC_REQBUFS, &amp;req);</span><br><span class="line">	if (ret &lt; 0) &#123;</span><br><span class="line">		perror(&quot;Request frame buffers failed&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	if (req.count &lt; 2) &#123;</span><br><span class="line">		perror(&quot;Request frame buffers while insufficient buffer memory&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	buffers = (struct cam_buffer*) calloc(req.count, sizeof(*buffers));</span><br><span class="line">	if (!buffers) &#123;</span><br><span class="line">		perror(&quot;Out of memory&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	for (n_buffers = 0; n_buffers &lt; req.count; n_buffers++) &#123;</span><br><span class="line">		struct v4l2_buffer buf;</span><br><span class="line">		CLEAR(buf);</span><br><span class="line">		// 查询序号为n_buffers 的缓冲区，得到其起始物理地址和大小</span><br><span class="line">		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">		buf.index = n_buffers;</span><br><span class="line">		ret = ioctl(fd_cam, VIDIOC_QUERYBUF, &amp;buf);</span><br><span class="line">		if (ret &lt; 0) &#123;</span><br><span class="line">			printf(&quot;VIDIOC_QUERYBUF %d failed\n&quot;, n_buffers);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		buffers[n_buffers].length = buf.length;</span><br><span class="line">		//printf(&quot;buf.length= %d\n&quot;,buf.length);</span><br><span class="line">		// 映射内存</span><br><span class="line">		buffers[n_buffers].start = mmap(</span><br><span class="line">				NULL, // start anywhere</span><br><span class="line">				buf.length, PROT_READ | PROT_WRITE, MAP_SHARED, fd_cam,</span><br><span class="line">				buf.m.offset);</span><br><span class="line">		if (MAP_FAILED == buffers[n_buffers].start) &#123;</span><br><span class="line">			printf(&quot;mmap buffer%d failed\n&quot;, n_buffers);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********释放缓存**********/</span><br><span class="line">int V4L2Capture::freeBuffers() &#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	for (i = 0; i &lt; n_buffers; ++i) &#123;</span><br><span class="line">		if (-1 == munmap(buffers[i].start, buffers[i].length)) &#123;</span><br><span class="line">			printf(&quot;munmap buffer%d failed\n&quot;, i);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	free(buffers);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********开始采集**********/</span><br><span class="line">int V4L2Capture::startCapture() &#123;</span><br><span class="line">	unsigned int i;</span><br><span class="line">	for (i = 0; i &lt; n_buffers; i++) &#123;</span><br><span class="line">		struct v4l2_buffer buf;</span><br><span class="line">		CLEAR(buf);</span><br><span class="line">		buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">		buf.index = i;</span><br><span class="line">		if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;buf)) &#123;</span><br><span class="line">			printf(&quot;VIDIOC_QBUF buffer%d failed\n&quot;, i);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enum v4l2_buf_type type;</span><br><span class="line">	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	if (-1 == ioctl(fd_cam, VIDIOC_STREAMON, &amp;type)) &#123;</span><br><span class="line">		printf(&quot;VIDIOC_STREAMON error&quot;);</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**********停止采集**********/</span><br><span class="line">int V4L2Capture::stopCapture() &#123;</span><br><span class="line">	enum v4l2_buf_type type;</span><br><span class="line">	type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	if (-1 == ioctl(fd_cam, VIDIOC_STREAMOFF, &amp;type)) &#123;</span><br><span class="line">		printf(&quot;VIDIOC_STREAMOFF error\n&quot;);</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********获取图像**********/</span><br><span class="line">int V4L2Capture::getFrame(void **frame_buf, size_t* len) &#123;</span><br><span class="line">	struct v4l2_buffer queue_buf;</span><br><span class="line">	CLEAR(queue_buf);</span><br><span class="line">	queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">	queue_buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">	if (-1 == ioctl(fd_cam, VIDIOC_DQBUF, &amp;queue_buf)) &#123;</span><br><span class="line">		printf(&quot;VIDIOC_DQBUF error\n&quot;);</span><br><span class="line">		return FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	//printf(&quot;queue_buf.index=%d\n&quot;,queue_buf.index);</span><br><span class="line">	//pthread_rwlock_wrlock(&amp;rwlock);</span><br><span class="line">	*frame_buf = buffers[queue_buf.index].start;</span><br><span class="line">	*len = buffers[queue_buf.index].length;</span><br><span class="line">	frameIndex = queue_buf.index;</span><br><span class="line">	//pthread_rwlock_unlock(&amp;rwlock);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********返回队列**********/</span><br><span class="line">int V4L2Capture::backFrame() &#123;</span><br><span class="line">	if (frameIndex != -1) &#123;</span><br><span class="line">		struct v4l2_buffer queue_buf;</span><br><span class="line">		CLEAR(queue_buf);</span><br><span class="line">		queue_buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;</span><br><span class="line">		queue_buf.memory = V4L2_MEMORY_MMAP;</span><br><span class="line">		queue_buf.index = frameIndex;</span><br><span class="line">		if (-1 == ioctl(fd_cam, VIDIOC_QBUF, &amp;queue_buf)) &#123;</span><br><span class="line">			printf(&quot;VIDIOC_QBUF error\n&quot;);</span><br><span class="line">			return FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		return TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********预览切换至拍照**********/</span><br><span class="line">int V4L2Capture::pre2cap() &#123;</span><br><span class="line">	if(V4L2Capture::stopCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StopCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::freeBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;FreeBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::closeDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;CloseDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::openDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;OpenDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initDeviceCap() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitDeviceCap fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::startCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StartCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********拍照切换至预览**********/</span><br><span class="line">int V4L2Capture::cap2pre() &#123;</span><br><span class="line">	if(V4L2Capture::stopCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StopCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::freeBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;FreeBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::closeDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;CloseDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::openDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;OpenDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::initBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::startCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StartCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********预览开启**********/</span><br><span class="line">int V4L2Capture::preBegin() &#123;</span><br><span class="line">	if(V4L2Capture::openDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;OpenDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;first~~\n&quot;);</span><br><span class="line">	if(V4L2Capture::initDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;second~~\n&quot;);</span><br><span class="line">	if(V4L2Capture::initBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;InitBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;third~~\n&quot;);</span><br><span class="line">	if(V4L2Capture::startCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StartCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;fourth~~\n&quot;);</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**********预览结束**********/</span><br><span class="line">int V4L2Capture::preEnd() &#123;</span><br><span class="line">	if(V4L2Capture::stopCapture() == FALSE)&#123;</span><br><span class="line">		printf(&quot;StopCapture fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::freeBuffers() == FALSE)&#123;</span><br><span class="line">		printf(&quot;FreeBuffers fail~~\n&quot;);</span><br><span class="line">		exit(2);</span><br><span class="line">	&#125;</span><br><span class="line">	if(V4L2Capture::closeDevice() == FALSE)&#123;</span><br><span class="line">		printf(&quot;CloseDevice fail~~\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * v4l2cap.h</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#ifndef V4L2CAP_H_</span><br><span class="line">#define V4L2CAP_H_</span><br><span class="line"></span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line"></span><br><span class="line">#define CLEAR(x) memset(&amp;(x), 0, sizeof(x))</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">class V4L2Capture &#123;</span><br><span class="line">public:</span><br><span class="line">	V4L2Capture(char *devName, int width, int height, int width_cap, int height_cap);</span><br><span class="line">	virtual ~V4L2Capture();</span><br><span class="line"></span><br><span class="line">	int openDevice();</span><br><span class="line">	int closeDevice();</span><br><span class="line">	int initDevice();</span><br><span class="line">	int initDeviceCap();</span><br><span class="line">	int startCapture();</span><br><span class="line">	int stopCapture();</span><br><span class="line">	int freeBuffers();</span><br><span class="line">	int getFrame(void **,size_t *);</span><br><span class="line">	int backFrame();</span><br><span class="line">	int pre2cap();</span><br><span class="line">	int cap2pre();</span><br><span class="line">	int preBegin();</span><br><span class="line">	int preEnd();</span><br><span class="line"></span><br><span class="line">	int initBuffers();</span><br><span class="line"></span><br><span class="line">	struct cam_buffer</span><br><span class="line">	&#123;</span><br><span class="line">		void* start;</span><br><span class="line">		unsigned int length;</span><br><span class="line">	&#125;;</span><br><span class="line">	char *devName;</span><br><span class="line">	int widthCap;</span><br><span class="line">	int heightCap;</span><br><span class="line">	int width;</span><br><span class="line">	int height;</span><br><span class="line">	int fd_cam;</span><br><span class="line">	cam_buffer *buffers;</span><br><span class="line">	unsigned int n_buffers;</span><br><span class="line">	int frameIndex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* V4L2CAP_H_ */</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * main.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jul 26, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;include.h&quot;</span><br><span class="line">#include &quot;v4l2cap.h&quot;</span><br><span class="line"></span><br><span class="line">#define IMAGEWIDTH 640</span><br><span class="line">#define IMAGEHEIGHT 480</span><br><span class="line"></span><br><span class="line">#define TRUE 1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	IplImage* img,* img_cap;</span><br><span class="line">	CvMat cvmat,cvmat_cap;</span><br><span class="line">	double t;</span><br><span class="line">	unsigned char *frame = NULL;</span><br><span class="line">	unsigned long frameSize = 0;</span><br><span class="line">	string videoDev=&quot;/dev/video1&quot;;</span><br><span class="line"></span><br><span class="line">	V4L2Capture *vcap = new V4L2Capture(const_cast&lt;char*&gt;(videoDev.c_str()),</span><br><span class="line">			IMAGEWIDTH, IMAGEHEIGHT, IMAGEWIDTH_CAP, IMAGEHEIGHT_CAP);</span><br><span class="line">	vcap-&gt;preBegin();                                //预览模式开启</span><br><span class="line"></span><br><span class="line">	cvNamedWindow(&quot;one&quot;,CV_WINDOW_AUTOSIZE);         //创建显示窗口</span><br><span class="line"></span><br><span class="line">	while(1)&#123;</span><br><span class="line">		t = (double)cvGetTickCount();</span><br><span class="line">		vcap-&gt;getFrame((void **) &amp;frame, &amp;frameSize);//获取图像队列</span><br><span class="line">		cvmat = cvMat(IMAGEHEIGHT,IMAGEWIDTH,CV_8UC3,frame);//CV_8UC3</span><br><span class="line">		img = cvDecodeImage(&amp;cvmat,1);               //OpenCV解码</span><br><span class="line">		if(!img)    printf(&quot;No img\n&quot;);</span><br><span class="line">		cvShowImage(&quot;one&quot;,img);                      //显示图像</span><br><span class="line">		cvReleaseImage(&amp;img);                        //循环外释放也可以</span><br><span class="line">		vcap-&gt;backFrame();                           //返回图像队列</span><br><span class="line">        cvWaitKey(1);                                //不写这句话将无法显示图像</span><br><span class="line">		t=(double)cvGetTickCount()-t;</span><br><span class="line">		printf(&quot;used time is %gms\n&quot;,(t/(cvGetTickFrequency()*1000)));</span><br><span class="line">	&#125;</span><br><span class="line">	vcap-&gt;preEnd();                                  //预览结束</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>USB摄像头</tag>
        <tag>MJPEG</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之八：Qt安装与配置</title>
    <url>/folder/2019/11/08/2017-10-01-tx-8/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">写在前面：</font></strong><br>很多朋友私下问我如何在NVIDIA TX1上安装和配置Qt，所以我就自己试着配置了一把，现在贴出了分享给大家。这篇文章是关于安装QT 5.5.1支持的Qt Creator 3.3.1 版本。</p>
<p><strong><font color="black" size=5 face="仿宋">一、安装Qt</font></strong></p>
<p>1.安装Qt Creator，打开终端执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install qt5-default qtcreator -y</span><br></pre></td></tr></table></figure>
<p>2.安装Qt示例和文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install qt5-doc qt5-doc-html qtbase5-doc-html qtbase5-examples -y</span><br></pre></td></tr></table></figure>

<p><strong><font color="black" size=5 face="仿宋">二、配置Qt</font></strong></p>
<p>1.搜索Qt并打开应用程序，当然也可以用命令行直接打开：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170730161851878?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400" /></div>
<p></p>

<p>2.Tools-&gt;Options-&gt;Build &amp; Run-&gt;Compilers，单击add选择添加GCC编译器，GCC编译器默认路径为/usr/bin/gcc，添加完路径之后还要修改开发平台，如图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170730161841734?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400" /></div>
<p></p>

<p>3.切换到Kit下，添加开发套件。名称可以随便写，需要注意的是必须先配置上一步的GCC，这一步才能直接添加GCC，否则就会像Desktop套件一样报错：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170730162006680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400" /></div>
<p></p>

<p><strong><font color="black" size=5 face="仿宋">三、测试Qt示例</font></strong></p>
<p>1.打开示例，随便选一个都可以，在这里我选择的是看起来比较酷炫的图标排列例程：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170730162312438?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="500" /></div>
<p></p>

<p>2.工程路径和打开例程方式，这里我们默认即可：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170730162347984?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="500" /></div>
<p></p>

<p>3.F5构建项目，然后运行结果如图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170730162440533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="800" /></div>
<p></p>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之七：FFMPEG安装与测试</title>
    <url>/folder/2019/11/08/2017-10-01-tx-7/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="red" size=5 face="仿宋">纪念雷神</font></strong><br>雷神在中国视音频领域影响深远，值此纪念日，缅怀雷神。</p>
<p><strong><font color="black" size=5 face="仿宋">——分割线——</font></strong></p>
<p><strong><font color="black" size=5 face="仿宋">前言：</font></strong><br>本人需要在NVIDIA TX1上通过USB摄像头实现拍照和预览功能，奈何自己买的USB摄像头的YUYV格式只有640*480这么一种分辨率，JPEG格式下的分辨率倒是很多。现在TX1上面的多媒体例程已经更新到第12个：12_camera_v4l2_cuda。但是本人不才，还是没有在nvcc中找到与V4L2中的MJPEG对应的format格式，期间还搞过一段时间的Gstreamer，但是只能单独实现预览或者拍照功能，再往深了就不会写了，资料太少了。挣扎许久之后还是放弃了，转战Ffmpeg。其实Gstreamer和Ffmpeg这两者挺像的，都是先用命令行测试之后再码代码，但是Gstreamer包括晦涩难懂的OBJECT编程，最起码我学起来很吃力，以后有精力了再尝试吧。</p>
<p><strong><font color="black" size=5 face="仿宋">一、Ffmpeg安装：</font></strong><br>1.安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install autoconf automake build-essential libass-dev libfreetype6-dev \</span><br><span class="line">  libsdl2-dev libtheora-dev libtool libva-dev libvdpau-dev libvorbis-dev libxcb1-dev libxcb-shm0-dev \</span><br><span class="line">  libxcb-xfixes0-dev pkg-config texinfo wget zlib1g-dev</span><br><span class="line">sudo apt-get -y install yasm nasm libx264-dev libx265-dev libmp3lame-dev libopus-dev libvpx-dev</span><br></pre></td></tr></table></figure>

<p>2.安装无法自动更新的libfdk-aac：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~/ffmpeg_sources</span><br><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget -O fdk-aac.tar.gz https://github.com/mstorsjo/fdk-aac/tarball/master</span><br><span class="line">tar xzvf fdk-aac.tar.gz</span><br><span class="line">cd mstorsjo-fdk-aac*</span><br><span class="line">autoreconf -fiv</span><br><span class="line">./configure --prefix=&quot;$HOME/ffmpeg_build&quot; --disable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>3.安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~/ffmpeg_sources</span><br><span class="line">wget http://ffmpeg.org/releases/ffmpeg-snapshot.tar.bz2</span><br><span class="line">tar xjvf ffmpeg-snapshot.tar.bz2</span><br><span class="line">cd ffmpeg</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; PKG_CONFIG_PATH=&quot;$HOME/ffmpeg_build/lib/pkgconfig&quot; ./configure \</span><br><span class="line">  --prefix=&quot;$HOME/ffmpeg_build&quot; \</span><br><span class="line">  --pkg-config-flags=&quot;--static&quot; \</span><br><span class="line">  --extra-cflags=&quot;-I$HOME/ffmpeg_build/include&quot; \</span><br><span class="line">  --extra-ldflags=&quot;-L$HOME/ffmpeg_build/lib&quot; \</span><br><span class="line">  --bindir=&quot;$HOME/bin&quot; \</span><br><span class="line">  --enable-gpl \</span><br><span class="line">  --enable-libass \</span><br><span class="line">  --enable-libfdk-aac \</span><br><span class="line">  --enable-libfreetype \</span><br><span class="line">  --enable-libmp3lame \</span><br><span class="line">  --enable-libopus \</span><br><span class="line">  --enable-libtheora \</span><br><span class="line">  --enable-libvorbis \</span><br><span class="line">  --enable-libvpx \</span><br><span class="line">  --enable-libx264 \</span><br><span class="line">  --enable-libx265 \</span><br><span class="line">  --enable-nonfree \</span><br><span class="line">  --enable-shared</span><br><span class="line">PATH=&quot;$HOME/bin:$PATH&quot; make</span><br><span class="line">make install</span><br><span class="line">hash -r</span><br></pre></td></tr></table></figure>

<p><strong><font color="black" size=5 face="仿宋">二、SDL安装：</font></strong><br>先简单再介绍一下SDL：SDL是Simple DirectMedia Layer（简易直控媒体层）的缩写。它是一个跨平台的多媒体库，以用于直接控制底层的多媒体硬件的接口。主要用在开发游戏上！</p>
<p>Ubuntu的新得立已经包含SDL库，所以通过几个简单的命令就可以安装，比windows还傻瓜！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libsdl1.2-dev</span><br></pre></td></tr></table></figure>
<p>附加包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libsdl-image1.2-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libsdl-mixer1.2-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libsdl-ttf2.0-dev</span><br><span class="line"></span><br><span class="line">sudo apt-get install libsdl-gfx1.2-dev</span><br></pre></td></tr></table></figure>

<p><strong><font color="black" size=5 face="仿宋">三、测试：</font></strong><br>这里用雷神的代码进行测试，Ffmpeg+SDL实现摄像头采集与显示。<br>先参考先前的博客在主机上用Nsight新建工程，然后进行配置，具体配置如下：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170718215605076?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="600" /></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170718215509730?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="600" /></div>
<p></p>

<p>代码如下，代码原文链接：<a href="http://blog.csdn.net/leixiaohua1020/article/details/39702113" target="_blank" rel="noopener">http://blog.csdn.net/leixiaohua1020/article/details/39702113</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">#define __STDC_CONSTANT_MACROS</span><br><span class="line"></span><br><span class="line">#ifdef _WIN32</span><br><span class="line">//Windows</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;libavcodec/avcodec.h&quot;</span><br><span class="line">#include &quot;libavformat/avformat.h&quot;</span><br><span class="line">#include &quot;libswscale/swscale.h&quot;</span><br><span class="line">#include &quot;libavdevice/avdevice.h&quot;</span><br><span class="line">#include &quot;SDL/SDL.h&quot;</span><br><span class="line">&#125;;</span><br><span class="line">#else</span><br><span class="line">//Linux...</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#endif</span><br><span class="line">#include &lt;libavcodec/avcodec.h&gt;</span><br><span class="line">#include &lt;libavformat/avformat.h&gt;</span><br><span class="line">#include &lt;libswscale/swscale.h&gt;</span><br><span class="line">#include &lt;libavdevice/avdevice.h&gt;</span><br><span class="line">#include &lt;SDL/SDL.h&gt;</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">//Output YUV420P </span><br><span class="line">#define OUTPUT_YUV420P 0</span><br><span class="line">//&apos;1&apos; Use Dshow </span><br><span class="line">//&apos;0&apos; Use VFW</span><br><span class="line">#define USE_DSHOW 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Refresh Event</span><br><span class="line">#define SFM_REFRESH_EVENT  (SDL_USEREVENT + 1)</span><br><span class="line"></span><br><span class="line">#define SFM_BREAK_EVENT  (SDL_USEREVENT + 2)</span><br><span class="line"></span><br><span class="line">int thread_exit=0;</span><br><span class="line"></span><br><span class="line">int sfp_refresh_thread(void *opaque)</span><br><span class="line">&#123;</span><br><span class="line">	thread_exit=0;</span><br><span class="line">	while (!thread_exit) &#123;</span><br><span class="line">		SDL_Event event;</span><br><span class="line">		event.type = SFM_REFRESH_EVENT;</span><br><span class="line">		SDL_PushEvent(&amp;event);</span><br><span class="line">		SDL_Delay(40);</span><br><span class="line">	&#125;</span><br><span class="line">	thread_exit=0;</span><br><span class="line">	//Break</span><br><span class="line">	SDL_Event event;</span><br><span class="line">	event.type = SFM_BREAK_EVENT;</span><br><span class="line">	SDL_PushEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//Show Dshow Device</span><br><span class="line">void show_dshow_device()&#123;</span><br><span class="line">	AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">	AVDictionary* options = NULL;</span><br><span class="line">	av_dict_set(&amp;options,&quot;list_devices&quot;,&quot;true&quot;,0);</span><br><span class="line">	AVInputFormat *iformat = av_find_input_format(&quot;dshow&quot;);</span><br><span class="line">	printf(&quot;========Device Info=============\n&quot;);</span><br><span class="line">	avformat_open_input(&amp;pFormatCtx,&quot;video=dummy&quot;,iformat,&amp;options);</span><br><span class="line">	printf(&quot;================================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Show Dshow Device Option</span><br><span class="line">void show_dshow_device_option()&#123;</span><br><span class="line">	AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">	AVDictionary* options = NULL;</span><br><span class="line">	av_dict_set(&amp;options,&quot;list_options&quot;,&quot;true&quot;,0);</span><br><span class="line">	AVInputFormat *iformat = av_find_input_format(&quot;dshow&quot;);</span><br><span class="line">	printf(&quot;========Device Option Info======\n&quot;);</span><br><span class="line">	avformat_open_input(&amp;pFormatCtx,&quot;video=Integrated Camera&quot;,iformat,&amp;options);</span><br><span class="line">	printf(&quot;================================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Show VFW Device</span><br><span class="line">void show_vfw_device()&#123;</span><br><span class="line">	AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">	AVInputFormat *iformat = av_find_input_format(&quot;vfwcap&quot;);</span><br><span class="line">	printf(&quot;========VFW Device Info======\n&quot;);</span><br><span class="line">	avformat_open_input(&amp;pFormatCtx,&quot;list&quot;,iformat,NULL);</span><br><span class="line">	printf(&quot;=============================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Show AVFoundation Device</span><br><span class="line">void show_avfoundation_device()&#123;</span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">    AVDictionary* options = NULL;</span><br><span class="line">    av_dict_set(&amp;options,&quot;list_devices&quot;,&quot;true&quot;,0);</span><br><span class="line">    AVInputFormat *iformat = av_find_input_format(&quot;avfoundation&quot;);</span><br><span class="line">    printf(&quot;==AVFoundation Device Info===\n&quot;);</span><br><span class="line">    avformat_open_input(&amp;pFormatCtx,&quot;&quot;,iformat,&amp;options);</span><br><span class="line">    printf(&quot;=============================\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	AVFormatContext	*pFormatCtx;</span><br><span class="line">	int				i, videoindex;</span><br><span class="line">	AVCodecContext	*pCodecCtx;</span><br><span class="line">	AVCodec			*pCodec;</span><br><span class="line">	</span><br><span class="line">	av_register_all();</span><br><span class="line">	avformat_network_init();</span><br><span class="line">	pFormatCtx = avformat_alloc_context();</span><br><span class="line">	</span><br><span class="line">	//Open File</span><br><span class="line">	//char filepath[]=&quot;src01_480x272_22.h265&quot;;</span><br><span class="line">	//avformat_open_input(&amp;pFormatCtx,filepath,NULL,NULL)</span><br><span class="line"></span><br><span class="line">	//Register Device</span><br><span class="line">	avdevice_register_all();</span><br><span class="line"></span><br><span class="line">//Windows</span><br><span class="line">#ifdef _WIN32</span><br><span class="line"></span><br><span class="line">	//Show Dshow Device</span><br><span class="line">	show_dshow_device();</span><br><span class="line">	//Show Device Options</span><br><span class="line">	show_dshow_device_option();</span><br><span class="line">    //Show VFW Options</span><br><span class="line">    show_vfw_device();</span><br><span class="line"></span><br><span class="line">#if USE_DSHOW</span><br><span class="line">	AVInputFormat *ifmt=av_find_input_format(&quot;dshow&quot;);</span><br><span class="line">	//Set own video device&apos;s name</span><br><span class="line">	if(avformat_open_input(&amp;pFormatCtx,&quot;video=Integrated Camera&quot;,ifmt,NULL)!=0)&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t open input stream.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">#else</span><br><span class="line">	AVInputFormat *ifmt=av_find_input_format(&quot;vfwcap&quot;);</span><br><span class="line">	if(avformat_open_input(&amp;pFormatCtx,&quot;0&quot;,ifmt,NULL)!=0)&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t open input stream.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">#endif</span><br><span class="line">#elif defined linux</span><br><span class="line">    //Linux</span><br><span class="line">	AVInputFormat *ifmt=av_find_input_format(&quot;video4linux2&quot;);</span><br><span class="line">	if(avformat_open_input(&amp;pFormatCtx,&quot;/dev/video0&quot;,ifmt,NULL)!=0)&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t open input stream.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">#else</span><br><span class="line">    show_avfoundation_device();</span><br><span class="line">    //Mac</span><br><span class="line">    AVInputFormat *ifmt=av_find_input_format(&quot;avfoundation&quot;);</span><br><span class="line">    //Avfoundation</span><br><span class="line">    //[video]:[audio]</span><br><span class="line">    if(avformat_open_input(&amp;pFormatCtx,&quot;0&quot;,ifmt,NULL)!=0)&#123;</span><br><span class="line">        printf(&quot;Couldn&apos;t open input stream.\n&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	if(avformat_find_stream_info(pFormatCtx,NULL)&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t find stream information.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	videoindex=-1;</span><br><span class="line">	for(i=0; i&lt;pFormatCtx-&gt;nb_streams; i++) </span><br><span class="line">		if(pFormatCtx-&gt;streams[i]-&gt;codec-&gt;codec_type==AVMEDIA_TYPE_VIDEO)</span><br><span class="line">		&#123;</span><br><span class="line">			videoindex=i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	if(videoindex==-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Couldn&apos;t find a video stream.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	pCodecCtx=pFormatCtx-&gt;streams[videoindex]-&gt;codec;</span><br><span class="line">	pCodec=avcodec_find_decoder(pCodecCtx-&gt;codec_id);</span><br><span class="line">	if(pCodec==NULL)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Codec not found.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	if(avcodec_open2(pCodecCtx, pCodec,NULL)&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Could not open codec.\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	AVFrame	*pFrame,*pFrameYUV;</span><br><span class="line">	pFrame=av_frame_alloc();</span><br><span class="line">	pFrameYUV=av_frame_alloc();</span><br><span class="line">	//unsigned char *out_buffer=(unsigned char *)av_malloc(avpicture_get_size(AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height));</span><br><span class="line">	//avpicture_fill((AVPicture *)pFrameYUV, out_buffer, AV_PIX_FMT_YUV420P, pCodecCtx-&gt;width, pCodecCtx-&gt;height);</span><br><span class="line">	//SDL----------------------------</span><br><span class="line">	if(SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;  </span><br><span class="line">		printf( &quot;Could not initialize SDL - %s\n&quot;, SDL_GetError()); </span><br><span class="line">		return -1;</span><br><span class="line">	&#125; </span><br><span class="line">	int screen_w=0,screen_h=0;</span><br><span class="line">	SDL_Surface *screen; </span><br><span class="line">	screen_w = pCodecCtx-&gt;width;</span><br><span class="line">	screen_h = pCodecCtx-&gt;height;</span><br><span class="line">	screen = SDL_SetVideoMode(screen_w, screen_h, 0,0);</span><br><span class="line"></span><br><span class="line">	if(!screen) &#123;  </span><br><span class="line">		printf(&quot;SDL: could not set video mode - exiting:%s\n&quot;,SDL_GetError());  </span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	SDL_Overlay *bmp; </span><br><span class="line">	bmp = SDL_CreateYUVOverlay(pCodecCtx-&gt;width, pCodecCtx-&gt;height,SDL_YV12_OVERLAY, screen); </span><br><span class="line">	SDL_Rect rect;</span><br><span class="line">	rect.x = 0;    </span><br><span class="line">	rect.y = 0;    </span><br><span class="line">	rect.w = screen_w;    </span><br><span class="line">	rect.h = screen_h;  </span><br><span class="line">	//SDL End------------------------</span><br><span class="line">	int ret, got_picture;</span><br><span class="line"></span><br><span class="line">	AVPacket *packet=(AVPacket *)av_malloc(sizeof(AVPacket));</span><br><span class="line"></span><br><span class="line">#if OUTPUT_YUV420P </span><br><span class="line">    FILE *fp_yuv=fopen(&quot;output.yuv&quot;,&quot;wb+&quot;);  </span><br><span class="line">#endif  </span><br><span class="line"></span><br><span class="line">	struct SwsContext *img_convert_ctx;</span><br><span class="line">	img_convert_ctx = sws_getContext(pCodecCtx-&gt;width, pCodecCtx-&gt;height, pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width, pCodecCtx-&gt;height, AV_PIX_FMT_YUV420P, SWS_BICUBIC, NULL, NULL, NULL); </span><br><span class="line">	//------------------------------</span><br><span class="line">	SDL_Thread *video_tid = SDL_CreateThread(sfp_refresh_thread,NULL);</span><br><span class="line">	//</span><br><span class="line">	SDL_WM_SetCaption(&quot;Simplest FFmpeg Read Camera&quot;,NULL);</span><br><span class="line">	//Event Loop</span><br><span class="line">	SDL_Event event;</span><br><span class="line"></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		//Wait</span><br><span class="line">		SDL_WaitEvent(&amp;event);</span><br><span class="line">		if(event.type==SFM_REFRESH_EVENT)&#123;</span><br><span class="line">			//------------------------------</span><br><span class="line">			if(av_read_frame(pFormatCtx, packet)&gt;=0)&#123;</span><br><span class="line">				if(packet-&gt;stream_index==videoindex)&#123;</span><br><span class="line">					ret = avcodec_decode_video2(pCodecCtx, pFrame, &amp;got_picture, packet);</span><br><span class="line">					if(ret &lt; 0)&#123;</span><br><span class="line">						printf(&quot;Decode Error.\n&quot;);</span><br><span class="line">						return -1;</span><br><span class="line">					&#125;</span><br><span class="line">					if(got_picture)&#123;</span><br><span class="line">						SDL_LockYUVOverlay(bmp);</span><br><span class="line">						pFrameYUV-&gt;data[0]=bmp-&gt;pixels[0];</span><br><span class="line">						pFrameYUV-&gt;data[1]=bmp-&gt;pixels[2];</span><br><span class="line">						pFrameYUV-&gt;data[2]=bmp-&gt;pixels[1];     </span><br><span class="line">						pFrameYUV-&gt;linesize[0]=bmp-&gt;pitches[0];</span><br><span class="line">						pFrameYUV-&gt;linesize[1]=bmp-&gt;pitches[2];   </span><br><span class="line">						pFrameYUV-&gt;linesize[2]=bmp-&gt;pitches[1];</span><br><span class="line">						sws_scale(img_convert_ctx, (const unsigned char* const*)pFrame-&gt;data, pFrame-&gt;linesize, 0, pCodecCtx-&gt;height, pFrameYUV-&gt;data, pFrameYUV-&gt;linesize);</span><br><span class="line"></span><br><span class="line">#if OUTPUT_YUV420P  </span><br><span class="line">						int y_size=pCodecCtx-&gt;width*pCodecCtx-&gt;height;    </span><br><span class="line">						fwrite(pFrameYUV-&gt;data[0],1,y_size,fp_yuv);    //Y   </span><br><span class="line">						fwrite(pFrameYUV-&gt;data[1],1,y_size/4,fp_yuv);  //U  </span><br><span class="line">						fwrite(pFrameYUV-&gt;data[2],1,y_size/4,fp_yuv);  //V  </span><br><span class="line">#endif  </span><br><span class="line"></span><br><span class="line">						SDL_UnlockYUVOverlay(bmp); </span><br><span class="line">						</span><br><span class="line">						SDL_DisplayYUVOverlay(bmp, &amp;rect); </span><br><span class="line"></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				av_free_packet(packet);</span><br><span class="line">			&#125;else&#123;</span><br><span class="line">				//Exit Thread</span><br><span class="line">				thread_exit=1;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;else if(event.type==SDL_QUIT)&#123;</span><br><span class="line">			thread_exit=1;</span><br><span class="line">		&#125;else if(event.type==SFM_BREAK_EVENT)&#123;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	sws_freeContext(img_convert_ctx);</span><br><span class="line"></span><br><span class="line">#if OUTPUT_YUV420P </span><br><span class="line">    fclose(fp_yuv);</span><br><span class="line">#endif </span><br><span class="line"></span><br><span class="line">	SDL_Quit();</span><br><span class="line"></span><br><span class="line">	//av_free(out_buffer);</span><br><span class="line">	av_free(pFrameYUV);</span><br><span class="line">	avcodec_close(pCodecCtx);</span><br><span class="line">	avformat_close_input(&amp;pFormatCtx);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>FFMPEG</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之六：SSD安装与测试</title>
    <url>/folder/2019/11/08/2017-10-01-tx-6/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="red" size=5 face="仿宋">写在前面：</font></strong><br>本博文原打算以SSD为例，介绍如何在NVIDIA Jetson TX1上安装SSD，并进行图片检测。</p>
<p><strong><font color="black" size=5 face="仿宋">安装过程：</font></strong></p>
<p>1.用以下命令安装依赖包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository universe</span><br><span class="line">$ sudo add-apt-repository multiverse</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install libboost-all-dev libprotobuf-dev libleveldb-dev libsnappy-dev</span><br><span class="line">$ sudo apt-get install libhdf5-serial-dev protobuf-compiler libgflags-dev libgoogle-glog-dev</span><br><span class="line">$ sudo apt-get install liblmdb-dev libblas-dev libatlas-base-dev libopenblas-dev</span><br></pre></td></tr></table></figure>

<p>2.下载SSD源码安装包从如下网站：<br>SSD：<a href="https://github.com/weiliu89/caffe.git" target="_blank" rel="noopener">https://github.com/weiliu89/caffe.git</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/weiliu89/caffe.git</span><br></pre></td></tr></table></figure>
<p>3.设置路径并解压：<br>a.如果是从官网下载的zip压缩包，则进行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -pv $HOME/Work/caffe</span><br><span class="line">$ cp caffe-ssd.zip $HOME/Work/caffe/</span><br><span class="line">$ cd $HOME/Work/caffe/ &amp;&amp; unzip caffe-ssd.zip</span><br></pre></td></tr></table></figure>
<p>b.如果是git获得的，则进行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv caffe $HOME/Work/caffe/caffe-ssd</span><br></pre></td></tr></table></figure>
<p>无论进行a操作还是b操作，最好都进行一下版本切换：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~/Work/caffe/caffe-ssd</span><br><span class="line">$ git checkout ssd</span><br></pre></td></tr></table></figure>
<p>4.安装python依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ../python</span><br><span class="line">$ sudo apt-get install python-pip python-numpy</span><br><span class="line">$ sudo pip install --upgrade pip</span><br><span class="line">$ for req in $(cat requirements.txt); do pip install $req; done</span><br></pre></td></tr></table></figure>

<p>requirements.txt内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cython&gt;=0.19.2</span><br><span class="line">numpy&gt;=1.7.1</span><br><span class="line">scipy&gt;=0.13.2</span><br><span class="line">scikit-image&gt;=0.9.3</span><br><span class="line">matplotlib&gt;=1.3.1</span><br><span class="line">ipython&gt;=3.0.0</span><br><span class="line">h5py&gt;=2.2.0</span><br><span class="line">leveldb&gt;=0.191</span><br><span class="line">networkx&gt;=1.8.1</span><br><span class="line">nose&gt;=1.3.0</span><br><span class="line">pandas&gt;=0.12.0</span><br><span class="line">python-dateutil&gt;=2.6.0</span><br><span class="line">protobuf&gt;=2.5.0</span><br><span class="line">python-gflags&gt;=2.0</span><br><span class="line">pyyaml&gt;=3.10</span><br><span class="line">Pillow&gt;=2.3.0</span><br><span class="line">six&gt;=1.1.0</span><br></pre></td></tr></table></figure>
<p>5.编译SSD源码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $HOME/Work/caffe/caffe-ssd</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp Makefile.config.example Makefile.config</span><br><span class="line">$ vi Makefile.config</span><br></pre></td></tr></table></figure>

<p>去掉下面该行代码的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE_CUDNN := 1</span><br></pre></td></tr></table></figure>
<p>重点来了，在Makefile.config中找到下面这几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CUDA_ARCH := -gencode arch=compute_30,code=sm_30 \</span><br><span class="line">        -gencode arch=compute_35,code=sm_35 \</span><br><span class="line">        -gencode arch=compute_50,code=sm_50 \</span><br><span class="line">        -gencode arch=compute_52,code=sm_52 \</span><br><span class="line">        -gencode arch=compute_60,code=sm_60 \</span><br><span class="line">        -gencode arch=compute_61,code=sm_61 \</span><br><span class="line">        -gencode arch=compute_61,code=compute_61</span><br></pre></td></tr></table></figure>
<p>更改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CUDA_ARCH := -gencode arch=compute_53,code=sm_53</span><br></pre></td></tr></table></figure>
<p>这里的后缀数字53是TX1的计算能力，在其他平台上编译CAFFE也是同样的道理，要把计算能力改成对应的值，否则有可能会报错。关于计算能力如何确定，CUDA例程里面有测试程序，跑一下就可以输出GPU性能指标。</p>
<p>声明下面这两行路径，保存后退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial</span><br><span class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/aarch64-linux-gnu/hdf5/serial</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make -j4</span><br></pre></td></tr></table></figure>
<p>完成后在build/lib目录下会出现库文件libcaffe.so。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make all -j4</span><br><span class="line">$ make runtest -j4(此部分报错，可以不跑)</span><br><span class="line">$ make pycaffe -j4</span><br></pre></td></tr></table></figure>

<p><strong><font color="black" size=5 face="仿宋">环境变量配置：</font></strong><br>1.在终端执行如下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>2.在最后一行添加caffe的python路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PYTHONPATH=$HOME/Work/caffe/caffe-ssd/python:$PYTHONPATH</span><br></pre></td></tr></table></figure>
<p>然后加上之前声明的环境变量，这样就不用每次make或者运行的时候再次声明环境变量了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export TEGRA_ARMABI=aarch64-linux-gnu</span><br><span class="line">export DISPLAY=:0</span><br><span class="line">export LD_LIBRARY_PATH=$HOME/Work/caffe/caffe-ssd/build/lib:/usr/local/cuda/lib64</span><br></pre></td></tr></table></figure>
<p>3.source环境变量，在终端执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p><strong><font color="black" size=5 face="仿宋">测试：</font></strong><br>1.使用jupyter或者ipython打开notebook：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jupyter notebook</span><br></pre></td></tr></table></figure>
<p>2.修改caffe路径，需要在下图的标记位置写上自己的caffe路径：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170715163635152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="800" /></div>
<p></p>

<p>3.下载VGG训练模型，直接从官网下载即可，然后解压到models下。并确认下图中标记框中路径是否正确：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170715163725622?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="800" /></div>
<p></p>

<p>4.置信度，通过调节置信度阈值，来控制在检测结果中需要显示的显示框：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170715163753223?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="800" /></div>
<p></p>

<p>5.测试结果：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170715163821537?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="600" /></div>
<p></p>

<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>SSD</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之五：CAFFE安装与NVIDIA多媒体例程测试</title>
    <url>/folder/2019/11/08/2017-10-01-tx-5/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p><strong><font color="black" size=5 face="仿宋">写在前面的前面：</font></strong><br>之前就已经在实验室的深度学习服务器上安装过CAFFE/SSD，由于当时深度学习服务器管理不佳，多人混用造成好多依赖环境删删减减，经常会出现今天装的CAFFE/SSD明天就不能用的情况，所以难免多折腾几次。因此，博主对他们的安装还是颇有研究的。<br>大家用NVIDIA Jetson TX1，无非就是看上了它的计算能力，能跑深度学习框架。由于NVIDIA Jetson TX1容量有限，所以建议大家需要哪个就安装哪个。偏向于学习，就安装纯版本的CAFFE，偏向于应用测试，就安装各个基于CAFFE的升级版，比如SSD。</p>
<p><strong><font color="red" size=5 face="仿宋">写在前面：</font></strong><br>本博文原打算以CAFFE/SSD为例，介绍如何在NVIDIA Jetson TX1上安装CAFFE/SSD，但是最近自己又安装了一遍，发现本博文的步骤不全面，导致python大部分依赖环境都没装上，这样的结果就是jupyter notebook这种工具用不了。所以本篇博文在此只介绍CAFFE安装和基于CAFFE的NVIDIA多媒体例程测试。</p>
<p><strong><font color="black" size=5 face="仿宋">安装过程：</font></strong></p>
<p>1.用以下命令安装依赖包:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository universe</span><br><span class="line">$ sudo add-apt-repository multiverse</span><br><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install libboost-all-dev libprotobuf-dev libleveldb-dev libsnappy-dev</span><br><span class="line">$ sudo apt-get install libhdf5-serial-dev protobuf-compiler libgflags-dev libgoogle-glog-dev</span><br><span class="line">$ sudo apt-get install liblmdb-dev libblas-dev libatlas-base-dev</span><br></pre></td></tr></table></figure>

<p>2.下载CAFFE源码安装包从如下网站：</p>
<p>CAFFE：<a href="https://github.com/BVLC/caffe.git" target="_blank" rel="noopener">https://github.com/BVLC/caffe.git</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone https://github.com/BVLC/caffe.git</span><br></pre></td></tr></table></figure>

<p>3设置路径并解压：<br>a.如果在步骤2中选择自己从网页手动下载zip文件，则进行如下操作：<br>CAFFE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -pv $HOME/Work/caffe</span><br><span class="line">$ cp caffe-master.zip $HOME/Work/caffe/</span><br><span class="line">$ cd $HOME/Work/caffe/ &amp;&amp; unzip caffe-master.zip</span><br></pre></td></tr></table></figure>
<p>b.如果在步骤2中直接git得到caffe文件，则进行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mv caffe $HOME/Work/caffe/caffe-master</span><br></pre></td></tr></table></figure>

<p>4.编译CAFFE源码:<br>CAFFE:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd $HOME/Work/caffe/caffe-master</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp Makefile.config.example Makefile.config</span><br><span class="line">$ vi Makefile.config</span><br></pre></td></tr></table></figure>

<p>去掉下面该行代码的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USE_CUDNN := 1</span><br></pre></td></tr></table></figure>
<p>重点来了，在Makefile.config中找到下面这几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CUDA_ARCH := -gencode arch=compute_30,code=sm_30 \</span><br><span class="line">        -gencode arch=compute_35,code=sm_35 \</span><br><span class="line">        -gencode arch=compute_50,code=sm_50 \</span><br><span class="line">        -gencode arch=compute_52,code=sm_52 \</span><br><span class="line">        -gencode arch=compute_60,code=sm_60 \</span><br><span class="line">        -gencode arch=compute_61,code=sm_61 \</span><br><span class="line">        -gencode arch=compute_61,code=compute_61</span><br></pre></td></tr></table></figure>
<p>更改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CUDA_ARCH := -gencode arch=compute_53,code=sm_53</span><br></pre></td></tr></table></figure>
<p>这里的后缀数字53是TX1的计算能力，在其他平台上编译CAFFE也是同样的道理，要把计算能力改成对应的值，否则有可能会报错。关于计算能力如何确定，CUDA例程里面有测试程序，跑一下就可以输出GPU性能指标。</p>
<p>声明下面这两行路径，保存后退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INCLUDE_DIRS := $(PYTHON_INCLUDE) /usr/local/include /usr/include/hdf5/serial</span><br><span class="line">LIBRARY_DIRS := $(PYTHON_LIB) /usr/local/lib /usr/lib /usr/lib/aarch64-linux-gnu/hdf5/serial</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make -j4</span><br></pre></td></tr></table></figure>
<p>完成后在build/lib目录下会出现库文件libcaffe.so。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make all -j4</span><br><span class="line">$ make runtest -j4</span><br><span class="line">$ make pycaffe -j4</span><br></pre></td></tr></table></figure>

<p>5.编译opencv用户库<br>这个库是CAFFE所必需的。而且只能在目标板上编译。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~/tegra_multimedia_api/samples/11_camera_object_identification/opencv_consumer_lib</span><br></pre></td></tr></table></figure>
<p>检查并确保正确设置makefile以下变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CUDA_DIR:=/usr/local/cuda</span><br><span class="line">CAFFE_DIR:=$HOME/Work/caffe/caffe-master</span><br></pre></td></tr></table></figure>
<p>编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ make</span><br></pre></td></tr></table></figure>
<p>完成后当前目录下会出现库文件 libopencv_consumer.so</p>
<ol start="6">
<li>通过下面的命令下载CAFFE模型二进制文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install python-pip</span><br><span class="line">$ sudo pip install pyyaml</span><br><span class="line">$ cd $HOME/Work/caffe/caffe-master</span><br><span class="line">$ ./scripts/download_model_binary.py models/bvlc_reference_caffenet/</span><br></pre></td></tr></table></figure>
用下面的命令获得ImageNet标签文件：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./data/ilsvrc12/get_ilsvrc_aux.sh</span><br></pre></td></tr></table></figure></li>
<li>使用下列命令生成和运行示例：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~/tegra_multimedia_api/samples/11_camera_object_identification</span><br><span class="line">$ export TEGRA_ARMABI=aarch64-linux-gnu</span><br><span class="line">$ export DISPLAY=:0</span><br><span class="line">$ make</span><br><span class="line">$ export LD_LIBRARY_PATH=$HOME/Work/caffe/caffe-master/build/lib:/usr/local/cuda/lib64</span><br><span class="line">$ ./camera_caffe -width 1920 -height 1080 \</span><br><span class="line">        -lib opencv_consumer_lib/libopencv_consumer.so \</span><br><span class="line">        -model $HOME/Work/caffe/caffe-master/models/bvlc_reference_caffenet/deploy.prototxt \</span><br><span class="line">        -trained $HOME/Work/caffe/caffe-master/models/bvlc_reference_caffenet/bvlc_reference_caffenet.caffemodel \</span><br><span class="line">        -mean $HOME/Work/caffe/caffe-master/data/ilsvrc12/imagenet_mean.binaryproto \</span><br><span class="line">        -label $HOME/Work/caffe/caffe-master/data/ilsvrc12/synset_words.txt</span><br></pre></td></tr></table></figure>
8、环境变量设置</li>
<li>在终端执行如下指令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li>在最后一行添加caffe的python路径<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export PYTHONPATH=$HOME/Work/caffe/caffe-master/python:$PYTHONPATH</span><br></pre></td></tr></table></figure>
然后加上之前声明的环境变量，这样就不用每次make或者运行的时候再次声明环境变量了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export TEGRA_ARMABI=aarch64-linux-gnu</span><br><span class="line">export DISPLAY=:0</span><br><span class="line">export LD_LIBRARY_PATH=$HOME/Work/caffe/caffe-master/build/lib:/usr/local/cuda/lib64</span><br></pre></td></tr></table></figure></li>
<li>source环境变量，在终端执行如下命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>CAFFE</tag>
      </tags>
  </entry>
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之四：Nsight Eclipse Edition进阶</title>
    <url>/folder/2019/11/08/2017-10-01-tx-4/</url>
    <content><![CDATA[<hr>
<ul>
<li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li>
<li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li>
<li><strong>嵌入式系统：Ubuntu16.04</strong></li>
<li><strong>虚拟机系统：Ubuntu14.04</strong></li>
<li><strong>编者: WordZzzz</strong></li>
</ul>
<hr>
<p>&#160;&#160;&#160;&#160;上一篇博文简单介绍了如何使用Nsight Eclipse Edition来导入CUDA例程并构建应用程序到NVIDIA Jetson TX1开发板上。本篇博文将继续介绍Nsight Eclipse Edition的进阶使用，通过OpenCV测试程序和GStreamer测试程序，分别介绍如何添加库链接和库路径到工程文件中，全是干货。友情提示，记得打开开发板并接入到局域网哦~</p>
<p><strong><font color="black" size=5 face="仿宋">1.  OpenCV测试程序</font></strong></p>
<p>&#160;&#160;&#160;&#160;JetPack3.0为TX1预装的OpenCV版本为OpenCV2.4.13，环境变量都已配置好，所以我们无需在开发套件上进行任何操作。</p>
<p>1.新建CUDA C++工程，如下图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604153758615?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>2.填入工程名称，工程类型为空工程，工具链为CUDA Toolkit 8.0，单击Next：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604154103462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>3.基础设置，这里我们之前已经说过了，对于TX1，全部选5.3。当然按默认的2.0一般也不会报错：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604154321262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500" /></div>
<p></p>

<p>4.目标系统，默认的是主机。如果你之前设置过，这次你只需要单击下拉条就会出现之前的设置，选中就好。我在这里还是重复一遍操作吧，单击Manage：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604154558719?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>5.上一步骤之后出现远程连接对话框，填入开发板IP地址和用户名，其他的默认就好，然后单击Finish退出：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604154853351?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="450" /></div>
<p></p>

<p>6.把Local System关掉，然后选择远程连接的工程路径、工具箱路径和CPU类型地，选完后单击Finish。7、8、9会分别对这三项进行详细说明：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604155215776?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>7.Project Path：在步骤6中单击Project Path后面的Browse，出现下图所示对话框，里面显示的是远程连接的开发套件的文件目录，可以进行简单的新建删除等功能。这里我们选择好自己的工程路径。中间可能会出现链接提示，有时还会让你填写TX1的密码，大家乖乖填上就好：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604155631075?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>8.Toolkit：在步骤6中单击Tookit后面的Manage，弹出下图所示对话框，第一次打开的话里面的Toolkit path 是空的。我们不需要自己去找工具箱的路径，只需要单击Detect，系统就会帮我们自动填写上工具箱路径。中间可能会出现链接提示，有时还会让你填写TX1的密码，大家乖乖填上就好：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604161321037?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>9.CPU Architecture：下拉菜单中有很多类型，我们的TX1对应的是AArch64：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604161207942?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="400" height="200" /></div>
<p></p>

<p>10.对新建的工程添加源文件：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604161538150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>11.因为我们例程用的是OpenCV的hpp头文件，所以源文件最好也写成C++的源文件。填入文件名，选择默认的C++源文件模板：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604162124259?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400" /></div>
<p></p>

<p>12.测试代码如下：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604162232987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="300" /></div>
<p></p>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * test_opencv.cpp</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jun 3, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        cv::Mat img(512, 512, CV_8UC3, cv::Scalar(0));</span><br><span class="line"></span><br><span class="line">        cv::putText(img,</span><br><span class="line">                &quot;Hello, OpenCV on Jetson!&quot;,</span><br><span class="line">                cv::Point(10, img.rows / 2),</span><br><span class="line">                cv::FONT_HERSHEY_DUPLEX,</span><br><span class="line">                1.0,</span><br><span class="line">                CV_RGB(118, 185, 0),</span><br><span class="line">                2);</span><br><span class="line">        cv::imshow(&quot;Hello!&quot;, img);</span><br><span class="line">        cv::waitKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>13.查看库链接。前面已经说到，JetPack3.0已经预装了OpenCV2.4.13，各种环境变量都已设置好，具体信息我们可以通过如下命令在TX1上进行查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pkg-config --cflags --libs opencv</span><br></pre></td></tr></table></figure>
<p>&#160;&#160;&#160;&#160;查看结果如下图所示：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604162731793?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="80" /></div>
<p></p>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ubuntu@tegra-ubuntu:~$ pkg-config --cflags --libs opencv</span><br><span class="line">-I/usr/include/opencv -L/usr/local/cuda-8.0/lib64 -lopencv_calib3d -lopencv_contrib -lopencv_core -lopencv_features2d -lopencv_flann -lopencv_gpu -lopencv_highgui -lopencv_imgproc -lopencv_legacy -lopencv_ml -lopencv_objdetect -lopencv_photo -lopencv_stitching -lopencv_superres -lopencv_ts -lopencv_video -lopencv_videostab -lopencv_detection_based_tracker -lopencv_esm_panorama -lopencv_facedetect -lopencv_imuvstab -lopencv_tegra -lopencv_vstab -lcufft -lnpps -lnppi -lnppc -lcudart -latomic -ltbb -lrt -lpthread -lm -ldl</span><br></pre></td></tr></table></figure>

<p>14.打开性能设置，即在工程右键，然后选择Properties：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604163304172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600" /></div>
<p></p>

<p>15.重点来了：添加库链接。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604165804309?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="450" /></div>
<p></p>


<p><font color="red">&#160;&#160;&#160;&#160;如果你在第12步直接构建上述代码，肯定会出错，因为我们现在所有的设置，都是在为我们的工程文件编写编译命令。熟悉g++/gcc的朋友们可能会有印象，就是我们直接用g++/gcc编译文件的时候，如果用到哪个链接库，一般都是在后面加上-l这种链接的，否则会找不到相应的库链接。</font></p>
<p>16.经过上述步骤后再CTR+B进行构建，我们可以看到构建命令包括了我们添加的库链接，没有报错表明构建成功：</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604171314582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="250" /></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604170640220?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="100" /></div>
<p></p>


<p><strong><font color="black" size=5 face="仿宋">2.  Gstreamer测试程序</font></strong></p>
<p>1.新建项目，过程不再赘述，然后添加源文件，这次我们用C模板，而不是C++。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * basic-tutorial-1.c</span><br><span class="line"> *</span><br><span class="line"> *  Created on: Jun 1, 2017</span><br><span class="line"> *      Author: wordzzzz</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;gst/gst.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">  GstElement *pipeline;</span><br><span class="line">  GstBus *bus;</span><br><span class="line">  GstMessage *msg;</span><br><span class="line"></span><br><span class="line">  /* Initialize GStreamer */</span><br><span class="line">  gst_init (&amp;argc, &amp;argv);</span><br><span class="line"></span><br><span class="line">  /* Build the pipeline */</span><br><span class="line">  pipeline = gst_parse_launch (&quot;playbin uri=https://www.freedesktop.org/software/gstreamer-sdk/data/media/sintel_trailer-480p.webm&quot;, NULL);</span><br><span class="line"></span><br><span class="line">  /* Start playing */</span><br><span class="line">  gst_element_set_state (pipeline, GST_STATE_PLAYING);</span><br><span class="line"></span><br><span class="line">  /* Wait until error or EOS */</span><br><span class="line">  bus = gst_element_get_bus (pipeline);</span><br><span class="line">  msg = gst_bus_timed_pop_filtered (bus, GST_CLOCK_TIME_NONE, GST_MESSAGE_ERROR | GST_MESSAGE_EOS);</span><br><span class="line"></span><br><span class="line">  /* Free resources */</span><br><span class="line">  if (msg != NULL)</span><br><span class="line">    gst_message_unref (msg);</span><br><span class="line">  gst_object_unref (bus);</span><br><span class="line">  gst_element_set_state (pipeline, GST_STATE_NULL);</span><br><span class="line">  gst_object_unref (pipeline);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>2.添加头文件路径和库链接：此处比OpenCV多了头文件路径的添加，因为gstremer-1.0的头文件路径貌似没有加入到环境变量中。</p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604172555604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500" /></div>
<p></p>

<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604173708168?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500" /></div>
<p></p>

<p><font color="red">&#160;&#160;&#160;&#160;上图中添加的路径，切记是TX1上的路径，而不是虚拟机里的路径。之前用过QT进行过交叉编译，感觉被洗脑了。Nsight的构建，是通过你的设置产生的编译命令，直接在TX1上进行编译的，而不是先生成在虚拟机里再拷贝到TX1上。所以你只要保证你添加的头文件路径和库路径能在TX1上找到就行，没必要把TX1上的库都拷过来，这样反而会出错。</font></p>
<p></p>
<div align=center><img src="http://img.blog.csdn.net/20170604172613325?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500" /></div>
<p></p>

<p>3.CTRL+B构建后在TX1上运行，会有视频播放出来。</p>
<p><strong><font color="red" size=3 face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p>
<p><strong><font color="red" size=3 face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>
]]></content>
      <categories>
        <category>TX1</category>
      </categories>
      <tags>
        <tag>TX1</tag>
        <tag>Nsight</tag>
      </tags>
  </entry>
  <entry>
    <title>2016-11-10-Objective-C Runtime详解</title>
    <url>/folder/2019/11/08/2016-11-10-Objective-C%20Runtime%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<hr>
<p>layout:     post<br>title:      Objective-C Runtime 详解<br>subtitle:   Runtime 详解<br>date:       2017-02-04<br>author:     BY<br>header-img: img/post-bg-ios9-web.jpg<br>catalog: true<br>tags:<br>    - Obj-C<br>    - Runtime<br>    - iOS</p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>最近在学习Runtime的知识，恰巧发现了这篇博客<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">《Objective-C Runtime》</a>，在此基础上，进行了些许补充说明,如有错误或其他想法，欢迎提出交流。</p>
</blockquote>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>引言</li>
<li>简介</li>
<li>与Runtime交互</li>
<li>RunTime术语</li>
<li>消息</li>
<li>动态方法解析</li>
<li>消息转发</li>
<li>健壮的实例变量</li>
<li>动态添加属性(Object-C Associated Objects)</li>
<li>方法调剂（Method Swizzling）</li>
<li>总结</li>
</ul>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>Objective-C的方法调用实则为“发送消息”,我们来看<code>[dog eat]</code>实际会被编译器转化为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_msgSend(dog, SEL)//SEL为eat方法的标识符@selector(@&quot;eat&quot;)</span><br></pre></td></tr></table></figure>

<p>若方法中函数参数，则为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc_msgSend(dog, SEL, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p>如果消息的接收者能够找到对应的方法，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个方法对应的实现内容，要么就干脆就crash掉。</p>
<p>现在可以看出<code>[dog eat]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>eat</code>这条消息，而<code>dog</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p>
<p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。</p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。</p>
<p>Runtime其实有两个版本:“modern”和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统，只能运行在 iOS 和 OS X 10.5 之后的64位程序中。而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p>
<p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。</p>
<h3 id="与Runtime交互"><a href="#与Runtime交互" class="headerlink" title="与Runtime交互"></a>与Runtime交互</h3><p>Objc 从<code>三种</code>不同的层级上与 Runtime 系统进行交互，分别是通过 <code>Objective-C 源代码</code>，通过 Foundation 框架的<code>NSObject类定义的方法</code>，通过对 <code>runtime 函数</code>的直接调用。</p>
<h4 id="Objective-C源代码"><a href="#Objective-C源代码" class="headerlink" title="Objective-C源代码"></a>Objective-C源代码</h4><p>大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。<br>还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中的类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如<code>objc_msgSend</code>函数及其参数列表中的<code>id</code>和<code>SEL</code>都是啥）</p>
<h4 id="NSObject的方法"><a href="#NSObject的方法" class="headerlink" title="NSObject的方法"></a>NSObject的方法</h4><p>Cocoa 中大多数类都继承于<code>NSObject</code>类，也就自然继承了它的方法。最特殊的例外是<code>NSProxy</code>，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活儿都交给幕后小弟去干。</p>
<p>有的<code>NSObject</code>中的方法起到了抽象接口的作用，比如<code>description</code>方法需要你重载它并为你定义的类提供描述内容。<code>NSObject</code>还有些方法能在运行时获得类的信息，并检查一些特性，比如<code>class</code>返回对象的类；<code>isKindOfClass</code>:和<code>isMemberOfClass:</code>则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code>检查对象能否响应指定的消息；<code>conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code>则返回指定方法实现的地址。</p>
<h4 id="Runtime的函数"><a href="#Runtime的函数" class="headerlink" title="Runtime的函数"></a>Runtime的函数</h4><p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了<code>NSObject</code>类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在<a href="https://developer.apple.com/reference/objectivec/1657527-objective_c_runtime" target="_blank" rel="noopener">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档。</p>
<h3 id="Runtime术语"><a href="#Runtime术语" class="headerlink" title="Runtime术语"></a>Runtime术语</h3><p>还记得引言中的<code>objc_msgSend:</code>方法吧，它的真身是这样的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id objc_msgSend ( id self, SEL op, ... );</span><br></pre></td></tr></table></figure>
<p>下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。</p>
<h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是<code>Selector</code>类）。<code>selector</code>是方法选择器，可以理解为区分方法的标识，而这个标识的数据结构是SEL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_selector *SEL;</span><br></pre></td></tr></table></figure>

<p>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。这个查找过程我们将在下面讨论。</p>
<p>我们可以在运行时添加新的selector，也可以在运行时获取已存在的selector，我们可以通过下面三种方法来获取SEL:</p>
<ol>
<li><p>sel_registerName函数</p>
</li>
<li><p>Objective-C编译器提供的@selector()</p>
</li>
<li><p>NSSelectorFromString()方法</p>
</li>
</ol>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p><code>objc_msgSend</code>第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_object *id;</span><br></pre></td></tr></table></figure>

<p>那<code>objc_object</code>又是啥呢：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_object &#123; Class isa; &#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_object</code>结构体包含一个<code>isa</code>指针，根据<code>isa</code>指针就可以顺藤摸瓜找到对象所属的类。</p>
<p>PS:<code>isa</code>指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用<code>class</code>方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 <strong>isa-swizzling</strong> 的技术，详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/KeyValueObserving/Articles/KVOImplementation.html#//apple_ref/doc/uid/20002307-BAJEAIEE" target="_blank" rel="noopener">官方文档</a>的这句段说明</p>
<blockquote>
<p>Key-Value Observing Implementation Details</p>
</blockquote>
<blockquote>
<p>Automatic key-value observing is implemented using a technique called isa-swizzling.</p>
</blockquote>
<blockquote>
<p>The isa pointer, as the name suggests, points to the object’s class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data.</p>
</blockquote>
<blockquote>
<p>When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance.</p>
</blockquote>
<blockquote>
<p>You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance.</p>
</blockquote>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_class *Class;</span><br></pre></td></tr></table></figure>
<p>而<code>objc_class</code>就是我们摸到的那个瓜，里面的东西多着呢：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议</p>
<p>PS:<code>OBJC2_UNAVAILABLE</code>之类的宏定义是苹果在 Objc 中对系统运行版本进行约束的黑魔法，为的是兼容非Objective-C 2.0的遗留逻辑，但我们仍能从中获得一些有价值的信息，有兴趣的可以查看源代码</p>
<p><code>Objective-C 2.0</code> 的头文件虽然没暴露出<code>objc_class</code>结构体更详细的设计，我们依然可以从<code>Objective-C 1.0</code> 的定义中小窥端倪</p>
<p>在<code>objc_class</code>结构体中：<code>ivars</code>是<code>objc_ivar_list</code>指针；<code>methodLists</code>是指向<code>objc_method_list</code>指针的指针。也就是说可以动态修改<code>*methodLists</code>的值来添加成员方法，这也是Category实现的原理，同样解释了Category不能添加属性的原因。而最新版的 Runtime 源码对这一块的描述已经有很大变化，可以参考下美团技术团队的<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a>.</p>
<p>PS：任性的话可以在Category中添加<code>@dynamic</code>的属性，并利用运行期动态提供存取方法或干脆动态转发；或者干脆使用关联度对象（AssociatedObject）</p>
<p>其中<code>objc_ivar_list</code>和<code>objc_method_list</code>分别是成员变量列表和方法列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_ivar_list &#123;</span><br><span class="line">    int ivar_count                                           OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">struct objc_method_list &#123;</span><br><span class="line">    struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;</span><br><span class="line"></span><br><span class="line">    int method_count                                         OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">    /* variable length structure */</span><br><span class="line">    struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你C语言不是特别好，可以理解为<code>objc_ivar_list</code>结构体存储着<code>objc_ivar</code>数组列表，而<code>objc_ivar</code>结构体存储了类的单个成员变量的信息；同理<code>objc_method_list</code>结构体存储着<code>objc_method</code>数组列表，而o<code>bjc_method</code>结构体存储了类的某个方法的信息。</p>
<p>最后要提到的还有一个<code>objc_cache</code>，顾名思义它是缓存，它在<code>objc_class</code>的作用很重要，在后面会讲到。</p>
<p>不知道你是否注意到了<code>objc_class</code>中也有一个<code>isa</code>对象，这是因为一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p>
<p><img src="http://7ni3rk.com1.z0.glb.clouddn.com/Runtime/class-diagram.jpg" alt=""></p>
<p>上图实线是 <code>super_class</code> 指针，虚线是<code>isa</code>指针。 有趣的是根元类的超类是<code>NSObjec</code>t，而<code>isa</code>指向了自己，而<code>NSObject</code>的超类为<code>nil</code>，也就是它没有超类</p>
<p>####Method</p>
<p><code>Method</code>是一种代表类中的某个方法的类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_method *Method;</span><br></pre></td></tr></table></figure>
<p>而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_method &#123;</span><br><span class="line">    SEL method_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *method_types                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp                                           OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法名 <code>method_name</code> 类型为 <code>SEL</code>, 相同名字的方法即使在不同类中定义，它们的方法选择器也相同。</li>
<li>方法类型<code>method_types</code>是个<code>char</code>指针，存储着方法的 参数类型 和 返回值 类型。</li>
<li><code>method_imp</code>指向了方法的实现，本质上是一个函数指针，后面会详细讲到。</li>
</ul>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>Ivar是一种代表类中实例变量的类型。定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_ivar *Ivar;</span><br></pre></td></tr></table></figure>
<p>它是一个指向objc_ivar结构体的指针，结构体有如下定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>这里我们注意第三个成员 <code>ivar_offset</code>。它表示基地址偏移字节。</p>
<p>在编译我们的类时，编译器生成了一个 <code>ivar</code> 布局，显示了在类中从哪可以访问我们的 <code>ivars</code> 。</p>
<p>我们对 ivar 的访问就可以通过 <code>对象地址</code> ＋ <code>ivar偏移字节</code>的方法。</p>
<p>但是当我们增加了父类的<code>ivar</code>，这个时候布局就出错了，我们就不得不重新编译子类来恢复兼容性。</p>
<p>而Objective－C Runtime中使用了<code>Non Fragile ivars</code>来避免这个问题</p>
<p>使用<code>Non Fragile ivars</code>时，Runtime会进行检测来调整类中新增的<code>ivar</code>的偏移量。 这样我们就可以通过 <code>对象地址 ＋ 基类大小 + ivar偏移字节</code>的方法来计算出<code>ivar</code>相应的地址，并访问到相应的<code>ivar</code>。</p>
<p>可以根据实例查找其在类中的名字，也就是“反射”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-(NSString *)nameWithInstance:(id)instance &#123;</span><br><span class="line">    unsigned int numIvars = 0;</span><br><span class="line">    NSString *key=nil;</span><br><span class="line">    Ivar * ivars = class_copyIvarList([self class], &amp;numIvars);</span><br><span class="line">    for(int i = 0; i &lt; numIvars; i++) &#123;</span><br><span class="line">        Ivar thisIvar = ivars[i];</span><br><span class="line">        const char *type = ivar_getTypeEncoding(thisIvar);</span><br><span class="line">        NSString *stringType =  [NSString stringWithCString:type encoding:NSUTF8StringEncoding];</span><br><span class="line">        if (![stringType hasPrefix:@&quot;@&quot;]) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((object_getIvar(self, thisIvar) == instance)) &#123;//此处若 crash 不要慌！</span><br><span class="line">            key = [NSString stringWithUTF8String:ivar_getName(thisIvar)];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(ivars);</span><br><span class="line">    return key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>class_copyIvarList</code> 函数获取的不仅有实例变量，还有属性。但会在原本的属性名前加上一个下划线。(属性的本质就是 <code>_属性名+set+get方法</code>)</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p><code>IMP</code>在<code>objc.h</code>中的定义是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef id (*IMP)(id, SEL, ...);</span><br></pre></td></tr></table></figure>
<p>它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/" target="_blank" rel="noopener">函数指针</a>，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。</p>
<p>我们再来看看objc_msgSend()的定义：<code>id objc_msgSend(id self, SEL op, ...)</code></p>
<p>你会发现<code>IMP</code>指向的方法与<code>objc_msgSend</code>函数类型相同，参数都包含id和SEL类型。每个方法名都对应一个SEL类型的方法选择器，而每个实例对象中的<code>SEL</code>对应的方法实现肯定是唯一的，通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址。</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>在<code>runtime.h</code>中Cache的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_cache *Cache</span><br></pre></td></tr></table></figure>
<p>还记得之前 <code>objc_class</code> 结构体中有一个 <code>struct objc_cache *cache</code> 吧，它到底是缓存啥的呢，先看看 <code>objc_cache</code> 的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_cache &#123;</span><br><span class="line">    unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;</span><br><span class="line">    unsigned int occupied                                    OBJC2_UNAVAILABLE;</span><br><span class="line">    Method buckets[1]                                        OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>objc_cache</code> 的定义看起来很简单，它包含了下面三个变量：</p>
<ul>
<li><code>mask</code>:可以认为是当前能达到的最大index（从0开始的），所以缓存的size（total）是mask+1</li>
<li><code>occupied</code>:被占用的槽位，因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</li>
<li><code>buckets</code>:用数组表示的hash表，cache_entry类型，每一个cache_entry代表一个方法缓存</li>
</ul>
<p>(buckets定义在objc_cache的最后，说明这是一个可变长度的数组)</p>
<p><code>Cache</code>为方法调用的性能进行优化,下面我们来看看<code>objc_msgSend</code>具体又是如何分发的呢？ 我们来看下runtime层<code>objc_msgSend</code>的源码。</p>
<p>在<code>objc-msg-arm.s</code>中，<code>objc_msgSend</code>的代码如下：</p>
<p>ps：Apple为了高度优化objc_msgSend的性能，这个文件是汇编写成的，不过即使我们不懂汇编，详尽的注释也可以让我们一窥其真面目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRY objc_msgSend</span><br><span class="line"># check whether receiver is nil</span><br><span class="line">teq     a1, #0</span><br><span class="line">    beq     LMsgSendNilReceiver</span><br><span class="line"># save registers and load receiver&apos;s class for CacheLookup</span><br><span class="line">stmfd   sp!, &#123;a4,v1&#125;</span><br><span class="line">ldr     v1, [a1, #ISA]</span><br><span class="line"># receiver is non-nil: search the cache</span><br><span class="line">CacheLookup a2, v1, LMsgSendCacheMiss</span><br><span class="line"># cache hit (imp in ip) and CacheLookup returns with nonstret (eq) set, restore registers and call</span><br><span class="line">ldmfd   sp!, &#123;a4,v1&#125;</span><br><span class="line">bx      ip</span><br><span class="line"># cache miss: go search the method lists</span><br><span class="line">LMsgSendCacheMiss:</span><br><span class="line">ldmfd sp!, &#123;a4,v1&#125;</span><br><span class="line">b _objc_msgSend_uncached</span><br><span class="line">LMsgSendNilReceiver:</span><br><span class="line">    mov     a2, #0</span><br><span class="line">    bx      lr</span><br><span class="line">LMsgSendExit:</span><br><span class="line">END_ENTRY objc_msgSend</span><br><span class="line">STATIC_ENTRY objc_msgSend_uncached</span><br><span class="line"># Push stack frame</span><br><span class="line">stmfd sp!, &#123;a1-a4,r7,lr&#125;</span><br><span class="line">add     r7, sp, #16</span><br><span class="line"># Load class and selector</span><br><span class="line">ldr a3, [a1, #ISA] /* class = receiver-&gt;isa  */</span><br><span class="line">/* selector already in a2 */</span><br><span class="line">/* receiver already in a1 */</span><br><span class="line"># Do the lookup</span><br><span class="line">MI_CALL_EXTERNAL(__class_lookupMethodAndLoadCache3)</span><br><span class="line">MOVE    ip, a1</span><br><span class="line"># Prep for forwarding, Pop stack frame and call imp</span><br><span class="line">teq v1, v1 /* set nonstret (eq) */</span><br><span class="line">ldmfd sp!, &#123;a1-a4,r7,lr&#125;</span><br><span class="line">bx ip</span><br></pre></td></tr></table></figure>

<p>如果向更深入了解 <code>objc_cache</code> ,可以看看这篇博文<a href="http://www.cocoachina.com/ios/20150818/13075.html" target="_blank" rel="noopener">深入理解Objective-C：方法缓存</a></p>
<p>从上述代码中可以看到，<code>objc_msgSend</code>（就ARM平台而言）的消息分发分为以下几个步骤：</p>
<ol>
<li>判断receiver是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象</li>
<li>从缓存里寻找，找到了则分发，否则</li>
<li>利用objc-class.mm中_class_lookupMethodAndLoadCache3（为什么有个这么奇怪的方法。本文末尾会解释）方法去寻找selector</li>
<li>如果支持GC，忽略掉非GC环境的方法（retain等）</li>
<li>从本class的method list寻找selector，如果找到，填充到缓存中，并返回selector，否则</li>
<li>寻找父类的method list，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则</li>
<li>调用_class_resolveMethod，如果可以动态resolve为一个selector，不缓存，方法返回，否则</li>
<li>转发这个selector，否则</li>
<li>报错，抛出异常</li>
</ol>
<p>从上面的分析中我们可以看到，当一个方法在比较“上层”的类中，用比较“下层”（继承关系上的上下层）对象去调用的时候，如果没有缓存，那么整个查找链是相当长的。就算方法是在这个类里面，当方法比较多的时候，每次都查找也是费事费力的一件事情。</p>
<p>当我们需要去调用一个方法数十万次甚至更多地时候，查找方法的消耗会变的非常显著。就算我们平常的非大规模调用，<code>除非一个方法只会调用一次，否则缓存都是有用的。</code>在运行时，那么多对象，那么多方法调用，节省下来的时间也是非常可观的。可见缓存的重要性。</p>
<p>方法缓存存在什么地方？</p>
<p>让我们再去去翻看 <code>objc_class</code> 的定义，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_class &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"></span><br><span class="line">#if !__OBJC2__</span><br><span class="line">    Class super_class                                        OBJC2_UNAVAILABLE;</span><br><span class="line">    const char *name                                         OBJC2_UNAVAILABLE;</span><br><span class="line">    long version                                             OBJC2_UNAVAILABLE;</span><br><span class="line">    long info                                                OBJC2_UNAVAILABLE;</span><br><span class="line">    long instance_size                                       OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;</span><br><span class="line">    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>我们看到在类的定义里就有<code>cache</code>字段，没错，类的所有缓存都存在metaclass上，所以每个类都只有一份方法缓存，而不是每一个类的object都保存一份。</p>
<p>子类类即便是从父类取到的方法，也会存在类本身的方法缓存里。而当用一个父类对象去调用那个方法的时候，也会在父类的metaclass里缓存一份。</p>
<h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p><code>@property</code>标记了类中的属性，这个不必多说大家都很熟悉，它是一个指向objc_property结构体的指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct objc_property *Property;</span><br><span class="line">typedef struct objc_property *objc_property_t;//这个更常用</span><br></pre></td></tr></table></figure>

<p>现在在类中声明声明属性和成员变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface ViewController ()</span><br><span class="line">&#123;</span><br><span class="line">    int age;</span><br><span class="line">    NSString *name;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, strong) NSString *property1;</span><br><span class="line">@property (nonatomic, strong) NSString *property2;</span><br><span class="line">@property (nonatomic, assign) int age;//这里的age为属性，对应变量：_age</span><br><span class="line">@property (nonatomic, assign) long ID;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>然后用下面的方法来获取类中属性列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id LenderClass = objc_getClass(&quot;ViewController&quot;);//获取calss</span><br><span class="line">//id LenderClass = [MyViewController class];//同上</span><br><span class="line">unsigned int outCount;//属性数量</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);//获取属性列表</span><br><span class="line">for (int i = 0; i &lt; outCount; i++) &#123;// 遍历</span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    const char *propertyName = property_getName(property);</span><br><span class="line">    const char *propertyAttributes = property_getAttributes(property);</span><br><span class="line">    printf(&quot;propertyName：%s \n&quot;, propertyName);</span><br><span class="line">    printf(&quot;propertyAttributes:%s\n--------\n&quot;, propertyAttributes);//属性名及描述</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">propertyName：property1 </span><br><span class="line">propertyAttributes:T@&quot;NSString&quot;,&amp;,N,V_property1</span><br><span class="line">--------</span><br><span class="line">propertyName：property2 </span><br><span class="line">propertyAttributes:T@&quot;NSString&quot;,&amp;,N,V_property2</span><br><span class="line">--------</span><br><span class="line">propertyName：age </span><br><span class="line">propertyAttributes:Ti,N,V_age</span><br><span class="line">--------</span><br><span class="line">propertyName：ID </span><br><span class="line">propertyAttributes:Tq,N,V_ID</span><br></pre></td></tr></table></figure>


<p>我们再来来看看获取成员变量的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id selfClass = [self class];</span><br><span class="line">unsigned int numIvars = 0;</span><br><span class="line">Ivar *ivars = class_copyIvarList(selfClass, &amp;numIvars);</span><br><span class="line">for(int i = 0; i &lt; numIvars; i++) &#123;</span><br><span class="line">    Ivar ivar = ivars[i];</span><br><span class="line">    const char *ivarType = ivar_getTypeEncoding(ivar);// 获取类型</span><br><span class="line">    const char *ivarName = ivar_getName(ivar);</span><br><span class="line">    printf(&quot;ivarName:%s\n&quot;, ivarName);</span><br><span class="line">    printf(&quot;ivarType:%s\n------\n&quot;, ivarType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ivarName:age</span><br><span class="line">ivarType:i</span><br><span class="line">------</span><br><span class="line">ivarName:name</span><br><span class="line">ivarType:@&quot;NSString&quot;</span><br><span class="line">------</span><br><span class="line">ivarName:_age</span><br><span class="line">ivarType:i</span><br><span class="line">------</span><br><span class="line">ivarName:_property1</span><br><span class="line">ivarType:@&quot;NSString&quot;</span><br><span class="line">------</span><br><span class="line">ivarName:_property2</span><br><span class="line">ivarType:@&quot;NSString&quot;</span><br><span class="line">------</span><br><span class="line">ivarName:_ID</span><br><span class="line">ivarType:q</span><br></pre></td></tr></table></figure>

<p>我们会发现与 <code>class_copyIvarList</code> 函数不同，使用 <code>class_copyPropertyList</code> 函数只能获取类的属性，而不包含成员变量。但此时获取的属性名是不带下划线的,得到属性或者变量名后我们就可以使用KVC去修改访问类中的私有属性或变量。所以OC中没有真正意义上的私有变量，私有方法也是。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>前面做了这么多铺垫，现在终于说到了消息了。Objc 中发送消息是用中括号 <code>[]</code> 把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。</p>
<p>有关消息发送和消息转发机制的原理，可以查看<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">这篇文章</a>。</p>
<h4 id="objc-msgSend函数"><a href="#objc-msgSend函数" class="headerlink" title="objc_msgSend函数"></a>objc_msgSend函数</h4><p>在引言中已经对 <code>objc_msgSend</code> 进行了一点介绍，看起来像是 <code>objc_msgSend</code> 返回了数据，其实 <code>objc_msgSend</code> 从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>
<ol>
<li>检测这个 消息 是不是要忽略的。比如 Mac OS X 开发，在ARC中有了垃圾回收就不理会MRC的 <code>retain</code>, <code>release</code> 这些函数了。</li>
<li>检测这个 目标对象 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code> 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>
<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到NSObject类为止。</li>
<li>如果还找不到就要开始进入动态方法解析了，后面会提到。</li>
</ol>
<p>PS:这里说的分发表其实就是 <code>Class</code> 中的方法列表，它将方法选择器和方法实现地址联系起来。<br><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt=""></p>
<p>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有”Super”的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有<code>”stret”</code>的函数。排列组合正好四个方法</p>
<p>PS：有木有发现这些函数的命名规律哦？带 <code>“Super”</code> 的是消息传递给超类；<code>“stret”</code>可分为<code>“st”</code>+<code>“ret”</code>两部分，分别代表 <code>“struct”</code> 和 <code>“return”</code> ；<code>“fpret”</code>就是 <code>“fp”</code> + <code>“ret”</code>，分别代表<code>“floating-point”</code>和 <code>“return”</code>。</p>
<h4 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h4><p>我们经常在方法中使用 <code>self</code> 关键字来引用实例本身，但从没有想过为什么 <code>self</code> 就能取到调用当前方法的对象吧。其实 <code>self</code> 的内容是在方法运行时被偷偷的动态传入的</p>
<p>当 <code>objc_msgSend</code> 找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:</p>
<ul>
<li>接收消息的对象（也就是<code>self</code>指向的内容）</li>
<li>方法选择器（<code>_cmd</code>指向的内容）</li>
</ul>
<p>之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。在下面的例子中，<code>self</code>引用了接收者对象，而<code>_cmd</code>引用了方法本身的选择器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- strange</span><br><span class="line">&#123;</span><br><span class="line">    id  target = getTheReceiver();</span><br><span class="line">    SEL method = getTheMethod();</span><br><span class="line"> </span><br><span class="line">    if ( target == self || method == _cmd )</span><br><span class="line">        return nil;</span><br><span class="line">    return [target performSelector:method];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这两个参数中，<code>self</code> 更有用。实际上,它是在方法实现中访问消息接收者对象的实例变量的途径</p>
<p>而当方法中的 <code>super</code> 关键字接收到消息时，编译器会创建一个 <code>objc_super</code> 结构体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_super &#123; id receiver; Class class; &#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体指明了消息应该被传递给特定父类的定义。但<code>receiver</code>仍然是<code>self</code>本身，这点需要注意，因为当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的<code>SEL</code>传递给了o<code>bjc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类才能找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver</code>, <code>@selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>
<h4 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h4><p>在 <code>IMP</code> 那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。<br>NSObject类中有个<code>methodForSelector:</code>实例方法，你可以用它来获取某个方法选择器对应的 <code>IMP</code> ，举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void (*imp)(id, SEL, BOOL);//定义一个函数指针</span><br><span class="line">imp = (void (*)(id, SEL, BOOL))[self methodForSelector:@selector(setFilled:)];//获取setFilled:函数的IMP</span><br></pre></td></tr></table></figure>

<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>你可以动态地提供一个方法的实现。例如我们可以用 <code>@dynamic</code> 关键字在类的实现文件中修饰一个属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@dynamic propertyName;</span><br></pre></td></tr></table></figure>
<p>这表明我们会为这个属性提供存取方法，也就是说编译器不会默认为我们生成 <code>setPropertyName:</code>和 <code>prepertyName</code> 方法，而需要我们自己提供动态方法。我们可以通过分别重载 <code>resolveIntanceMethod：</code> 和 <code>resolvrClassMethod:</code> 方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在 <code>Cache</code> 和方法分发表中（包括父类）找不到要执行的方法时，Runtime会调用 <code>resolveIntanceMethod：</code> 和 <code>resolvrClassMethod:</code> 来给我们一次动态添加实现的机会。我们需要 <code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void dynamicMethodIMP(id self, SEL _cmd) &#123;</span><br><span class="line">    // implementation ....</span><br><span class="line">&#125;</span><br><span class="line">@implementation MyClass</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    if (aSEL == @selector(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);</span><br><span class="line">          return YES;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super resolveInstanceMethod:aSEL];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的例子为resolveThisMethodDynamically方法添加了实现内容，也就是dynamicMethodIMP方法中的代码。其中 “v@:” 表示返回值和参数，这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encoding</a></p>
<p>PS：动态方法解析会在消息转发机制浸入前执行。如果 <code>respondsToSelector:</code> 或 <code>instancesRespondToSelector:</code> 方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的 <code>IMP</code> 的机会。如果你想让该方法选择器被传送到转发机制，那么就让<code>resolveInstanceMethod:</code> 返回 <code>NO</code> 。</p>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code> 方法替换消息的接受者为其他对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if(aSelector == @selector(mysteriousMethod:))&#123;</span><br><span class="line">        return alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，不过千万别返回<code>self</code>，因为那样会死循环</p>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>当动态方法解析不作处理返回NO时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    if ([someOtherObject respondsToSelector:</span><br><span class="line">            [anInvocation selector]])</span><br><span class="line">        [anInvocation invokeWithTarget:someOtherObject];</span><br><span class="line">    else</span><br><span class="line">        [super forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该消息的唯一参数是个<code>NSInvocation</code>类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现<code>forwardInvocation:</code>方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>
<p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过 <code>forwardInvocation:</code> 消息通知该对象。每个对象都从NSObject类中继承了 <code>forwardInvocation:</code> 方法。然而，NSObject中的方法实现只是简单地调用了 <code>doesNotRecognizeSelector:</code> 。通过实现我们自己的 <code>forwardInvocation:</code> 方法，我们可以在该方法实现中将消息转发给其它对象。</p>
<p><code>forwardInvocation:</code> 方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的”吃掉“某些消息，因此没有响应也没有错误。<code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>
<p>注意： <code>forwardInvocation:</code> 方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将negotiate消息转发给其它对象，则这个对象不能有<code>negotiate</code>方法。否则，<code>forwardInvocation:</code>将不可能会被调用。</p>
<h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。</p>
<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt=""></p>
<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中 <code>Warrior</code> 和 <code>Diplomat</code> 没有继承关系，但是 <code>Warrior</code> 将<code>negotiate</code> 消息转发给了 <code>Diplomat</code> 后，就好似 <code>Diplomat</code> 是 <code>Warrior</code> 的超类一样。<br>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的</p>
<h4 id="替代者对象-Surrogate-Objects"><a href="#替代者对象-Surrogate-Objects" class="headerlink" title="替代者对象(Surrogate Objects)"></a>替代者对象(Surrogate Objects)</h4><p>转发不仅能模拟多继承，也能使轻量级对象代表重量级对象。弱小的女人背后是强大的男人，毕竟女人遇到难题都把它们转发给男人来做了。这里有一些适用案例，可以参看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11" target="_blank" rel="noopener">官方文档</a>。</p>
<h4 id="转发于继承"><a href="#转发于继承" class="headerlink" title="转发于继承"></a>转发于继承</h4><p>尽管转发很像继承，但是NSObject类不会将两者混淆。像 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个 <code>Warrior</code> 对象如果被问到是否能响应 <code>negotiate</code> 消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ( [aWarrior respondsToSelector:@selector(negotiate)] )</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>结果是 <code>NO</code> ，尽管它能够接受 <code>negotiate</code> 消息而不报错，因为它靠转发消息给 <code>Diplomat</code> 类来响应消息。</p>
<p>如果你为了某些意图偏要“弄虚作假”让别人以为<code>Warrior</code> 继承到了 <code>Diplomat</code> 的 <code>negotiate</code> 方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code> 来加入你的转发算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    if ( [super respondsToSelector:aSelector] )</span><br><span class="line">        return YES;</span><br><span class="line">    else &#123;</span><br><span class="line">        /* Here, test whether the aSelector message can     *</span><br><span class="line">         * be forwarded to another object and whether that  *</span><br><span class="line">         * object can respond to it. Return YES if it can.  */</span><br><span class="line">    &#125;</span><br><span class="line">    return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了<code>respondsToSelector:</code>和 <code>isKindOfClass:</code>之外，<code>instancesRespondToSelector:</code>中也应该写一份转发算法。如果使用了协议，<code>conformsToProtocol:</code>同样也要加入到这一行列中。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个<code>methodSignatureForSelector:</code>来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现<code>methodSignatureForSelector:</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">    NSMethodSignature* signature = [super methodSignatureForSelector:selector];</span><br><span class="line">    if (!signature) &#123;</span><br><span class="line">       signature = [surrogate methodSignatureForSelector:selector];</span><br><span class="line">    &#125;</span><br><span class="line">    return signature;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="健壮的实例变量-Non-Fragile-ivars"><a href="#健壮的实例变量-Non-Fragile-ivars" class="headerlink" title="健壮的实例变量(Non Fragile ivars)"></a>健壮的实例变量(Non Fragile ivars)</h3><p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部地址开始，实例变量依次根据自己所占空间而产生位移：</p>
<p>再翻出Ivar的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct objc_ivar &#123;</span><br><span class="line">    char *ivar_name                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    char *ivar_type                                          OBJC2_UNAVAILABLE;</span><br><span class="line">    int ivar_offset                                          OBJC2_UNAVAILABLE;</span><br><span class="line">#ifdef __LP64__</span><br><span class="line">    int space                                                OBJC2_UNAVAILABLE;</span><br><span class="line">#endif</span><br><span class="line">&#125;                                                            OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p><code>ivar</code> 的访问可以通过 <code>对象地址</code> ＋ <code>ivar偏移字节(ivar_offset)</code>的方法。</p>
<p>当我们增加了父类的<code>ivar</code>，这个时候布局就出错了，我们就不得不重新编译子类来恢复兼容性。</p>
<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了</p>
<p>需要注意的是在健壮的实例变量下，不要使用 <code>sizeof(SomeClass)</code>，而是用 <code>class_getInstanceSize([SomeClass class])</code> 代替；也不要使用 <code>offsetof(SomeClass, SomeIvar)</code> ，而要用 <code>ivar_getOffset(class_getInstanceVariable([SomeClass class], &quot;SomeIvar&quot;))</code> 来代替。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 定义一个Student类 */</span><br><span class="line">@interface Student : NSObject</span><br><span class="line">&#123;</span><br><span class="line">@private</span><br><span class="line">    int age;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Student</span><br><span class="line">// 重写%@输出方法</span><br><span class="line">- (NSString *)description</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;current pointer = %p&quot;, self);</span><br><span class="line">    NSLog(@&quot;age pointer = %p&quot;, &amp;age);</span><br><span class="line">    return [NSString stringWithFormat:@&quot;age = %d&quot;, age];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // insert code here...</span><br><span class="line">        </span><br><span class="line">        Student *student = [[Student alloc] init];</span><br><span class="line">        Ivar age_ivar = class_getInstanceVariable(object_getClass(student), &quot;age&quot;);//获取&quot;age&quot;的ivar</span><br><span class="line">        int *age_pointer = (int *)((__bridge void *)(student) + ivar_getOffset(age_ivar));//定义一个指向age_ivar的指针：指向地址为 student对象地址 + age_ivar的偏移量（ivar_offset）</span><br><span class="line">        NSLog(@&quot;age ivar offset = %td&quot;, ivar_getOffset(age_ivar));//输出offset偏移量</span><br><span class="line">        *age_pointer = 10;//对指针age_pointer指向的变量（age_ivar）赋值</span><br><span class="line">        NSLog(@&quot;%@&quot;, student);//输出重写的description方法</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-11-11 16:22:56.364 Iavr_offset[1501:928608] age ivar offset = 8</span><br><span class="line">2016-11-11 16:22:56.365 Iavr_offset[1501:928608] current pointer = 0x100400170</span><br><span class="line">2016-11-11 16:22:56.365 Iavr_offset[1501:928608] age pointer = 0x100400178</span><br><span class="line">2016-11-11 16:22:56.366 Iavr_offset[1501:928608] age = 10</span><br></pre></td></tr></table></figure>

<p>我们发现<code>age pointer = current pointer + age ivar offset</code></p>
<h3 id="Objective-C-Associated-Objects"><a href="#Objective-C-Associated-Objects" class="headerlink" title="Objective-C Associated Objects"></a>Objective-C Associated Objects</h3><p>在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );</span><br><span class="line">id objc_getAssociatedObject ( id object, const void *key );</span><br><span class="line">void objc_removeAssociatedObjects ( id object );</span><br></pre></td></tr></table></figure>
<p>这些方法以键值对的形式动态地向对象添加、获取或删除关联值。其中关联政策是一组枚举常量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enum &#123;</span><br><span class="line">   OBJC_ASSOCIATION_ASSIGN  = 0,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,</span><br><span class="line">   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,</span><br><span class="line">   OBJC_ASSOCIATION_RETAIN  = 01401,</span><br><span class="line">   OBJC_ASSOCIATION_COPY  = 01403</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些常量对应着引用关联值的政策，也就是 Objc 内存管理的引用计数机制。</p>
<h3 id="Method-Swizzling"><a href="#Method-Swizzling" class="headerlink" title="Method Swizzling"></a>Method Swizzling</h3><p>之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。</p>
<p>这里摘抄一个 NSHipster 的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;objc/runtime.h&gt; </span><br><span class="line"></span><br><span class="line">@implementation UIViewController (Tracking)</span><br><span class="line"></span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = [self class];</span><br><span class="line">        // When swizzling a class method, use the following: </span><br><span class="line">        // Class class = object_getClass((id)self); </span><br><span class="line">        SEL originalSelector = @selector(viewWillAppear:);</span><br><span class="line">        SEL swizzledSelector = @selector(xxx_viewWillAppear:);</span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line">        BOOL didAddMethod =</span><br><span class="line">            class_addMethod(class,</span><br><span class="line">                originalSelector,</span><br><span class="line">                method_getImplementation(swizzledMethod),</span><br><span class="line">                method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        if (didAddMethod) &#123;</span><br><span class="line">            class_replaceMethod(class,</span><br><span class="line">                swizzledSelector,</span><br><span class="line">                method_getImplementation(originalMethod),</span><br><span class="line">                method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">#pragma mark - Method Swizzling </span><br><span class="line">- (void)xxx_viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [self xxx_viewWillAppear:animated];</span><br><span class="line">    NSLog(@&quot;viewWillAppear: %@&quot;, self);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面的代码通过添加一个 <code>Tracking</code> 类别到 <code>UIViewController</code> 类中，将 <code>UIViewController</code> 类的 <code>viewWillAppear:</code> 方法和 <code>Tracking</code> 类别中 <code>xxx_viewWillAppear:</code> 方法的实现相互调换。<code>Swizzling</code> 应该在 <code>+load</code> 方法中实现，因为 <code>+load</code> 是在一个类最开始加载时调用。<code>dispatch_once</code> 是GCD中的一次性方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>
<p>先用 <code>class_addMethod</code> 和 <code>class_replaceMethod</code> 函数将两个方法的实现进行调换，如果类中已经有了 <code>viewWillAppear:</code> 方法的实现，那么就调用 <code>method_exchangeImplementations</code> 函数交换了两个方法的 <code>IMP</code> ，这是苹果提供给我们用于实现 <code>Method Swizzling</code> 的便捷方法。<br>最后 <code>xxx_viewWillAppear:</code> 方法的定义看似是递归调用引发死循环，其实不会的。因为 <code>[self xxx_viewWillAppear:animated]</code> 消息会动态找到 <code>xxx_viewWillAppear:</code> 方法的实现，而它的实现已经被我们与 <code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把 <code>[self xxx_viewWillAppear:animated]</code> 换成 <code>[self viewWillAppear:animated]</code> 反而会引发死循环。<br>看到有人说 <code>+load</code>方法本身就是线程安全的，因为它在程序刚开始就被调用，很少会碰到并发问题，于是 <code>stackoverflow</code> 上也有大神给出了另一个 <code>Method Swizzling</code> 的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)replacementReceiveMessage:(const struct BInstantMessage *)arg1 &#123;</span><br><span class="line">    NSLog(@&quot;arg1 is %@&quot;, arg1);</span><br><span class="line">    [self replacementReceiveMessage:arg1];</span><br><span class="line">&#125;</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    SEL originalSelector = @selector(ReceiveMessage:);</span><br><span class="line">    SEL overrideSelector = @selector(replacementReceiveMessage:);</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(self, originalSelector);</span><br><span class="line">    Method overrideMethod = class_getInstanceMethod(self, overrideSelector);</span><br><span class="line">    if (class_addMethod(self, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) &#123;</span><br><span class="line">            class_replaceMethod(self, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, overrideMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实也就是去掉了<code>dispatch_once</code>的部分罢了。</p>
<p><code>Method Swizzling</code> 的确是一个值得深入研究的话题，<code>Method Swizzling</code> 的最佳实现是什么呢？小弟才疏学浅理解的不深刻，找了几篇不错的资源推荐给大家：</p>
<ul>
<li><a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411" target="_blank" rel="noopener">Objective-C的hook方案（一）: Method Swizzling</a></li>
<li><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="noopener">Method Swizzling</a></li>
<li><a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling" target="_blank" rel="noopener">How do I implement method swizzling?</a></li>
<li><a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c" target="_blank" rel="noopener">What are the Dangers of Method Swizzling in Objective C?</a></li>
<li><a href="https://github.com/rentzsch/jrswizzle" target="_blank" rel="noopener">JRSwizzle</a></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们之所以让自己的类继承 <code>NSObject</code> 不仅仅因为苹果帮我们完成了复杂的内存分配问题，更是因为这使得我们能够用上 Runtime 系统带来的便利。深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 <code>Method Swizzling</code> 等。</p>
<p>参考链接</p>
<ul>
<li>原文：<a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/" target="_blank" rel="noopener">Objective-C Runtime</a></li>
<li>Apple官方文档：<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048" target="_blank" rel="noopener">Objective-C Runtime Programming Guide</a></li>
<li>Apple开源代码：<a href="https://opensource.apple.com/source/objc4/" target="_blank" rel="noopener">Objective-C Runtime源码</a></li>
<li><a href="http://blog.csdn.net/wzzvictory/article/details/8615569" target="_blank" rel="noopener">Objective-C runtime之运行时的基本特点</a></li>
<li><a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html" target="_blank" rel="noopener">Understanding the Objective-C Runtime</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>新站的第一份博客</title>
    <url>/folder/2019/11/08/%E6%96%B0%E7%AB%99%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/folder/2019/11/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>5分钟带你看完 WWDC 2018</title>
    <url>/folder/2018/06/05/2018-06-05-5%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E7%9C%8B%E5%AE%8C-WWDC-2018/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一年一度的 WWDC（苹果全球开发者大会）于北京时间 6月5日 凌晨1点开幕。废话不多说，来看看这次WWDC 都有哪些亮点吧!</p>
<h2 id="iOS-12-和-ARKit-2-0"><a href="#iOS-12-和-ARKit-2-0" class="headerlink" title="iOS 12 和 ARKit 2.0"></a>iOS 12 和 ARKit 2.0</h2><blockquote>
<p>关键词：官方防沉迷最为致命</p>
</blockquote>
<h3 id="iOS-12"><a href="#iOS-12" class="headerlink" title="iOS 12"></a>iOS 12</h3><p>iOS 12 相较于 iOS 11 并没有太多UI上的变动，刚更新完 bate 版本的 iOS 12，完全感觉不到这是个新系统。</p>
<p>iOS 12 主要是对安全和性能的优化，iOS 12 在旧设备上的运行速度比 iOS 11更块，程序加载速度快了一倍。（PS：看来苹果并没有放弃旧设备）</p>
<p><img src="https://cdn.mos.cms.futurecdn.net/RdxhPVv8fAyM6oHsRgF6dH-650-80.png" alt=""></p>
<h3 id="ARKit-2-0"><a href="#ARKit-2-0" class="headerlink" title="ARKit 2.0"></a>ARKit 2.0</h3><p>Apple 与 皮克斯 合作开发了一种用于共享AR内容的新文件格式，新的 AR 格式名为 USDZ。</p>
<p>作为一个含着金苹果出生的新生儿，USDZ 一开始就得到了 Adobe Creative Cloud （包括 Photoshop CC、InDesign CC、Illustrator CC、Dreamweaver CC、Premiere Pro CC）套件的支持。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-10.jpg" alt=""></p>
<p>同时，面向开发者的开发套件 ARKit 则升级到了二代，主要提升了面部跟踪、渲染能力、3D 探测和共享体验等能力。</p>
<p>随后展示了一款名为 Measure 的 App，可使用AR查看物品大小。</p>
<p><img src="https://cdn.mos.cms.futurecdn.net/4tbGCxGUGsH9VwSLsfMDK5-650-80.png" alt=""></p>
<p>最后为了演示新的 AR 能力和效果，苹果请来了乐高的创意总监来捧场。这是一个真实的乐高积木建筑物为基础，最多四个人可以用苹果 AR 应用进行游戏，可以在真实环境中模拟出各种虚拟的形象和建筑。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-9.jpg" alt=""><br><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-11.jpg" alt=""></p>
<h3 id="相册优化"><a href="#相册优化" class="headerlink" title="相册优化"></a>相册优化</h3><p>iOS 12 的相册将大大提升搜索性能，系统不仅会提出搜索建议，还会帮你按主题整理照片。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-13.jpg" alt=""></p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-14.jpg" alt=""></p>
<h3 id="Siri变得更聪明"><a href="#Siri变得更聪明" class="headerlink" title="Siri变得更聪明"></a>Siri变得更聪明</h3><p>iOS 12 中，苹果为 Siri 提供了更加高效的操作，让它可以操作各个应用内部的功能，并且能在锁屏界面建议用户下一步的行动。</p>
<p>苹果还发布了一款名为「Shortcuts」的应用，它允许用户自定义 Siri 搜索指令，支持通过拖拽来快速编辑指令，同时还提供了一个指令库供用户下载现成的命令，就像是为 Siri 打造的 Workflow 自动化工具。</p>
<p><img src="https://cdn.sspai.com/2018-06-04-Artboard.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<p>看到这里，相比熟悉苹果的朋友大概明白了，Siri 的本次改进，很可能是源于它收购的效率神器 Workflow，堪称一个用 Siri 唤醒的 Workflow。</p>
<h3 id="原生应用大更新"><a href="#原生应用大更新" class="headerlink" title="原生应用大更新"></a>原生应用大更新</h3><p>iOS 12 中，不少原生应用都得到了更新。</p>
<ul>
<li>iBooks 更名为 <strong>Apple Books</strong>，采用类似 App Store 的新界面设计。</li>
<li>新闻应用（News）在 iPad 上新添加了侧边栏，方便浏览，也突出策划内容。</li>
<li>语音备忘录现在支持 iCloud 了</li>
<li>股市的界面重构，可以看到股票全天走势，并打通 News 应用，方便看财经新闻；</li>
</ul>
<h3 id="CarPlay-开放了"><a href="#CarPlay-开放了" class="headerlink" title="CarPlay 开放了"></a>CarPlay 开放了</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-21.jpg" alt=""></p>
<p>CarPlay 变得更加开放了，曾经被苹果狠心抛弃的 Google Maps 和 Google 的干儿子地图 Waze，以及来自东方的神秘力量高德地图成为首批 CarPlay 支持的第三方导航，从此“志玲姐姐为您导航”将可以常伴林肯领航者车主左右，中国梦和美国梦一起实现。</p>
<h3 id="防手机沉迷-划重点！"><a href="#防手机沉迷-划重点！" class="headerlink" title="防手机沉迷 - 划重点！"></a>防手机沉迷 - 划重点！</h3><p>本次 iOS 12 的重点就是：<strong>防沉迷！</strong></p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-25.jpg" alt=""></p>
<p>鉴于手机上瘾成为了一个社会议题，今年 Google 和苹果都不约而同地将“防沉迷”加入到了系统更新当中：</p>
<ul>
<li><strong>Do Not Disturb（别吵我）</strong>功能将关掉手机的视觉通知，在夜深人静想起她或梦见她的时候，来了邮件也不会亮屏刺破夜的静谧和黑暗</li>
<li>Deliver Quietly（安静通知）则是将消息推送静默化、不显示在锁屏，也不出声，也不会在 app 右上角标红</li>
<li><strong>Grouped Notifications（分组通知</strong>）可以将某一类型的通知归组，微信群聊消息不再有轰炸的感觉</li>
<li><strong>Reports（应用报告）</strong>可以用周报告的形式，告诉用户用什么应用最多，哪个应用通知最多，每天起床第一个打开的是什么应用等等</li>
<li><strong>App Limits（应用限制</strong>）可以给某个应用规定使用时间，当然这不是强制性的，用户可以突破限制继续“吃鸡”</li>
<li><strong>Allowances（零用钱？）</strong> 是家长限制孩子使用应用的新特性</li>
</ul>
<h3 id="iMessage-和-FeacTime"><a href="#iMessage-和-FeacTime" class="headerlink" title="iMessage 和 FeacTime"></a>iMessage 和 FeacTime</h3><p>Animoji 新增了 4 个新表情（幽灵，考拉，老虎和霸王龙），用户还可以为自己量身定做 Animoji ，并用到各种场景——这就是全新的 Memoji 技术</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-26.jpg" alt=""></p>
<p><img src="https://cdn.sspai.com/2018/06/05/67b6fba3d36bdd7caf09bec94dcb157b.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<p>iOS 版 <strong>FaceTime</strong> 迎来了群聊功能，最多支持 32 人同时聊天，成员可以随时加入或离开聊天。聊天界面用瀑布流的形式呈现，正在说话的成员窗口会自动放大。macOS 版 FaceTime 同样也得到了更新。</p>
<p><img src="https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%202.00.58%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<h2 id="tvOS"><a href="#tvOS" class="headerlink" title="tvOS"></a>tvOS</h2><blockquote>
<p>关键词：优化试听体验</p>
</blockquote>
<p>tvOS 今年的变化比较小，更新主要集中在了影视资源以及细节优化上。</p>
<p>Apple TV 4K 将支持杜比全景声和杜比视界，让你在家里也能获得电影院般的听觉体验。</p>
<p><img src="https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%202.26.21%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<h2 id="watchOS-5"><a href="#watchOS-5" class="headerlink" title="watchOS 5"></a>watchOS 5</h2><blockquote>
<p>关键词：运动进行到底</p>
</blockquote>
<p>随着 Apple Watch 成长的，还有它的操作系统 watchOS，这一次 watchOS 升级到了第五代。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-31.jpg" alt=""></p>
<p>Apple Watch 的功能朝着运动的方向发展，此次 watchOS 5 的更新，也以运动为主。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-35.jpg" alt=""></p>
<p>watchOS 5 的一个小惊喜是让 Apple Watch 成为了对讲机，这个应用名为 Walkie Talkie（对讲机）。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-38.jpg" alt=""></p>
<p>Apple Watch 早就支持了 Apple Pay，不过在通知上，Apple Watch 显然可以做得更多，比如值机和给滴滴师傅付款评分，手表不再只是个通知器，也能做些轻交互。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-51.jpg" alt=""></p>
<p>还有 Apple Watch 可以浏览网页了~</p>
<h2 id="macOS-Mojave"><a href="#macOS-Mojave" class="headerlink" title="macOS Mojave"></a>macOS Mojave</h2><blockquote>
<p>关键词：夜间模式、全新的App Store</p>
</blockquote>
<p><img src="https://cdn.sspai.com/2018-06-04-macOS01.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<p>对于大多数人来说，macOS 更新最大的悬念，是新系统叫什么名字。</p>
<p>答案是：<strong>macOS Mojave</strong>，Mojave 中译名是莫哈韦沙漠，位于在美国加利福尼亚西南，出于洛杉矶和拉斯维加斯之间。</p>
<p>在 Mojave 这版系统中，苹果加入了一套适应暗光环境下使用的夜间主题，并对 Mac App Store 的交互界面进行了重塑，整个系统的改变甚至连库克都称为是苹果的一次 “巨大的跨越”。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-89.jpg" alt=""></p>
<h3 id="夜间模式-动态桌面"><a href="#夜间模式-动态桌面" class="headerlink" title="夜间模式 / 动态桌面"></a>夜间模式 / 动态桌面</h3><p>不少用户会在暗光环境下使用电脑，即便是将屏幕亮度调到最低，也难免会因为白底色为主的主题而感到刺眼。在这次更新中，macOS Mojave 新增加了一套暗色主题，不同于目前将菜单和程序栏调成暗色的选项，新系统上的是一套全局暗色主题，即便是在文件夹、应用里都是以黑色为主色呈现。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-63.jpg" alt=""></p>
<p>另外，系统可根据时间变化对桌面进行自动调整，日间使用时系统为正常主题；夜间使用时系统则自动切换至暗色模式主题。此时，台下的开发者们爆发出了一阵欢呼，大概是这个主题能够提升程序员朋友夜间加班的幸福感吧。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-63.jpg" alt=""></p>
<h3 id="智能分类"><a href="#智能分类" class="headerlink" title="智能分类"></a>智能分类</h3><p>macOS 会跟据文件类型和标签对桌面的文件进行自动分类整理，从此再也不用担心满桌面都是文件了。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-82.jpg" alt=""></p>
<p><img src="https://cdn.sspai.com/2018-06-04-macOS04.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<h3 id="快速查看升级"><a href="#快速查看升级" class="headerlink" title="快速查看升级"></a>快速查看升级</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-92.jpg" alt=""></p>
<p>访达在这次系统上的更新并不多，只是针对图片查看增添了 “图库视图” 功能。通过 “图库视图”，用户可更加便捷快速地浏览到访达文件夹内的图片内容，与此同时功能内部也内置了图片元数据显示窗，用户可以借助数据窗口了解到图片的相关详情，并且可对图片进行快速编辑操作。</p>
<h3 id="截图-录屏操作-类似iOS"><a href="#截图-录屏操作-类似iOS" class="headerlink" title="截图/录屏操作 - 类似iOS"></a>截图/录屏操作 - 类似iOS</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-93.jpg" alt=""></p>
<p>此次 macOS Mojave 加入了 “系统级” 的截屏功能，用户也可以在截屏后对截屏图片进行简单的标记。不过实际上，目前不少社交软件其实都已经具备了截图 + 标记的相关功能，且在体验上也相当不错。</p>
<h3 id="安全权限"><a href="#安全权限" class="headerlink" title="安全权限"></a>安全权限</h3><p>当我们在 iOS 系统上打开刚下载的应用程序时，系统会弹出弹窗，提示是否允许程序访问用户信息和手机硬件。而这次苹果也将相关的安全控制策略从 iOS “搬” 到了 macOS 上，当用户打开某个网址或程序时，系统会弹出 “是否允许访问” 的弹窗以获得用户批准。这也可能是为了呼应最近越发严格的隐私政策。</p>
<h3 id="在-macOS-上运行的几款-iOS-程序"><a href="#在-macOS-上运行的几款-iOS-程序" class="headerlink" title="在 macOS 上运行的几款 iOS 程序"></a>在 macOS 上运行的几款 iOS 程序</h3><p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-84.jpg" alt=""></p>
<p>将 iOS 的应用程序搬到 macOS 上运行是不少玩家曾经有过的想法。此次苹果在新版的 macOS 系统上加入了 iOS 端的新闻、股市、家、语音备忘录四个程序，用户可以在桌面系统上通过这几款应用阅读新闻、控制家庭设备等等。</p>
<p>在发布会的最后，苹果否认了将对 iOS 和 macOS 进行合并的传闻，但考虑到 iOS 平台有非常庞大的应用数量，他们也希望其中的部分应用能来到 macOS。于是苹果在发布会上为大家提前预览了一个准备多年的项目，macOS 将可以使用 iOS 的 UIKit 框架进行开发，以降低开发多平台应用的成本。</p>
<p><img src="https://cdn.sspai.com/2018-06-04-Screen%20Shot%202018-06-05%20at%203.08.05%20AM.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<p>比如这次 macOS Mojave 中新增的 4 款应用——News、股票、语音备忘录、家庭——均采用了这种新技术。</p>
<h3 id="全新的-Mac-App-Store"><a href="#全新的-Mac-App-Store" class="headerlink" title="全新的 Mac App Store"></a>全新的 Mac App Store</h3><p><img src="https://cdn.sspai.com/2018-06-04-macOS09.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p>
<p>在 iOS 11 对 Mac App Store 进行了重新设计后，macOS Mojave 也迎来了全新设计的 Mac App Store。新版拥有与 iOS 上 App Store 类似的发现页，里面能看到每日编辑推荐和一些 App 的使用技巧。进入 App 页面后，你可以看到视频预览和与 iOS 类似的评分系统。为了方便用户评分，新版 macOS 还加入了和 iOS 一样的 App 内打分功能。此外，苹果还宣布包括 Office 365 和 Adobe Lightroom CC 在内的一批重量级 App 将在今年稍后登录 Mac App Store。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>是的，这次的 WWDC 只有软件，没有新的电子设备发布，没有新 iPad Pro、没有 iPhone SE2、没有带八代酷睿的新 MacBook，唯一能和“硬件”沾上边的就是一个新的彩虹表带。</p>
<p><img src="https://images.ifanr.cn/wp-content/uploads/2018/06/WWDC-56.jpg" alt=""></p>
<p>时至今日，苹果生态已经日趋完善了，大概苹果的产品经理们也想不出什么石破天惊的功能让大家 wow 一声了，有的只是细节层面的改进。作为看客和用户，也只能接受这样的现实了。</p>
<p>对了，那个可以四个人一起玩的乐高积木和 AR 应用，倒是可以考虑买来玩一下，不要一边说没有新东西，一边又对新东西视而不见。</p>
<p>对于 iOS 开发者来说，macOS 将可以使用 iOS 的 UIKit 框架进行开发是一个值得关注的点。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.apple.com/videos/play/wwdc2018/101/" target="_blank" rel="noopener">WWDC 2018 Keynote</a></li>
<li><a href="https://www.techradar.com/news/apple-wwdc-2018-keynote" target="_blank" rel="noopener">Apple WWDC 2018: what’s new? All the announcements from the keynote</a></li>
<li><a href="http://www.ifanr.com/1043270" target="_blank" rel="noopener">iOS 加入「防沉迷」，macOS 有了暗色主题，今年的 WWDC 重点都在系统上</a></li>
<li><a href="https://sspai.com/post/44816" target="_blank" rel="noopener">苹果 WWDC 2018：最全总结看这里，不错过任何重点</a></li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode命令行工具管理</title>
    <url>/folder/2018/05/05/2018-05-05-Xcode%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code>xcode-select --install</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/545662-f9031dfcce085f8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/459" alt=""></p>
<h2 id="Xcode版本切换"><a href="#Xcode版本切换" class="headerlink" title="Xcode版本切换"></a>Xcode版本切换</h2><h3 id="显示当前使用的xocde版本"><a href="#显示当前使用的xocde版本" class="headerlink" title="显示当前使用的xocde版本"></a>显示当前使用的xocde版本</h3><pre><code>$ xcode-select --print-path</code></pre><h3 id="选择Xcode中的默认版本"><a href="#选择Xcode中的默认版本" class="headerlink" title="选择Xcode中的默认版本"></a>选择Xcode中的默认版本</h3><pre><code>$ sudo xcode-select -switch /Applications/Xcode.app</code></pre>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>柔术最大的谎言「译」</title>
    <url>/folder/2018/01/04/2018-01-04-%E6%9F%94%E6%9C%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B0%8E%E8%A8%80%E3%80%8C%E8%AF%91%E3%80%8D/</url>
    <content><![CDATA[<blockquote>
<p>译自 <a href="http://www.jiujitsubrotherhood.com/the-biggest-lie-in-jiu-jitsu/" target="_blank" rel="noopener">《THE BIGGEST LIE IN JIU JITSU》</a></p>
</blockquote>
<p><img src="http://mjrnxewya3t1in23ybpwjw59.wpengine.netdna-cdn.com/wp-content/uploads/buchecha-marcus-almeida-roger-gracie.jpg" alt="Marcus&#39;Buchecha&#39;Almeida - 现任IBJJF绝对冠军。这家伙很坚强，相信我！图片由BJJ Pix的William Burkhardt提供  。"></p>
<p>最近我看到了一个让我捧腹的柔术笑话。</p>
<p>“柔术的技术是无敌的！”</p>
<p>你可能不想听听下面的内容，但是作为一名柔术教练，我的工作是与你分享我认为的真理，而不是虚假的谎言。所以在这里与你们分享我的见解：</p>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>技术不是无敌的</li>
<li>我的见解</li>
<li>一个假设</li>
<li>真实的例子</li>
<li>这个神话是从哪里来的？</li>
<li>好消息</li>
<li>如何变得更强</li>
<li>你该怎么做</li>
</ul>
<h2 id="技术不是无敌的"><a href="#技术不是无敌的" class="headerlink" title="技术不是无敌的"></a>技术不是无敌的</h2><p>基础运动能力，特别是力量，对柔术的表现起着巨大的作用，而且往往可以克服技巧。尽管你被告知了卓越的技术并不总是能克服体型和力量优势。但在我看来，力量和技术一样重要。</p>
<h2 id="我的见解"><a href="#我的见解" class="headerlink" title="我的见解"></a>我的见解</h2><p>我练习巴西柔术将近二十年，已经是一个黑带了。我认为自己是一个技术顶尖的柔术运动员，我致力于使自己的技术动作更加高效和精准。</p>
<p>但是这里有个小秘密：有时候，我会利用力量强行完成一个柔术动作。我并不常这样做，但我明白力量对于柔术的重要性，并且它可以更好的帮助我完成动作，我已经认识到这样做是正确的。</p>
<p>我的脑袋中仍然有一种“无力游戏”的想法，那就是我技术非常优秀，以至于我不需要出力就可以降服对手。但我知道这只是我的一个天真的想法。</p>
<p>是的，世界顶尖的柔术运动员毫无疑问都拥有顶尖的柔术技术。但是，他们无一例外都是非常强壮的人。由于先天的遗传和后天科学的训练，这些家伙拥有不可思议的力量和体格。</p>
<p>我的经验得出的这个等式适用与大多数情况：</p>
<blockquote>
<p><strong>运动员A（中等技术 + 上等身体素质） &gt;  运动员B（上等技术 + 下等身体素质）</strong></p>
</blockquote>
<h3 id="一个假设"><a href="#一个假设" class="headerlink" title="一个假设"></a>一个假设</h3><p>我知道你还不相信我，所以我会用一个例子来说明我的观点。让我们来看看使用两个战士 Steve 和 JoJo 的假想情景。</p>
<h4 id="Steve"><a href="#Steve" class="headerlink" title="Steve:"></a>Steve:</h4><p>Steve 5岁开始学习柔术，由马塞洛·加西亚，拉法·门德斯和瑞克森·格雷西执教。它学会了他们所有的技巧，并且吸收了他们所有关于压力，时间和人体力学的智慧。他在接下来的13年里每周训练6天。</p>
<p>18岁，体重200磅的 Steve 击败了所有对手取得了 <a href="https://en.wikipedia.org/wiki/International_Brazilian_Jiu-Jitsu_Federation" target="_blank" rel="noopener">IBJJF（国际巴西柔术联合会</a>）世界锦标赛的棕色带中量级冠军，并且立即被授予黑带。第二年，在对战拥有绝对黑带实力的 Buchecha（开头照片中的人）的决赛中，用了一个飞身十字固在13秒内降服了他。</p>
<h4 id="JoJo："><a href="#JoJo：" class="headerlink" title="JoJo："></a>JoJo：</h4><p>JoJo 是一个10岁的银背大猩猩。他体重400磅。他从未接受过柔术或其他武术的训练。</p>
<h4 id="一决胜负："><a href="#一决胜负：" class="headerlink" title="一决胜负："></a>一决胜负：</h4><p>假设 JoJo 与 Steve 展开一场柔术规则的比赛。</p>
<p>你认为谁会赢得这场比赛？如果你认为 Steve 会用他的“无敌技巧”击败 JoJo，那么你就是妄想。（此外，你可以用 <a href="https://en.wikipedia.org/wiki/Dim_Mak_Records" target="_blank" rel="noopener">点穴</a> 试试~）</p>
<p>JoJo 的<strong>体格</strong>与<strong>力量</strong>优势根本无法用技术来克服。</p>
<p><img src="http://mjrnxewya3t1in23ybpwjw59.wpengine.netdna-cdn.com/wp-content/uploads/gorilla.jpg" alt="你可以知道世界上所有的柔术运动，但是你不会打败JoJo。"></p>
<h3 id="真实的例子"><a href="#真实的例子" class="headerlink" title="真实的例子"></a>真实的例子</h3><p>好吧，上面的例子非常不切实际，根本不会发生。但是，我可以举一些我身边的例子：</p>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1:"></a>例子1:</h4><p>在2013年，我亲眼目睹了世界冠军中，一位黑带女性与体重相同的紫色带男性的比赛，他们在一个开放的垫子上打成一片。这个女人一点机会都没有。她在6分钟内拍垫近十次。</p>
<p>那么现在是因为“女人不擅长柔术”还是因为“男人比女人好”呢？当然不是。这只是一个简单的力量问题。这位男性拥有更高的睾酮水平，因此拥有更强大的结缔组织和更多的肌肉。</p>
<h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2:"></a>例子2:</h4><p>我有一个朋友身高 1.95m，重达 300磅（136kg），是一个前NCAA中后卫球员。同时他也是柔术棕色腰带。他可以（而且经常）很容易地只用一只手臂将我从地面上抬起。当我们滚动时他绝对砸我，这时候基本上我是无能为力的。</p>
<p>这是否因为他的技术比我好？当然不是。我的训练的时间比他更长，训练频率和强度要高得多。这是因为他比我更高，更大，更强壮。</p>
<h4 id="例子3"><a href="#例子3" class="headerlink" title="例子3:"></a>例子3:</h4><p>我的正常体重大约是203磅（92kg）。有时，由于各种原因，包括力量训练计划，肌酸周期或假日过度放纵，可能会高达218甚至220磅。</p>
<p>因为我一直在垫子上呆着，所以我可以敏锐的察觉到体重对于柔术的影响。我可以直接告诉你：你越重，对抗越轻松。我可以更轻松的控制体重较轻的对手，并且能对抗更长的时间。</p>
<h3 id="这个神话是从哪里来的？"><a href="#这个神话是从哪里来的？" class="headerlink" title="这个神话是从哪里来的？"></a>这个神话是从哪里来的？</h3><h4 id="传统武术的胡扯"><a href="#传统武术的胡扯" class="headerlink" title="传统武术的胡扯"></a>传统武术的胡扯</h4><p>这个误解也是传统武术的骗人的精髓所在。告诉一个弱小的人学习了某种武术，他就轻松可以击败比他高大，更强壮的坏人。</p>
<p>在20世纪，一个巨大的产业就建立在这个基础之上，各种乱七八糟的武术系统被包装并推给了好骗的西方人。尽管MMA中的柔术技术帮助清除了许多武术的骗局，但现在仍然受到影响。</p>
<h4 id="柔术课的结构"><a href="#柔术课的结构" class="headerlink" title="柔术课的结构"></a>柔术课的结构</h4><p>还有一部分原因是由于柔术学院商业模式的本质。虽然柔术比赛竞争激烈，但是现在的柔术学院通常还只是围绕着<code>技术动作</code>和<code>实战对抗</code>这两个方面进行教学和训练。因此，早期的先驱者重视身体训练，这是有道理的。</p>
<p>乔治·圣皮埃尔的教练Firhas Zahabi曾经对我说过。“随着柔术学院商业化的推广，我们看到了很多必要的体能训练消失了。”他说的对，在绝大多数的柔术学院中，体能训练并不被重视。当然，你也可以做一些跳跃俯卧撑和俯卧撑作为热身的一部分，但这还远远不够。看看拳击手和摔跤手。体能训练往往是他们训练的最重要的组成部分，而对抗往往是花时间最小的一个。</p>
<h4 id="罗伊斯·格雷斯-与-UFC"><a href="#罗伊斯·格雷斯-与-UFC" class="headerlink" title="罗伊斯·格雷斯 与 UFC"></a>罗伊斯·格雷斯 与 UFC</h4><p>罗伊斯·格雷西（Royce Gracie）在 UFC 早期的比赛中的惊人表现导致了一些人相信技术确实是无敌的。在我看来，罗伊斯赢了，因为他打的比赛看起来像这样：</p>
<blockquote>
<p><strong>斗士A（中等属性+强大的技术）&gt; 斗士B（伟大的属性+没有技术）</strong></p>
</blockquote>
<p>由于第二代 MMA 斗士的的属性已经改变，因为家伙们已经开始学习柔术了。比赛开始更像这样：</p>
<blockquote>
<p><strong>斗士A（中等属性+强大技术）≥ 斗士B（强大属性+一点点技巧）</strong></p>
</blockquote>
<p>在如今的 MMA 比赛中，我们经常看到的情况是这样的：</p>
<blockquote>
<p><strong>斗士A（卓越的属性+伟大的技术）&gt; 斗士B（伟大的属性+伟大的技术）</strong></p>
</blockquote>
<h4 id="杠杠原理的迷惑"><a href="#杠杠原理的迷惑" class="headerlink" title="杠杠原理的迷惑"></a>杠杠原理的迷惑</h4><p>杠杠原理能成倍加强力量，但不是力量的来源。当然，杠杠原理能帮你能更有效的利用力量，但没有力量来源，这个杠杠力也不复存在。这就是‘柔术’中‘杠杠原理’这个概念的迷惑性。</p>
<p>尽管可能会有人告诉你，没有人能为柔术添加杠杠作用。但是一些聪明的运动员及教练确实能够准确的找到杠杠的支点，并且使用的力量来完成动作，效果惊人。</p>
<h3 id="好消息"><a href="#好消息" class="headerlink" title="好消息"></a>好消息</h3><p>好消息是就算你只进行柔术对抗训练也能自然而然的提升你的体能，尽管这个提升有局限性并且基因决定了你的体能极限（抱歉，就是这样），而通过科学而且集中体能训练可以大幅度提升你的体能。</p>
<p>同时，体型小的训练者并不是总是处于劣势。相对力量会随着体型的增加而减小。所以假设其他条件相同的情况下，一个体重比你大20%的对手，力量并不会比你大20%，通常这个值会是12%~15%。这就意味着那些拥有惊人身体的小个子训练者通常会扳平体型的劣势，有时候甚至还会反超。</p>
<p>最后一个就是力量的增长也会随着年龄的增长而称下降的趋势，并在年老的时候就维持不变了。“人的力量就是这么真实”。</p>
<h3 id="如何变得更强"><a href="#如何变得更强" class="headerlink" title="如何变得更强"></a>如何变得更强</h3><h4 id="检查你的激素水平"><a href="#检查你的激素水平" class="headerlink" title="检查你的激素水平"></a>检查你的激素水平</h4><p>如果你是一个男性柔术运动员，我建议你去内分泌专家那检查你的激素水平。如果你的睾丸酮激素水平过低，不管你如何训练，你的身体素质都不会有较大的提升。一个好医生会建议你使用多种补剂和药品来解决这个问题。</p>
<h4 id="体操"><a href="#体操" class="headerlink" title="体操"></a>体操</h4><p>总体来说，拥有了功能性力量与身体控制能力，你将很难被击败。如果让我在力量训练之外再挑选一个最为柔术的赋值训练，那就是体操了。</p>
<h4 id="攀岩"><a href="#攀岩" class="headerlink" title="攀岩"></a>攀岩</h4><p>另一项能直接对柔术的运动表现及其力量提升极大的运动就是攀岩了，尤其是握力。</p>
<h4 id="举重"><a href="#举重" class="headerlink" title="举重"></a>举重</h4><p>举重对运动表现的提升不是通过几组二头弯举或者卧推就可以的，那是健身。你需要在专业教练的指导下练习奥运举和力量举（例如挺举，深蹲）。</p>
<h3 id="你该怎么做"><a href="#你该怎么做" class="headerlink" title="你该怎么做"></a>你该怎么做</h3><p>提高柔术水平不仅仅是提升柔术技术。我喜欢柔术的技术，它是那样的直接有效，令人着迷。如果你想在道垫上降服对手，高质量的动作是必不可少的。但这还不够。你可以在<a href="http://www.jiujitsubrotherhood.com/brazilian-jiu-jitsu-tips-a-c-t-model/" target="_blank" rel="noopener">这篇文章</a>中找到答案。</p>
<p>真正的武术家是一个在各个方面力精益求精的人。这包括变得更加强壮。如果你想成为顶级的柔术家，将你的体能提升到极限是你的必修课。</p>
]]></content>
      <tags>
        <tag>BJJ</tag>
      </tags>
  </entry>
  <entry>
    <title>从一道网易面试题浅谈 Tagged Pointer</title>
    <url>/folder/2017/12/26/2017-12-26-%E4%BB%8E%E4%B8%80%E9%81%93%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B5%85%E8%B0%88-Tagged-Pointer/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇博客九月就想写了，因为赶项目拖了到现在，抓住17年尾巴写吧~</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>上次看了一篇 <a href="https://www.jianshu.com/p/cec2a41aa0e7" target="_blank" rel="noopener">《从一道网易面试题浅谈OC线程安全》</a> 的博客，主要内容是：</p>
<p>作者去网易面试，面试官出了一道面试题：下面代码会发生什么问题？</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *target;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"parallel"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span> ; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.target = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"ksddkjalkjd%d"</span>,i];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案是：会 crash。</p>
<p>我们来看看对<code>target</code>属性（<code>strong</code>修饰）进行赋值，相当与 MRC 中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)setTarget:(NSString *)target &#123;</span><br><span class="line">    if (target == _target) return;</span><br><span class="line">    id pre = _target;</span><br><span class="line">    [target retain];//1.先保留新值</span><br><span class="line">    _target = target;//2.再进行赋值</span><br><span class="line">    [pre release];//3.释放旧值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为在 <em>并行队列</em> <code>DISPATCH_QUEUE_CONCURRENT</code> 中<em>异步</em> <code>dispatch_async</code> 对 <code>target</code>属性进行赋值，就会导致 target 已经被 <code>release</code>了，还会执行 <code>release</code>。这就是向已释放内存对象发送消息而发生 crash 。</p>
<h3 id="但是"><a href="#但是" class="headerlink" title="但是"></a>但是</h3><p>我敲了这段代码，执行的时候发现并不会 crash~</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *target;</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"parallel"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span> ; i++) &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    	<span class="comment">// ‘ksddkjalkjd’删除了</span></span><br><span class="line">        <span class="keyword">self</span>.target = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d"</span>,i];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原因就出在对 <code>self.target</code> 赋值的字符串上。博客的最后也提到了 - <em>‘上述代码的字符串改短一些，就不会崩溃’</em>，还有 <code>Tagged Pointer</code> 这个东西。</p>
<p>我们将上面的代码修改下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%d"</span>, i];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%d, %s, %p"</span>, i, object_getClassName(str), str);</span><br><span class="line"><span class="keyword">self</span>.target = str;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0, NSTaggedPointerString, 0x3015</span><br></pre></td></tr></table></figure>

<p>发现这个字符串类型是 <code>NSTaggedPointerString</code>，那我们来看看 Tagged Pointer 是什么？</p>
<h3 id="Tagged-Pointer"><a href="#Tagged-Pointer" class="headerlink" title="Tagged Pointer"></a>Tagged Pointer</h3><p>Tagged Pointer 详细的内容可以看这里 <a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a>。</p>
<p>Tagged Pointer 是一个能够提升性能、节省内存的有趣的技术。</p>
<ul>
<li>Tagged Pointer 专门用来存储小的对象，例如 <strong>NSNumber</strong> 和 <strong>NSDate</strong>（后来可以存储小字符串）</li>
<li>Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。</li>
<li>它的内存并不存储在堆中，也不需要 malloc 和 free，所以拥有极快的读取和创建速度。</li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><p><a href="https://www.jianshu.com/p/cec2a41aa0e7" target="_blank" rel="noopener">从一道网易面试题浅谈OC线程安全</a></p>
</li>
<li><p><a href="http://www.infoq.com/cn/articles/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解Tagged Pointer</a></p>
</li>
<li><p><a href="http://www.cocoachina.com/ios/20150918/13449.html" target="_blank" rel="noopener">【译】采用Tagged Pointer的字符串</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>为博客添加 Gitalk 评论插件</title>
    <url>/folder/2017/12/19/2017-12-19-%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于 <strong>Disqus</strong> 对于国内网路的支持十分糟糕，很多人反映 Disqus 评论插件一直加载不出来。而我一直是处于翻墙状态的~（话说你们做程序员的都不翻墙用Google的吗😅，哈哈，吐嘈下）</p>
<p>针对这个问题，我添加了<a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">Gitalk</a> 评论插件。在此，非常感谢 <a href="https://github.com/FeDemo" target="_blank" rel="noopener">@FeDemo</a> 的推荐 。</p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="Gitalk-评论插件"><a href="#Gitalk-评论插件" class="headerlink" title="Gitalk 评论插件"></a>Gitalk 评论插件</h3><p>首先来看看 Gitalk 的界面和功能：</p>
<p><a href="https://gitalk.github.io/" target="_blank" rel="noopener"><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm4u3j0lmj30nk0kl40i.jpg" alt=""></a></p>
<p>gitalk 使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 <code>MarkDown语法</code>。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Gitalk 是一个利用 Github API,基于 Github issue 和 Preact 开发的评论插件，在 Gitalk 之前还有一个 <a href="https://github.com/imsun/gitment" target="_blank" rel="noopener">gitment</a> 插件也是基于这个原理开发的,不过 gitment 已经很久没人维护了。</p>
<p>可以看到在 gitalk 的评论框进行评论时，其实就是在对应的 issue 上提问题。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm5916av1j30i209rab7.jpg" alt="gitalk评论框"></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm596ggkfj30mx0gfjuk.jpg" alt="Github issue"></p>
<h3 id="集成-Gitalk"><a href="#集成-Gitalk" class="headerlink" title="集成 Gitalk"></a>集成 Gitalk</h3><p>到这里，你应该对 Gitalk 有个大致的了解了，现在，开始集成 gitalk 插件吧。</p>
<p>将这段代码插入到你的网站：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- Gitalk 评论 start  --&gt;</span><br><span class="line">&#123;% <span class="keyword">if</span> site.gitalk.enable %&#125;</span><br><span class="line">&lt;!-- Link Gitalk 的支持文件  --&gt;</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"https://unpkg.com/gitalk/dist/gitalk.css"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://unpkg.com/gitalk@latest/dist/gitalk.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;div id=<span class="string">"gitalk-container"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="keyword">var</span> gitalk = <span class="keyword">new</span> Gitalk(&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gitalk的主要参数</span></span><br><span class="line">		clientID: <span class="string">`Github Application clientID`</span>,</span><br><span class="line">		clientSecret: <span class="string">`Github Application clientSecret`</span>,</span><br><span class="line">		repo: <span class="string">`存储你评论 issue 的 Github 仓库名`</span>,</span><br><span class="line">		owner: <span class="string">'Github 用户名'</span>,</span><br><span class="line">		admin: [<span class="string">'Github 用户名'</span>],</span><br><span class="line">		id: <span class="string">'页面的唯一标识，gitalk会根据这个标识自动创建的issue的标签'</span>,</span><br><span class="line">    </span><br><span class="line">    &#125;);</span><br><span class="line">    gitalk.render(<span class="string">'gitalk-container'</span>);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br><span class="line"><span class="regexp">&lt;!-- Gitalk end --&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们需要关心的就是配置下面几个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">clientID: <span class="string">`Github Application clientID`</span>,</span><br><span class="line">clientSecret: <span class="string">`Github Application clientSecret`</span>,</span><br><span class="line">repo: <span class="string">`Github 仓库名`</span>,<span class="comment">//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）</span></span><br><span class="line">owner: <span class="string">'Github 用户名'</span>,</span><br><span class="line">admin: [<span class="string">'Github 用户名'</span>], <span class="comment">//这个仓库的管理员，可以有多个，用数组表示，一般写自己,</span></span><br><span class="line">id: <span class="string">'window.location.pathname'</span>, <span class="comment">//页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识</span></span><br></pre></td></tr></table></figure>
<p>当然，还有其他很多参数，有兴趣的话可以 <a href="https://github.com/gitalk/gitalk#options" target="_blank" rel="noopener"> 点这里</a>。</p>
<p>比如我就增加了这个全屏遮罩的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">distractionFreeMode: true,</span><br></pre></td></tr></table></figure>

<h3 id="创建-Github-Application"><a href="#创建-Github-Application" class="headerlink" title="创建 Github Application"></a>创建 Github Application</h3><p>Gitalk 需要一个 <strong>Github Application</strong>，<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">点击这里申请</a>。</p>
<p>填写下面参数：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jaib6fj30jo0gaacs.jpg" alt=""></p>
<p>点击创建</p>
<p>获取 <code>Client ID</code> 和 <code>Client Secret</code> 填入你的我们 Gitalk 参数中</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fmm7jrzff6j30lc0budhp.jpg" alt=""></p>
<p>当你参数都设置好，将代码推送到 Github 仓库后，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。</p>
<p>当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 <code>repo</code> 的仓库下创建对应 issue。</p>
<p>比如说这样：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fmm867n88cj30l809mjse.jpg" alt=""></p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fmm8a0i0jkj30rr0ct42t.jpg" alt=""></p>
<p>当然，你也可以手动创建issue作为 gitalk评论容器。只要有 <code>Gitalk</code> 标签 和 <code>id</code> 对应标签就可以。比我我自己创建的 <a href="https://github.com/qiubaiying/qiubaiying.github.io/issues/38" target="_blank" rel="noopener">About issue</a> 。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>最后说几句吐嘈几句， Gitalk 需要你点开每篇文章的页面才会创建对应的 issue,对我来说真是个糟糕的体验（文章有点多~）。</p>
<p>当然，也有解决办法，这篇 <a href="https://draveness.me/git-comments-initialize" target="_blank" rel="noopener">自动初始化 Gitalk 和 Gitment 评论</a>，就解决了这个问题。</p>
<p>最后，<a href="https://github.com/qiubaiying/qiubaiying.github.io" target="_blank" rel="noopener">给个 star 吧</a>~</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>GCD 在 Swift 中的用法</title>
    <url>/folder/2017/10/04/2017-10-04-GCD-%E5%9C%A8-Swift-%E4%B8%AD%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="DispatchQueue"><a href="#DispatchQueue" class="headerlink" title="DispatchQueue"></a>DispatchQueue</h2><p>Swift 中，对 GCD 语法进行了彻底改写。引入了 <code>DispatchQueue</code> 这个类。</p>
<p>先来看看在一个异步队列中读取数据， 然后再返回主线程更新 UI， 这种操作在新的 Swift 语法中是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新UI操作</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>DispatchQueue.global().async</code> 相当于使用全局队列进行异步操作。然后在调用 <code>DispatchQueue.main.async</code> 使用主线程更新相应的 UI 内容。</p>
<h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>新的 GCD 引入了 QoS (Quality of Service) 的概念。</p>
<p>先看看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global(qos: .userInitiated).async &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>QoS 对应的就是 <code>Global Queue</code> 中的优先级。 其优先级由最低的 <code>background</code> 到最高的 <code>userInteractive</code> 共五个，还有一个未定义的 <code>unspecified</code>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> background: <span class="type">DispatchQoS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> utility: <span class="type">DispatchQoS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> `<span class="keyword">default</span>`: <span class="type">DispatchQoS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> userInitiated: <span class="type">DispatchQoS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> userInteractive: <span class="type">DispatchQoS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> unspecified: <span class="type">DispatchQoS</span></span><br></pre></td></tr></table></figure>

<h2 id="自定义-Queue"><a href="#自定义-Queue" class="headerlink" title="自定义 Queue"></a>自定义 Queue</h2><p>除了直接使用 <code>DispatchQueue.global().async</code> 这种封装好的代码外，还可以通过<code>DispatchWorkItem</code> 自定义队列的优先级，特性：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"swift_queue"</span>)</span><br><span class="line"><span class="keyword">let</span> dispatchworkItem = <span class="type">DispatchWorkItem</span>(qos: .userInitiated, flags: .inheritQoS) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">queue.async(execute: dispatchworkItem)</span><br></pre></td></tr></table></figure>
<h2 id="GCD定时器"><a href="#GCD定时器" class="headerlink" title="GCD定时器"></a>GCD定时器</h2><p>Swift 中 <code>dispatch_time</code>的用法改成了：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> delay = <span class="type">DispatchTime</span>.now() + .seconds(<span class="number">60</span>)</span><br><span class="line"><span class="type">DispatchQueue</span>.main.asyncAfter(deadline: delay) &#123; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相较与OC来说更易读了：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">let dispatch_time = dispatch_time(DISPATCH_TIME_NOW, Int64(<span class="number">60</span> * <span class="built_in">NSEC_PER_SEC</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>参考 <a href="https://www.swiftcafe.io/2016/10/16/swift-gcd/" target="_blank" rel="noopener">GCD 在 Swift 3 中的玩儿法</a></li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 4 新特性</title>
    <url>/folder/2017/09/11/2017-09-11-Swift-4-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="private-权限扩大"><a href="#private-权限扩大" class="headerlink" title="private 权限扩大"></a>private 权限扩大</h3><p>在 Swift 4 中，<code>extension</code> 可以读取 <code>private</code> 变量了。</p>
<p>Swift 3 中，如果将主体函数的变量定义为 <code>private</code>，则其 <code>extension</code> 无法读取此变量，必须将其改为 <code>filePrivate</code> 才可以。</p>
<h3 id="单向区间"><a href="#单向区间" class="headerlink" title="单向区间"></a>单向区间</h3><p>单向区间是一个新的类型，主要分两种：确定上限和确定下限的区间。直接用字面量定义大概可以写成 <code>…6</code>和 <code>2…</code></p>
<p>例如</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> intArr = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr1 = intArr[...<span class="number">3</span>] 	<span class="comment">// [0, 1, 2, 3]</span></span><br><span class="line"><span class="keyword">let</span> arr2 = intArr[<span class="number">3</span>...] 	<span class="comment">// [3, 4]</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串改动"><a href="#字符串改动" class="headerlink" title="字符串改动"></a>字符串改动</h3><h4 id="String-操作简化了"><a href="#String-操作简化了" class="headerlink" title="String 操作简化了"></a>String 操作简化了</h4><p><code>String</code> 许多要通过 <code>.characters</code> 进行的操作，可以直接用 String 进行操作了。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Hello, 😜!"</span></span><br><span class="line"><span class="comment">// No need to drill down to .characters</span></span><br><span class="line"><span class="keyword">let</span> n = greeting.<span class="built_in">count</span></span><br><span class="line"><span class="keyword">let</span> endOfSentence = greeting.index(of: <span class="string">"!"</span>)!</span><br></pre></td></tr></table></figure>

<h4 id="新增-Substring-类型"><a href="#新增-Substring-类型" class="headerlink" title="新增 Substring 类型"></a>新增 Substring 类型</h4><p>swift 4 为字符串片段新增了一个叫 <code>Substring</code> 的类型。</p>
<p>当你创建一个字符串的片段时，会产生一个 <code>Substring</code> 实例。<code>Substring</code> 与 <code>String</code> 用法相同， 因为子串和原字符串共享内存，所以对子串的操作快速而且高效。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = <span class="string">"Hi there! It's nice to meet you! 👋"</span></span><br><span class="line"><span class="keyword">let</span> endOfSentence = greeting.index(of: <span class="string">"!"</span>)! </span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生 Substring 实例</span></span><br><span class="line"><span class="keyword">let</span> firstSentence = greeting[...endOfSentence]</span><br><span class="line"><span class="comment">// firstSentence == "Hi there!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `Substring` 与 `String` 用法相同</span></span><br><span class="line"><span class="keyword">let</span> shoutingSentence = firstSentence.uppercased()</span><br><span class="line"><span class="comment">// shoutingSentence == "HI THERE!"</span></span><br></pre></td></tr></table></figure>

<p>但是要注意一个 <code>Substring</code> 保留从其生成的完整的 <code>String</code>值。 当您传递一个看似很小的 <code>Substring</code> 时，这可能导致意外的高内存开销。所以使用 <code>Substring</code>时，最好转化为 <code>String</code>.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newString = <span class="type">String</span>(substring)</span><br></pre></td></tr></table></figure>


<h4 id="换行可以不用-n了！"><a href="#换行可以不用-n了！" class="headerlink" title="换行可以不用 \n了！"></a>换行可以不用 <code>\n</code>了！</h4><p>Swift 3，字符串换行要插入 <code>\n</code>。<br>例如：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fjdam0wvhhj305d0283yf.jpg" alt=""></p>
<p>在 Swift 4 可以这样操作:</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fjdas2yri4j303q0260sm.jpg" alt=""></p>
<p>用两个 <code>“”“</code> 包裹起来的字符串会自动添加 <code>\n</code> 换行，更加直观了。注意：换行与缩进参照的是第二个 <code>“”“</code> 号的位置。</p>
<p>嗯，我觉得OK！</p>
<h4 id="支持-Unicode-9"><a href="#支持-Unicode-9" class="headerlink" title="支持 Unicode 9"></a>支持 Unicode 9</h4><p>Swift 4 支持 Unicode 9，<a href="https://oleb.net/blog/2016/12/emoji-4-0/" target="_blank" rel="noopener">为现代表情符号修正了一些问题</a>。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> family1 = <span class="string">"👨‍👩‍👧‍👦"</span></span><br><span class="line"><span class="keyword">let</span> family2 = <span class="string">"👨\u&#123;200D&#125;👩\u&#123;200D&#125;👧\u&#123;200D&#125;👦"</span></span><br><span class="line">family1 == family2 <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>

<p>居然还有这种操作~</p>
<h3 id="新增-KeyPath-数据类型"><a href="#新增-KeyPath-数据类型" class="headerlink" title="新增 KeyPath 数据类型"></a>新增 KeyPath 数据类型</h3><p>KeyPath 是 Swift 4 新增加的数据类型。</p>
<p>定义两个结构体 <code>Person</code>与<code>Book</code> </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> authors: [<span class="type">Person</span>]</span><br><span class="line">    <span class="keyword">var</span> primaryAuthor: <span class="type">Person</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> authors.first!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> abelson = <span class="type">Person</span>(name: <span class="string">"Harold Abelson"</span>)</span><br><span class="line"><span class="keyword">let</span> sussman = <span class="type">Person</span>(name: <span class="string">"Gerald Jay Sussman"</span>)</span><br><span class="line"><span class="keyword">let</span> book = <span class="type">Book</span>(title: <span class="string">"Structure and Interpretation of Computer Programs"</span>, authors: [abelson, sussman])</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">book[keyPath: \<span class="type">Book</span>.title]</span><br><span class="line">book[keyPath: \<span class="type">Book</span>.primaryAuthor.name]</span><br><span class="line"><span class="comment">// 相当与</span></span><br><span class="line">book.title</span><br><span class="line">book.primaryAuthor.name</span><br></pre></td></tr></table></figure>

<p>这里 <code>\Book.title</code> 与 <code>\Book.primaryAuthor.name</code> 就是 KeyPath.</p>
<p>KeyPath 可以用 <code>.appending</code> 拼接</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> authorKeyPath = \<span class="type">Book</span>.primaryAuthor</span><br><span class="line"><span class="keyword">let</span> nameKeyPath = authorKeyPath.appending(path: \.name)</span><br><span class="line"><span class="comment">// nameKeyPath = \Book.primaryAuthor.name</span></span><br></pre></td></tr></table></figure>

<h3 id="新增-swapAt-函数"><a href="#新增-swapAt-函数" class="headerlink" title="新增  swapAt() 函数"></a>新增  <code>swapAt()</code> 函数</h3><p>Swift 4 引入了一种在集合中交换两个元素的新方法: <code>swapAt()</code></p>
<p>Swift 3 交换集合中的元素的用 <code>swap()</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">swap</span>(&amp;numbers[<span class="number">0</span>], &amp;numbers[<span class="number">1</span>])</span><br><span class="line"><span class="comment">// numbers = [2,1,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p>Swift 4 中可以直接用 </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">numbers.swapAt(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">// numbers = [2,1,3,4,5]</span></span><br></pre></td></tr></table></figure>



<h3 id="其他改动"><a href="#其他改动" class="headerlink" title="其他改动"></a>其他改动</h3><p>其他改动如：<strong>新的整数协议</strong>、<strong>泛型下标</strong>、<strong>NSNumber bridging</strong>等</p>
<p>可以参考：<a href="https://github.com/ole/whats-new-in-swift-4" target="_blank" rel="noopener">whats new in swift4</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>利用 Debug Memory Graph 检测内测泄漏</title>
    <url>/folder/2017/07/26/2017-07-26-%E5%88%A9%E7%94%A8-Debug-Memory-Graph-%E6%A3%80%E6%B5%8B%E5%86%85%E6%B5%8B%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平常我们都会用 Instrument 的 Leaks / Allocations 或其他一些开源库进行内存泄露的排查，但它们都存在各种问题和不便，</p>
<p>在这个 ARC 时代更常见的内存泄露是循环引用导致的 Abandoned memory，Leaks 工具查不出这类内存泄露，应用有限。</p>
<p>今天介绍一种简单直接的检测内测泄漏的方法：<strong>Debug Memory Graph</strong></p>
<p>就是这货：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fhxct12udnj311x0s3grw.jpg" alt=""></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我最近的项目中，退出登录后（跳转到登录页），发现首页控制器没有被销毁，依旧能接收通知。</p>
<p>退出登录代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UIStoryboard</span> *storyboard = [<span class="built_in">UIStoryboard</span> storyboardWithName:<span class="string">@"Login"</span> bundle:[<span class="built_in">NSBundle</span> mainBundle]];</span><br><span class="line">AppDelegate *appDelegate = (AppDelegate *)[<span class="built_in">UIApplication</span> sharedApplication].delegate;</span><br><span class="line">appDelegate.window.rootViewController = [storyboard instantiateViewControllerWithIdentifier:<span class="string">@"LoginVC"</span>];</span><br></pre></td></tr></table></figure>

<p>很明显发生了循环引用导致的内测泄漏。</p>
<p>接下来就使用 <strong>Debug Memory Graph</strong> 来查看内测泄漏了。</p>
<h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>首先启动 Xcode 运行程序。</p>
<h3 id="Debug-Memory-Graph"><a href="#Debug-Memory-Graph" class="headerlink" title="Debug Memory Graph"></a>Debug Memory Graph</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fhxend1a8aj315y0s3gw5.jpg" alt=""></p>
<p>点击 Debug Memory Graph 按钮后，可以看到红框内的是当前内存中存在的对象。其中，绿色的就是视图控制器。</p>
<p>这样，我们随时都可以查看内测中存在的对象，换句话说，就是可以通过观察 Memory Graph 查看内测泄漏。</p>
<h3 id="调试你的App"><a href="#调试你的App" class="headerlink" title="调试你的App"></a>调试你的App</h3><p>继续运行你的程序</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fhxeuh1np5j30v90kvn03.jpg" alt=""></p>
<p>然后对App进行调试、push、pop 操作，再次点击 Debug Memory Graph 按钮。那些该释放而依旧在内测中的 <code>控制器</code> 或 <code>对象</code> 就能一一找出来了。</p>
<p>接下来，只要进入对应的控制器找到内测泄漏的代码就OK了，一般是Block里引用了 <code>self</code>，改为 <code>weakSelf</code> 就解决了。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#define WS(weakSelf) __weak __typeof(&amp;*self)weakSelf = self;</span></span><br><span class="line"></span><br><span class="line">WS(weakSelf)</span><br><span class="line">sView.btnBlock = ^(<span class="built_in">NSInteger</span> idx)&#123;</span><br><span class="line">    [weakSelf.tableView reloadSections:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:idx] withRowAnimation:<span class="built_in">UITableViewRowAnimationAutomatic</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>就这样，利用 Debug Memory Graph，可以简单快速的检测内测泄漏。</p>
<p>一般由两个对象循环引用的内测泄漏是比较好发现的，如果是由三个及其三个以上的对象形成的大的循环引用，就会比较难排查了。</p>
]]></content>
      <tags>
        <tag>开发技巧</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>iTunes Connect 构建版本不显示</title>
    <url>/folder/2017/07/24/2017-07-24-iTunes-Connect-%E6%9E%84%E5%BB%BA%E7%89%88%E6%9C%AC%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天新项目上架，在Xcode打包上传到App Store后，在iTunes Connect构建版本中居然找不到上传的App…</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>从iOS10开始,苹果更加注重对用于隐私的保护,App 里边如果需要访问用户隐私,必须要做描述,所以要在 plist 文件中添加描述。</p>
<p>而这三个基础描述是必须添加的：</p>
<ul>
<li><p><strong>麦克风权限</strong>：<code>Privacy - Microphone Usage Description</code> 是否允许此App使用你的麦克风？</p>
</li>
<li><p><strong>相机权限</strong>：<code>Privacy - Camera Usage Description</code> 是否允许此App使用你的相机？</p>
</li>
<li><p><strong>相册权限</strong>：<code>Privacy - Photo Library Usage Description</code> 是否允许此App访问你的媒体资料库？</p>
</li>
</ul>
<p>其他的权限可以根据自己 APP 的情况来添加。</p>
<p>添加完权限之后然后继续提交 App 就可以了。</p>
<p>若还是找不到，返回 plist 文件中，删除之前的权限，重新添加一下，有可能你哪不小心添加的权限末尾有空格，或者字段不对。</p>
<p>End</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift的HMAC和SHA1加密</title>
    <url>/folder/2017/07/19/2017-07-19-Swift%E7%9A%84HMAC%E5%92%8CSHA1%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>HMAC是密钥相关的哈希运算消息认证码（Hash-based Message Authentication Code）。 HMAC运算利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。也就是说HMAC通过将哈希算法(SHA1, MD5)与密钥进行计算生成摘要。</p>
</blockquote>
<h2 id="Objectice-C"><a href="#Objectice-C" class="headerlink" title="Objectice-C"></a>Objectice-C</h2><p>在上个 Objectice-C 项目中，使用的 HMAC 和 SHA1 进行加密。如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSString</span> *)hmacsha1:(<span class="built_in">NSString</span> *)text key:(<span class="built_in">NSString</span> *)secret &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSData</span> *secretData = [secret dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSData</span> *clearTextData = [text dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> result[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">// SHA1加密</span></span><br><span class="line">    CCHmac(kCCHmacAlgSHA1, [secretData bytes], [secretData length], [clearTextData bytes], [clearTextData length], result);</span><br><span class="line">    <span class="keyword">char</span> base64Result[<span class="number">32</span>];</span><br><span class="line">    size_t theResultLength = <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 转为Base64</span></span><br><span class="line">    Base64EncodeData(result, <span class="number">20</span>, base64Result, &amp;theResultLength,<span class="literal">YES</span>);</span><br><span class="line">    <span class="built_in">NSData</span> *theData = [<span class="built_in">NSData</span> dataWithBytes:base64Result length:theResultLength];</span><br><span class="line">    <span class="built_in">NSString</span> *base64EncodedResult = [[<span class="built_in">NSString</span> alloc] initWithData:theData encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="keyword">return</span> base64EncodedResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="swift"><a href="#swift" class="headerlink" title="swift"></a>swift</h2><p>最近用 swift 重构项目,用 Swift <a href="https://stackoverflow.com/questions/26970807/implementing-hmac-and-sha1-encryption-in-swift?rq=1" target="_blank" rel="noopener">重写了</a> HMAC 的 SHA1 加密方式。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用HMAC和SHA加密</span></span><br><span class="line"><span class="keyword">let</span> hmacResult:<span class="type">String</span> = <span class="string">"myStringToHMAC"</span>.hmac(<span class="type">HMACAlgorithm</span>.<span class="type">SHA1</span>, key: <span class="string">"myKey"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>使用下面代码时，需要在 OC 桥接文件<code>xxx-Bridging-Header</code>中 <code>#import &lt;CommonCrypto/CommonHMAC.h&gt;</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hmac</span><span class="params">(algorithm: HMACAlgorithm, key: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cKey = key.cStringUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">        <span class="keyword">let</span> cData = <span class="keyword">self</span>.cStringUsingEncoding(<span class="type">NSUTF8StringEncoding</span>)</span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">CUnsignedChar</span>](<span class="built_in">count</span>: <span class="type">Int</span>(algorithm.digestLength()), repeatedValue: <span class="number">0</span>)</span><br><span class="line">        <span class="type">CCHmac</span>(algorithm.toCCHmacAlgorithm(), cKey!, strlen(cKey!), cData!, strlen(cData!), &amp;result)</span><br><span class="line">        <span class="keyword">var</span> hmacData:<span class="type">NSData</span> = <span class="type">NSData</span>(bytes: result, length: (<span class="type">Int</span>(algorithm.digestLength())))</span><br><span class="line">        <span class="keyword">var</span> hmacBase64 = hmacData.base64EncodedStringWithOptions(<span class="type">NSDataBase64EncodingOptions</span>.<span class="type">Encoding76CharacterLineLength</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(hmacBase64)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HMACAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">MD5</span>, <span class="type">SHA1</span>, <span class="type">SHA224</span>, <span class="type">SHA256</span>, <span class="type">SHA384</span>, <span class="type">SHA512</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">toCCHmacAlgorithm</span><span class="params">()</span></span> -&gt; <span class="type">CCHmacAlgorithm</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">MD5</span>:</span><br><span class="line">            result = kCCHmacAlgMD5</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA1</span>:</span><br><span class="line">            result = kCCHmacAlgSHA1</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA224</span>:</span><br><span class="line">            result = kCCHmacAlgSHA224</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA256</span>:</span><br><span class="line">            result = kCCHmacAlgSHA256</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA384</span>:</span><br><span class="line">            result = kCCHmacAlgSHA384</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA512</span>:</span><br><span class="line">            result = kCCHmacAlgSHA512</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">CCHmacAlgorithm</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">digestLength</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> result: <span class="type">CInt</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .<span class="type">MD5</span>:</span><br><span class="line">            result = <span class="type">CC_MD5_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA1</span>:</span><br><span class="line">            result = <span class="type">CC_SHA1_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA224</span>:</span><br><span class="line">            result = <span class="type">CC_SHA224_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA256</span>:</span><br><span class="line">            result = <span class="type">CC_SHA256_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA384</span>:</span><br><span class="line">            result = <span class="type">CC_SHA384_DIGEST_LENGTH</span></span><br><span class="line">        <span class="keyword">case</span> .<span class="type">SHA512</span>:</span><br><span class="line">            result = <span class="type">CC_SHA512_DIGEST_LENGTH</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Int</span>(result)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之动力链</title>
    <url>/folder/2017/07/10/2017-07-10-%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E5%8A%A8%E5%8A%9B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>与其说体能训练是一种行为，不如说体能训练是一种程序。只要符合逻辑，就可以自由组合。<br> 那么体能训练的逻辑是什么？我们将之总结为：<a href="http://qiubaiying.top/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E5%8A%A8%E5%8A%9B%E9%93%BE/" target="_blank" rel="noopener"><strong>动力链</strong></a>、<a href="http://qiubaiying.top/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7/" target="_blank" rel="noopener"><strong>功能性</strong></a>、<a href="http://qiubaiying.top/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="noopener"><strong>金字塔</strong></a>。</p>
<h2 id="动力链"><a href="#动力链" class="headerlink" title="动力链"></a>动力链</h2><p>如果说 <strong>五大运动素质</strong>（力量、速度、耐力、灵敏、柔韧）代表了体能的宏观表现，那么动力链理论则阐释了人体解剖结构在运动中的客观规律，这二者同为人体的本质属性。</p>
<p>动力链这一理论早在1875年就被提出过，当时的定义还很简单，就是指几个相邻的关节所组成的复杂动作单元。后来在不断地实践与研究中，动力链理论也不断的升级，越来越清晰，越来越客观，也越来越复杂，并且逐渐成为了体能训练师们必备的思考工具之一。</p>
<p>来看看动力链的英文解释:</p>
<blockquote>
<p>The concept of the kinetic chain originated in 1875, when a mechanical engineer named Franz Reuleaux proposed that if a series of overlapping segments were connected via pin joints, these interlocking joints would create a system that would allow the movement of one joint to affect the movement of another joint within the kinetic link. Dr. Arthur Steindler adapted this theory in 1955, and included an analysis of human movement. Steindler suggested that the extremities be viewed as a series of rigid, overlapping segments and defined the kinetic chain as a “combination of several successively arranged joints constituting a complex motor unit.” The movements that occur within these segments present as two primary types—open and closed.</p>
</blockquote>
<p>这种模糊形容根本无法让人们理解它真正的内核，虽然它看起来就像是一堆联动的齿轮和杠杆。实际上它也真的很像一堆齿轮和杠杆，有的负责驱动，有的负责传力，有的负责稳定。</p>
<p>为了方便大家理解，下面我要将这个理论拆解开来跟大家分享。</p>
<p>首先，我们需要从以上的定义中提炼出来一些关键词，比如说 “运动”、“几个”、“相邻”等等。那么这几个词分别代表了什么？</p>
<ol>
<li>我们讨论问题的角度是<strong>运动</strong>的；</li>
<li>我们需要考虑的<strong>人体解剖结构</strong>问题；</li>
<li>我们需要考虑相邻关节的<strong>协作关系</strong>；</li>
<li>我们需要分析每一个关节的<strong>使用特点</strong>。</li>
</ol>
<p>所以，它似乎并不能被完美的定义，而是只可意会不可言传。<br> 那么关于动力链，我们需要掌握两个最基本的知识：<strong>动力链模型</strong>、<strong>开链与闭链</strong>。</p>
<h3 id="动力链模型"><a href="#动力链模型" class="headerlink" title="动力链模型"></a>动力链模型</h3><p>在动力链理论中，我们考虑运动的最小单位是<strong>关节</strong>，诸多关节运动的协作产生了整体上的复杂动作。所以每一个关节的功能就决定了整体动作的表现，任何一个关节功能受限都会导致整体动作的失衡。 </p>
<p>而我们所指的关节功能，可以从生物力学角度简单的概括为：</p>
<ul>
<li><strong>灵活</strong>(<strong>M</strong>,Mobility)</li>
<li><strong>稳定</strong>(<strong>S</strong>,Stability)</li>
</ul>
<p>但看起来简单的两个词，其实意义非常。</p>
<h4 id="什么是灵活？"><a href="#什么是灵活？" class="headerlink" title="什么是灵活？"></a>什么是灵活？</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2avap5sj30ao08rdg4.jpg" alt=""></p>
<p>很多人的第一反应就是能自由的运动呗~然后部分专业人士可能会想到活动度。但是你的关节如果仅仅具备很好的活动度就能够胜任运动中的需求么？显然是不能的。所以灵活的意义远不止关节活动度，关节活动度仅仅是灵活的基础，而更重要的还有产力的能力。没错，这里的灵活既包括关节主被动活动范围，也包括产力的能力，比如产力的大小，产力的快慢等等。<br> 举个例子：小明的髋关节活动范围非常好，能竖叉能横叉，但是臀大肌并没有很好的力量，所以不能够支撑你的跑步与跳跃，所以此时的髋关节灵活性仍然是不足的，只不过这里强调的是力量的缺失。</p>
<h4 id="什么是稳定？"><a href="#什么是稳定？" class="headerlink" title="什么是稳定？"></a>什么是稳定？</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2b1gendj30fa08t74f.jpg" alt=""></p>
<p>稳定就是稳定呗<del>就是待着不动呗</del>就是牢固呗~灵活还能说出个关节活动度，而稳定的定义真的让很多人摸不到头脑，因为似乎“稳定”一词已经很好地形容了关节的功能表现。但是实际上我们仍然可以对其进行深究，并且这样做是有意义的，因为表现的不同直接影响训练的手段。</p>
<p>如果我们把“稳定”定义为是一种提供安全性的保护，那么我们就可以假想出两个现象：</p>
<ol>
<li>一个非常贵重的瓷器抱在手中，我不能把它摔碎，所以我抱着不动~</li>
<li>同样是这个非常贵重的瓷器抱在手中，我不能把它摔碎，但是我可以慢慢的把它放在地上。<br>同样是保护瓷器不被摔碎，但是却有两个表现，一个是hold住，另外一个是慢慢的放在地上，一个不动，一个动。所以我们人体关节的稳定也是如此，既包括保持身体姿态，关节位置的相对固定，也包括有控制的缓冲外力，退让做功。</li>
</ol>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg2b6eo7uj30m80h477k.jpg" alt=""></p>
<p>举个例子：我们的核心区域在运动中应该尽可能的保持姿态的稳定，所以是抱着瓷器不动；我们的膝关节在走路与跑步中从伸到屈，缓冲脚落地产生的冲击力，所以是抱着瓷器往下放。 </p>
<p>在了解了 SM (稳定和灵活)的意义之后，更重要的是明白：这两种并不会孤立的存在，而是相辅相成同时存在的，只不过在人体整体动力链中体现的侧重点不一样，在肢体的协同运动中扮演的角色不一样。比如对于核心区域来说，灵活恰是其稳定的基础，因为不同体位下脊柱的排列形式直接影响稳定的表现。</p>
<p>当 SM 代表了关节功能之后，在人体的整体运动结构中，不同的关节所凸显出来的功能是不同的，并且它们遵循一定的逻辑分布。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2bewsh2j30hs0b0t8y.jpg" alt=""></p>
<p>从下往上说：</p>
<ol>
<li><p>足弓——稳定</p>
<p> 第一个缓冲冲击力的关节，并且没有多大的关节活动度。</p>
</li>
<li><p>足踝——灵活</p>
<p> “足” “踝”形成了一个稳定与灵活兼备的整体，但是在运动中它是下肢蹬伸最后一个主动发力的关节，并且无时无刻不在调整着身体与地面之间的位置关系，所以在这里我们更强调它的灵活性。</p>
</li>
<li><p>膝关节——稳定</p>
<p> 强大的承重关节，且仅存在屈伸的动作（屈膝位的内外旋的意义是提供可控的缓冲空间，并非叫你主动旋转），更重要的是，无论走路、跑步、跳跃，膝关节都是非常重要的离心缓冲关节。</p>
</li>
<li><p>髋关节——灵活</p>
<p> 强大的发力关节，而且活动范围也非常广泛，它引领着下肢的动作产生。但是由于位置与功能的特殊，所以其稳定性也相当重要，直接可以影响核心的稳定结构，特别是在闭链状态下。</p>
</li>
<li><p>腰椎——稳定</p>
<p> 相对的绝对稳定体。所谓绝对，是因为腰椎所处的位置恰好为核心地带，这里的功能是维持姿态以及为上下肢的运动提供稳定基础，所以要“抱着缸不动”。而所谓相对，是因为不同的体位下腰椎的姿态是需要随之调整的，并不能以不变应万变。</p>
</li>
<li><p>胸椎——灵活</p>
<p> 胸椎的灵活性其实并不好，但是相比于腰椎来说就好太多了，特别是在旋转动作上。在旋转鞭打的动作模式中，胸椎是继下肢产力之后的第一个角速度放大的关节，其灵活程度直接影响了上肢的鞭打效果。当然，在更多的时候胸椎要参与承重，但即便承重，也是以其良好的灵活性为基础的，比如说手臂上举过头负重的动作。</p>
</li>
<li><p>颈椎——稳定</p>
<p> 虽然很灵活，但却需要很稳定！因为头部的位置变化会直接改变身体肌张力的大小分布，这个不仅可以让我们身体姿态发生变化，还会破坏掉本体感觉的准确性。当然，这也是猫在空中可以转体的原因，以及为什么我们打拳的时候不能回头。</p>
</li>
<li><p>肩胛胸关节——稳定</p>
<p> 这是一个很奇葩的关节，从动力链结构上看，它是稳定关节，但稳定的并不是它自己，而是肩关节。在实际运动中，肩胛胸关节和肩关节是联动运动的，而且前者为后者提供稳定性，是后者得以安全展现灵活的基础。但是这个“稳定”恰恰是通过肩胛胸关节本身的灵活性来展现的，比如手臂上举时的上回旋。</p>
</li>
<li><p>肩关节——灵活</p>
<p> 没的说，人体最灵活的关节，也是人体最不稳定的关节，其球窝关节的解剖结构已经说明了一切。</p>
</li>
<li><p>肘关节——稳定</p>
<p>结构上跟膝关节相对，但是实际上要比膝关节灵活的多。所以如果进化论成立的话，人类从四脚着地变成双脚着地的过程，使我们的下肢关节趋向于稳定，上肢关节趋向于灵活。而这正与 “开链”或者“闭链”的需求相适应。</p>
</li>
</ol>
<h3 id="开链-amp-闭链"><a href="#开链-amp-闭链" class="headerlink" title="开链&amp;闭链"></a>开链&amp;闭链</h3><p>我们的关节同时存在S与M，而在整体的运动中有不同的体现，甚至于同样是S或者M的上下肢关节却存在了显著的差别。那么在此我们需要引出一个新的概念：<strong>开链</strong> &amp; <strong>闭链</strong>。</p>
<h4 id="开链"><a href="#开链" class="headerlink" title="开链"></a>开链</h4><p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg2bltahoj30dg09h74k.jpg" alt=""></p>
<p>开链，简单地说就是我们身体产生力量，改变了外界物体的运动状态。比如说哑铃二头弯举，投掷，摘苹果等动作都是开链动作。我们可以认为我们的身体在对抗趋于无穷小的阻力，那么我们就可以随意改变物体的运动状态，随便摆弄它，所以此时我们的肢体的灵活性就可以充分的发挥。比如我们的上肢就是以开链运动为主的，所以它整体表现出更好的灵活性。</p>
<h4 id="闭链"><a href="#闭链" class="headerlink" title="闭链"></a>闭链</h4><p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2bq4z76j30fk0dp0tf.jpg" alt=""></p>
<p>闭链，简单的说就是我们的身体产生力量，却没能推动外界的物体，反而改变了我们自身的运动状态。比如说跑步与深蹲，我们扒地，我们蹬地，并没有让地板产生位移，我们自己却向前或者向上运动了。所以我们可以认为闭链运动时，我们的身体在对抗趋于无穷大的阻力，我们根本不可能改变它，所以只能运动我们自己。而在面对这样无穷大的阻力的时候，我们需要将我们的关节摆在力学结构最优的位置上才能发挥我们自身的最大经济性和效率，而且在这个状态下，各个关节的位置直接影响了身体的整体姿态和状态，所以灵活性被抑制。我们的下肢，最擅长、做的最多的就是闭链运动，所以它更加的趋于稳定。</p>
<p>开链和闭链直接影响我们的训练适应，因为它们所表现的力学结构是不同的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解动力链并不是让我们<strong>装逼</strong>的，而是让我们更加了解人体的客观规律来指导训练的。</p>
<p>它是一个非常好的思考工具。比如我们在训练下肢力量的时候，我们就需要考虑髋关节灵活性对于下肢力量表现的影响，于是乎我们可能更加重点强化髋的产力能力。但是当考虑到屈髋动作时，也许实际中更多的是开链的屈髋，所以我们就能以此为依据来选择髂腰肌和股直肌的训练动作。</p>
<p>除此之外，每个关节本身的功能完整性是非常重要的，如果一个关节有功能缺陷，那么在整体运动中它就不能够尽到它的职责，所以一定会有另外一个或者几个关节来代偿它的功能，那么就相当于一个3人的团队，一个请假了，另外两个就得加班。如果一次两次没关系，它要是请了一年的产假，那么另外俩人可能会由于长期超负荷工作而积劳成疾。当然，对于公司来说我可以再雇人，但是我们的人体可没有能再多长一个关节之说。</p>
<p>所以其实很多跑步膝的问题恰是由于髋和踝的功能缺陷而导致的。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fhg2buv4nwj30ia0a2dfx.jpg" alt=""></p>
<p><strong>最后我要再次强调</strong>：任何一个关节，稳定与灵活同时存在，只不过体现的程度和侧重不同。在动力链中，灵活的关节不代表没有稳定，更不代表稳定不重要；稳定的关节也需要灵活，而且灵活可能是稳定的基础。</p>
<p>了解了动力链，你会更懂运动中的人体，也许你有了思考问题的方向，但仍然缺少方法，所以你还需要具备<a href="http://qiubaiying.github.io/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7/" target="_blank" rel="noopener">「功能性」</a>的思维方式。</p>
<blockquote>
<p>转自 <a href="https://zhuanlan.zhihu.com/p/20774747" target="_blank" rel="noopener">《体能训练之动力链》</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之功能性</title>
    <url>/folder/2017/07/10/2017-07-10-%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>体能训练是一种开源的程序它所依仗的并不是固有的方法手段，而是能够贯穿始终的逻辑，它是一种指导实践的思维方式，我们管它叫“体能思路”。</p>
<p>体能思路有两个方向，一个是原点，一个是过程。所谓原点我们认为是人体的本质属性，比如之前我们分享的五大运动素质以及动力链理论。所谓过程是我们分析问题实现目的的思考方向以及逻辑，它主要体现在接下来要跟大家分享的功能性原则和金字塔。</p>
<p>今天先来说功能性原则。</p>
<h2 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h2><p>我们所说的功能性是一种解决问题的思维方式，而功能性训练则定义了一种多关节参与，多平面运动的复杂练习。功能性训练是具体的，比较好理解，我就不赘述了，也不评价其优劣，因为在“功能性”的思维方式下，只存在目标之下的合适与否。</p>
<h3 id="什么是功能性？"><a href="#什么是功能性？" class="headerlink" title="什么是功能性？"></a>什么是功能性？</h3><p>我们把它定义为目标导向下的效率，所以它是一种程度的体现。如果一个练习与目标的相关性强，那么我们认为它具备较强的功能意义；而如果一个练习与它的目标背道而驰，那么我们就认为它缺乏功能意义。</p>
<p>举个例子，对于偏瘫患者来说，一个手指的屈伸就已经具备非常强的功能意义了，而对于一个马拉松爱好者来说，静蹲的价值可能并不是想象中那么高。</p>
<p>一般来说，在思考功能性问题的时候我习惯从以下三个方面入手：<strong>肌肉的生理适应</strong> 、<strong>动作模式</strong> 和 <strong>专项需求</strong>。</p>
<h4 id="1-肌肉的生理适应"><a href="#1-肌肉的生理适应" class="headerlink" title="1. 肌肉的生理适应"></a>1. 肌肉的生理适应</h4><p>其实练肌肉谁都会，是一个相对好入手的技能，但是当你给这个行为赋予体能训练使命的时候就需要思考一些问题，比如说你现在练习所发展的东东真的是你实际运动中所需要的东东么？</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg24pm22dj30e709474v.jpg" alt=""></p>
<p>我们都知道肌肉的生理收缩模式可以简单的分为向心收缩，离心收缩和静力收缩。现在的研究表明，这三种收缩模式的练习所产生的适应性提高存在显著的特异性。也就是说我向心练习所发展的能力只在向心运动中表现最好，在离心和静力中都不佳。同样，离心收缩也只能获得最好的离心能力收益。而静力就更变态，其训练最佳效果仅仅体现在所锻炼的关节角度下，换一个角度能够迁移的效果有可能都不到一半儿。这样看来，你的训练是不是并没有达到你想要的效果呢？</p>
<p>举个例子：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1fhg251pmatj30go0b5q5d.jpg" alt=""></p>
<p>为什么静蹲对于跑步爱好者来说可能并没有那么理想？因为膝关节股四头肌在跑步中以离心缓冲为主，而且角度在伸膝末端的30°左右，而静蹲却是在屈曲90°左右的角度下呆着不动……着不动……不动……动……</p>
<p>除此之外，需要考虑的问题还很多，比如说发力模式，是加速？减速？还是匀速？再比如关节活动角度上发力点的位置，是伸展末端发力？屈曲极限发力？还是在屈伸过程中的某一点发力？阻力加在哪里，就会在哪里产生最好的适应，那么功能的意义就体现在这里。</p>
<h4 id="2-动作模式"><a href="#2-动作模式" class="headerlink" title="2. 动作模式"></a>2. 动作模式</h4><p>动作模式是动作程序的体现，而基础动作模式是诸多复杂动作模式共性的抽象体现，并且基础动作模式一定是符合解剖结构和生物力学特点的，说白了也就是我们人体被设计来应该完成的动作。</p>
<p>如果说大多数运动都可以认为是基础动作模式的升级与排列组合，同时基础动作模式本身又能衍生出来很多训练动作，那么选择和实际运动相对应的练习就是另一个功能性的体现了。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg25l7ep2j30g609o0ue.jpg" alt=""></p>
<p>比如说发展起跳能力，因为跳是蹲的升级，所以我一定首选深蹲练习；再比如说跑步，存在大量的下肢摆动与支撑的交替，摆动可以认为是下肢开链屈髋与蹬伸，而支撑可以认为是下肢单腿蹲的一瞬间，那么我会选择箱式单腿蹲，保加利亚蹲，悬垂屈髋等等；再再比如，拳击是基于“旋转”加“上肢推”加“单腿蹲”的动作模式，那么我就要练习剪蹲…旋转…单臂…推举…吗？</p>
<p>其实动作模式的选择要结合动力链一起去思考，这里除了要思考开链还是闭链之外，还要考虑动力链的完整性以及发力的顺序或者说是力学结构。说到上肢推的动作模式，水平推的话我相信很多人都会想到卧推和俯卧撑，那么这两个动作的功能性如何评价呢？</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg26a2ve0j30go0ce76n.jpg" alt=""></p>
<p><strong>卧推</strong>，一个挺奇葩的动作，奇葩在哪呢？来，咱们数数卧推的主动关节都有哪些：肩关节，肘关节。那么我们上肢链在上肢推动作模式下参与的关节都有哪些呢？肩关节，肘关节！就这些么？再想想！其实你还疏漏了一个非常重要的关节——<strong>肩胛胸关节</strong>！几乎所有上肢的动作都以肩胛胸关节的运动为基础，而卧推却并没有，特别是标准的卧推~</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg26h6oejj30go09lwgj.jpg" alt=""></p>
<p><strong>俯卧撑</strong>，虽然肩胛胸，肩关节，肘关节全面参与到运动中去，但不巧的是它是一个闭链运动，而实际运动中我们的上肢会以开链为主！呵呵~</p>
<p>别着急，认真你就输了！上面两段其实是个伪命题，我这么做主要是想通过这个平易近人的例子来帮助大家掌握的分析问题的思路！如果你需要发展上肢最大力量表现，那么显然卧推是你的首选。而如果你要优化上肢的力学结构，特别是水平推的发力顺序，那么俯卧撑是你首选。再如果你要提高上肢的延展性以及伴随旋转的加速能力，那么单臂水平推的练习给你的帮助最大！</p>
<p>所以，选择什么，看目标喽~</p>
<h4 id="3-专项需求"><a href="#3-专项需求" class="headerlink" title="3. 专项需求"></a>3. 专项需求</h4><p>其实这个非常好理解，也是功能性原则的根本目的，但是为了和上面两个方向区分开，这里主要针对的是不同的运动素质需求。</p>
<p>Q：对一个英超的后卫进行长距离高强度的游泳练习是否具备功能性意义？！</p>
<p>A：具备！</p>
<p>Q：为什么？</p>
<p>A：因为他喜欢游泳，这个可以让他心情愉悦然后更好的训练和比赛！</p>
<p>咳咳！当然，这样的答案是合情合理的！但是我们不妨换一个角度去分析。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg26rdi6vj30go0b4goo.jpg" alt=""></p>
<p>英超，几乎是足球联赛中对抗最强的，他们的后卫每场比赛动不动就跑个8千1万的，而这8千1万真心不是慢慢悠悠颠儿下来的，而是各种加速减速变向拼抢，所以其强度非常之大。那么这就需要很好的心肺系统功能，一方面体现在有氧与无氧耐力上，另一方面呼吸器官的机能上。游泳练习，不仅可以提高有氧以及无氧耐力，其水环境还可以给胸扩张带来阻力，直接锻炼了呼吸肌的收缩能力。另外，水环境真的能够给人们带来愉悦的感觉，特别是水流水压给肌肉和筋膜的按摩效果，真的是一举两得的“功能性”训练。</p>
<p>还有，你以为篮球运动员的拳击练习真的只是给枯燥乏味的体能训练增加一点乐趣么？并不是！</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg276m81pj31h50rgtbv.jpg" alt=""></p>
<p><strong>1. 拳击可以在发生场内冲突的时候很好地保护自己；</strong></p>
<p><strong>2. 拳击运动可以强化旋转动作模式下的速度、稳定、和准确性；</strong></p>
<p><strong>3. 拳击是手脚高度协调的运动，对于发展手脚搭配的动作灵敏有神奇的效果。</strong></p>
<p>而这些不就是一名篮球运动员所需要的么？！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以，功能性原则，解决的是“<strong>为什么练</strong>（for！not why）以及 <strong>练什么</strong>”的问题！</p>
<p>如果我们是简单活动活动身体那就算了，但如果我们要进行一个有针对性的体能训练，那么请琢磨琢磨你选择的动作是否合理，是否能够满足你的专项需求！</p>
<p>所以，招财猫式弹力带抗阻外旋真的是练习肩袖首推的动作么？</p>
<p>所以，蚌式练习和dirty dog真的是发展髋外旋外展能力最好的练习么？</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fhg28jvnhqj30dw099q3z.jpg" alt=""></p>
<p>所以，仰卧卷腹发展出来的腹直肌是好看呢？还是好用呢？</p>
<p>所以，我们真的要来一次大清洗，摒弃掉我们以前那些练习么？</p>
<p>当然不要！每一个动作都有它存在的意义，都有它的价值所在！有可能这个动作和你要发展的能力不直接相关，但是它可能是你进行“功能性”训练的基础，你不得不去做它！</p>
<p>所以，训练的逻辑很重要！</p>
<blockquote>
<p>转自<a href="https://zhuanlan.zhihu.com/p/20786373" target="_blank" rel="noopener">《体能训练之功能性》</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title>「体能训练理论」之金字塔</title>
    <url>/folder/2017/07/10/2017-07-10-%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E9%87%91%E5%AD%97%E5%A1%94/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>体能，人体基础运动能力的统称，人体的本质属性，它支撑着日常生活工作的需要，也支撑着运动技战术的表现。 体能思路，是指导我们设计实施体能训练的思维方式，分析逻辑。它包括回归原点的 <strong>五大运动素质</strong> &amp; <a href="http://qiubaiying.top/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E5%8A%A8%E5%8A%9B%E9%93%BE/" target="_blank" rel="noopener"><strong>动力链理论</strong></a>，也包括在过程中引领方向的 <a href="http://qiubaiying.top/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7/" target="_blank" rel="noopener"><strong>功能性原则</strong></a> 和 <a href="http://qiubaiying.top/2017/07/10/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA-%E4%B9%8B%E9%87%91%E5%AD%97%E5%A1%94/" target="_blank" rel="noopener"><strong>金字塔</strong></a> 。</p>
<h2 id="金字塔"><a href="#金字塔" class="headerlink" title="金字塔"></a>金字塔</h2><p>体能训练是一门实践科学，实践先于理论，而理论印证实践。体能训练有四大基础学科，分别是运动解剖学、运动生理学、运动生物力学和运动训练学。</p>
<p>五大运动素质对应生理学和运动训练学；动力链对应解剖学和运动生物力学；功能性对应着生理和生物力。而金字塔则对应了它们全部！或者说金字塔其实是诸学科在体能训练中的交汇，它囊括了所有之前的理论，并且赋予了更深层的意义。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg20ydk8uj30go0brwh1.jpg" alt=""></p>
<p>金字塔代表了人体运动能力发展的客观规律，它是一个流程的引领，思维的分级，以及训练阶段的划分。</p>
<p>这里包括 <strong>关节功能+核心控制</strong>、<strong>基础动作模式</strong>、<strong>基础力量</strong>、<strong>综合体能</strong>、<strong>专项运动</strong>。他们在逻辑上互为基础和进阶，关节是动作的基础，动作承载力量，力量支撑各个运动素质，而专项是各个运动素质在具体运动中的表现。</p>
<p>也许这么说可能不能够让大家有清晰的认识，那么接下来我就把每层的内容和它们之间的逻辑关系简单的跟大家分享一下。 99%的运动者都是基础不足，上层过度。我们从基础开始，从下往上说起。</p>
<h3 id="运动基础（关节功能-核心控制）"><a href="#运动基础（关节功能-核心控制）" class="headerlink" title="运动基础（关节功能 + 核心控制）"></a>运动基础（关节功能 + 核心控制）</h3><p>运动基础主要内容包括 <strong>关节功能</strong> 和 <strong>核心控制</strong> 能力。</p>
<p>人体的关节功能有两个属性，一个是灵活性，一个是稳定性。举例来说，很多人由于长期缺乏锻炼，肩关节灵活性缺失，第一次学习竖直上举时，怎么努力都举不到头顶，显然应该先改善肩关节灵活性。再比如，膝关节的结构导致它只能进行屈伸的运动，所以我们要保证运动过程中不出现膝内扣，膝外翻的现象，也就是膝关节需要具备的稳定能力。在健身之前我们，应该先评估我们的关节功能。</p>
<p>运动基础中的第二部分内容就是核心控制能力。很多健身者入门者都会觉得核心是腹肌，觉得练核心的目的是拥有一个好看的腹肌。实际上，腹肌只是核心的一部分，核心是指一个区域，我们的整个躯干都属于核心区域。</p>
<p>运动的外在表现虽来源于四肢，比如跑步时你的四肢在运动，但是一个出色的外在运动表现是建立在稳定的核心基础之上的。如果躯干不稳定，在跑步的过程中整个脊柱很松散，甩来甩去，这样是很难提高跑步速度的。所以在学习动作之前，应该先加强核心控制能力。</p>
<p>所以我们会推荐没有进行过抗阻训练、长期久坐的同学先去练习一段时间的瑜伽和普拉提，瑜伽可以很好地改善关节灵活性，进而提高身体的柔韧性；而普拉提能提高的核心控制能力，并提高关节稳定性。<br>一个合格的健身训练者，应该了解不同的训练体系，他要知道自身还缺乏什么，然后向不同的训练体系去借鉴，以提高自己。</p>
<h3 id="基础动作模式"><a href="#基础动作模式" class="headerlink" title="基础动作模式"></a>基础动作模式</h3><h4 id="什么是基础动作模式？"><a href="#什么是基础动作模式？" class="headerlink" title="什么是基础动作模式？"></a>什么是基础动作模式？</h4><p>简单地说就是，所有动作肢体特有的运动程序。人体就这么些零件，所以很多的动作之间都存在着些许的共性，我们将这些共性提炼出来并进行功能上的抽象，那么就形成了我们现在所要说的基础动作模式——<strong>双腿蹲</strong>、<strong>单腿蹲</strong>、<strong>推</strong>、<strong>拉</strong>、<strong>旋转</strong>、<strong>屈髋</strong>。</p>
<ul>
<li><strong>蹲</strong>：分为单腿蹲、双腿蹲。对应的训练动作有剪蹲和深蹲。</li>
<li><strong>推</strong>：分为水平推、竖直推。对应的训练动作是卧推和实力举。</li>
<li><strong>拉</strong>：分为竖直拉、水平拉。竖直拉包括引体向上、高位下拉，水平拉包括弹力带划船等等。</li>
<li><strong>屈髋</strong>：最具代表性的动作就是硬拉。</li>
<li><strong>旋转</strong>：动作比较复杂，在训练当中比较少出现，适合比较资深的训练者，比如说劈和砍，比如下劈球，比如拿锤子砸轮胎。前期不建议做，当你有一定训练水平的时候再去做旋转类动作。</li>
</ul>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1fhg20yeticj30go0ptdmg.jpg" alt=""></p>
<h4 id="基础动作模式的意义是什么？"><a href="#基础动作模式的意义是什么？" class="headerlink" title="基础动作模式的意义是什么？"></a>基础动作模式的意义是什么？</h4><ol>
<li>教会我们如何正确的使用我们的身体</li>
<li>评估你的是否存在关节功能缺陷</li>
</ol>
<p>基于基础动作模式的学习意义和诊断意义，我们对待健身者或者需要进行体能训练的人很多时候都从这里开始。如果诊断结果良好，那么我们学习动作之后就可以上升到基础力量训练，如果诊断出关节功能缺陷，我们就要进行针对性的解决。</p>
<h3 id="基础力量（肌肉力量）"><a href="#基础力量（肌肉力量）" class="headerlink" title="基础力量（肌肉力量）"></a>基础力量（肌肉力量）</h3><p>力量是所有运动素质的基础，如果你没有足够的力量，很多事情都很难完成。你想学习倒立，如果上肢力量足够，只需要了解动作技巧和细节，可能半个小时就能学会倒立。但是如果力量水平很低，就算把各种技巧和细节都学会了，也没有力气把自身撑起来，更不可能完成倒立。日常生活中，力量水平不足经常会成为我们突破运动瓶颈的障碍，有足够的力量才能跑得更快、跑得更远、跳得更高。所以，力量是所有运动素质的基础。</p>
<p>因此，在金字塔的这层，我们就要从徒手训练的阶段进阶到自由力量训练的阶段。负重和徒手的训练效果差异非常大，它不仅仅在于力量的提高，在重心控制、身体平衡、协调性控制等方面的区别也很大。力量训练能让身体各项能力同时提高，只有真正进入力量训练阶段（对于健身来说），才可以说真正踏上健身入门之路。</p>
<h3 id="训练目标（综合体能和专项体能）"><a href="#训练目标（综合体能和专项体能）" class="headerlink" title="训练目标（综合体能和专项体能）"></a>训练目标（综合体能和专项体能）</h3><p>最后，我们来到了金字塔的顶端，这就是我们的最终追求。</p>
<p>综合体能在此指的是体能所包含的五大运动素质——力量，速度，灵敏，耐力，柔韧。对于有专项运动需求的人，我们需要有针对性的重点发展这五大运功素质中的某几个。</p>
<p>当我们身体各关节灵活性和稳定性都可以满足要求，且核心控制能力也很强的情况下，又在标准动作的基础上储备了足够的肌肉力量，那么，不管你的目标是减肥，增肌，或者是进行某一个竞技性运动项目，你都可以相对安全且轻松地达成你的目标。</p>
<p>一般我们把还处在第一第二层的健身者称为健身入门者。不管你是刚刚走进健身房的新手，还是健身多年的老司机，都可以根据这个健身发展流程来审视自己目前的训练处在哪一个阶段。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>体能训练金字塔告诉我们，体能训练要从关节功能和核心控制开始训练，通过六大基础运动模式的训练增强身体基础力量，只有基础力量够了，我们才能真正开始我们的训练目标，根据我们训练的项目增强专项体能，比如拳击，我们要增强力量，耐力，灵敏。</p>
<p>清楚了这个体能训练金字塔之后，更重要的事还是要去执行。执行层面会涉及更多技术问题，也就是我们常说的如何做标准的动作，如何制定适合自己的训练计划等等。</p>
<p>健身是一项系统性工程，愿每一个人都能找到方法，科学有效地塑造自己的身体。</p>
<blockquote>
<p>参考 </p>
</blockquote>
<blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/20801623" target="_blank" rel="noopener">《体能训练之金字塔》</a></li>
<li><a href="http://www.jianshenjiaolian.com.cn/lingjichu-fazhan.html" target="_blank" rel="noopener">零基础健身者的运动发展流程</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode9 无线调试功能</title>
    <url>/folder/2017/07/04/2017-07-04-Xcode9-%E6%97%A0%E7%BA%BF%E8%B0%83%E8%AF%95%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<blockquote>
<p>支持：Xcode 9 及 iOS 11</p>
</blockquote>
<p>使用数据线连接 iPhone 到电 Mac，Mac 和 iPhone 必须在同一个局域网</p>
<h3 id="1-打开设备列表"><a href="#1-打开设备列表" class="headerlink" title="1. 打开设备列表"></a>1. 打开设备列表</h3><p>使用快捷键盘 <code>⇧⌘2</code><br>或 在 Xcode 菜单栏选择 Window &gt; Devices and Simulators,打开设备列表</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fh6uij2kq9j30dg08l417.jpg" alt=""></p>
<h3 id="2-勾选在线调试按钮"><a href="#2-勾选在线调试按钮" class="headerlink" title="2. 勾选在线调试按钮"></a>2. 勾选在线调试按钮</h3><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fh6ugx3097j30rl06kq4i.jpg" alt=""></p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fh6ugwec7sj30re06gdhl.jpg" alt=""></p>
<h3 id="3-拔掉数据线"><a href="#3-拔掉数据线" class="headerlink" title="3. 拔掉数据线"></a>3. 拔掉数据线</h3><p>这时就可以无线调试了。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fh6uhd01f8j30ef05v75k.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>开发技巧</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>快速配置zsh</title>
    <url>/folder/2017/06/19/2017-06-19-%E5%BF%AB%E9%80%9F%E9%85%8D%E7%BD%AEzsh/</url>
    <content><![CDATA[<blockquote>
<p>比较水的 Personal Notes</p>
</blockquote>
<h2 id="查看你的系统有几种shell"><a href="#查看你的系统有几种shell" class="headerlink" title="查看你的系统有几种shell"></a>查看你的系统有几种shell</h2><pre><code>cat /etc/shells</code></pre><p>显示</p>
<pre><code>/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh</code></pre><h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 oh my zsh</h2><pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre><p>重新打开终端，输入 </p>
<pre><code>zsh</code></pre><p>即可切换终端，并且发现 oh my zsh 已经帮我们配置好 zsh 了</p>
<h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><pre><code>open ~/.zshrc </code></pre><p>修改 <code>ZSH_THEME=”robbyrussell”</code>，主题在 ~/.oh-my-zsh/themes 目录下。<br>修改为</p>
<pre><code>ZSH_THEME=&quot;kolo&quot;</code></pre><p>可以<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">参照这里</a>进行选择.</p>
<h2 id="设置为默认shell"><a href="#设置为默认shell" class="headerlink" title="设置为默认shell"></a>设置为默认shell</h2><pre><code>chsh -s /bin/zsh</code></pre><h2 id="添加自定义命令"><a href="#添加自定义命令" class="headerlink" title="添加自定义命令"></a>添加自定义命令</h2><pre><code>open ~/.zshrc</code></pre><p>添加显示隐藏文件的快捷命令</p>
<pre><code>alias fd=&apos;defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder&apos;
alias fh=&apos;defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder&apos;</code></pre>]]></content>
      <tags>
        <tag>终端</tag>
        <tag>zsh</tag>
        <tag>Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Swift 中使用 IBInspectable</title>
    <url>/folder/2017/05/05/2017-05-05-%E5%9C%A8-Swift-%E4%B8%AD%E4%BD%BF%E7%94%A8-IBInspectable/</url>
    <content><![CDATA[<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过 IB 设置 控件 的属性非常的方便。</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff9fpog0vrj30ho084t9m.jpg" alt=""></p>
<p>但是缺点也很明显，那就是有一些属性没有暴露在 IB 的设置面板中。这时候就要使用 <code>@IBInspectable</code> 在 IB 面板中添加这些没有的属性。</p>
<p>关于在 OC 中使用 <code>IBInspectable</code> 可以看一下我的 <a href="http://qiubaiying.top/2016/12/01/%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E5%9C%86%E8%A7%92%E5%92%8C%E6%8F%8F%E8%BE%B9/#高级" target="_blank" rel="noopener">这篇文章</a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>在项目中最常遇到的情况是为 view 设置圆角、描边，以及为 文本控件 添加本地化字符串。</p>
<h2 id="圆角、描边"><a href="#圆角、描边" class="headerlink" title="圆角、描边"></a>圆角、描边</h2><p>先来看看设置圆角、描边</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBInspectable</span> <span class="keyword">var</span> cornerRadius: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> layer.cornerRadius</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            layer.cornerRadius = newValue</span><br><span class="line">            layer.masksToBounds = newValue &gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBInspectable</span> <span class="keyword">var</span> borderWidth: <span class="type">CGFloat</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> layer.borderWidth</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            layer.borderWidth = newValue &gt; <span class="number">0</span> ? newValue : <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@IBInspectable</span> <span class="keyword">var</span> borderColor: <span class="type">UIColor</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">UIColor</span>(cgColor: layer.borderColor!)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            layer.borderColor = newValue.cgColor</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加完成就可以在 IB 中设置 view 的这些属性了</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff9h5afhv2j30f803ajri.jpg" alt=""></p>
<p>运行效果</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff9h70z922j30ag061wf7.jpg" alt=""></p>
<h2 id="利用-IBDesignable-在-IB-中实时显示-IBInspectable-的样式"><a href="#利用-IBDesignable-在-IB-中实时显示-IBInspectable-的样式" class="headerlink" title="利用 @IBDesignable 在 IB 中实时显示 @IBInspectable 的样式"></a>利用 @IBDesignable 在 IB 中实时显示 @IBInspectable 的样式</h2><p>创建一个新的 class 继承 <code>UIView</code> ，并且使用 <code>@IBDesignable</code> 声明</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="meta">@IBDesignable</span> <span class="class"><span class="keyword">class</span> <span class="title">IBDesignableView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 IB 中，选择 view 的 class 为 我们新建的 <code>IBDesignableView</code></p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gy1ff9hs6z5q1j30fr03vweu.jpg" alt=""></p>
<p>这样在 IB 调整属性时，这些属性的变化就会实时显示在 IB 中。</p>
<h2 id="本地化字符串"><a href="#本地化字符串" class="headerlink" title="本地化字符串"></a>本地化字符串</h2><p>本地化字符串的解决方法和上面的添加圆角一样</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBInspectable</span> <span class="keyword">var</span> localizedKey: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newValue = newValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            text = <span class="type">NSLocalizedString</span>(newValue, comment: <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> text &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIButton</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBInspectable</span> <span class="keyword">var</span> localizedKey: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newValue = newValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            setTitle(<span class="type">NSLocalizedString</span>(newValue, comment: <span class="string">""</span>), <span class="keyword">for</span>: .normal)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> titleLabel?.text &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITextField</span> </span>&#123;</span><br><span class="line">    <span class="meta">@IBInspectable</span> <span class="keyword">var</span> localizedKey: <span class="type">String?</span> &#123;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> newValue = newValue <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">            placeholder = <span class="type">NSLocalizedString</span>(newValue, comment: <span class="string">""</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> placeholder &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，在 IB 中我们就可以利用对应类型的 Localized Key 来直接设置本地化字符串了：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79gy1ff9h94um01j30aj01vjre.jpg" alt=""></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p><code>IBInspectable</code> 可以使用这些的类型</p>
<ul>
<li><code>Int</code></li>
<li><code>CGFloat</code></li>
<li><code>Double</code></li>
<li><code>String</code></li>
<li><code>Bool</code></li>
<li><code>CGPoint</code></li>
<li><code>CGSize</code></li>
<li><code>CGRect</code></li>
<li><code>UIColor</code></li>
<li><code>UIImage</code></li>
</ul>
<p>合理的使用<code>@IBInspectable</code> 能减少很多的模板代码，提高我们的开发效率。</p>
<blockquote>
<p>参考</p>
<ul>
<li><a href="https://onevcat.com/2017/04/storyboard-argue/" target="_blank" rel="noopener">《再看关于 Storyboard 的一些争论》</a></li>
<li><a href="https://medium.com/@Anantha1992/ibdesignable-and-ibinspectable-in-swift-3-702d7dd00ca" target="_blank" rel="noopener">《@IBDesignable and @IBInspectable in Swift 3》</a></li>
</ul>
</blockquote>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>IBInspectable</tag>
      </tags>
  </entry>
  <entry>
    <title>R.swift 的使用</title>
    <url>/folder/2017/05/04/2017-05-04-R.swift-%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
<h1 id="什么是-R-swift"><a href="#什么是-R-swift" class="headerlink" title="什么是 R.swift"></a>什么是 R.swift</h1><p>介绍 <a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 前，我们先看看 R.swift 能做什么</p>
<p>通常，我们是基于 字符串 来获取资源，例如：图片、xib、或者是 segue</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = <span class="type">UIImage</span>(named: <span class="string">"myImage"</span>)</span><br><span class="line"><span class="keyword">let</span> myViewController = <span class="type">R</span>.storyboard.main.myViewController()</span><br></pre></td></tr></table></figure>

<p>使用 R.swfit，我们可以这样写</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myImage = <span class="type">R</span>.image.myImage()</span><br><span class="line"><span class="keyword">let</span> viewController = <span class="type">R</span>.storyboard.main.myViewController()</span><br></pre></td></tr></table></figure>

<p>R.swift 通过扫描你的各种基于字符串命名的资源，创建一个使用类型来获取资源。</p>
<p>在保证类型安全的同时，也在自动补全的帮助下节省了大量的时间。</p>
<h1 id="导入-R-swift"><a href="#导入-R-swift" class="headerlink" title="导入 R.swift"></a>导入 R.swift</h1><p><a href="https://github.com/mac-cain13/R.swift" target="_blank" rel="noopener">R.swift</a> 开源在 github 上。</p>
<p>这里是导入的<a href="https://vimeo.com/122888912" target="_blank" rel="noopener">视频教程</a></p>
<p>使用 CocoaPods 导入项目中</p>
<ol>
<li><p>添加 <code>pod &#39;R.swift&#39;</code>到 Podfile 文件，然后运行 <code>pod install</code></p>
</li>
<li><p>添加一个 <code>New Run Script Phase</code></p>
<p> <img src="https://ww4.sinaimg.cn/large/006tKfTcgy1ff84sw06qxj30vm0hrq6s.jpg" alt=""></p>
</li>
<li><p>将 <code>Run Script</code> 拖动到 <code>Check Pods Manifest.lock</code> 的下面，并且添加脚本 <code>&quot;$PODS_ROOT/R.swift/rswift&quot; &quot;$SRCROOT/项目名称&quot;</code></p>
<p> <img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff853qjiucj30yp0kkn1b.jpg" alt=""></p>
</li>
<li><p><code>Command+B</code> 编译项目，在项目代码目录下，会生成一个 <code>R.generated.swift</code> 的文件，将它拖如项目中</p>
<blockquote>
<p>注意：不要勾选 <code>Copy items if needed</code> 选项，因为每次编译都会生成新的 <code>R.generated.swift</code> 文件，copy 的话，旧的 <code>R.generated.swift</code> 将不会被覆盖。</p>
</blockquote>
<p> <img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff85epj1qpj30qj0hdn17.jpg" alt=""></p>
</li>
</ol>
<blockquote>
<p>tip： 可以在添加 <code>.gitignore</code> 添加一行 <code>*.generated.swift</code> 忽略该文件，避免造成冲突</p>
</blockquote>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>导入完成后，就可以在使用 R.swift 了</p>
<p> <img src="https://github.com/mac-cain13/R.swift/raw/master/Documentation/Images/DemoUseImage.gif" alt=""> </p>
<p>关于 R.swift 的更多用法，可以 <a href="https://github.com/mac-cain13/R.swift/blob/master/Documentation/Examples.md" target="_blank" rel="noopener">看这里</a>。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 的懒加载和计算型属性</title>
    <url>/folder/2017/05/03/2017-05-03-Swift-%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%AE%A1%E7%AE%97%E5%9E%8B%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>常规（简化）写法</p>
<p>懒加载的属性用 <code>var</code> 声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy var name: String = &#123;</span><br><span class="line">	return &quot;BY&quot;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>完整写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazy var name: String = &#123; () -&gt; String i</span><br><span class="line">	return &quot;BY&quot;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>本质是一个创建一个闭包 <code>{}</code> 并且在调用该属性时执行闭包 <code>()</code>。</p>
<p>如OC的懒加载不同的是 swift 懒加载闭包只调用一次，再次调用该属性时因为属性已经创建，不再执行闭包。</p>
<h3 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h3><p>常规写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name: string &#123;</span><br><span class="line">	return &quot;BY&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整写法 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name: string &#123;</span><br><span class="line">	get &#123;</span><br><span class="line">		return &quot;BY&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算型属性本质是重写了 <code>get</code> 方法，其类似一个无参有返回值函数，每次调用该属性都会执行 <code>return</code></p>
<p>通常这样使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct Cuboid &#123;</span><br><span class="line">    var width = 0.0, height = 0.0, depth = 0.0</span><br><span class="line">    var volume: Double &#123;</span><br><span class="line">        return width * height * depth</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let fourByFiveByTwo = Cuboid(width: 4.0, height: 5.0, depth: 2.0)</span><br><span class="line">print(&quot;the volume of fourByFiveByTwo is \(fourByFiveByTwo.volume)&quot;)</span><br><span class="line">// Prints &quot;the volume of fourByFiveByTwo is 40.0&quot;</span><br></pre></td></tr></table></figure>

<h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><p>相同点</p>
<ul>
<li>使用方法完全一致</li>
<li>都是用 <code>var</code> 声明</li>
</ul>
<p>不同点</p>
<ul>
<li><p>实现原理不同</p>
<p>  懒加载是第一次调用属性时执行闭包进行赋值</p>
<p>  计算型属性是重写 <code>get</code> 方法</p>
</li>
<li><p>调用 <code>{}</code>的次数不同</p>
<p>  懒加载的闭包只在属性第一次调用时执行<br>  计算型属性每次调用都要进入 <code>{}</code> 中，<code>return</code> 新的值</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Swift语法</tag>
      </tags>
  </entry>
  <entry>
    <title>RVM 使用指南</title>
    <url>/folder/2017/04/28/2017-04-28-RVM-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<blockquote>
<p>RVM 常用的命令整理</p>
</blockquote>
<p>RVM 是一个命令行工具，可以提供一个便捷的多版本 Ruby 环境的管理和切换。<a href="https://rvm.io/" target="_blank" rel="noopener">https://rvm.io/</a></p>
<p>我相信做为iOS开发者，对ruby的使用都是从安装 <strong>CocoaPods</strong> 开始的吧~</p>
<blockquote>
<p><strong>Note</strong>：这里所有的命令都是再用户权限下操作的，任何命令最好都不要用 sudo.</p>
</blockquote>
<h2 id="RVM-安装"><a href="#RVM-安装" class="headerlink" title="RVM 安装"></a>RVM 安装</h2><pre><code>$ gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
$ \curl -sSL https://get.rvm.io | bash -s stable
$ source ~/.bashrc
$ source ~/.bash_profile</code></pre><p>修改 RVM 的 Ruby 安装源到 <a href="https://ruby-china.org/" target="_blank" rel="noopener">Ruby China</a> 的 Ruby 镜像服务器，这样能提高安装速度</p>
<pre><code>$ echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db</code></pre><h2 id="Ruby版本的安装与切换"><a href="#Ruby版本的安装与切换" class="headerlink" title="Ruby版本的安装与切换"></a>Ruby版本的安装与切换</h2><p>列出已知的 Ruby 版本</p>
<pre><code>rvm list known</code></pre><p>安装一个 Ruby 版本</p>
<pre><code>rvm install 2.2.0 --disable-binary</code></pre><p>切换 Ruby 版本</p>
<pre><code>rvm use 2.2.0</code></pre><p>如果想设置为默认版本，这样一来以后新打开的控制台默认的 Ruby 就是这个版本</p>
<pre><code>rvm use 2.2.0 --default </code></pre><p>查询已经安装的ruby</p>
<pre><code>rvm list</code></pre><p>卸载一个已安装版本</p>
<pre><code>rvm remove 1.8.7</code></pre><blockquote>
<p>参考：<a href="https://ruby-china.org/wiki/rvm-guide" target="_blank" rel="noopener">https://ruby-china.org/wiki/rvm-guide</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>ruby</tag>
        <tag>shell</tag>
        <tag>RVM</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS自动打包</title>
    <url>/folder/2017/04/20/2017-04-20-iOS%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<blockquote>
<p>利用xcode的命令行工具 <code>xcdeobulid</code> 进行项目的编译打包，生成ipa包，并上传到fir</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在网上的自动打包教程几乎都还是<code>xcodebuild + xcrun</code>的方式先生成<code>.app</code>包 再生成<code>.ipa</code>包,结果弄了一整天硬是没成功~</p>
<p>后来发现<code>PackageApplication is deprecated</code>，悲剧。然后手动压缩的 <code>.ipa</code>包因为签名问题无法装到手机上。</p>
<p>后来用了<code>archive + -exportArchive</code>终于可以了~</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Xcodebuild"><a href="#Xcodebuild" class="headerlink" title="Xcodebuild"></a>Xcodebuild</h2><p><strong>xcodebuild</strong> 的使用可以用 <code>man xcodebuild</code>查看。</p>
<p>查看项目详情</p>
<pre><code># cd 项目主目录
xcodebuild -list</code></pre><p>输出项目的信息</p>
<pre><code>Information about project &quot;StackGameSceneKit&quot;:
    Targets:
        StackGameSceneKit
        StackGameSceneKitTests

    Build Configurations:
        Debug
        Release

    If no build configuration is specified and -scheme is not passed then &quot;Release&quot; is used.

    Schemes:
        StackGameSceneKit</code></pre><p>要留意 <code>Configurations</code>，<code>Schemes</code>这两个属性。</p>
<h2 id="自动打包流程"><a href="#自动打包流程" class="headerlink" title="自动打包流程"></a>自动打包流程</h2><h3 id="生成-archive"><a href="#生成-archive" class="headerlink" title="生成 archive"></a>生成 archive</h3><p>生成archive的命令是 <code>xcodebuild archive</code> </p>
<pre><code>xcodebuild archive -workspace ${project_name}.xcworkspace \
               -scheme ${scheme_name} \
               -configuration ${build_configuration} \
               -archivePath ${export_archive_path}</code></pre><ul>
<li><p>参数一：项目类型，，如果是混合项目 workspace 就用 <code>-workspace</code>，如果是 project 就用 <code>-project</code></p>
</li>
<li><p><code>-scheme</code>：项目名，上面<code>xcodebuild -list</code>中的 <code>Schemes</code></p>
</li>
<li><p><code>-configuration</code>：编译类型，在<code>configuration</code>选择, <code>Debug</code> 或者 <code>Release</code></p>
</li>
<li><p><code>-archivePath</code>：生成 archive 包的路径，需要精确到 <code>xx/xx.archive</code></p>
</li>
</ul>
<p>首先需要创建一个<code>AdHocExportOptions.plist</code>文件</p>
<h3 id="导出ipa包"><a href="#导出ipa包" class="headerlink" title="导出ipa包"></a>导出ipa包</h3><p>导出<code>.ipa</code>包经常会出现错误，<del>在ruby2.4.0版本中会报错，所以请使用其他版本的ruby</del>,最初的原因是使用了 ruby2.4.0 进行编译时出现的错误。</p>
<p>解决方法是低版本的 ruby 进行编译，如使用系统版本：<code>rvm use system</code>。后面升级macOS系统（10.12.5）后发现 ruby2.4.0 能成功 导出ipa包了。</p>
<p>导出ipa包使用命令：<code>xcodebuild  -exportArchive</code></p>
<pre><code>xcodebuild  -exportArchive \
            -archivePath ${export_archive_path} \
            -exportPath ${export_ipa_path} \
            -exportOptionsPlist ${ExportOptionsPlistPath}</code></pre><ul>
<li><code>archivePath</code>：上面生成 archive 的路径</li>
<li><code>-exportPath</code>：导出 ipa包 的路径</li>
<li><code>exportOptionsPlist</code>：导出 ipa包 类型，需要指定格式的<code>plist</code>文件，分别是<code>AppStroe</code>、<code>AdHoc</code>、<code>Enterprise</code>,如下图</li>
</ul>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff1bcz534ij30g609uq48.jpg" alt=""></p>
<p>选择这三个类别需要分别创建三个<code>plist</code>文件：</p>
<ul>
<li><p><code>AdHocExportOptionsPlist.plist</code></p>
<p>  <img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff1bhmwvxfj30ax01pdfu.jpg" alt=""></p>
</li>
<li><p><code>AppStoreExportOptionsPlist.plist</code></p>
<p>  <img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff1bijdlsgj30bh01st8q.jpg" alt=""></p>
</li>
<li><p><code>EnterpriseExportOptionsPlist.plist</code></p>
<p>  <img src="https://ww4.sinaimg.cn/large/006tNc79gy1ff1bishpk8j30be01sglm.jpg" alt=""></p>
</li>
</ul>
<h3 id="上传到-Fir"><a href="#上传到-Fir" class="headerlink" title="上传到 Fir"></a>上传到 Fir</h3><p>将项目上传到 <a href="https://fir.im" target="_blank" rel="noopener">Fir</a></p>
<p>下载 <a href="https://github.com/FIRHQ/fir-cli/blob/master/doc/install.md" target="_blank" rel="noopener">fir 命令行工具</a> </p>
<pre><code>gem install fir-cli</code></pre><p>获取 fir 的 API Token（右上角）</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79gy1ff28ccsqhyj304t07bwei.jpg" alt=""></p>
<p>上传</p>
<pre><code>fir publish &quot;ipa_Path&quot; -T &quot;firApiToken&quot;</code></pre><h2 id="自动打包脚本"><a href="#自动打包脚本" class="headerlink" title="自动打包脚本"></a>自动打包脚本</h2><p><del>再次提醒，请不要使用 ruby 2.4.0 运行该脚本！</del>，若在 ruby 2.4.0 下编译失败，请切换低版本的ruby。</p>
<p>切换完毕记得重新安装 fir 命令行工具。</p>
<p>脚本我fork了 <a href="https://github.com/jkpang/PPAutoPackageScript" target="_blank" rel="noopener">jkpang</a> 的脚本进行修改，添加了自动上传到 fir 的功能。</p>
<p>使用方法在Github上有详细介绍。</p>
<p>GitHub：<a href="https://github.com/qiubaiying/iOSAutoArchiveScript" target="_blank" rel="noopener">https://github.com/qiubaiying/iOSAutoArchiveScript</a></p>
<h3 id="利用-自定义终端指令-简化打包过程"><a href="#利用-自定义终端指令-简化打包过程" class="headerlink" title="利用 自定义终端指令 简化打包过程"></a>利用 自定义终端指令 简化打包过程</h3><p>以zsh为例:</p>
<pre><code>open ~/.zshrc</code></pre><p>添加自定义命令 cd + sh</p>
<pre><code>alias mybuild=&apos;cd 项目地址/iOSAutoArchiveScript/ &amp;&amp;  sh 项目地址/iOSAutoArchiveScript/iOSAutoArchiveScript.sh&apos;</code></pre><p>这样打开终端输入<code>mybuild</code>，就可以轻松实现一键打包上传了</p>
<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>ruby</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods 安装和使用</title>
    <url>/folder/2017/04/13/2017-04-13-CocoaPods-%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近换了新机器，重新搭建了开发环境，其中当然包括 <strong>CocoaPods</strong>。</p>
<p>装完顺便更新下 <strong>CocoaPods</strong> 安装文档。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>CocoaPods</strong> 是用 ruby 实现的，要想使用它首先需要有 ruby 的环境。</p>
<h4 id="升级ruby"><a href="#升级ruby" class="headerlink" title="升级ruby"></a>升级ruby</h4><pre><code>查看ruby版本 
$ ruby -v

ruby 2.0.0p648 (2015-12-16 revision 53162) [universal.x86_64-darwin16]</code></pre><p>CocoaPods需要<strong>2.2.2</strong>版本及以上的，我们先升级ruby。</p>
<p>使用 <strong>rvm</strong> 安装 ruby</p>
<pre><code>curl -L get.rvm.io | bash -s stable 
source ~/.bashrc
source ~/.bash_profile</code></pre><p>切换 ruby 源</p>
<p>ruby 下载源使用亚马逊的云服务被墙了，切换国内的 <strong>ruby-china源</strong> （<a href="https://ruby.taobao.org/" target="_blank" rel="noopener">https://ruby.taobao.org/</a>已经停止维护，详情<a href="https://ruby.taobao.org/" target="_blank" rel="noopener">查看公告</a>）：</p>
<pre><code>$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/
$ gem sources -l
*** CURRENT SOURCES ***

https://gems.ruby-china.org</code></pre><p>安装并切换 ruby</p>
<blockquote>
<p>这里不建议安装最新的 2.4.0 版本，因为次版本的 ruby，在xcodebuild 自动打包时，会出现问题！ 所以退一步，安装 2.3.3版本~</p>
</blockquote>
<pre><code>rvm install 2.3.3 --disable-binary
rvm use 2.3.3 --default</code></pre><p>到此ruby升级完毕.</p>
<p>有关RVM的使用可以看这篇 <a href="http://qiubaiying.github.io/2017/04/28/RVM-使用指南/" target="_blank" rel="noopener">RVM 使用指南</a></p>
<h4 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h4><ol>
<li><p>安装</p>
<pre><code>sudo gem install -n /usr/local/bin cocoapods</code></pre></li>
<li><p>升级版本库</p>
<pre><code>pod setup</code></pre><p> 这里需要下载版本库（非常庞大），需要等很久</p>
<pre><code>Receiving objects:  72% (865815/1197150), 150.07 MiB | 190.00 KiB/s</code></pre><p> 或者直接从其他装有cocoapod的电脑中拷贝<code>~/.cocoapods</code>到你的用户目录，然后再 <code>pod setup</code>会节省不少时间</p>
</li>
</ol>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h4 id="创建-podfile-文件"><a href="#创建-podfile-文件" class="headerlink" title="创建 podfile 文件"></a>创建 <code>podfile</code> 文件</h4><p>绝大多数人创建<code>podfile</code>都是用 <code>vim Podfile</code> 命令</p>
<p>其实pod 已经提供了创建 <code>podfile</code> 文件的命令，在工程目录下</p>
<pre><code>pod init</code></pre><p>将会自动生成 <code>podfile</code> 文件，并且为你写好了格式，稍做修改就能使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line"># platform :ios, &apos;9.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;projectName&apos; do</span><br><span class="line">  # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for projectName</span><br><span class="line"></span><br><span class="line">  target &apos;projectNameTests&apos; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  target &apos;projectNameUITests&apos; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>其中的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target &apos;projectNameTests&apos; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  target &apos;projectNameUITests&apos; do</span><br><span class="line">    inherit! :search_paths</span><br><span class="line">    # Pods for testing</span><br><span class="line">  end</span><br></pre></td></tr></table></figure>

<p>是指定在单元测试和UI测试时导入的测试框架，若没有使用测试框架可以删除。</p>
<p>修改iOS版本，添加<code>Alamofire</code>库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Uncomment the next line to define a global platform for your project</span><br><span class="line"># platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;projectName&apos; do</span><br><span class="line">  # Comment the next line if you&apos;re not using Swift and don&apos;t want to use dynamic frameworks</span><br><span class="line">  use_frameworks!</span><br><span class="line"></span><br><span class="line">  # Pods for projectName</span><br><span class="line">  </span><br><span class="line">  pod &apos;Alamofire&apos;, &apos;~&gt; 4.4&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="加载代码库"><a href="#加载代码库" class="headerlink" title="加载代码库"></a>加载代码库</h4><p>使用下面的命令，直接在本地版本库中查找对应的代码库信息，不升级版本库，节省时间</p>
<pre><code>pod install --verbose --no-repo-update</code></pre><p>若找不到库，再使用下面的命令</p>
<pre><code>pod install</code></pre><h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>对版本号的操作除了指定与不指定，你还可以做其他操作：</p>
<ul>
<li><code>\&gt;0.1</code>  高于0.1的任何版本</li>
<li><code>\&gt;=0.1</code>  版本0.1和任何更高版本</li>
<li><code>&lt;0.1</code>  低于0.1的任何版本</li>
<li><code>&lt;=0.1</code>  版本0.1和任何较低的版本</li>
<li><code>〜&gt;0.1.2</code>  版本 0.1.2的版本到0.2 ，不包括0.2。<br>这个基于你指定的版本号的最后一个部分。这个例子等效于&gt;= 0.1.2并且 &lt;0.2.0，并且始终是你指定范围内的最新版本</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>关于<strong>CocoaPods</strong>的安装和使用就这样简单的介绍完了，至于更多使用的方法（平时也用不到~）你可以用下面命令查看</p>
<pre><code>$ pod</code></pre><p>若对 CocoaPods 的<strong>个人仓库</strong>感兴趣，也可以看看我的这两篇博客</p>
<ul>
<li><p><a href="http://qiubaiying.top/2017/03/08/CocoaPods%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">CocoaPods公有仓库的创建</a></p>
</li>
<li><p><a href="http://qiubaiying.top/2017/03/10/CocoaPods%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/" target="_blank" rel="noopener">CocoaPods私有仓库的创建</a></p>
<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>Cocopods</tag>
        <tag>ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>强化 swift 中的 print</title>
    <url>/folder/2017/04/07/2017-04-07-%E5%BC%BA%E5%8C%96-Swift-%E4%B8%AD%E7%9A%84-print/</url>
    <content><![CDATA[<p>在 Swift 中，最简单的输出方法就是使用 <code>print()</code>，在我们关心的地方输出字符串和值。</p>
<p>当程序变得非常复杂的时候，我们可能会输出很多内容，而想在其中寻找到我们希望的输出其实并不容易。我们往往需要更好更精确的输出，这包括输出这个 log 的文件，调用的行号以及所处的方法名字等等。</p>
<p>在 Swift 中，编译器为我们准备了几个很有用的编译符号，它们分别是：</p>
<table><thead>
<tr>
<th>符号</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead><tbody>
<tr>
<td>#file</td>
<td>String</td>
<td>包含这个符号的文件的路径</td>
</tr>
<tr>
<td>#line</td>
<td>Int</td>
<td>符号出现处的行号</td>
</tr>
<tr>
<td>#column</td>
<td>Int</td>
<td>符号出现处的列</td>
</tr>
<tr>
<td>#function</td>
<td>String</td>
<td>包含这个符号的方法名字</td>
</tr>
</tbody></table>


<p>有了上面的这些编译符号，我们就可以自定义一个输出函数：<code>printm</code></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printm</span><span class="params">(items: <span class="keyword">Any</span>..., filename: String = #file, function: String = #function, line: Int = #line)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"[\((filename as NSString).lastPathComponent) \(line) \(function)]\n"</span>,items)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为输出是一个很消耗性能的操作，所以在releass环境下需要将输出函数去掉，将上面的函数换成：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">#<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printm</span><span class="params">(items: <span class="keyword">Any</span>..., filename: String = #file, function: String = #function, line: Int = #line)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"[\((filename as NSString).lastPathComponent) \(line) \(function)]\n"</span>,items)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printm</span><span class="params">(items: <span class="keyword">Any</span>..., filename: String = #file, function: String = #function, line: Int = #line)</span></span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h4 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h4><ul>
<li><a href="http://swifter.tips/log/" target="_blank" rel="noopener">《LOG 输出》</a> - 王巍 (@ONEVCAT)</li>
</ul>
<blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Debug</tag>
        <tag>Xcode</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 3.1 的新变化「译」</title>
    <url>/folder/2017/03/30/2017-03-30-Swift%203.1-%E7%9A%84%E6%96%B0%E5%8F%98%E5%8C%96%E3%80%8C%E8%AF%91%E3%80%8D/</url>
    <content><![CDATA[<p><img src="https://koenig-media.raywenderlich.com/uploads/2017/03/WhatsNewSwift3.1-feature-1-250x250.png" alt=""></p>
<p>Xcode 8.3 和 Swift 3.1 现在已经发布了(3/28)！</p>
<p>可以通过 <a href="https://itunes.apple.com/us/app/xcode/id497799835?ls=1&mt=12#" target="_blank" rel="noopener">AppStore</a> 或 <a href="https://developer.apple.com/download/more/" target="_blank" rel="noopener">Apple Developer</a> 进行下载</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fe2it3xwt6j30s50g3mya.jpg" alt=""></p>
<p>Xcode 8.3 优化了 Objective-C 与 Swift 混编项目的编译速度.</p>
<p>Swift 3.1 版本包含一些期待已久的 <a href="https://github.com/apple/swift-package-manager" target="_blank" rel="noopener">Swift package manager</a> 功能和语法本身的改进。</p>
<p>如果您没有密切关注 <a href="https://github.com/apple/swift-evolution" target="_blank" rel="noopener">Swift Evolution</a> 进程，请继续阅读 - 本文非常适合您！</p>
<p>在本文中，我将强调Swift 3.1中最重要的变化，这将对您的代码产生重大影响。我们来吧！😃</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>Swift 3.1与Swift 3.0源代码兼容，因此如果您已经使用Xcode 中的 <code>Edit \ Convert \ To Current Swift Syntax ...</code> 将项目迁移到Swift 3.0，新功能将不会破坏您的代码。不过，苹果已经在Xcode 8.3中支持Swift 2.3。所以如果你还没有从Swift 2.3迁移，现在是时候这样做了！</p>
<p>在下面的部分，您会看到链接的标签，如<code>[SE-0001]</code>。这些是 <a href="https://apple.github.io/swift-evolution/" target="_blank" rel="noopener">Swift Evolution</a> 提案号码。我已经列出了每个提案的链接，以便您可以发现每个特定更改的完整详细信息。我建议您尝试在Playground上验证新的功能，以便更好地了解所有更改的内容。</p>
<blockquote>
<p>Note:如果你想了解 swift 3.0 中的新功能，可以看<a href="https://www.raywenderlich.com/135655/whats-new-swift-3" target="_blank" rel="noopener">这篇文章</a>。</p>
</blockquote>
<h2 id="语法改进"><a href="#语法改进" class="headerlink" title="语法改进"></a>语法改进</h2><p>首先，我们来看看这个版本中的语法改进，包括关于数值类型的<code>可失败构造器</code>（<code>Failable Initializers</code>），新的序列函数等等。</p>
<h4 id="可失败的数值转换构造器（Failable-Numeric-Conversion-Initializers）"><a href="#可失败的数值转换构造器（Failable-Numeric-Conversion-Initializers）" class="headerlink" title="可失败的数值转换构造器（Failable Numeric Conversion Initializers）"></a>可失败的数值转换构造器（Failable Numeric Conversion Initializers）</h4><p>Swift 3.1 为所有数值类型 <code>(Int, Int8, Int16, Int32, Int64, UInt, UInt8, UInt16, UInt32, UInt64, Float, Float80, Double)</code> 添加了<a href="https://www.swiftmi.com/topic/121.html" target="_blank" rel="noopener">可失败构造器</a>。</p>
<p>这个功能非常有用，例如，以安全、可恢复的方式处理外源松散类型数据的转换，下面来看 Student 的 JSON 数组的处理：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">let</span> grade: <span class="type">Int</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">init</span>?(json: [<span class="type">String</span>: <span class="type">Any</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = json[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> gradeString = json[<span class="string">"grade"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">          <span class="keyword">let</span> gradeDouble = <span class="type">Double</span>(gradeString),</span><br><span class="line">          <span class="keyword">let</span> grade = <span class="type">Int</span>(exactly: gradeDouble)  <span class="comment">// &lt;-- 3.1 的改动在这</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.grade = grade</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeStudents</span><span class="params">(with data: Data)</span></span> -&gt; [<span class="type">Student</span>] &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .allowFragments),</span><br><span class="line">        <span class="keyword">let</span> jsonArray = json <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> jsonArray.flatMap(<span class="type">Student</span>.<span class="keyword">init</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> rawStudents = <span class="string">"[&#123;\"name\":\"Ray\", \"grade\":\"5.0\"&#125;, &#123;\"name\":\"Matt\", \"grade\":\"6\"&#125;,</span></span><br><span class="line"><span class="string">                    &#123;\"name\":\"Chris\", \"grade\":\"6.33\"&#125;, &#123;\"name\":\"Cosmin\", \"grade\":\"7\"&#125;, </span></span><br><span class="line"><span class="string">                    &#123;\"name\":\"Steven\", \"grade\":\"7.5\"&#125;]"</span></span><br><span class="line"><span class="keyword">let</span> data = rawStudents.data(using: .utf8)!</span><br><span class="line"><span class="keyword">let</span> students = makeStudents(with: data)</span><br><span class="line"><span class="built_in">dump</span>(students) <span class="comment">// [(name: "Ray", grade: 5), (name: "Matt", grade: 6), (name: "Cosmin", grade: 7)]</span></span><br></pre></td></tr></table></figure>
<p>在 <code>Student</code> 类中使用了一个可失败构造器将 <code>grade</code> 属性从 <code>Double</code> 转变为 <code>Int</code>，像这样</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> grade = <span class="type">Int</span>(exactly: gradeDouble)</span><br></pre></td></tr></table></figure>

<p>如果<code>gradeDouble</code>不是整数，例如6.33，它将失败。如果它可以用一个正确的表示Int，例如6.0，它将成功。</p>
<blockquote>
<p>Note：虽然<code>throwing initializers</code> 可以用来替代 <code>failable initializers</code>。但是使用 <code>failable initializers</code> 会更好，更符合人的思维。</p>
</blockquote>
<h5 id="新的序列函数（Sequence-Functions）"><a href="#新的序列函数（Sequence-Functions）" class="headerlink" title="新的序列函数（Sequence Functions）"></a>新的序列函数（Sequence Functions）</h5><p>swift3.1添加了两个新的标准库函数在 <code>Sequence</code> 协议中：<code>prefix(while:)``和prefix(while:)</code><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0045-scan-takewhile-dropwhile.md" target="_blank" rel="noopener">[SE-0045]</a>。</p>
<p>构造一个<a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank" rel="noopener">斐波纳契</a>无限序列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci = sequence(state: (<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">  (state: <span class="keyword">inout</span> (<span class="type">Int</span>, <span class="type">Int</span>)) -&gt; <span class="type">Int?</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">defer</span> &#123;state = (state.<span class="number">1</span>, state.<span class="number">0</span> + state.<span class="number">1</span>)&#125;</span><br><span class="line">  <span class="keyword">return</span> state.<span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Swift 3.0中，您只需指定<code>迭代次数</code>即可遍历fibonacci序列：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> fibonacci.<span class="keyword">prefix</span>(<span class="number">10</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(number)  <span class="comment">// 0 1 1 2 3 5 8 13 21 34</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在swift 3.1中，您可以使用<code>prefix(while:)</code>和<code>drop(while:)</code>获得符合条件在两个给定值之间的序列中的所有元素，就像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.1</span></span><br><span class="line"><span class="keyword">let</span> interval = fibonacci.<span class="keyword">prefix</span>(<span class="keyword">while</span>: &#123;$<span class="number">0</span> &lt; <span class="number">1000</span>&#125;).drop(<span class="keyword">while</span>: &#123;$<span class="number">0</span> &lt; <span class="number">100</span>&#125;)</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> interval &#123;</span><br><span class="line">  <span class="built_in">print</span>(element) <span class="comment">// 144 233 377 610 987</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>prefix(while:)</code>返回满足某个谓词的最长子序列。它从序列的开头开始，并停在给定闭包返回false的第一个元素上。</p>
<p><code>drop(while:)</code> 相反：它返回从给定关闭返回false的第一个元素开始的子序列，并在序列结尾完成。</p>
<blockquote>
<p>Note:这种情况，可以使用尾随闭包的写法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> interval = fibonacci.<span class="keyword">prefix</span>&#123;$<span class="number">0</span> &lt; <span class="number">1000</span>&#125;.drop&#123;$<span class="number">0</span> &lt; <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Concrete-Constrained-Extensions（姑且翻译为类的约束扩展吧）"><a href="#Concrete-Constrained-Extensions（姑且翻译为类的约束扩展吧）" class="headerlink" title="Concrete Constrained Extensions（姑且翻译为类的约束扩展吧）"></a>Concrete Constrained Extensions（姑且翻译为类的约束扩展吧）</h2><p>Swift 3.1允许您扩展具有类型约束的通用类型。以前，你不能像这样扩展类型，因为约束必须是一个协议。我们来看一个例子。</p>
<p>例如，Ruby on Rails提供了一种<code>isBlank</code>检查用户输入的非常有用的方法。以下是在Swift 3.0中用 <code>String</code> 类型的扩展实现这个<strong>计算型属性</strong>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isBlank: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> trimmingCharacters(<span class="keyword">in</span>: .whitespaces).isEmpty</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> abc = <span class="string">" "</span></span><br><span class="line"><span class="keyword">let</span> def = <span class="string">"x"</span></span><br><span class="line"> </span><br><span class="line">abc.isBlank <span class="comment">// true</span></span><br><span class="line">def.isBlank <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>如果你希望<code>isBlank</code>计算型属性为一个可选值所用，在swift 3.0中，你将要这样做</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">StringProvider</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> string: <span class="type">String</span> &#123;<span class="keyword">get</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">StringProvider</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> string: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> <span class="title">where</span> <span class="title">Wrapped</span>: <span class="title">StringProvider</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isBlank: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>?.string.isBlank ?? <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> foo: <span class="type">String?</span> = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">let</span> bar: <span class="type">String?</span> = <span class="string">"  "</span></span><br><span class="line"><span class="keyword">let</span> baz: <span class="type">String?</span> = <span class="string">"x"</span></span><br><span class="line"> </span><br><span class="line">foo.isBlank <span class="comment">// true</span></span><br><span class="line">bar.isBlank <span class="comment">// true</span></span><br><span class="line">baz.isBlank <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>这创建了一个采用 <code>String</code> 的 <code>StringProvider</code> 协议而在你使用StringProvider扩展可选的 wrapped 类型时,添加isBlank方法。</p>
<p>Swift 3.1中，用来替代协议方法，扩展具体类型的方法像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.1</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Optional</span> <span class="title">where</span> <span class="title">Wrapped</span> == <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isBlank: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>?.isBlank ?? <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就用更少的代码实现了和原先相同的功能~</p>
<h2 id="泛型嵌套（Nested-Generics）"><a href="#泛型嵌套（Nested-Generics）" class="headerlink" title="泛型嵌套（Nested Generics）"></a>泛型嵌套（Nested Generics）</h2><p>Swift 3.1允许您将嵌套类型与泛型混合。作为一个练习，考虑这个（不是太疯狂）的例子。每当某个团队领导raywenderlich.com想在博客上发布一篇文章时，他会分配一批专门的开发人员来处理这个问题，以满足网站的高质量标准：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">TeamType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> swift</span><br><span class="line">    <span class="keyword">case</span> iOS</span><br><span class="line">    <span class="keyword">case</span> macOS</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">BlogPostType</span> </span>&#123;</span><br><span class="line">      <span class="keyword">case</span> tutorial</span><br><span class="line">      <span class="keyword">case</span> article</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> title: <span class="type">T</span></span><br><span class="line">    <span class="keyword">let</span> type: <span class="type">BlogPostType</span></span><br><span class="line">    <span class="keyword">let</span> category: <span class="type">TeamType</span></span><br><span class="line">    <span class="keyword">let</span> publishDate: <span class="type">Date</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">init</span>(title: <span class="type">T</span>, type: <span class="type">BlogPostType</span>, category: <span class="type">TeamType</span>, publishDate: <span class="type">Date</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.title = title</span><br><span class="line">      <span class="keyword">self</span>.type = type</span><br><span class="line">      <span class="keyword">self</span>.category = category</span><br><span class="line">      <span class="keyword">self</span>.publishDate = publishDate</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">let</span> type: <span class="type">TeamType</span></span><br><span class="line">  <span class="keyword">let</span> author: <span class="type">T</span></span><br><span class="line">  <span class="keyword">let</span> teamLead: <span class="type">T</span></span><br><span class="line">  <span class="keyword">let</span> blogPost: <span class="type">BlogPost</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">init</span>(type: <span class="type">TeamType</span>, author: <span class="type">T</span>, teamLead: <span class="type">T</span>, blogPost: <span class="type">BlogPost</span>&lt;<span class="type">T</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">self</span>.type = type</span><br><span class="line">    <span class="keyword">self</span>.author = author</span><br><span class="line">    <span class="keyword">self</span>.teamLead = teamLead</span><br><span class="line">    <span class="keyword">self</span>.blogPost = blogPost</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>BlogPost</code>内部类嵌套在其对应的<code>Team</code>外部类中，并使两个类都通用。这是团队如何寻找我在网站上发布的教程和文章：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Team</span>(type: .swift, author: <span class="string">"Cosmin Pupăză"</span>, teamLead: <span class="string">"Ray Fix"</span>, </span><br><span class="line">     blogPost: <span class="type">Team</span>.<span class="type">BlogPost</span>(title: <span class="string">"Pattern Matching"</span>, type: .tutorial, </span><br><span class="line">     category: .swift, publishDate: <span class="type">Date</span>()))</span><br><span class="line"> </span><br><span class="line"><span class="type">Team</span>(type: .swift, author: <span class="string">"Cosmin Pupăză"</span>, teamLead: <span class="string">"Ray Fix"</span>, </span><br><span class="line">     blogPost: <span class="type">Team</span>.<span class="type">BlogPost</span>(title: <span class="string">"What's New in Swift 3.1?"</span>, type: .article, </span><br><span class="line">     category: .swift, publishDate: <span class="type">Date</span>()))</span><br></pre></td></tr></table></figure>

<p>但实际上，在这种情况下，您可以简化该代码。如果嵌套的内部类型使用通用外部类型，那么它默认继承父类的类型。因此，您不需要如此声明：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Team</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// original code </span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span> </span>&#123;</span><br><span class="line">    <span class="comment">// original code</span></span><br><span class="line">  &#125;  </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// original code </span></span><br><span class="line">  <span class="keyword">let</span> blogPost: <span class="type">BlogPost</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">init</span>(type: <span class="type">TeamType</span>, author: <span class="type">T</span>, teamLead: <span class="type">T</span>, blogPost: <span class="type">BlogPost</span>) &#123;</span><br><span class="line">    <span class="comment">// original code   </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Note：如果您想了解更多关于Swift中的<strong>泛型</strong>，请阅读我们最近更新的<a href="https://www.raywenderlich.com/154371/swift-generics-tutorial-getting-started" target="_blank" rel="noopener">Swift泛型入门的教程</a>。</p>
</blockquote>
<h2 id="Swift版本的可用性"><a href="#Swift版本的可用性" class="headerlink" title="Swift版本的可用性"></a>Swift版本的可用性</h2><p>您可以使用<strong>#if swift(&gt;= N)</strong> <code>静态构造</code>来检查特定的Swift版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line">#<span class="keyword">if</span> swift(&gt;=<span class="number">3.1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(exactly: number)</span><br><span class="line">  &#125;</span><br><span class="line">#elseif swift(&gt;=<span class="number">3.0</span>)</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Int</span>(number)</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>然而，当使用Swift标准库时，这种方法有一个主要缺点。它需要为每个受支持的旧语言版本编译标准库。这是因为当您以向后兼容模式运行Swift编译器时，例如您要使用Swift 3.0行为，则需要使用针对该特定兼容性版本编译的标准库版本。如果您使用版本3.1模式编译的，那么您根本就没有正确的代码</p>
<p>因此，@available除了现有平台版本 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0141-available-by-swift-version.md" target="_blank" rel="noopener">[SE-0141]</a> 之外，Swift 3.1扩展了该属性以支持指定Swift版本号：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.1</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">@available</span>(swift <span class="number">3.1</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Int</span>(exactly: number)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@available</span>(swift, introduced: <span class="number">3.0</span>, obsoleted: <span class="number">3.1</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intVersion</span><span class="params">(number: Double)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Int</span>(number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个新功能提供了与<code>intVersionSwift</code>版本有关的方法相同的行为。但是，它只允许像标准库这样的库被编译一次。编译器然后简单地选择可用于所选择的给定兼容性版本的功能。</p>
<blockquote>
<p>Note：注意：如果您想了解更多关于Swift 的<code>可用性属性（ availability attributes）</code>，请参阅我们关于<a href="https://www.raywenderlich.com/139077/availability-attributes-swift" target="_blank" rel="noopener">Swift中可用性属性的教程</a>。</p>
</blockquote>
<h2 id="逃逸闭包（Escaping-Closures）"><a href="#逃逸闭包（Escaping-Closures）" class="headerlink" title="逃逸闭包（Escaping Closures）"></a>逃逸闭包（Escaping Closures）</h2><p>在Swift 3.0 <a href="https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md" target="_blank" rel="noopener">[ SE-0103 ]</a> 中函数中的闭包的参数是默认是不逃逸的（non-escaping）。在Swift 3.1中，您可以使用新的函数<code>withoutActuallyEscaping()</code>将非逃逸闭包转换为临时逃逸。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(<span class="number">_</span> f: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>, simultaneouslyWith g: () -&gt; <span class="type">Void</span>,</span><br><span class="line">             on queue: <span class="type">DispatchQueue</span>) &#123;</span><br><span class="line">  withoutActuallyEscaping(f) &#123; escapableF <span class="keyword">in</span>     <span class="comment">// 1</span></span><br><span class="line">    withoutActuallyEscaping(g) &#123; escapableG <span class="keyword">in</span></span><br><span class="line">      queue.async(execute: escapableF)           <span class="comment">// 2</span></span><br><span class="line">      queue.async(execute: escapableG)     </span><br><span class="line"> </span><br><span class="line">      queue.sync(flags: .barrier) &#123;&#125;             <span class="comment">// 3</span></span><br><span class="line">    &#125;                                            <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数同时加载两个闭包，然后在两个完成之后返回。</p>
<ol>
<li><code>f</code> 与 <code>g</code> 进入函数后由非逃逸状态，分别转换为逃逸闭包:<code>escapableF</code>和<code>escapableG</code>。</li>
<li>async(execute:) 的调用需要逃逸闭包，我们在上面已经进行了转换。</li>
<li>通过运行<code>sync(flags: .barrier)</code>，您确保<code>async(execute:)</code>方法完全完成，稍后将不会调用闭包。</li>
<li>在范围内使用 <code>escapableF</code> and <code>escapableG</code>.</li>
</ol>
<p>如果你存储临时逃离闭包(即真正逃脱)这将是一个Bug。未来版本的标准库可以检测这个陷阱,如果你试图调用它们。</p>
<h2 id="Swift-Package-Manager-更新"><a href="#Swift-Package-Manager-更新" class="headerlink" title="Swift Package Manager 更新"></a>Swift Package Manager 更新</h2><p>啊，期待已久的 <strong>Swift Package Manage</strong> 的更新了！</p>
<h4 id="可编辑软件包（Editable-Packages）"><a href="#可编辑软件包（Editable-Packages）" class="headerlink" title="可编辑软件包（Editable Packages）"></a>可编辑软件包（Editable Packages）</h4><p>Swift 3.1将<code>可编辑软件包(editable packages)</code>的概念添加到Swift软件包管理器 <a href="https://github.com/apple/swift-package-manager/blob/master/Documentation/Usage.md#editable-packages" target="_blank" rel="noopener">[ SE-0082 ]</a>。</p>
<p>该<code>swift package edit</code>命令使用现有的<code>Packages</code>并将其转换为<code>editable Packages</code>。使用<code>--end-edit</code>命令将 <code>package manager</code> 还原回 <strong>规范解析的软件包（canonical resolved packag）</strong>。</p>
<h4 id="版本固定（Version-Pinning）"><a href="#版本固定（Version-Pinning）" class="headerlink" title="版本固定（Version Pinning）"></a>版本固定（Version Pinning）</h4><p>Swift 3.1 添加了版本固定的概念[ SE-0145 ]。该 <code>pin</code> 命令 固定一个或所有依赖关系如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">$ swift package pin --all      <span class="comment">// 固定所有的依赖</span></span><br><span class="line">$ swift package pin <span class="type">Foo</span>        <span class="comment">// 固定 Foo 在当前的闭包</span></span><br><span class="line">$ swift package pin <span class="type">Foo</span> --version <span class="number">1.2</span>.<span class="number">3</span>  <span class="comment">// 固定 Foo 在 1.2.3 版本</span></span><br></pre></td></tr></table></figure>

<p>使用<code>unpin</code>命令恢复到以前的包版本：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">$ swift package unpin —all</span><br><span class="line">$ swift package unpin <span class="type">Foo</span></span><br></pre></td></tr></table></figure>

<p>Package manager 将每个依赖库的版本固定信息存储在 <code>Package.pins</code> 文件中。如果该文件不存在，则Package manager 会自动创建。</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><code>swift package reset</code> 命令将会把 Package 重置干净。</p>
<p><code>swift test --parallel</code> 命令 执行测试。</p>
<h2 id="其他改动"><a href="#其他改动" class="headerlink" title="其他改动"></a>其他改动</h2><p>在 swift 3.1 中还有一些小改动</p>
<h4 id="多重返回函数"><a href="#多重返回函数" class="headerlink" title="多重返回函数"></a>多重返回函数</h4><p>C函数返回两次，例如<code>vfork</code> 和 <code>vfork</code>已经不用了。他们以有趣的方式改变了程序的控制流程。所以 Swift 社区 已经禁止了该行为，以免导致编译错误。</p>
<h4 id="自动链接失效（Disable-Auto-Linking）"><a href="#自动链接失效（Disable-Auto-Linking）" class="headerlink" title="自动链接失效（Disable Auto-Linking）"></a>自动链接失效（Disable Auto-Linking）</h4><p><a href="https://github.com/apple/swift-package-manager" target="_blank" rel="noopener">Swift Package Manager</a> 禁用了在C语言 <a href="http://nsomar.com/modular-framework-creating-and-using-them/" target="_blank" rel="noopener"><strong>模块映射（module maps）</strong></a>中的<strong>自动链接</strong>的功能：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Swift 3.0</span></span><br><span class="line">module <span class="type">MyCLib</span> &#123;</span><br><span class="line">    header “foo.h<span class="string">"</span></span><br><span class="line"><span class="string">    link “MyCLib"</span></span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Swift 3.1</span></span><br><span class="line">module <span class="type">MyCLib</span> &#123;</span><br><span class="line">    header “foo.h”</span><br><span class="line">    export *</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Swift 3.1改善了Swift 3.0的一些功能，为即将到来的Swift 4.0的大改动做准备。这些包括对泛型，正则表达式，更科学的<code>String</code>等方面的作出极大的改进。</p>
<p>如果你想了解更多，请转到 <a href="https://developer.apple.com/reference/swift?changes=latest_minor" target="_blank" rel="noopener">Swift standard library diffs</a> 或者查看官方的的<a href="https://github.com/apple/swift/blob/master/CHANGELOG.md" target="_blank" rel="noopener">Swift CHANGELOG</a>，您可以在其中阅读所有更改的信息。或者您可以使用它来了解 <strong>Swift 4.0</strong> 中的内容！</p>
<h2 id="著作权声明"><a href="#著作权声明" class="headerlink" title="著作权声明"></a>著作权声明</h2><p>本文译自 <a href="https://www.raywenderlich.com/156352/whats-new-in-swift-3-1" target="_blank" rel="noopener">What’s New in Swift 3.1?</a></p>
<p>由<a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a>进行翻译,首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>，转载请保留原文链接.</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>AsyncDisplayKit 2.0 教程:入门「译」</title>
    <url>/folder/2017/03/23/2017-03-23-AsyncDisplayKit-2.0-%E6%95%99%E7%A8%8B%EF%BC%9A%E5%85%A5%E9%97%A8%E3%80%8C%E8%AF%91%E3%80%8D/</url>
    <content><![CDATA[<blockquote>
<p>AsyncDisplayKit 2.0 Tutorial: Getting Started</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>“艺术是你任何能做到极致的事”</p>
</blockquote>
<p><a href="http://asyncdisplaykit.org/" target="_blank" rel="noopener"><strong>AsyncDisplayKit</strong></a> 是一个UI框架，最初诞生于 Facebook 的 <strong>Paper</strong> 应用程序。它是为了解决 Paper 团队面临的核心问题之一：如何尽可能缓解主线程的压力？</p>
<p>现在,许多应用程序的用户体验,很大程度上依赖于持续手势和物理动画。至少,你的UI可能是依赖于某种形式的 <code>scrollView</code>。</p>
<p>这些类型的用户界面完全依赖于主线程，并且对主线程阻塞非常敏感。主线程阻塞将导致丢帧，降低用户的体验。</p>
<p>一些主线程开销较大的任务包括：</p>
<ul>
<li><strong>计算尺寸和布局</strong>：比如  <code>-heightForRowAtIndexPath:</code>，或者在UILbel中调用 <code>-sizeThatFits</code> 以及<a href="http://floriankugler.com/2013/04/22/auto-layout-performance-on-ios/" target="_blank" rel="noopener">指数上升</a>的 <code>AutoLayout‘s</code>布局计算。</li>
<li><strong>图像解码</strong>：想要在一个 image view 中使用 <code>UIImage</code>，首先要进行解码。</li>
<li><strong>绘图</strong>：复杂的文本以及手动绘制渐变和阴影。</li>
<li><strong>对象生命周期</strong>：创建，操纵和销毁系统对象（即创建一个UIView）</li>
</ul>
<p>当正确使用时,AsyncDisplayKit 允许您在默认情况下异步执行所有测量、布局和渲染。无需任何额外的优化，一个应用程序可以减少约一个数量级的主线程开销。</p>
<p>除了这些性能优势，酷炫的 AsyncDisplayKit 还为开发者提供的便利接口，用简洁的代码就能完成复杂的功能。</p>
<p>在这两部分 <strong>AsyncDisplayKit 2.0</strong> 教程中，你将掌握使用ASDK构建一个实用的和动态的应用程序的所有要素。在第一部分中，你将要学习一些在你构建应用程序时可以用到的宏观思想。在<a href="https://www.raywenderlich.com/124696/asyncdisplaykit-2-0-tutorial-automatic-layout" target="_blank" rel="noopener">第二部分</a>中，你将学习如何构建自己 node 的 subclass，以及如何使用ASDK强大的布局引擎。为了更好的完成本教程，你需要会使用 Xcode 以及 熟悉 Objective-C。</p>
<blockquote>
<p><strong>免责声明</strong>：ASDK不兼容 <a href="http://www.youtube.com/watch?v=RY_X7l1g79Q&feature=youtu.be&t=29m37s" target="_blank" rel="noopener">Interface Builder和AutoLayout</a>，因此，您将不会在本教程中使用它们，虽然ASDK完全支持Swift(除了ComponentKit)，许多开发者仍在使用<br>Objective-C。免费App排行榜前100大多数都没有使用Swift（至少6个使用ASDK）。出于这些原因，本系列将重点介绍 Objective-C。话虽这么说，我们已经包括了一个Swift版本的实例项目。（嘴上说没有，代码还是很诚实的😂~）</p>
</blockquote>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先，<a href="https://koenig-media.raywenderlich.com/uploads/2016/12/AsyncDisplayKit-Starter-4.zip" target="_blank" rel="noopener">下载初始项目</a>。</p>
<p>该项目使用 <a href="https://cocoapods.org/" target="_blank" rel="noopener">CocoaPods</a> 来拉入AsyncDisplayKit。所以，在正常的 CocoaPods 体系下，打开 <code>RainforestStarter.xcworkspace</code> 而不是<code>RainforestStarter.xcodeproj</code>。</p>
<blockquote>
<p><strong>注意</strong>：需要网络连接才能完成本教程。</p>
</blockquote>
<p>构建并运行以查看包含 <code>UITableView</code> 动物列表的应用程序。如果你看过了代码，<code>AnimalTableController</code> 你会发现这是一个正常且熟悉的 <code>UITableViewController</code> 类。</p>
<blockquote>
<p><strong>注意</strong>：确保在真机上运行本教程中的代码，而不是在模拟器中运行。</p>
</blockquote>
<p>向上滑动你将看到帧数丢失引起的卡顿。你不需要启动控制台，以便能发现到这个应用程序需要在性能方面上的一些优化。</p>
<p>你可以通过 <strong>AsyncDisplayKit</strong> 的力量来解决这个问题</p>
<h1 id="ASDisplayNode-简介"><a href="#ASDisplayNode-简介" class="headerlink" title="ASDisplayNode 简介"></a>ASDisplayNode 简介</h1><p><code>ASDisplayNode</code> 是ASDK的核心类，它只是一个类似于 MVC 中的 “View” 一样的<code>UIView</code> 或 <code>CALayer</code>。认识一个 node 的最佳方法是参照你已经熟悉的 <code>UIViews</code> 和 <code>CALayers</code> 之间的关系。</p>
<p>记住，iOS应用程序中的所有在屏幕上的显示都通过<code>CALayer</code>对象表示的。<code>UIViews</code> 创建并且拥有一个底层的 <code>CALayer</code>，并为他们添加触摸处理和其他交互功能。<code>UIView</code> 并不是 <code>CALayer</code> 的子类，而是相互环绕，扩展其功能。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/view-layer-480x229.png" alt="">    </p>
<p>这种抽象的情况下扩展 <code>ASDisplayNode</code>：您可以将它们视为包装一个 view，就像在 view 上添加一个 layer 一样。</p>
<p>通常由 Node 创建的一个常规的view，其创建和配置都在行队列中执行，并且异步渲染。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/node-view-layer-480x161.png" alt=""></p>
<p>幸运的是，用于处理 Node 的 API 对于任何使用过的 <code>UIViews</code> 或者 <code>CALayers</code> 的人来说应该异常的熟悉。所有 View 的属性都可以等效为 Node 类。你可以访问基础的 view 或者 layer 本身，就像是访问 <code>view.layer</code> 一样</p>
<h1 id="节点容器（The-Node-Containers）"><a href="#节点容器（The-Node-Containers）" class="headerlink" title="节点容器（The Node Containers）"></a>节点容器（The Node Containers）</h1><p>虽然 Node 本身提供了巨大的性能改进的可能，但真正的强大的是它们与四个容器类结合使用时产生的黑魔法。</p>
<p>这些类包括：</p>
<ul>
<li><strong>ASViewController</strong>：一个 <code>UIViewController</code> 的子类，允许你提供要管理的 Node。</li>
<li><strong>ASCollectionNode</strong> and <strong>ASTableNode</strong>：Node 等效于 <code>UICollectionView</code> 和 <code>UITableView</code>，其子类实际上保留在底层。</li>
<li><strong>ASPagerNode</strong>:一个<code>ASCollectionNode</code>的子类，提供极好的滑动性能相比与 <code>UIKit</code> 的 <code>UIPageViewController</code> 来说。</li>
</ul>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/ragecomic-480x229.png" alt=""></p>
<p>说得好，但真正的黑魔法来自 <code>ASRangeController</code> 这些类用于影响所包含的 Node 的行为。现在，跟着我并把你们的脑袋放空吧~</p>
<h1 id="TableNode"><a href="#TableNode" class="headerlink" title="TableNode"></a>TableNode</h1><p>你要做的第一件事就是将当前 TableView 替换为 TableNode。这个没什么难度。</p>
<h4 id="将-TableView-替换为-TableNode"><a href="#将-TableView-替换为-TableNode" class="headerlink" title="将 TableView 替换为 TableNode"></a>将 TableView 替换为 TableNode</h4><p>首先，进入到 <code>AnimalTableController.m</code> 。在此类中添加下面代码下面代码。</p>
<pre><code>#import &lt;AsyncDisplayKit/AsyncDisplayKit.h&gt;</code></pre><p>这就导入了 ASDK 框架。</p>
<p>然后，我们继续，替换 <code>tableView</code> 的声明属性 ：</p>
<pre><code>@property  （ strong，nonatomic ） UITableView * tableView;</code></pre><p>替换为 <code>tableNode</code>：</p>
<pre><code>@property  （ strong，nonatomic ） ASTableNode * tableNode;</code></pre><p>这将导致这个类中很多地方报错，但不要慌张！</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/butBut-1-480x229.png" alt=""></p>
<p>别担心。这些错误和警告将作为你的向导，将代码转换成我们想要的。</p>
<p><code>-viewDidLoad</code> 中的报错是理所当然，因为 <code>tableView</code> 已经被替换掉。我不会让你通过 <code>tableNode</code> 替换 所有的 <code>tableView</code> 实例（我的意思是，查找和替换并非那么难），但是如果你做了，你会看到：</p>
<ol>
<li>你应该为 <code>ASTableNode</code> 分配一个属性。</li>
<li>table Node  没有调用 <code>-registerClass:forCellReuseIdentifier:</code> 方法。</li>
<li>你不能添加一个 node 到 subview</li>
</ol>
<p>此时，你应该将 <code>-viewDidLoad</code> 中的方法替换为：</p>
<pre><code>- (void)viewDidLoad {
  [super viewDidLoad];

  [self.view addSubnode:self.tableNode];
  [self applyStyle];
}</code></pre><p>这里要注意一个有趣的情况，你调用的是 UIView 的一个 <code>-addSubnode:</code> 方法，该方法是通过 category 添加到 <code>UIView</code> 上的，等效于: </p>
<pre><code>[self.view addSubview:self.tableNode.view];</code></pre><p>接下来，修改 <code>-viewWillLayoutSubviews</code> 中的代码：</p>
<pre><code>- (void)viewWillLayoutSubviews {
  [super viewWillLayoutSubviews];

  self.tableNode.frame = self.view.bounds;
}</code></pre><p>这样就替换用 <code>self.tableNode</code> 替换了 <code>self.tableView</code>，并且设置了 table 的 Frame</p>
<p>继续修改 <code>-applyStyle</code> 方法中的代码为：</p>
<pre><code>- (void)applyStyle {
  self.view.backgroundColor = [UIColor blackColor];
  self.tableNode.view.separatorStyle = UITableViewCellSeparatorStyleNone;
}</code></pre><p>这是唯一设置 table 的 <code>separatorStyle</code> 的一行代码。注意 tableNode 的 view 是如何访问 table 的 <code>separatorStyle</code> 属性的。<code>ASTableNode</code> 不会暴露所有<code>UITableView</code>的的属性，所以你必须通过 tableNode 底层的 <code>UITableView</code> 实例去设置 <code>UITableView</code> 的特殊属性。</p>
<p>然后，在 <code>-initWithAnimals:</code> 方法中添加。</p>
<pre><code>_tableNode = [[ASTableNode alloc] initWithStyle:UITableViewStylePlain];</code></pre><p>并且在 <strong>return</strong> 之前，调用：</p>
<pre><code>[self wireDelegation];</code></pre><p>这就会在初始化 <code>AnimalTableController</code> 的时候，创建了一个 tableNode 并且调用 <code>-wireDelegation</code> 方法 设置 tableNode 的 代理。</p>
<h4 id="设置-TableNode-的-DataSource-amp-Delegate"><a href="#设置-TableNode-的-DataSource-amp-Delegate" class="headerlink" title="设置  TableNode 的 DataSource &amp; Delegate"></a>设置  TableNode 的 DataSource &amp; Delegate</h4><p>类似于 <code>UITableView</code>，<code>ASTableNode</code> 也使用 DataSource 和 Delegate 来设置本身。TableNode 的<code>ASTableDataSource</code> 和 <code>ASTableDelegate</code> protocols 非常类似于 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code>。</p>
<p>事实上，虽然他们定义了一些完全相同的方法，如 <code>-tableNode:numberOfRowsInSection:</code>，但两组协议也不完全相同，因为 <code>ASTableNode</code> 行为和<code>UITableView</code>还以所有不同的。</p>
<p>找到 <code>-wireDelegation</code> 方法， 并用 <code>tableNode</code> 替换 <code>tableView</code>：</p>
<pre><code>- (void)wireDelegation {
  self.tableNode.dataSource = self;
  self.tableNode.delegate = self;
}</code></pre><p>现在， 你会收到警告, <code>AnimalTableController</code> 实际上不符合协议。目前，<code>AnimalTableController</code> 仅遵循 <code>UITableViewDataSource</code> 和 <code>UITableViewDelegate</code>协议。在下面的章节中，我们将遵循这些协议，使我们能够使用 tableNode 的功能。</p>
<h4 id="遵循-ASTableDataSource"><a href="#遵循-ASTableDataSource" class="headerlink" title="遵循 ASTableDataSource"></a>遵循 ASTableDataSource</h4><p>在 <code>AnimalTableController.m</code> 开头的地方找到 <code>AnimalTableController</code> 的 <code>DataSource</code> 扩展声明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimalTableController</span> (<span class="title">DataSource</span>)&lt;<span class="title">UITableViewDataSource</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>用 <code>ASTableDataSource</code> 替换 <code>UITableViewDataSource</code>为：</p>
<pre><code>@interface AnimalTableController (DataSource)&lt;ASTableDataSource&gt;
@end</code></pre><p>现在，<code>AnimalTableController</code> 已经遵循了 <code>AnimalTableController</code> 协议。本就该如此了。</p>
<p>导航到 <code>AnimalTableController.m</code> 的底部并找到 <code>DataSource</code> category 的实现。</p>
<p>首先，将 <code>UITableViewDataSource</code> 的 <code>-tableView:numberOfRowsInSection:</code>方法，<br>更改为<code>ASTableDataSource</code> 的版本。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)tableNode:(ASTableNode *)tableNode numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.animals.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着，<code>ASTableNodes</code> 的 cells 会以不同于 <code>UITableView</code> 的方式返回。用下面的代码替换 <code>-tableView:cellForRowAtIndexPath:</code> 以适应新的规则。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line">- (ASCellNodeBlock)tableNode:(ASTableView *)tableView nodeBlockForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  RainforestCardInfo *animal = <span class="keyword">self</span>.animals[indexPath.row];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 3 return ASCellNodeBlock</span></span><br><span class="line">  <span class="keyword">return</span> ^&#123;</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    CardNode *cardNode = [[CardNode alloc] initWithAnimal:animal];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//You'll add something extra here later...</span></span><br><span class="line">    <span class="keyword">return</span> cardNode;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们整理一下：</p>
<ol>
<li>ASDK 中的 <code>ASCellNode</code> 等价于 <code>UITableViewCell</code> 或者 <code>UICollectionViewCell</code>。要注意的是这个方法返回的是一个 <code>ASCellNodeBlock</code>，<code>ASTableNode</code> 维持着内部所有的 Cell，每个 indexPath 对应一个 block，并且随时准备进行初始化。</li>
<li>你的首要任务是通过数据模型构建cell。这是非常重要的一步，要注意！你获取数据后在 下面的 block 处理。不要在 block 里引用<code>indexPath</code>,以防止 block 运行前的数据变动。</li>
<li>然后返回一个 block，其返回值必须为 <code>ASCellNode</code>。</li>
<li>没有必要担心Cell的复用以及初始化一个Cell的方法。您可能会注意到您现在返回了<code>CardNode</code>，而不是<code>CardCell</code>。</li>
</ol>
<p>这让我想到一个重要的点。或许你已经了解到，<strong>使用 ASDK 不需要复用 cell</strong>，好吧，我已经说了两遍了，但能记住就好。请随意删除顶部<code>kCellReuseIdentifier</code>的定义吧</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> *kCellReuseIdentifier = <span class="string">@"CellReuseIdentifier"</span>;</span><br></pre></td></tr></table></figure>

<p>你不必再担心 <code>-prepareForReuse</code>了</p>
<h4 id="遵循-ASTableDelegate"><a href="#遵循-ASTableDelegate" class="headerlink" title="遵循 ASTableDelegate"></a>遵循 ASTableDelegate</h4><p>在 <code>AnimalTableController.m</code> 顶部，找到以下Delegate类别接口声明：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimalTableController</span> (<span class="title">Delegate</span>)&lt;<span class="title">UITableViewDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>用 <code>ASTableDelegate</code> 替换 <code>UITableViewDelegate</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnimalTableController</span> (<span class="title">Delegate</span>)&lt;<span class="title">ASTableDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>现在 <code>AnimalTableController</code> 已经遵循了 <code>ASTableDelegate</code>，是时候做处理了。在 <code>AnimalTableController.m</code> 底部找到 <code>Delegate</code> 分类的实现。</p>
<p>我们都知道，每个 <code>UITableView</code> 至少都要提供一个 <code>-tableView:heightForRowAtIndexPath:</code> 实现方法，因为每个 cell 的高度都由代理计算和返回。</p>
<p><code>ASTableDelegate</code> 中没有 <code>-tableView:heightForRowAtIndexPath:</code>。再 ASDK 中，所有的 <code>ASCellNode</code> 都负责确定自己的大小。你可以选择为单元格定义最小和最大尺寸，而不是提供静态高度。这种情况下，你希望每个cell的高度至少为屏幕的 2／3。</p>
<p>现在不用担心太多，这个会在第二部分中介绍。</p>
<p>现在只需要替换 <code>-tableView:heightForRowAtIndexPath:</code>为:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (ASSizeRange)tableView:(ASTableView *)tableNode </span><br><span class="line">  constrainedSizeForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  <span class="built_in">CGFloat</span> width = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width;</span><br><span class="line">  <span class="built_in">CGSize</span> min = <span class="built_in">CGSizeMake</span>(width, ([<span class="built_in">UIScreen</span> mainScreen].bounds.size.height/<span class="number">3</span>) * <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">CGSize</span> max = <span class="built_in">CGSizeMake</span>(width, INFINITY);</span><br><span class="line">  <span class="keyword">return</span> ASSizeRangeMake(min, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过我们的辛勤劳动，重新编译、运行项目，看看发生了什么。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/InfiniteScrollingGif.gif" alt=""></p>
<p>真是一个流畅的 <code>tableView</code>！一旦你开始做了，那就让我们做的更好吧！</p>
<h2 id="无限滚动"><a href="#无限滚动" class="headerlink" title="无限滚动"></a>无限滚动</h2><p>在大多数应用中，服务器的数据点的个数往往会多于当前 tableView 中显示的单元格数量。这意味着，你必须通过某些手段做无缝处理，以便用户刷完当前数据列表时从服务端加载新的数据。</p>
<p>很多时候，这是通过手动观察滚动视图方法中的内容偏移来处理 <code>scrollViewDidScroll:</code>, 使用 ASDK， 有一种更具说明性的处理方式。相反的，你可以预先确定好你需要加载的页数。</p>
<p>你要做的第一件事是取消已经存在的方法的注释。在 <code>AnimalTableController.m</code> 的结尾，取消 <code>Helpers</code> 分类中的两个方法。你可以认为 <code>-retrieveNextPageWithCompletion:</code> 是你的网络调用，而 <code>-insertNewRowsInTableNode:</code> 是个非常典型的再表中添加新的元素的方法。</p>
<p>接下来，在 <code>-viewDidLoad</code> 添加：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableNode.view.leadingScreensForBatching = <span class="number">1.0</span>;  <span class="comment">// overriding default of 2.0</span></span><br></pre></td></tr></table></figure>

<p>设置 <code>leadingScreensForBatching</code> 为 <strong>1.0</strong> 意味着当用户滑动一个屏的时候，就会载入新的数据。</p>
<p>继续，在 <code>Delegate</code> 分类中实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)shouldBatchFetchForTableNode:(ASTableNode *)tableNode &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法用于告诉 <code>tableView</code> 是否继续请求新的数据。如果返回 <code>NO</code>，则在到达 API 数据末尾时，不会再不会发出任何请求。</p>
<p>因为你希望无限滚动，那就返回 <code>YES</code>，以确保总是请求新的数据。</p>
<p>接下来，还要添加：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableNode:(ASTableNode *)tableNode willBeginBatchFetchWithContext:(ASBatchContext *)context &#123;</span><br><span class="line">  <span class="comment">//1</span></span><br><span class="line">  [<span class="keyword">self</span> retrieveNextPageWithCompletion:^(<span class="built_in">NSArray</span> *animals) &#123;</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    [<span class="keyword">self</span> insertNewRowsInTableNode:animals];</span><br><span class="line">    <span class="comment">//3</span></span><br><span class="line">    [context completeBatchFetching:<span class="literal">YES</span>];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法在用户滑动到 table 的末端并，且 <code>-shouldBatchFetchForTableNode:</code> 方法返回 <code>YES</code> 时被调用。</p>
<p>让我们回顾下上面的章节：</p>
<ol>
<li>首先，你要请求新的 animals 数据来展示。通常是通过 API 来获取的一组array。</li>
<li>完成后，用新下载的数据更新 tableView</li>
<li>最后，确保 <code>-completeBatchFetching:</code>返回的是<code>YES</code>，即大功告成。在完成操作之前，不会进行新的数据请求。</li>
</ol>
<p>Build and Run，并且不停的滚呀滚。你将会看到不停的看到一只鸟，他们是无限的。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/06/InfiniteScrollingGif.gif" alt=""></p>
<h2 id="智能预加载"><a href="#智能预加载" class="headerlink" title="智能预加载"></a>智能预加载</h2><p>你在工作中是否曾经遇到需要预先加载内容到 scrollView 或者 pageView 控制器中？也许你正在处理一个充满屏幕 image ，并且总是希望在接下来的几张图片加载时处于等待状态，所以用户很少看到占位符。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/03/iThinkIveGotThis-480x229.png" alt=""></p>
<p>当你再这样的体系下工作时，你很快就会意识到有很多问题要考虑。</p>
<ul>
<li>你占用了多少内存</li>
<li>你应该提前多久加载内容</li>
<li>你决定什么时候忽略用户的交互反映</li>
</ul>
<p>并且当你考虑到多个维度的内容时，将些问题将会变得更加复杂。假设你有一个<code>pageViewController</code>，里面每个 <code>viewController</code> 都带有一个 <code>collectionView</code>。现在，你就需要考虑如何在两个方向上动态加载内容。同时，还要对每个设备进行优化。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/12/officespaceboss.png" alt=""></p>
<p>还记得告诉你 <code>ASRangeController</code> 是不重要的吗？现在，这将是我们的重点。</p>
<p>在每个容器类中，所有包含的 node 都有一个接口状态的概念。在任何给定的时间，一个 node 可以是下面的任意组合：</p>
<ul>
<li><strong>Preload Range（预载范围）</strong>：通常最远的范围从可见区域。这是当cell的每个 subNode （例如ASNetworkImageNode） 的内容从外源加载，例如API和本地缓存。这与批量获取时，使用用模型对象代表cell本身形成对比。</li>
<li><strong>Display Range（显示范围）</strong>：在这里进行显示任务，例如文本绘制和进行图像解码。</li>
<li><strong>Visible Range（可见范围）</strong>：此时，node 至少有一个像素在屏幕上。</li>
</ul>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/12/preloadingRanges-small.png" alt=""></p>
<p>这些范围也适用于 <strong>screenfuls</strong> 的度量，并且可以使用 <code>ASRangeTuningParameters</code> 属性轻松调整。</p>
<p>例如：你正在使用一个 <code>ASNetworkImageNode</code>在 gallery 的每个页面中展示图像，当每个cell进入 <strong>Preload Range</strong> 时，会发送网络请求，并且在进入 <strong>Display Range</strong> 时进行图像解码。</p>
<p>通常来说，你不必对这些 <strong>Ranges</strong> 太较真。利用好已有的组件，如：<code>ASNetworkImageNode</code> 和 <code>ASTextNode</code>，通常来说你将会获得极大的便利。</p>
<blockquote>
<p><strong>注意</strong>: 有件不明显的事，这些 <strong>Ranges</strong> 不是堆栈的。相反，它们会在<br><strong>Visible Range</strong> 上重叠和汇聚。如果将显示和预取都设置为一个屏幕，则它们将完全相同。通常数据需要存在才能显示，所以一般预取范围应该稍大一点。那么在 node 到达该范围时，就可以开始显示。</p>
</blockquote>
<p>通常，该范围的前侧大于后侧。当用户改变其滚动方向时，范围的大小也是相反的，以便于对应用户实际移动的方向。</p>
<h2 id="Node接口的状态回调"><a href="#Node接口的状态回调" class="headerlink" title="Node接口的状态回调"></a>Node接口的状态回调</h2><p>你可能会疑惑：这些 <strong>Ranges</strong> 是如何正确工作的？很高兴你这样问~</p>
<p>系统中的每个 node 都有一个<code>interfaceState</code> 属性，是一个带有字段（(NS_OPTION）<code>ASInterfaceState</code>类型。<code>ASRangeController</code> 负责管理 <code>ASCellNode</code> 在 <code>scrolView</code> 上的移动，每个subNode 都由一个 <code>interfaceState</code> 属性做对应的更新。这意味着即使时 tree 中最深的 nodes 也可以相应 <code>interfaceState</code> 的变化。</p>
<p>幸运的是，我们很少需要直接去操作 node 的 <code>interfaceState</code> 上的 二进制位。更常见的做法时，你只需要对某 node 的特定的状态进行更改。这就是接口的状态回调。</p>
<h4 id="Node-命名"><a href="#Node-命名" class="headerlink" title="Node 命名"></a>Node 命名</h4><p>为了看到一个 node 的各种状态，给它命名时很有必要的。这样，你就可以监测每个 node 的数据加载、内容成、屏幕展示以及所以的事情。</p>
<p>回到代码<code>-tableNode:nodeBlockForRowAtIndexPath:</code>,添加一句注释</p>
<pre><code>//You&apos;ll add something extra here later...</code></pre><p>在它的下面，给 <code>cardNode</code> 添加一个 <code>debugName</code>：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">cardNode.debugName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"cell %zd"</span>, indexPath.row];</span><br></pre></td></tr></table></figure>
<h4 id="观察-Cells"><a href="#观察-Cells" class="headerlink" title="观察 Cells"></a>观察 Cells</h4><p>进入 <code>CardNode_InterfaceCallbacks.m</code> 中，你可以找到六种追踪 node 在 ranges 中的状态的方法。取消注释，Build and Run。打开你的控制台，然后慢慢滑动 table。对照你的滑动，观察cell在对应的状态变化。</p>
<blockquote>
<p><strong>注意</strong>： 大多数情况下，你只要关心 <code>-didEnterVisibleState</code> 或 <code>-didExitVisibleState</code> 方法对 <code>ASInterfaceState</code> 的改变。或者说，已经为你做好了许多引擎。你可以查看 <code>ASNetworkImageNode</code> 中的代码，看看你集成的通过<code>Preload</code> 和 <code>Display</code> 状态实现的功能。 所有 node 网络图片的请求和解码，以及内存的释放都是自动完成，不费吹灰之力。</p>
</blockquote>
<h2 id="智能预加载（续）"><a href="#智能预加载（续）" class="headerlink" title="智能预加载（续）"></a>智能预加载（续）</h2><p>在 <strong>2.0</strong> 版本中，已经介绍了多个维度上智能与加载的概念。假设你有一个竖直滚动的<code>tableView</code>，在其中某些Cell包含了水平滚动的 <code>collectionView</code>。</p>
<p><img src="https://koenig-media.raywenderlich.com/uploads/2016/07/proaldGif%5E2.gif" alt=""></p>
<p>尽管现在的技术能够实现，但你不会希望在到达可见区域之前预先加载全部的 collection。相反的，两个方向上的 scrollView 都由各自的 <code>ASRangeController</code> 单独控制自己的 range 参数。</p>
<h2 id="来到二次元"><a href="#来到二次元" class="headerlink" title="来到二次元"></a>来到二次元</h2><p>现在，你已经有了完整的 <code>AnimalTableController</code>， 你可以把它做为 ASPagerNode 的一个page。</p>
<p>项目已经提前写好了控制器的代码，首先进入 <strong><code>AppDelegate.m</code></strong>。</p>
<p>找到 <code>-installRootViewController</code> 的下面代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">AnimalTableController *vc = [[AnimalTableController alloc] </span><br><span class="line">                              initWithAnimals:[RainforestCardInfo allAnimals]];</span><br></pre></td></tr></table></figure>
<p>替换为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AnimalPagerController *vc = [[AnimalPagerController alloc] init];</span><br></pre></td></tr></table></figure>

<p>然后，跳到 <strong><code>AnimalPagerController.m</code></strong> 在 <code>-init</code> 方法中添加创建 <code>pager</code> 方法以及 <code>dataSource</code> 的数据源：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">_pagerNode = [[ASPagerNode alloc] init];</span><br><span class="line">_pagerNode.dataSource = <span class="keyword">self</span>;</span><br></pre></td></tr></table></figure>

<p>pagerNode 是 <code>ASCollectionNode</code> 的子类，使用方法与 <code>UIPageViewController</code> 一样。API 实际上比 <code>UIPageViewController</code> 要简单的多。</p>
<p>接下来要实现 pager 的 <code>dataSource</code> 方法，在底部找到 <code>ASPagerDataSource</code> 分类.</p>
<p>首先，告诉 pager 有几个页面。实际上当前的 animal 数组中有三组不同动物，我们需要重写 <code>-numberOfPagesInPagerNode:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSInteger</span>)numberOfPagesInPagerNode:(ASPagerNode *)pagerNode &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.animals.count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，你需要实现 <code>-pagerNode:nodeAtIndex</code> 方法，类似于先前实现的 ASTableNode 的 <code>dataSource</code> 方法。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (ASCellNode *)pagerNode:(ASPagerNode *)pagerNode nodeAtIndex:(<span class="built_in">NSInteger</span>)index &#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">NSArray</span> *animals = <span class="keyword">self</span>.animals[index];</span><br><span class="line">    <span class="comment">// 2</span></span><br><span class="line">    ASCellNode *node = [[ASCellNode alloc] initWithViewControllerBlock:^<span class="built_in">UIViewController</span> * _Nonnull&#123;</span><br><span class="line">        <span class="keyword">return</span>  [[AnimalTableController alloc] initWithAnimals:animals];</span><br><span class="line">    &#125; didLoadBlock:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来总结下这部分：</p>
<ol>
<li>尽管这个版本中没有进行模块化分，但是首先获取数据模型是个好习惯。</li>
<li>这一次，你使用的正是强大的 <code>-initWithViewControllerBlock:</code> 构造器。你所要做的就是返回一个block，这个 block 返回你提前设置好的 tableNodeController，它将自动展示在pager 的 页面中。真是太酷了😏~</li>
</ol>
<p>一旦你添加了这个方法，你将拥有一个完整功能的 Pagar，其中的 cell 是从你原先创建的 <code>tableNodeController</code> 生成的。现在，就可以在用户的垂直和水平滑动下，充分发挥二维预加载的功能！</p>
<p>要查看这个 AsyncDisplayKit 2.0 教程完整的项目，<a href="https://koenig-media.raywenderlich.com/uploads/2016/12/AsyncDisplayKit-Finished-4.zip" target="_blank" rel="noopener">点击这里进行下载</a>。如果你想查看swift版本，<a href="https://koenig-media.raywenderlich.com/uploads/2016/12/RainForestSwift-1.zip" target="_blank" rel="noopener">这里也有</a>。</p>
<p>准备好之后，请转到该项目的第2部分，了解 AsyncDisplayKit 2.0 引入的强大的新的布局系统。</p>
<p>如果你想先进行深入了解，你可以阅读 <a href="https://asyncdisplaykit.org/" target="_blank" rel="noopener">AsyncDisplayKit主页</a> 的文档。Scott Goodson（AsyncDisplayKit的原创作者）也有几个你可能会感兴趣的话题。最近的话题很好的概述了一些框架对处理大图片存在问题的的尝试。</p>
<p>你可能会对 <a href="https://www.youtube.com/watch?v=OiY1cheLpmI" target="_blank" rel="noopener">Paper的构建</a> 感兴趣。虽然当时并没有开源，并且有许多地方发生了变化，但看到这一切的开始还是挺有意思的。</p>
<p>这里有一个 <a href="https://github.com/facebook/AsyncDisplayKit/issues/1582" target="_blank" rel="noopener">public Skack channel</a> ,欢迎来提问~</p>
<h1 id="著作权声明"><a href="#著作权声明" class="headerlink" title="著作权声明"></a>著作权声明</h1><p>本文译自 <a href="https://www.raywenderlich.com/124311/asyncdisplaykit-2-0-tutorial-getting-started" target="_blank" rel="noopener">AsyncDisplayKit 2.0 Tutorial: Getting Started</a> .</p>
<p>由<a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a>进行翻译,首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>，转载请保留原文链接.</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Objective-C</tag>
        <tag>AsyncDisplayKit</tag>
        <tag>开源库</tag>
      </tags>
  </entry>
  <entry>
    <title>2017-03-17-Mac终端(zsh)下用代码编辑器打开文件或目录</title>
    <url>/folder/2017/03/17/2017-03-17-Mac%E7%BB%88%E7%AB%AF(zsh)%E4%B8%8B%E7%94%A8%E4%BB%A3%E7%A0%81%E7%BC%96%E8%BE%91%E5%99%A8%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近在喵神 onevcat 的直播中发现喵神直接在终端就能用 vsCode 打开当前代码目录，非常方便。</p>
<p> 在<code>zsh</code>终端中 使用 <code>code .</code>，在 <strong>vcCode</strong> 打开当前文件目录</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdpxob9m7sj31000rkam7.jpg" alt=""></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="配置终端环境"><a href="#配置终端环境" class="headerlink" title="配置终端环境"></a>配置终端环境</h2><p>终端环境为：<a href="https://www.iterm2.com/" target="_blank" rel="noopener">iTerm2</a> + <a href="https://wiki.archlinux.org/index.php/Zsh_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)" target="_blank" rel="noopener">zsh</a></p>
<p>zsh 使用 <a href="http://ohmyz.sh/" target="_blank" rel="noopener">oh_my_zsh</a> 配置</p>
<h2 id="安装zsh"><a href="#安装zsh" class="headerlink" title="安装zsh"></a>安装zsh</h2><h4 id="查看你的系统有几种shell"><a href="#查看你的系统有几种shell" class="headerlink" title="查看你的系统有几种shell"></a>查看你的系统有几种shell</h4><pre><code>cat /etc/shells</code></pre><p>显示</p>
<pre><code>/bin/bash
/bin/csh
/bin/ksh
/bin/sh
/bin/tcsh
/bin/zsh</code></pre><h4 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 oh my zsh</h4><pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></pre><p>重新打开终端，输入 </p>
<pre><code>zsh</code></pre><p>即可切换终端，并且发现 oh my zsh 已经帮我们配置好 zsh 了</p>
<h4 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h4><pre><code>open ~/.zshrc </code></pre><p>修改 <code>ZSH_THEME=”robbyrussell”</code>，主题在 ~/.oh-my-zsh/themes 目录下。<br>修改为</p>
<pre><code>ZSH_THEME=&quot;kolo&quot;</code></pre><p>可以<a href="https://github.com/robbyrussell/oh-my-zsh/wiki/themes" target="_blank" rel="noopener">参照这里</a>进行选择.</p>
<h4 id="设置为默认shell"><a href="#设置为默认shell" class="headerlink" title="设置为默认shell"></a>设置为默认shell</h4><pre><code>chsh -s /bin/zsh</code></pre><h2 id="修改-zsh-配置文件"><a href="#修改-zsh-配置文件" class="headerlink" title="修改 zsh 配置文件"></a>修改 <code>zsh</code> 配置文件</h2><pre><code>$ open ~/.zshrc</code></pre><p>在文件中加上这几行代码</p>
<p>对应 atom、SublimeText、与 vcCode。</p>
<pre><code>alias atom=&apos;/Applications/Atom.app/Contents/MacOS/Atom&apos;
alias subl=&apos;/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl&apos;
alias code=&apos;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&apos;</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>使用 vcCode 打开</p>
<pre><code>$ code .</code></pre><blockquote>
<p>本文首次发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>, 作者 <a href="http://github.com/qiubaiying" target="_blank" rel="noopener">@柏荧(BY)</a> ,转载请保留原文链接.</p>
</blockquote>
]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
        <tag>效率</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods私有仓库的创建</title>
    <url>/folder/2017/03/10/2017-03-10-CocoaPods%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>本文发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>、<a href="http://www.jianshu.com/p/d2d98298b1b8" target="_blank" rel="noopener">简书</a> 转载请保留链接</p>
<p>上一篇文章 <a href="http://qiubaiying.top/2017/03/08/CocoaPods公有仓库的创建/" target="_blank" rel="noopener">《CocoaPods公有仓库的创建》</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近参照了网上一大堆 CocoaPods私有仓库 的教程，按教程操作得到的pod仓库里面是这样的~</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdgexnidglj30yq0eqn0r.jpg" alt=""></p>
<p>代码和版本描述居然混在了一起，简直太糟糕~</p>
<p>虽然也能用，但是和CocoaPods本身的结构设计就不相符。</p>
<p>在上一篇<a href="http://qiubaiying.top/2017/03/08/CocoaPods公有仓库的创建/" target="_blank" rel="noopener">《CocoaPods公有仓库的创建》</a>中我们了解到，<code>master</code> 目录中只存放 代码库 的描述文件，而不是存放代码。就像这样</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdgf4l54rxj30ya09ujst.jpg" alt=""></p>
<p>代码我们另外存放在代码仓库中</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdgf9t7vcgj30n206s0u8.jpg" alt=""></p>
<p>很多人不了解CocoaPods的工作原理就复制粘贴别人的教程来做教程~</p>
<p>吐槽结束，进入正文</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h4 id="创建版本库-repo"><a href="#创建版本库-repo" class="headerlink" title="创建版本库(repo)"></a>创建版本库(<strong>repo</strong>)</h4><p>首先，创建一个像 <code>master</code> 一样的存放版本描述文件的git仓库，因为是私人git仓库，我们选择 <a href="http://git.oschina.net/" target="_blank" rel="noopener">oschina</a> 创建远程私有仓库（因为是免费的）或者也可以在GitHub上创建（<strong>$7/month</strong>）。</p>
<p>下面以 <a href="http://git.oschina.net/" target="_blank" rel="noopener">oschina</a> 为例</p>
<p>创建版本描述仓库</p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fdgfqdqyy1j31kw1c2th0.jpg" alt=""></p>
<p>回到终端，将这个远程的私有版本仓库添加到本地，<code>repo</code> 就是 repository 储存库的缩写。</p>
<pre><code>$ pod repo add MyRepo https://git.oschina.net/baiyingqiu/MyRepo.git</code></pre><p>查看在 Finder 目录 <code>~/.cocoapods/repos</code>， 可以发现增加了一个 MyRepo 的储存库</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgfyfl6v6j316y0piwhz.jpg" alt=""></p>
<h4 id="创建代码库"><a href="#创建代码库" class="headerlink" title="创建代码库"></a>创建代码库</h4><p>回到 <a href="http://git.oschina.net/" target="_blank" rel="noopener">oschina</a> 创建私人代码库</p>
<p>创建时添加 <code>MIT License</code> 和 <code>README</code></p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgjfu7n96j31kw17y7cq.jpg" alt=""></p>
<p>将仓库克隆到本地，添加<code>你的代码文件</code>、<code>仓库名.podspec</code> 描述文件，还有<code>.swift-version</code>.</p>
<p>如下</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdgmyefutej311a0kegqh.jpg" alt=""></p>
<p><code>.swift-version</code>文件用来知道swift版本，用命令行创建</p>
<pre><code>$ echo &quot;3.0&quot; &gt; .swift-version</code></pre><p><strong><code>.podspec</code></strong> 文件是你这个代码库的pod描述文件,可以通过pod指令创建空白模板：</p>
<pre><code>$ pod spec create MyAdditions</code></pre><p>或者 <strong>强烈建议</strong> 直接拷贝下面的模板进行修改</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  s.name         = <span class="string">"MyAdditions"</span> <span class="comment"># 项目名称</span></span><br><span class="line">  s.version      = <span class="string">"0.0.1"</span>        <span class="comment"># 版本号 与 你仓库的 标签号 对应</span></span><br><span class="line">  s.license      = <span class="string">"MIT"</span>          <span class="comment"># 开源证书</span></span><br><span class="line">  s.summary      = <span class="string">"私人pod代码"</span> <span class="comment"># 项目简介</span></span><br><span class="line"></span><br><span class="line">  s.homepage     = <span class="string">"https://git.oschina.net/baiyingqiu/MyAdditions"</span> <span class="comment"># 仓库的主页</span></span><br><span class="line">  s.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://git.oschina.net/baiyingqiu/MyAdditions.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"<span class="subst">#&#123;s.version&#125;</span>"</span> &#125;<span class="comment">#你的仓库地址，不能用SSH地址</span></span><br><span class="line">  s.source_files = <span class="string">"MyAdditions/*.&#123;h,m&#125;"</span> <span class="comment"># 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件</span></span><br><span class="line">  s.requires_arc = <span class="literal">true</span> <span class="comment"># 是否启用ARC</span></span><br><span class="line">  s.platform     = <span class="symbol">:ios</span>, <span class="string">"7.0"</span> <span class="comment">#平台及支持的最低版本</span></span><br><span class="line">  <span class="comment"># s.frameworks   = "UIKit", "Foundation" #支持的框架</span></span><br><span class="line">  <span class="comment"># s.dependency   = "AFNetworking" # 依赖库</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># User</span></span><br><span class="line">  s.author             = &#123; <span class="string">"BY"</span> =&gt; <span class="string">"qiubaiyingios@163.com"</span> &#125; <span class="comment"># 作者信息</span></span><br><span class="line">  s.social_media_url   = <span class="string">"http://qiubaiying.github.io"</span> <span class="comment"># 个人主页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这里我要说一下一个坑，用 <a href="http://git.oschina.net/" target="_blank" rel="noopener">oschina</a> 创建私人仓库时, 在验证时可能会找不到 <code>MIT LICENSE</code>证书,将其中的</p>
<pre><code>s.license      = &quot;MIT&quot;
修改为，指定文件
s.license      = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; }</code></pre><p>然后开始验证我们的仓库配置是否正确，并按照要求进行修改</p>
<pre><code>$ pod lib lint</code></pre><p>一般出现错误警告，需要添加 <code>--private</code> 或者 <code>--allow-warnings</code>，就可以通过验证</p>
<pre><code>$ pod lib lint --private</code></pre><p>验证成功后出现</p>
<pre><code> -&gt; MyAdditions (0.0.1)

MyAdditions passed validation.</code></pre><h4 id="将描述文件推送到版本库"><a href="#将描述文件推送到版本库" class="headerlink" title="将描述文件推送到版本库"></a>将描述文件推送到版本库</h4><p>将项目打上标签推到远程仓库，标签号 和 版本号对应 都是<code>0.0.1</code></p>
<p>最后将我们的代码仓库的描述信息，push 到我们的版本仓库中</p>
<pre><code>$ pod repo push MyRepo MyAdditions.podspec</code></pre><p>这时会对远程仓库进行验证，成功的话就会在 <code>~/.cocoapods/repos/MyRep</code>中发现新增的仓库描述信息了</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdgo62knrwj31ko0s8784.jpg" alt=""></p>
<p>若是出现错误信息</p>
<pre><code>[!] The repo `MyRepo` at `../.cocoapods/repos/MyRepo` is not clean</code></pre><p>更新下我们的版本库，</p>
<pre><code>$ pod repo update MyRepo</code></pre><p>再继续上传即可。</p>
<p><code>pod repo push MyRepo MyAdditions.podspec</code> 的过程就是</p>
<ol>
<li>验证 <code>MyAdditions.podspec</code> 文件</li>
</ol>
<ul>
<li>拉取远程版本库 <code>MyRepo</code></li>
<li>添加 <code>MyAdditions.podspec</code> 到版本库中</li>
<li>push 到远程</li>
</ul>
<p>添加完成后我们就可以在pod中搜索</p>
<pre><code>$ pod search MyAdditions</code></pre><hr>
<pre><code>-&gt; MyAdditions (0.0.1)
   Some category of the framework and UIKit
   pod &apos;MyAdditions&apos;, &apos;~&gt; 0.0.1&apos;
   - Homepage: https://git.oschina.net/baiyingqiu/MyAdditions
   - Source:   https://git.oschina.net/baiyingqiu/MyAdditions.git
   - Versions: 0.0.1 [MyRepo repo]
(END)</code></pre><h3 id="私人pod库的使用"><a href="#私人pod库的使用" class="headerlink" title="私人pod库的使用"></a>私人pod库的使用</h3><p>使用私人pod库的需要在<code>Podflie</code>中添加这句话，指明你的版本库地址。</p>
<pre><code>source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’</code></pre><p><strong>注意</strong>是版本库的地址，而不是代码库的地址，很多教程都把我搞晕了~</p>
<p>若有还使用了公有的pod库，需要把公有库地址也带上</p>
<pre><code>source ‘https://github.com/CocoaPods/Specs.git’</code></pre><p>最后的<code>Podflie</code>文件变成这个样子</p>
<pre><code>source ‘https://github.com/CocoaPods/Specs.git’
source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’

platform :ios, &apos;8.0&apos;

target ‘MyPodTest’ do
use_frameworks!

pod “BYPhoneNumTF” #公有库
pod ‘MyAdditions’ #我们的私有库
pod ‘BYAdditions’ #这是我又添加到版本库中的另一个代码库

end</code></pre><p>测试：</p>
<pre><code>$ pod install</code></pre><p>加载完成可以看到代码已经整合到我们的项目中了</p>
<p><strong>perfect！</strong></p>
<img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdhkgtfn98j30ee0hwq6y.jpg" width="250">

<p>回到Fender中 <code>~/.cocoapods/repos</code>,会发现 repos 中增加了一个pod版本库。 </p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fdhlc59rl9j30ya08y0ub.jpg" alt=""></p>
<p>执行 <code>pod install</code> 命令时</p>
<ul>
<li><p>会拉取远程 <code>Podflie</code> 中 <code>source</code> 标记 版本库 到本地的 repos 文件夹中</p>
</li>
<li><p>在 版本库 中搜索我们<code>pod ‘MyAdditions’</code> 的 <code>MyAdditions.podspec</code> 文件。</p>
</li>
<li><p>根据 <code>MyAdditions.podspec</code> 文件中描述的源码地址下载并整合到项目中</p>
</li>
</ul>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过 <a href="http://qiubaiying.top/2017-03-10-CocoaPods私有仓库的创建/" target="_blank" rel="noopener">《CocoaPods私有仓库的创建》</a> 和 <a href="http://qiubaiying.top/2017/03/08/CocoaPods公有仓库的创建/" target="_blank" rel="noopener">《CocoaPods公有仓库的创建</a>》这两篇文章，相信大家对CocoaPods的工作原理都有了更深层次的了解。</p>
<p>在写博客和和创建的过程中，踩了不少的坑（😀前人教程留下的），很多的东西只有自己操作完才能真正的领会。</p>
<p>最后，如果本文有什么错误或者有什么不同的观点欢迎提出交流。😉</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Git</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods公有仓库的创建</title>
    <url>/folder/2017/03/08/2017-03-08-CocoaPods%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>本文发布于 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener">BY Blog</a>、<a href="http://www.jianshu.com/p/d2d98298b1b8" target="_blank" rel="noopener">简书</a> 转载请保留链接</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为iOS开发者，CocoaPods的使用为我们开发带来了极大的便利。</p>
<p>我们先来看看CocoaPods本地目录中有什么</p>
<pre><code>$ cd ~/.cocoapods/repos/master</code></pre><p>或者显示隐藏文件</p>
<pre><code>$ defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder</code></pre><p>然后进入 <code>~/.cocoapods/repos/master</code> </p>
<p>你会发现 <code>master</code> 是一个 git 仓库，输出仓库的远程地址，发现是一个GitHub仓库</p>
<pre><code>$ git remote -v

origin    https://github.com/CocoaPods/Specs.git (fetch)
origin    https://github.com/CocoaPods/Specs.git (push)</code></pre><p><a href=""><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdgdi59dnnj31kw10247u.jpg" alt=""></a></p>
<p>继续，我们进入<code>Specs</code>文件夹一直往里点</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fdgdpyex7mj30yk0bkdi5.jpg" alt=""></p>
<p>你会发现很多框架以及版本号，选择一个框架，通过</p>
<pre><code>$ pod search YYImage</code></pre><p>pod搜索 Specs 文件夹中的框架，输出框架信息</p>
<pre><code>-&gt; YYImage (1.0.4)
   Image framework for iOS to display/encode/decode animated WebP, APNG, GIF,
   and more.
   pod &apos;YYImage&apos;, &apos;~&gt; 1.0.4&apos;
   - Homepage: https://github.com/ibireme/YYImage
   - Source:   https://github.com/ibireme/YYImage.git
   - Versions: 1.0.4, 1.0.3, 1.0.2, 1.0.1, 1.0, 0.9.5, 0.9.4, 0.9.3, 0.9.2,
   0.9.1, 0.9.0, 0.8.9 [master repo]
   - Subspecs:
     - YYImage/Core (1.0.4)
     - YYImage/WebP (1.0.4)</code></pre><p>每个版本号对应的一个json文件,描述了每个对应版本的框架的信息、配置、及源码下载地。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdgdsl5tdxj318q14mdq2.jpg" alt=""></p>
<p>我们在 CocoaPods 发布我们的框架时，就是要在 <code>master</code> 仓库中添加我们的仓库描述信息，然后push到远程仓库中。不过这个过程不用我们手动去操作，只需要通过<code>pod</code>命令进行操作即可。</p>
<p>下面我们将一步步把我封装的这个简单的TextFiled控件 <a href="https://github.com/qiubaiying/BYPhoneNumTF" target="_blank" rel="noopener">BYPhoneNumTF</a> 上传到 Cocoapods 公有仓库中。</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h4 id="注册-CocoaPods-账号"><a href="#注册-CocoaPods-账号" class="headerlink" title="注册 CocoaPods 账号"></a>注册 CocoaPods 账号</h4><p>想创建开源的Pod库，就要注册一个CocoaPods账号，我们使用终端注册, <code>email</code> 用你的 <code>GitHub</code> 邮箱</p>
<pre><code>$ pod trunk register GitHub_email &apos;user_name&apos; --verbose</code></pre><p>等终端出现下面文字，CocoaPods 会发一个<code>确认邮件</code>到你的邮箱上，登录你的邮箱进行确认。</p>
<pre><code>[!] Please verify the session by clicking the link in the verification email that has been sent to you_email@163.com</code></pre><p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fdeco0ndc9j30r10h3wgt.jpg" alt=""></p>
<p>注册成功！</p>
<p>确认后再终端输入</p>
<pre><code>pod trunk me</code></pre><p>可以看到你的注册信息</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fdecs0z72oj30n004q3z2.jpg" alt=""></p>
<h4 id="创建Git仓库"><a href="#创建Git仓库" class="headerlink" title="创建Git仓库"></a>创建Git仓库</h4><p>在 <a href="https://github.com" target="_blank" rel="noopener">GitHub</a> 上创建一个公开项目，项目中必须包含这几个文件</p>
<ul>
<li><code>LICENSE</code>:开源许可证</li>
<li><code>README.md</code>:仓库说明</li>
<li>你的代码</li>
<li><code>BYPhoneNumTF.podspec</code>: CocoaPods 的描述文件，这个文件<strong>非常重要</strong></li>
</ul>
<p>如下图：</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fdfhvy3c19j31iq0dqn03.jpg" alt=""></p>
<p><code>BYPhoneNumTF</code> 文件夹下是我存放代码的地方</p>
<p><code>BYPhoneNumTF_Demo</code> 是代码使用样例（不是必须的）</p>
<h4 id="创建-podspec"><a href="#创建-podspec" class="headerlink" title="创建.podspec"></a>创建<code>.podspec</code></h4><p><code>.podspec</code> 是用 Ruby 的配置文件，描述你项目的信息。</p>
<p>在你的仓库目录下，使用终端命令创建</p>
<pre><code>$ pod spec create BYPhoneNumTF</code></pre><p>这时就会在你的仓库下生成 <code>BYPhoneNumTF.podspec</code> 文件</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fdfioo1c4zj31bq0s20zn.jpg" alt=""></p>
<p>修改里面的配置就可以发布了~当然，没这么简单。</p>
<p>配置文件中的注释很多，而且很多配置都不是必须的，写多了等下验证还不让过~</p>
<p>so~<strong>强烈建议</strong>，直接拷贝下面的主要配置进行修改</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Pod::Spec.new <span class="keyword">do</span> <span class="params">|s|</span></span><br><span class="line">  s.name         = <span class="string">"BYPhoneNumTF"</span> <span class="comment"># 项目名称</span></span><br><span class="line">  s.version      = <span class="string">"1.0.0"</span>        <span class="comment"># 版本号 与 你仓库的 标签号 对应</span></span><br><span class="line">  s.license      = <span class="string">"MIT"</span>          <span class="comment"># 开源证书</span></span><br><span class="line">  s.summary      = <span class="string">"A delightful TextField of PhoneNumber"</span> <span class="comment"># 项目简介</span></span><br><span class="line"></span><br><span class="line">  s.homepage     = <span class="string">"https://github.com/qiubaiying/BYPhoneNumTF"</span> <span class="comment"># 你的主页</span></span><br><span class="line">  s.source       = &#123; <span class="symbol">:git</span> =&gt; <span class="string">"https://github.com/qiubaiying/BYPhoneNumTF.git"</span>, <span class="symbol">:tag</span> =&gt; <span class="string">"<span class="subst">#&#123;s.version&#125;</span>"</span> &#125;<span class="comment">#你的仓库地址，不能用SSH地址</span></span><br><span class="line">  s.source_files = <span class="string">"BYPhoneNumTF/*.&#123;h,m&#125;"</span> <span class="comment"># 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件</span></span><br><span class="line">  s.requires_arc = <span class="literal">true</span> <span class="comment"># 是否启用ARC</span></span><br><span class="line">  s.platform     = <span class="symbol">:ios</span>, <span class="string">"7.0"</span> <span class="comment">#平台及支持的最低版本</span></span><br><span class="line">  s.frameworks   = <span class="string">"UIKit"</span>, <span class="string">"Foundation"</span> <span class="comment">#支持的框架</span></span><br><span class="line">  <span class="comment"># s.dependency   = "AFNetworking" # 依赖库</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># User</span></span><br><span class="line">  s.author             = &#123; <span class="string">"BY"</span> =&gt; <span class="string">"qiubaiyingios@163.com"</span> &#125; <span class="comment"># 作者信息</span></span><br><span class="line">  s.social_media_url   = <span class="string">"http://qiubaiying.github.io"</span> <span class="comment"># 个人主页</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>最最关键的步骤的到了，验证 <code>.podspec</code> 文件的格式是否正确，</p>
<pre><code>$ pod lib lint</code></pre><p>验证会出现成功出现</p>
<pre><code> -&gt; BYPhoneNumTF (1.0.0)

BYPhoneNumTF passed validation.    </code></pre><p>但是很多情况没这么顺利，比如:</p>
<pre><code> -&gt; BYPhoneNumTF (1.0.0)
    - WARN  | url: There was a problem validating the URL http://qiubaiying.github.io.

[!] BYPhoneNumTF did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it) and all results apply only to public specs, but you can use `--private` to ignore them if linting the specification for a private pod.
[!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: 
    `echo &quot;2.3&quot; &gt; .swift-version`.
You can use the `--no-clean` option to inspect any issue.</code></pre><p>提示我们需要加<code>--allow-warnings</code>这么一句话，命令改为</p>
<pre><code>$ pod lib lint --allow-warnings</code></pre><p>若还是提示什么<code>&#39;echo &quot;2.3&quot; &gt; .swift-version&#39;</code>的，就加这么一个东西。</p>
<pre><code>$ echo &quot;2.3&quot; &gt; .swift-version</code></pre><p>然后在进行验证，这是应该就可以了。若还是不行，回到配置文件中检查有没有写错配置信息~</p>
<h4 id="给仓库打标签"><a href="#给仓库打标签" class="headerlink" title="给仓库打标签"></a>给仓库打标签</h4><p>验证成功后，将仓库提交到远程，然后给仓库打上标签并将标签也推送到远程。</p>
<p>标签相当于将你的仓库的一个压缩包，用于稳定存储当前版本。标签号与你在 <code>s.version = &quot;1.0.0&quot;</code>的版本号一致 <code>1.0.0</code></p>
<pre><code>创建标签
$ git tag -a 1.0.0 -m &apos;标签说明&apos; 
推送到远程
$ git push origin --tags</code></pre><h4 id="发布-podspec"><a href="#发布-podspec" class="headerlink" title="发布.podspec"></a>发布<code>.podspec</code></h4><p>最后一步，发布项目的描述的文件 <code>BYPhoneNumTF.podspec</code> </p>
<p>在仓库目录下执行</p>
<pre><code>pod trunk push BYPhoneNumTF.podspec</code></pre><p>将你的 <code>BYPhoneNumTF.podspec</code> 发布到公有的speecs上,这一步其实做了很多操作,包括 </p>
<ol>
<li>更新本地 pods 库 <code>~/.cocoaPods.repo/master</code></li>
</ol>
<ul>
<li>验证<code>.podspec</code>格式是否正确</li>
<li>将 <code>.podspec</code> 文件转成 JSON 格式</li>
<li>对 <code>master</code> 仓库 进行合并、提交.<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">master仓库地址</a> </li>
</ul>
<p>成功后将会出现下列信息：</p>
<pre><code>Updating spec repo `master`
Validating podspec
 -&gt; BYPhoneNumTF (1.0.0)

Updating spec repo `master`

--------------------------------------------------------------------------------
 🎉  Congrats

 🚀  BYPhoneNumTF (1.0.0) successfully published
 📅  March 7th, 01:39
 🌎  https://cocoapods.org/pods/BYPhoneNumTF
 👍  Tell your friends!</code></pre><p>说明发布成功，你就可以通过上面的URL: <a href="https://cocoapods.org/pods/BYPhoneNumTF" target="_blank" rel="noopener">https://cocoapods.org/pods/BYPhoneNumTF</a> 进入的Pods查看自己的仓库信息了.</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fded7yh8ugj31kw19djyk.jpg" alt=""></p>
<h4 id="使用仓库"><a href="#使用仓库" class="headerlink" title="使用仓库"></a>使用仓库</h4><p>发布到Cocoapods后，在终端更新本地pods仓库信息</p>
<pre><code>$ pod setup</code></pre><p>查询仓库</p>
<pre><code>$ pod search BYPhoneNumTF</code></pre><hr>
<pre><code>-&gt; BYPhoneNumTF (1.0.0)
   A delightful TextField of PhoneNumber
   pod &apos;BYPhoneNumTF&apos;, &apos;~&gt; 1.0.0&apos;
   - Homepage: https://github.com/qiubaiying/BYPhoneNumTF
   - Source:   https://github.com/qiubaiying/BYPhoneNumTF.git
   - Versions: 1.0.0, 0.0.1 [BYPhoneNumTF repo]
(END)</code></pre><p>若出现仓库信息说明已经成功了，这时候你就可以在 <code>Podfile</code> 添加、使用自己的仓库了 <code>pod &#39;BYPhoneNumTF&#39;, &#39;~&gt; 1.0.0&#39;</code></p>
<p><img src="https://ww1.sinaimg.cn/large/006tNbRwgy1fdedvficvaj30fu0loaex.jpg" alt=""></p>
<h4 id="更新维护"><a href="#更新维护" class="headerlink" title="更新维护"></a>更新维护</h4><p>当你的代码更新维护后，就需要重写发布，流程是：</p>
<ul>
<li>更新<code>BYPhoneNumTF.podspec</code>中的版本号</li>
<li>打上标签推送远程</li>
<li><code>pod trunk push BYPhoneNumTF.podspec</code> 推送到pods仓库</li>
</ul>
<p>更新后你就可以在 <a href="https://github.com/CocoaPods/Specs" target="_blank" rel="noopener">CocoaPods Master Repo</a> 仓库上看到自己的提交记录了。</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNbRwgy1fdfkr2l7omj31kw0d7446.jpg" alt=""></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>到此,你已经掌握了创建和维护一个Cocoapods公有仓库的技能了，是不是很棒~</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Git</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>文件目录树状(tree)显示</title>
    <url>/folder/2017/03/07/2017-3-07-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%A0%91%E7%8A%B6(tree)%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<blockquote>
<p>使用 <strong>tree</strong> 在终端显示树状文件结构</p>
</blockquote>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdhotefcb5j315s0ugjwk.jpg" alt=""></p>
<h4 id="安装-tree"><a href="#安装-tree" class="headerlink" title="安装 tree"></a>安装 tree</h4><p>使用 <strong>brew</strong> 进行安装</p>
<pre><code>$ brew install tree</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>直接使用 <code>tree</code> 命令，会在当前文件目录下，递归输出所有文件层级</p>
<pre><code>$ tree</code></pre></li>
<li><p>限制层级</p>
<pre><code>$ tree -L 2</code></pre></li>
<li><p>指定当前目录下的某个文件夹</p>
<pre><code>$ tree Desktop</code></pre></li>
</ul>
<h4 id="导出文件"><a href="#导出文件" class="headerlink" title="导出文件"></a>导出文件</h4><p>用<code>&gt; 文件名.格式</code> 的形式导出</p>
<pre><code>$ tree -L 1 &gt; tree.md</code></pre>]]></content>
      <tags>
        <tag>开发技巧</tag>
        <tag>Mac</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 代理模式</title>
    <url>/folder/2017/03/06/2017-03-06-Swift-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>Xcode 8.2 | Swift 3.0</p>
</blockquote>
<p>在iOS开发中，无论是 <strong>Objective-C</strong> 还是 <strong>Swift</strong> ，<strong>Delegate</strong> 有着具足轻重的位置，如<code>TabelViewDelegate</code> 与 <code>TableViewDataSource</code>。</p>
<p><strong>Swift</strong> 中的代理模式 和 <strong>Objective-C</strong> 除了语法外，几乎一样。</p>
<h2 id="Objective-C-代理模式"><a href="#Objective-C-代理模式" class="headerlink" title="Objective-C 代理模式"></a>Objective-C 代理模式</h2><p>在介绍 Swift 代理模式前，先来看回顾一下 Objective-C 中的代理模式如何实现</p>
<p>Objective-C 中用代理实现反向传值：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fdd51zf5cwg307i0dck3f.gif" alt=""></p>
<h4 id="委托方（子控制器）"><a href="#委托方（子控制器）" class="headerlink" title="委托方（子控制器）"></a>委托方（子控制器）</h4><p>委托方需要实现</p>
<ul>
<li><p>创建协议 、声明协议方法</p>
<pre><code>@protocol SubViewDelegate &lt;NSObject&gt;

- (void)backWithStr:(NSString *) str;

@end</code></pre></li>
<li><p>创建一个代理属性</p>
<pre><code>// weak声明
@property (nonatomic, weak) id&lt;SubViewDelegate&gt; delegate;</code></pre></li>
<li><p>执行协议方法</p>
<pre><code>// 判断代理是实现该方法，避免carsh
if ([self.delegate respondsToSelector:@selector(backWithStr:)]) {
     [self.delegate backWithStr:self.textField.text];
 }</code></pre></li>
</ul>
<h4 id="代理方（主控制器）"><a href="#代理方（主控制器）" class="headerlink" title="代理方（主控制器）"></a>代理方（主控制器）</h4><p>代理方需要实现</p>
<ul>
<li><p>遵守（继承）协议</p>
<pre><code>@interface ViewController () &lt;SubViewDelegate&gt;</code></pre></li>
<li><p>将代理设为自己</p>
<pre><code>subVC.delegate = self;</code></pre></li>
<li><p>实现代理方法</p>
<pre><code>- (void)backWithStr:(NSString *)str {
    self.label.text = str;
}</code></pre></li>
</ul>
<h2 id="Swift-代理模式"><a href="#Swift-代理模式" class="headerlink" title="Swift 代理模式"></a>Swift 代理模式</h2><p>Swift 代理模式 与 Objective-C 一样，只是语法不同。</p>
<p>Swift 中用代理实现反向传值：</p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fdd5oi9048g307i0dc7co.gif" alt=""></p>
<h4 id="委托方（子控制器）-1"><a href="#委托方（子控制器）-1" class="headerlink" title="委托方（子控制器）"></a>委托方（子控制器）</h4><ul>
<li><p>创建协议 、声明协议方法</p>
<pre><code>protocol SubViewDelegate {
func backStr(str: String)
}    </code></pre></li>
<li><p>创建一个代理属性</p>
<pre><code>var delegate: SubViewDelegate?</code></pre></li>
<li><p>执行协议方法</p>
<pre><code>/// 执行代理方法，将值回传
delegate?.backStr(str: textField.text ?? &quot;&quot;)</code></pre></li>
</ul>
<h4 id="代理方-主控制器"><a href="#代理方-主控制器" class="headerlink" title="代理方(主控制器)"></a>代理方(主控制器)</h4><ul>
<li><p>继承协议</p>
<pre><code>class ViewController: UIViewController, SubViewDelegate</code></pre></li>
<li><p>将代理设为自己</p>
<pre><code>subVC.delegate = self</code></pre></li>
<li><p>实现代理方法</p>
  <figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backStr</span><span class="params">(str: String)</span></span> &#123;</span><br><span class="line">       <span class="keyword">self</span>.textF.text = str</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对比可以方法 Swift 代理模式 与 Objective-C 用法完全相同，只是语法发生了变化。</p>
<p>值得一提的是Swift 的扩展 <code>extension</code>可以用来继承协议,实现代码隔离，便于维护。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 使用扩展继承协议 实现协议方法 可以分离代码</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">SubViewDelegate</span></span>&#123;</span><br><span class="line">    <span class="comment">/// 实现代理方法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">backStr</span><span class="params">(str: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.textF.text = str</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Demo源码"><a href="#Demo源码" class="headerlink" title="Demo源码"></a>Demo源码</h2><p>最后附上<a href="https://github.com/qiubaiying/iOS-Delegate_Demo" target="_blank" rel="noopener">Demo源码</a></p>
<p>如果对你有帮助的话，<strong>Star</strong>✨下一吧！</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode 控制台输出中文</title>
    <url>/folder/2017/03/01/2017-03-01-Xcode-%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%87%BA%E4%B8%AD%E6%96%87/</url>
    <content><![CDATA[<blockquote>
<p>重写 NSArray、NSSet、NSDictionary 的输出方法，在Xcode实现中文（Unicode）字符在控制台的输出</p>
</blockquote>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p> Xcode 控制台中在输出 NSArray、NSSet、NSDictionary 时，其中的中文字符会变成Unicode编码 如<code>&quot;\U67cf\U8367&quot;</code>.</p>
<p>我们通过分类重写这些类的输出方法即可实现在控制台输出中文：</p>
<pre><code>- (NSString *)descriptionWithLocale:(id)locale indent:(NSUInteger)level</code></pre><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>先看看效果：</p>
<p>创建一个字典并输出:</p>
<pre><code>NSData *strData = [@&quot;str -&gt; data格式的字符串&quot; dataUsingEncoding:NSUTF8StringEncoding];

NSData *dicData = [NSJSONSerialization dataWithJSONObject:@{@&quot;key0&quot;: @&quot;字典 -&gt; data 的数据&quot;,}
                                                      options:NSJSONWritingPrettyPrinted
                                                        error:nil];

NSMutableSet *set = [NSMutableSet setWithArray:@[@&quot;set0&quot;,
                                                 strData,
                                                 dicData]];
NSDictionary *dic = @{@&quot;name&quot;  : @&quot;BY&quot;,
                       @&quot;My bolg&quot; : @&quot;http://qiubaiying.top&quot;,
                       @&quot;count&quot; : @(11),
                       @&quot;strData&quot; : strData,
                       @&quot;dicData&quot; : dicData,
                       @&quot;set&quot;     : set,
                       @&quot;Unicode&quot; : @&quot;😀😁🤣😂😄&quot;,
                       @&quot;contact&quot; : @[@&quot;BY Blog:http://qiubaiying.top&quot;,
                                      @&quot;GitHub:https://github.com/qiubaiying&quot;,
                                      @&quot;简书:https://http://www.jianshu.com/u/e71990ada2fd&quot;]};
NSLog(@&quot;%@&quot;, dic);</code></pre><p>输出结果：</p>
<pre><code>2017-03-01 10:36:45.709 BYFoundationLog_Demo[1657:53604] {
    &quot;My bolg&quot; = &quot;http://qiubaiying.top&quot;;
    Unicode = &quot;\Ud83d\Ude00\Ud83d\Ude01\Ud83e\Udd23\Ud83d\Ude02\Ud83d\Ude04&quot;;
    contact =     (
        &quot;BY Blog:http://qiubaiying.top&quot;,
        &quot;GitHub:https://github.com/qiubaiying&quot;,
        &quot;\U7b80\U4e66:https://http://www.jianshu.com/u/e71990ada2fd&quot;
    );
    count = 11;
    dicData = &lt;7b0a2020 226b6579 3022203a 2022e5ad 97e585b8 202d3e20 64617461 20e79a84 e695b0e6 8dae220a 7d&gt;;
    name = BY;
    set = &quot;{(\n    &lt;73747220 2d3e2064 617461e6 a0bce5bc 8fe79a84 e5ad97e7 aca6e4b8 b2&gt;,\n    set0,\n    &lt;7b0a2020 226b6579 3022203a 2022e5ad 97e585b8 202d3e20 64617461 20e79a84 e695b0e6 8dae220a 7d&gt;\n)}&quot;;
    strData = &lt;73747220 2d3e2064 617461e6 a0bce5bc 8fe79a84 e5ad97e7 aca6e4b8 b2&gt;;
}</code></pre><p>将<code>BYFoundationLog.m</code>拖入项目，再次运行</p>
<pre><code>2017-03-01 10:35:52.545 BYFoundationLog_Demo[1635:52772]     {
    set =     {(
        &quot;str -&gt; data格式的字符串&quot;,
        &quot;set0&quot;,
            {
            key0 = &quot;字典 -&gt; data 的数据&quot;,
        },
    )},
    Unicode = &quot;😀😁🤣😂😄&quot;,
    strData = &quot;str -&gt; data格式的字符串&quot;,
    count = 11,
    dicData =     {
        key0 = &quot;字典 -&gt; data 的数据&quot;,
    },
    contact =     (
        &quot;BY Blog:http://qiubaiying.top&quot;,
        &quot;GitHub:https://github.com/qiubaiying&quot;,
        &quot;简书:https://http://www.jianshu.com/u/e71990ada2fd&quot;,
    ),
    name = &quot;BY&quot;,
    My bolg = &quot;http://qiubaiying.top&quot;,
}</code></pre><h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p>以 <code>NSArray</code> 为例：</p>
<p>创建一个 <code>NSArray</code> 的分类，重写输出方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation NSArray (Log)</span><br><span class="line"></span><br><span class="line">- (NSString *)descriptionWithLocale:(id)locale indent:(NSUInteger)level &#123;</span><br><span class="line">    NSMutableString *desc = [NSMutableString string];</span><br><span class="line">    </span><br><span class="line">    NSMutableString *tabString = [[NSMutableString alloc] initWithCapacity:level];</span><br><span class="line">    for (NSUInteger i = 0; i &lt; level; ++i) &#123;</span><br><span class="line">        [tabString appendString:@&quot;\t&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *tab = @&quot;&quot;;</span><br><span class="line">    if (level &gt; 0) &#123;</span><br><span class="line">        tab = tabString;</span><br><span class="line">    &#125;</span><br><span class="line">    [desc appendString:@&quot;\t(\n&quot;];</span><br><span class="line">    </span><br><span class="line">    for (id obj in self) &#123;</span><br><span class="line">        if ([obj isKindOfClass:[NSDictionary class]]</span><br><span class="line">            || [obj isKindOfClass:[NSArray class]]</span><br><span class="line">            || [obj isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">            NSString *str = [((NSDictionary *)obj) descriptionWithLocale:locale indent:level + 1];</span><br><span class="line">            [desc appendFormat:@&quot;%@\t%@,\n&quot;, tab, str];</span><br><span class="line">        &#125; else if ([obj isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">            [desc appendFormat:@&quot;%@\t\&quot;%@\&quot;,\n&quot;, tab, obj];</span><br><span class="line">        &#125; else if ([obj isKindOfClass:[NSData class]]) &#123;</span><br><span class="line">            </span><br><span class="line">            NSError *error = nil;</span><br><span class="line">            NSObject *result =  [NSJSONSerialization JSONObjectWithData:obj</span><br><span class="line">                                                                options:NSJSONReadingMutableContainers</span><br><span class="line">                                                                  error:&amp;error];</span><br><span class="line">            </span><br><span class="line">            if (error == nil &amp;&amp; result != nil) &#123;</span><br><span class="line">                if ([result isKindOfClass:[NSDictionary class]]</span><br><span class="line">                    || [result isKindOfClass:[NSArray class]]</span><br><span class="line">                    || [result isKindOfClass:[NSSet class]]) &#123;</span><br><span class="line">                    NSString *str = [((NSDictionary *)result) descriptionWithLocale:locale indent:level + 1];</span><br><span class="line">                    [desc appendFormat:@&quot;%@\t%@,\n&quot;, tab, str];</span><br><span class="line">                &#125; else if ([obj isKindOfClass:[NSString class]]) &#123;</span><br><span class="line">                    [desc appendFormat:@&quot;%@\t\&quot;%@\&quot;,\n&quot;, tab, result];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                @try &#123;</span><br><span class="line">                    NSString *str = [[NSString alloc] initWithData:obj encoding:NSUTF8StringEncoding];</span><br><span class="line">                    if (str != nil) &#123;</span><br><span class="line">                        [desc appendFormat:@&quot;%@\t\&quot;%@\&quot;,\n&quot;, tab, str];</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        [desc appendFormat:@&quot;%@\t%@,\n&quot;, tab, obj];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                @catch (NSException *exception) &#123;</span><br><span class="line">                    [desc appendFormat:@&quot;%@\t%@,\n&quot;, tab, obj];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            [desc appendFormat:@&quot;%@\t%@,\n&quot;, tab, obj];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [desc appendFormat:@&quot;%@)&quot;, tab];</span><br><span class="line">    </span><br><span class="line">    return desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>NSSet、NSDictionary 与 NSArray 实现方法类似</p>
<h2 id="代码下载"><a href="#代码下载" class="headerlink" title="代码下载"></a>代码下载</h2><p>代码及Demo地址：<a href="https://github.com/qiubaiying/BYFoundationLog" target="_blank" rel="noopener">GitHub</a></p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>直接将 <code>BYFoundationLog.m</code> 文件拖入项目中就能使用</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 文件的隐藏与显示</title>
    <url>/folder/2017/02/22/2017-02-22-Mac-%E6%96%87%E4%BB%B6%E7%9A%84%E9%9A%90%E8%97%8F%E4%B8%8E%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<blockquote>
<p>让 Finder 显示隐藏文件和文件夹</p>
</blockquote>
<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><pre><code>$ defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder</code></pre><h4 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h4><pre><code>$ defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder</code></pre><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>创建终端快捷命令</p>
<p>在 <strong>zsh</strong> shell 下，创建快捷命令</p>
<h4 id="创建显示命令-fd-（fileDisplay）"><a href="#创建显示命令-fd-（fileDisplay）" class="headerlink" title="创建显示命令 fd （fileDisplay）"></a>创建显示命令 fd （fileDisplay）</h4><pre><code>$ echo &quot;alias fd=&apos;defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder&apos;&quot;&gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</code></pre><h4 id="创建隐藏命令-fh（fileHide）"><a href="#创建隐藏命令-fh（fileHide）" class="headerlink" title="创建隐藏命令 fh（fileHide）"></a>创建隐藏命令 fh（fileHide）</h4><pre><code>$ echo &quot;alias fd=&apos;defaults write com.apple.finder AppleShowAllFiles -boolean false ; killall Finder&apos;&quot;&gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</code></pre><p>使用方法</p>
<p>显示隐藏文件</p>
<pre><code>$ fd</code></pre><p>隐藏文件</p>
<pre><code>$ fh</code></pre>]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 .gitignore 忽略 Git 仓库中的文件</title>
    <url>/folder/2017/02/22/2017-02-22-%E4%BD%BF%E7%94%A8-.gitignore-%E5%BF%BD%E7%95%A5-git-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>使用 <code>.gitignore</code> 文件忽略指定文件</p>
</blockquote>
<h2 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h2><p>在Git中，很多时候你只想将代码提交到仓库，而不是将当前文件目录下的文件全部提交到Git仓库中，例如在MacOS系统下面的<code>.DS_Store</code>文件，或者是Xocde的操作记录，又或者是pod库的中一大串的源代码。这种情况下使用<code>.gitignore</code>就能够在Git提交时自动忽略掉这些文件。</p>
<h2 id="忽略的格式"><a href="#忽略的格式" class="headerlink" title="忽略的格式"></a>忽略的格式</h2><ul>
<li><code>#</code> :此为注释 – 将被 Git 忽略</li>
<li><code>*.a</code> :忽略所有 <code>.a</code> 结尾的文件</li>
<li><code>!lib.a</code> : 不忽略 <code>lib.a</code> 文件</li>
<li><code>/TODO</code> :仅仅忽略项目根目录下的 <code>TODO</code> 文件,不包括 <code>subdir/TODO</code></li>
<li><code>build/</code> : 忽略 <code>build/</code> 目录下的所有文件</li>
<li><code>doc/*.txt</code> : 会忽略 <code>doc/notes.txt</code> 但不包括 <code>doc/server/arch.txt</code></li>
</ul>
<h2 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h2><h4 id="从-github-上获取"><a href="#从-github-上获取" class="headerlink" title="从 github 上获取"></a>从 <a href="https://github.com/github/gitignore.git" target="_blank" rel="noopener">github</a> 上获取</h4><p>github上整理了一些常用需要的项目中需要忽略的文件配置，根据需要进行获取</p>
<pre><code>https://github.com/github/gitignore.git</code></pre><p>与 Xcode 相关的三个文件</p>
<ul>
<li>Xcode.gitignore</li>
<li>Objective-C.gitignore</li>
<li>Swift.gitignore</li>
</ul>
<p><code>Xcode.gitignore</code>忽略 <code>Xcode</code> 配置信息，如操作记录，默认打开窗口等</p>
<p>其他两个在 <code>Xcode.gitignore</code> 基础上针对不同的语言进行忽略</p>
<p>将这些文件重写命名为 <code>.gittignore</code></p>
<pre><code>$ mv Swift.gitignore .gittignore</code></pre><h4 id="通过-gitignore-io-创建（推荐）"><a href="#通过-gitignore-io-创建（推荐）" class="headerlink" title="通过 gitignore.io 创建（推荐）"></a>通过 <a href="https://www.gitignore.io/" target="_blank" rel="noopener">gitignore.io</a> 创建（推荐）</h4><h6 id="先自定义终端命令："><a href="#先自定义终端命令：" class="headerlink" title="先自定义终端命令："></a>先自定义终端命令：</h6><p>macOS下默认是<code>\#!/bin/bash</code>：</p>
<pre><code>$ echo &quot;function gi() { curl -L -s https://www.gitignore.io/api/\$@ ;}&quot; &gt;&gt; ~/.bash_profile &amp;&amp; source ~/.bash_profile</code></pre><p>如果是 <code>#!/bin/zsh</code></p>
<pre><code>$ echo &quot;function gi() { curl -L -s https://www.gitignore.io/api/\$@ ;}&quot; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc</code></pre><h6 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h6><p>在当前终端目录下</p>
<pre><code>$ gi swift &gt; .gitignore</code></pre><p>就会针对 Swifit 类型的工程创建 <code>.gitignore</code> 文件。</p>
]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 代码回滚</title>
    <url>/folder/2017/02/16/2017-02-16-Git-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A/</url>
    <content><![CDATA[<blockquote>
<p>并不适合阅读的个人文档。</p>
</blockquote>
<h1 id="git-revert-和-git-reset-的区别"><a href="#git-revert-和-git-reset-的区别" class="headerlink" title="git revert 和 git reset 的区别"></a><strong>git revert</strong> 和 <strong>git reset</strong> 的区别</h1><p> 先看图：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNbRwgy1fcr9tu6vdjj30t30ez0y8.jpg" alt=""></p>
<p><strong>sourceTree</strong> 中 <strong>revert</strong> 译为<strong><code>提交回滚</code></strong>，作用为忽略你指定的版本，然后提交一个新的版本。新的版本中已近删除了你所指定的版本。</p>
<p><strong>reset</strong> 为 <strong>重置到这次提交</strong>，将内容重置到指定的版本。<code>git reset</code> 命令后面是需要加2种参数的：<code>–-hard</code> 和 <code>–-soft</code>。这条命令默认情况下是 <code>-–soft</code>。</p>
<p>执行上述命令时，这该条commit号之 后（时间作为参考点）的所有commit的修改都会退回到git缓冲区中。使用<code>git status</code> 命令可以在缓冲区中看到这些修改。而如果加上<code>-–hard</code>参数，则缓冲区中不会存储这些修改，git会直接丢弃这部分内容。可以使用 <code>git push origin HEAD --force</code> 强制将分区内容推送到远程服务器。</p>
<h4 id="代码回退"><a href="#代码回退" class="headerlink" title="代码回退"></a>代码回退</h4><p>默认参数 <code>-soft</code>,所有commit的修改都会退回到git缓冲区<br>参数<code>--hard</code>，所有commit的修改直接丢弃</p>
<pre><code>$ git reset --hard HEAD^         回退到上个版本
$ git reset --hard commit_id    退到/进到 指定commit_id</code></pre><p>推送到远程    </p>
<pre><code>$ git push origin HEAD --force</code></pre><h4 id="可以吃的后悔药-gt-版本穿梭"><a href="#可以吃的后悔药-gt-版本穿梭" class="headerlink" title="可以吃的后悔药-&gt;版本穿梭"></a>可以吃的后悔药-&gt;版本穿梭</h4><p>当你回滚之后，又后悔了，想恢复到新的版本怎么办？</p>
<p>用<code>git reflog</code>打印你记录你的每一次操作记录</p>
<pre><code>$ git reflog

输出：
c7edbfe HEAD@{0}: reset: moving to c7edbfefab1bdbef6cb60d2a7bb97aa80f022687
470e9c2 HEAD@{1}: reset: moving to 470e9c2
b45959e HEAD@{2}: revert: Revert &quot;add img&quot;
470e9c2 HEAD@{3}: reset: moving to 470e9c2
2c26183 HEAD@{4}: reset: moving to 2c26183
0f67bb7 HEAD@{5}: revert: Revert &quot;add img&quot;</code></pre><p>找到你操作的id如：<code>b45959e</code>，就可以回退到这个版本</p>
<pre><code>$ git reset --hard b45959e</code></pre>]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git指令整理</title>
    <url>/folder/2017/02/15/2017-02-15-Git%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>随便整理的一些自用的Git指令</p>
</blockquote>
<h1 id="GitHub创建仓库提示代码"><a href="#GitHub创建仓库提示代码" class="headerlink" title="GitHub创建仓库提示代码"></a>GitHub创建仓库提示代码</h1><pre><code>echo &quot;# 项目名&quot; &gt;&gt; README.md
git init
git add README.md
git commit -m &quot;first commit&quot;
git remote add origin git@github.com:qiubaiying/项目名.git
git push -u origin master</code></pre><p>若仓库存在直接push</p>
<pre><code>git remote add origin git@github.com:qiubaiying/test.git
git push -u origin master</code></pre><h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h4 id="创建仓库（初始化）"><a href="#创建仓库（初始化）" class="headerlink" title="创建仓库（初始化）"></a>创建仓库（初始化）</h4><pre><code>在当前指定目录下创建
git init

新建一个仓库目录
git init [project-name]

克隆一个远程项目
git clone [url]</code></pre><h4 id="添加文件到缓存区"><a href="#添加文件到缓存区" class="headerlink" title="添加文件到缓存区"></a>添加文件到缓存区</h4><pre><code>添加所有变化的文件
 git add .

添加名称指定文件
git add text.txt</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code>设置提交代码时的用户信息
git config [--global] user.name &quot;[name]&quot;
git config [--global] user.email &quot;[email address]&quot;</code></pre><h4 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h4><pre><code>提交暂存区到仓库区
git commit -m &quot;msg&quot;

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...</code></pre><h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><pre><code># 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all</code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code># 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]</code></pre><h4 id="标签Tags"><a href="#标签Tags" class="headerlink" title="标签Tags"></a>标签Tags</h4><pre><code>添加标签 在当前commit
git tag -a v1.0 -m &apos;xxx&apos; 

添加标签 在指定commit
git tag v1.0 [commit]

查看
git tag

删除
git tag -d V1.0

删除远程tag
git push origin :refs/tags/[tagName]

推送
git push origin --tags

拉取
git fetch origin tag V1.0

新建一个分支，指向某个tag
git checkout -b [branch] [tag]</code></pre><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><pre><code># 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog</code></pre><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><pre><code># 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop</code></pre><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><pre><code># 生成一个可供发布的压缩包
$ git archives</code></pre>]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 文本转音频</title>
    <url>/folder/2017/02/15/2017-02-15-Mac-%E6%96%87%E6%9C%AC%E8%BD%AC%E9%9F%B3%E9%A2%91/</url>
    <content><![CDATA[<h1 id="文本转语音"><a href="#文本转语音" class="headerlink" title="文本转语音"></a>文本转语音</h1><blockquote>
<p>分享一条在Mac上将一个文本转换为音频文件的终端命令，个人认为还是蛮实用的。</p>
<p>来自: <a href="http://25.io/toau/" target="_blank" rel="noopener">http://25.io/toau/</a></p>
</blockquote>
<p><img src="https://ww2.sinaimg.cn/large/006tNbRwgy1fcqwv0i9ovj30du04p74y.jpg" alt=""></p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令:"></a>指令:</h4><pre><code>cat sample.txt | say -o sample.aiff</code></pre>]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
      </tags>
  </entry>
  <entry>
    <title>随便聊聊</title>
    <url>/folder/2017/02/14/2017-02-14-%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A/</url>
    <content><![CDATA[<h1 id="随便谈谈"><a href="#随便谈谈" class="headerlink" title="随便谈谈"></a>随便谈谈</h1><p>今天是情人节，首先祝大家情人节快乐~</p>
<p>在这特殊的节<strong>日</strong>里，我特意花了半天的时间，我将在简书中的文章都搬到 <a href="http://qiubaiying.github.io" target="_blank" rel="noopener"><strong>BY Blog</strong></a> 上，顺便又修改了下博客框架。</p>
<h1 id="关于分享"><a href="#关于分享" class="headerlink" title="关于分享"></a>关于分享</h1><p>最近有很多人来请教我关于建站的问题，我都花时间为其解答一一解答。</p>
<p>感觉在解答别人的问题时，你自己也能学到很多新的知识，同时能沉浸其中。</p>
<p>我想这就是分享的魔力吧。</p>
<p>所以，把问题都砸过来吧~</p>
]]></content>
      <tags>
        <tag>生活</tag>
        <tag>博客</tag>
        <tag>漫谈</tag>
      </tags>
  </entry>
  <entry>
    <title>快速搭建个人博客</title>
    <url>/folder/2017/02/06/2017-02-06-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>正所谓前人栽树，后人乘凉。</p>
<p>感谢<a href="https://github.com/huxpro" target="_blank" rel="noopener">Huxpro</a>提供的博客模板</p>
<p><a href="http://qiubaiying.top" target="_blank" rel="noopener">我的的博客</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从 Jekyll 到 GitHub Pages 中间踩了许多坑，终于把我的个人博客<a href="http://qiubaiying.top" target="_blank" rel="noopener">BY Blog</a>搭建出来了。。。</p>
<p>本教程针对的是不懂技术又想搭建个人博客的小白，操作简单暴力且快速。当然懂技术那就更好了。</p>
<p>看看看博客的主页样式：</p>
<p><a href="http://qiubaiying.github.io/" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/2178672-51a2fe6fbe24d1cd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></a></p>
<p>在手机上的布局：</p>
<p><a href="http://qiubaiying.github.io/" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/2178672-d58bb45f9faedb70.jpg" alt=""></a></p>
<p>废话不多说了，开始进入正文。</p>
<h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h3 id="从注册一个Github账号开始"><a href="#从注册一个Github账号开始" class="headerlink" title="从注册一个Github账号开始"></a>从注册一个Github账号开始</h3><p>我采用的搭建博客的方式是使用 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> + <a href="http://jekyll.com.cn/" target="_blank" rel="noopener">jekyll</a> 的方式。</p>
<p>要使用 GitHub Pages，首先你要注册一个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账号，GitHub 是全球最大的同性交友网站(吐槽下程序员~)，你值得拥有。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-e65e5cda50f38cef.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="拉取我的博客模板"><a href="#拉取我的博客模板" class="headerlink" title="拉取我的博客模板"></a>拉取我的博客模板</h3><p>注册完成后搜索 <code>qiubaiying.github.io</code> 进入<a href="https://github.com/qiubaiying/qiubaiying.github.io" target="_blank" rel="noopener">我的仓库</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-1b234fb8549e58aa.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>点击右上角的 <strong>Fork</strong> 将我的仓库拉倒你的账号下</p>
<p>稍等一下，点击刷新，你会看到<strong>Fork</strong>了成功的页面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-b2347768a1f2d993.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h3 id="修改仓库名"><a href="#修改仓库名" class="headerlink" title="修改仓库名"></a>修改仓库名</h3><p>点击<strong>settings</strong>进入设置</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-f47b7e4802de6a34.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p id = "Rename"></p>
修改仓库名为 `你的Github账号名.github.io`，然后 Rename

<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ca3d843e526cdd5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这时你在在浏览器中输入 <code>你的Github账号名.github.io</code> 例如:<code>baiyingqiu.github.io</code></p>
<p>你将会看到如下界面</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-96b5db55df9db422.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>说明已经成功一半了😀。。。当然，还需要修改博客的配置才能变成你的博客。</p>
<p>若是出现</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-cfd55a22902a9d2c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>则需要 <a href="#Rename">检查一下你的仓库名是否正确</a></p>
<h3 id="整个网站结构"><a href="#整个网站结构" class="headerlink" title="整个网站结构"></a>整个网站结构</h3><p>修改Blog前我们来看看Jekyll 网站的基础结构，当然我们的网站比这个复杂。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── _drafts</span><br><span class="line">|   ├── begin-with-the-crazy-ideas.textile</span><br><span class="line">|   └── on-simplicity-in-technology.markdown</span><br><span class="line">├── _includes</span><br><span class="line">|   ├── footer.html</span><br><span class="line">|   └── header.html</span><br><span class="line">├── _layouts</span><br><span class="line">|   ├── default.html</span><br><span class="line">|   └── post.html</span><br><span class="line">├── _posts</span><br><span class="line">|   ├── 2007-10-29-why-every-programmer-should-play-nethack.textile</span><br><span class="line">|   └── 2009-04-26-barcamp-boston-4-roundup.textile</span><br><span class="line">├── _data</span><br><span class="line">|   └── members.yml</span><br><span class="line">├── _site</span><br><span class="line">├── img</span><br><span class="line">└── index.html</span><br></pre></td></tr></table></figure>

<p>很复杂看不懂是不是，不要紧，你只要记住其中几个OK了</p>
<ul>
<li><code>_config.yml</code> 全局配置文件</li>
<li><code>_posts</code>    放置博客文章的文件夹</li>
<li><code>img</code>    存放图片的文件夹</li>
</ul>
<p>其他的想继续深究可以<a href="http://jekyll.com.cn/docs/structure/" target="_blank" rel="noopener">看这里</a></p>
<h3 id="修改博客配置"><a href="#修改博客配置" class="headerlink" title="修改博客配置"></a>修改博客配置</h3><p>来到你的仓库，找到<code>_config.yml</code>文件,这是网站的全局配置文件。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-c23d4a5d67c88084.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>点击修改</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-b37268df7a7852ca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>然后编辑<code>_config.yml</code>的内容</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0c8750f5a18dbe03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>接下来我们来详细说说以下配置文件的内容：</p>
<h4 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Site settings</span><br><span class="line">title: You Blog    				  	#你博客的标题</span><br><span class="line">SEOTitle: 你的博客 | You Blog    	 #显示在浏览器上搜索的时候显示的标题</span><br><span class="line">header-img: img/post-bg-rwd.jpg  	#显示在首页的背景图片</span><br><span class="line">email: You@gmail.com	</span><br><span class="line">description: &quot;You Blog&quot;  			 #网站介绍</span><br><span class="line">keyword: &quot;BY, BY Blog, 柏荧的博客, qiubaiying, 邱柏荧, iOS, Apple, iPhone&quot; #关键词</span><br><span class="line">url: &quot;https://qiubaiying.github.io&quot;          # 这个就是填写你的博客地址</span><br><span class="line">baseurl: &quot;&quot;      # 这个我们不用填写</span><br></pre></td></tr></table></figure>
<h4 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Sidebar settings</span><br><span class="line">sidebar: true                           # 是否开启侧边栏.</span><br><span class="line">sidebar-about-description: &quot;说点装逼的话。。。&quot;</span><br><span class="line">sidebar-avatar:/img/avatar-by.JPG      # 你的个人头像 这里你可以改成我在img文件夹中的两张备用照片 img/avatar-m 或 avatar-g</span><br></pre></td></tr></table></figure>
<h4 id="社交账号"><a href="#社交账号" class="headerlink" title="社交账号"></a>社交账号</h4><p>展示你的其他社交平台</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ec775a22f76e2f40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在下面你的社交账号的用户名就可以了，若没有可不用填</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># SNS settings</span><br><span class="line">RSS: false</span><br><span class="line">weibo_username:     username</span><br><span class="line">zhihu_username:     username</span><br><span class="line">github_username:    username</span><br><span class="line">facebook_username:  username</span><br><span class="line">jianshu_username:	jianshu_id</span><br></pre></td></tr></table></figure>

<p>新加入了<strong>简书</strong>，<code>jianshu_id</code> 在你打开你的简书主页后的地址如：<code>http://www.jianshu.com/u/e71990ada2fd</code>中，后面这一串数字：<code>e71990ada2fd</code></p>
<h4 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h4><p>博客中使用的是 <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a> 评论系统，在 <a href="https://disqus.com/" target="_blank" rel="noopener">官网</a> 注册帐号后，按下面的步骤简单的配置即可：</p>
<p>进入 <a href="https://disqus.com/home/settings/profile/" target="_blank" rel="noopener">设置页面</a> 配置个人信息</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-904ecb30c536c73b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配置 Disqus 个人信息"></p>
<p>找到 <strong>Username</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-19d1b9e7d2624bfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Disqus Account"></p>
<p>这个 <strong>Username</strong>  就是我们 <code>_config.yml</code> 中 <code>disqus_username</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Disqus settings（https://disqus.com/）</span><br><span class="line">disqus_username: qiubaiying</span><br></pre></td></tr></table></figure>

<blockquote>
<p>很对人反映 Disqus 评论插件加载不出来，因为 Disqus 在国内加载缓慢，所以我新集成了 Gitalk 评论插件（感谢<a href="https://github.com/FeDemo" target="_blank" rel="noopener">@FeDemo</a>的推荐），喜欢折腾的朋友可以看这篇：<a href="http://qiubaiying.top/2017/12/19/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6/" target="_blank" rel="noopener">《为博客添加 Gitalk 评论插件》</a>。 我已经在<code>_config.yml</code> 配置就好了，只需要填写参数可以了。</p>
</blockquote>
<h4 id="网站统计"><a href="#网站统计" class="headerlink" title="网站统计"></a>网站统计</h4><p>集成了 <a href="http://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">Baidu Analytics</a> 和 <a href="http://www.google.cn/analytics/" target="_blank" rel="noopener">Google Analytics</a>，到各个网站注册拿到track_id替换下面的就可以了</p>
<p>这是我的 Google Analytics</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-c36b895c53196fdb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>不要使用我的track_id</strong>😂。。。</p>
<p>若不想启用统计，直接删除或注释掉就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Analytics settings</span><br><span class="line"># Baidu Analytics</span><br><span class="line">ba_track_id: 83e259f69b37d02a4633a2b7d960139c</span><br><span class="line"></span><br><span class="line"># Google Analytics</span><br><span class="line">ga_track_id: &apos;UA-90855596-1&apos;            # Format: UA-xxxxxx-xx</span><br><span class="line">ga_domain: auto</span><br></pre></td></tr></table></figure>

<h4 id="好友"><a href="#好友" class="headerlink" title="好友"></a>好友</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">friends: [</span><br><span class="line">    &#123;</span><br><span class="line">        title: &quot;简书·BY&quot;,</span><br><span class="line">        href: &quot;http://www.jianshu.com/u/e71990ada2fd&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        title: &quot;Apple&quot;,</span><br><span class="line">        href: &quot;https://apple.com&quot;</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        title: &quot;Apple Developer&quot;,</span><br><span class="line">        href: &quot;https://developer.apple.com/&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h4><p>讲网页拉倒底部，点击 <code>Commit changes</code> 提交保存</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0781006b5d15d149.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>再次进入你的主页，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-a49ee2975d524c93.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>恭喜你，你的个人博客搭建完成了😀。</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>利用 Github网站 ，我们可以不用学习<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>，就可以轻松管理自己的博客</p>
<p>对于轻车熟路的程序猿来说，使用git管理会更加方便。。。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>文章统一放在网站根目录下的 <code>_posts</code> 的文件夹中。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-fb74cdc11a950bd4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>创建一个文件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9a47b2074362e570.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>在下面写文章，和标题，还能实时预览，最后提交保存就能看到自己的新文章了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-88acd9e29fa3ae8a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><p>每一篇文章文件命名采用的是<code>2017-02-04-Hello-2017.md</code>时间+标题的形式，空格用<code>-</code>替换连接。</p>
<p>文件的格式是 <code>.md</code> 的 <a href="http://sspai.com/25137/" target="_blank" rel="noopener"><strong>MarkDown</strong></a> 文件。</p>
<p>我们的博客文章格式采用是 <strong>MarkDown</strong>+ <strong>YAML</strong> 的方式。</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html?f=tt" target="_blank" rel="noopener"><strong>YAML</strong></a> 就是我们配置 <code>_config</code>文件用的语言。</p>
<p><a href="http://sspai.com/25137/" target="_blank" rel="noopener"><strong>MarkDown</strong></a> 是一种轻量级的「标记语言」，很简单。<a href="http://sspai.com/25137" target="_blank" rel="noopener">花半个小时看一下</a>就能熟练使用了</p>
<p>大概就是这么一个结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">layout:     post   				    # 使用的布局（不需要改）</span><br><span class="line">title:      My First Post 				# 标题 </span><br><span class="line">subtitle:   Hello World, Hello Blog #副标题</span><br><span class="line">date:       2017-02-06 				# 时间</span><br><span class="line">author:     BY 						# 作者</span><br><span class="line">header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片</span><br><span class="line">catalog: true 						# 是否归档</span><br><span class="line">tags:								#标签</span><br><span class="line">    - 生活</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## Hey</span><br><span class="line">&gt;这是我的第一篇博客。</span><br><span class="line"></span><br><span class="line">进入你的博客主页，新的文章将会出现在你的主页上.</span><br></pre></td></tr></table></figure>

<p>按格式创建文章后，提交保存。进入你的博客主页，新的文章将会出现在你的主页上.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-f4d5bb65ae3abd00.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>到这里，恭喜你！</p>
<p>你已经成功搭建了自己的个人博客以及学会在博客上撰写文字的技能了（是不是有点小兴奋🙈）。</p>
<h4 id="首页标签"><a href="#首页标签" class="headerlink" title="首页标签"></a>首页标签</h4><p>在首页可以看到这些特色标签，当你的文章出现相同标签（默认相同的<strong>标签数量大于1</strong>），才会自动生成。</p>
<p>所以当你只放一篇文章的时候是不会出现标签的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9281b7176c456f92.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>建站的初期，博客比较少，若你想直接在首页生成比较多的标签。你可以在 <code>_congfig.yml</code>中找到这段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Featured Tags</span><br><span class="line">featured-tags: true                     # 是否使用首页标签</span><br><span class="line">featured-condition-size: 1              # 相同标签数量大于这个数，才会出现在首页</span><br></pre></td></tr></table></figure>

<p>将其修改为<code>featured-condition-size: 0</code>, 这样只有一个标签时也会出现在首页了。</p>
<p>相反，当你博客比较多，标签也很多时，这时你就需要改回 <code>1</code> 甚至是 <code>2</code> 了。</p>
<h1 id="自定义域名"><a href="#自定义域名" class="headerlink" title="自定义域名"></a>自定义域名</h1><p>搭建好博客之后 你可能不想直接使用 <a href="http://baiyingqiu.github.io" target="_blank" rel="noopener">baiyingqiu.github.io</a> 这么长的博客域名吧, 想换成想 <a href="http://qiubaiying.top" target="_blank" rel="noopener">qiubaiying.top</a> 这样简短的域名。那我们开始吧！</p>
<h4 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h4><p>首先，你必须购买一个自己的域名。</p>
<p>我是在<a href="https://wanwang.aliyun.com/domain/?spm=5176.8006371.1007.dnetcndomain.q1ys4x" target="_blank" rel="noopener">阿里云</a>购买的域名</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ef3844cab15e35ff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>用<strong>阿里云</strong> app也可以注册域名，域名的价格根据后缀的不同和域名的长度而分，比如我这个 <code>qiubaiying.top</code> 的域名第一年才只要4元~</p>
<p>域名尽量选择短一点比较好记住，注意，不能选择中文域名，比如 <code>张三.top</code> ,GitHub Pages <strong>无法处理中文域名</strong>，会导致你的域名在你的主页上使用。</p>
<p>注册的步骤就不在介绍了</p>
<h4 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h4><p>注册好域名后，需要将域名解析到你的博客上</p>
<p>管理控制台 → 域名与网站（万网） → 域名</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9a75bba50d1b14d7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>选择你注册好的域名，点击解析</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0968a8dd2045f4fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>添加解析</p>
<p>分别添加两个<code>A</code> 记录类型,</p>
<p>一个主机记录为 <code>www</code>,代表可以解析 <code>www.qiubaiying.top</code>的域名</p>
<p>另一个为 <code>@</code>, 代表 <code>qiubaiying.top</code></p>
<p>记录值就是我们博客的IP地址，是 GitHub Pagas 在美国的服务器的地址 <code>151.101.100.133</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0769a93bc487e9d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以通过 <a href="http://ip.chinaz.com/" target="_blank" rel="noopener">这个网站</a>  或者直接在终端输入<code>ping 你的地址</code>，查看博客的IP</p>
<pre><code>ping qiubaiying.github.io</code></pre><p>细心地你会发现所有人的博客都解析到 <code>151.101.100.133</code> 这个IP。</p>
<p>然后 GitHub Pages 再通过 CNAME记录 跳转到你的主页上。</p>
<h4 id="修改CNAME"><a href="#修改CNAME" class="headerlink" title="修改CNAME"></a>修改CNAME</h4><p>最后一步，只需要修改 我们github仓库下的 <strong>CNAME</strong> 文件。</p>
<p>选择 <strong>CNAME</strong> 文件</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-a422f3dab436dfb7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>使用的注册的域名进行替换,然后提交保存</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-6e613004fb410b44.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这时，输入你自己的域名，就可以解析到你的主页了。</p>
<p>大功告成！</p>
<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>若你对博客模板进行修改，你就要看看 Jekyll 的<a href="http://jekyll.com.cn" target="_blank" rel="noopener">开发文档</a>,是中文文档哦，对英语一般的朋友简直是福利啊（比如说我😀）。</p>
<p>还要学习 <strong>Git</strong> 和 <strong>GitHub</strong> 的工作机制了及使用。</p>
<p>你可以先看看这个<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/" target="_blank" rel="noopener">git教程</a>，对git有个初步的了解后，那么相信你就能将自己图片传到GitHub仓库上，或者可以说掌握了 <strong>使用git管理自己的GitHub仓库</strong> 的技能呢。</p>
<p>对于轻车熟路的程序猿来说，这篇教程就算就结束了，因为下面的内容对于你们来说 so eazy~</p>
<p>但相信很多小白都一脸懵逼，那我们继续👇。</p>
<h1 id="利用GithHub-Desktop管理GitHub仓库"><a href="#利用GithHub-Desktop管理GitHub仓库" class="headerlink" title="利用GithHub Desktop管理GitHub仓库"></a>利用GithHub Desktop管理GitHub仓库</h1><p><a href="https://desktop.github.com/" target="_blank" rel="noopener">GithHub Desktop</a> 是 <strong>GithHub</strong> 推出的一款管理GitHub仓库的桌面软件，换句话说就是将你在<strong>Github</strong>上的文件同步到本地电脑上，并将修改后的文件同步到<strong>Github</strong>远程仓库。</p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>点击图片进入下载页面，选择对应的平台进行下载</p>
<p><a href="https://desktop.github.com/" target="_blank" rel="noopener"><img src="http://upload-images.jianshu.io/upload_images/2178672-6022ba3938b3088e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></a></p>
<p>下面以<strong>Mac</strong>平台为例：</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>将下载好的文件解压，将这只小猫拖到应用程序文件夹中</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-8f8c27f4e5c72276.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>就可以在<strong>Launchpad</strong>找到这只小猫咪~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0f2da4717361459c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><p>点开应用,会弹出<strong>登录</strong>框，</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-adb7d6824e471ef5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>输入你的<strong>GitHub</strong>账号和密码进行登录</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-2d7c407ebddbb44f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>登录后关闭窗口</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-93cdccc42024914b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>然后返回引导窗，一直按 <strong>Continue</strong> 继续</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-450ccef6b1ab7b0a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>Continue</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-06b6e6792472ecae.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>还是<strong>Continue</strong>~<br><img src="http://upload-images.jianshu.io/upload_images/2178672-681a6c455f6b512f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>进入主界面，先 <strong>右键Remve</strong> 删除这个用户指导，贼烦~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-604f6f23b8fab6f3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h4><p>选择你的仓库克隆到本地</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-45ddcd27e2f858a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-625be1220fea36b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="管理仓库"><a href="#管理仓库" class="headerlink" title="管理仓库"></a>管理仓库</h4><p>现在文件夹中打开</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-92c1616af56b501a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>打开后你会的发现文件结构和你在Github上的一模一样~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-bf3580ae1cd9a29e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>你最先关心的可能是你的头像~在<strong>img</strong>文件夹中把替换我的头像就好了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-c9421d64538c3ba6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>不仅是图片，所有在Github上的的操作都可以进行。</p>
<h4 id="保存修改"><a href="#保存修改" class="headerlink" title="保存修改"></a>保存修改</h4><p>当你对仓库文件夹的文件下进行修改、添加或删除时，都可以在 <strong>GitHub Desktop</strong> 中看到</p>
<p>例如我在 <code>img</code> 中添加了一张图片 <code>avatar-demo.png</code> 添加了一张图片</p>
<p>就可以在看到<strong>GitHub Desktop</strong>显示了我的修改</p>
<p>保存修改只要按 <strong>Commit to master</strong>，然后可以写上你的修改说明</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-4bfbfec37cbb8eb6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>将修改同步到 <strong>GitHub</strong> 远程仓库上只需要一步：点击右上角的<strong>同步按钮</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-3c2ee8234a7f1832.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h4><p>打开你的GitHub上的仓库，你就可以看到已经和本地同步了</p>
<p>可以看到你提交的详情： <code>add img</code> </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-293bdd4cbee0e9e3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>这样，你已经能轻松管理自己的博客了。</p>
<p>想上传头像，背景，或者是删掉你不要的图片（我的头像😏）已经是 so eazy了吧~</p>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>你在 <strong>GitHub</strong> 网站上进行 <strong>Commit</strong> 操作后，需要在<strong>GitHub Desktop</strong>上按一下 <strong>同步按键</strong> 才能同步网站上的修改到你的本地。</p>
<h1 id="修改个人介绍"><a href="#修改个人介绍" class="headerlink" title="修改个人介绍"></a>修改个人介绍</h1><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fme0poz7gqj30vq0l8whh.jpg" alt=""></p>
<p>修改个人介绍需要修改根目录下的 <code>about.html</code> 文件</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fme0rna33tj30bw0bntah.jpg" alt=""></p>
<p>看不懂 HTML 标签？没关系，对照着修改就好了~ 还有注意这个有中英介绍</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fme0sbvmmcj30zp0os7ap.jpg" alt=""></p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>最近有很多人给我提问题，我这边总结一下</p>
<h4 id="配置文件修改后没有效果"><a href="#配置文件修改后没有效果" class="headerlink" title="配置文件修改后没有效果"></a>配置文件修改后没有效果</h4><p>刷新几遍浏览器就好了~</p>
<p>不行的话，先清除浏览器缓存再试试。</p>
<h4 id="404错误"><a href="#404错误" class="headerlink" title="404错误"></a>404错误</h4><ol>
<li>检查你的仓库名是否有按照要求填写</li>
<li>确定 <strong>Fork</strong> 的是不是我的仓库~</li>
</ol>
<h4 id="修改CNAME文件，域名还是不变"><a href="#修改CNAME文件，域名还是不变" class="headerlink" title="修改CNAME文件，域名还是不变"></a>修改CNAME文件，域名还是不变</h4><p>清除浏览器缓存就OK~</p>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><p>直接在评论中提出来或私信我，我会一一替大家解决的😀</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>最近有人往我的远程仓库不停的 <strong>push</strong>，一天连收几十封邮件！例如像这样的</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-1347f2cc9a4a8dc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>原因大多是直接Clone了我的仓库到本地，<strong>没有删除我的远程仓库地址</strong>，添加完自己的仓库地址后，一口气推送到所有远程仓库（包括我的😂）~</p>
<p>打扰了我的工作和生活~</p>
<p>所以，<strong>请不要往我的仓库上推送分支</strong>！</p>
<p>我发现一个问题是，很多人每次修改博客的内容都commit一次到远程仓库，然后再查看修改结果，这样效率非常低！</p>
<h4 id="来，上车！"><a href="#来，上车！" class="headerlink" title="来，上车！"></a>来，上车！</h4><h2 id="在本地调试博客"><a href="#在本地调试博客" class="headerlink" title="在本地调试博客"></a>在本地调试博客</h2><blockquote>
<p>注：下面的操作是在 <strong>Mac</strong> 终端进行的。<br><strong>Windows</strong> 环境下的配置请参考 <a href="http://www.jianshu.com/u/a13e7484dc21" target="_blank" rel="noopener">@梦幻之云</a> 提供的 <a href="https://agcaiyun.cn/2017/09/10/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">这篇文章</a>。</p>
</blockquote>
<p>有心的同学在 <a href="http://jekyllcn.com/" target="_blank" rel="noopener">jekyll官网</a> 就会发现 <code>jekyll</code> 的 提供的实例代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~ $ gem install jekyll bundler</span><br><span class="line">~ $ jekyll new my-awesome-site</span><br><span class="line">~ $ cd my-awesome-site</span><br><span class="line">~/my-awesome-site $ bundle install</span><br><span class="line">~/my-awesome-site $ bundle exec jekyll serve</span><br><span class="line"># =&gt; 打开浏览器 http://localhost:4000</span><br></pre></td></tr></table></figure>


<p>这段命令创建了一个默认的 <code>jekll</code> 网站，然后在本机的 4000 窗口展示。聪明的你应该发现怎么做了吧~</p>
<p>安装 <code>jekyll</code>和 <code>jekyll bundler</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gem install jekyll</span><br><span class="line">$ gem install jekyll bundler</span><br></pre></td></tr></table></figure>

<p>进入你的 <strong>Blog 所在目录</strong>，然后创建本地服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jekyll s</span><br></pre></td></tr></table></figure>

<p>然后会显示 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Auto-regeneration: enabled for &apos;/Users/baiying/Blog&apos;</span><br><span class="line">Configuration file: /Users/baiying/Blog/_config.yml</span><br><span class="line">    Server address: http://127.0.0.1:4000/</span><br><span class="line">  Server running... press ctrl-c to stop.</span><br></pre></td></tr></table></figure>

<p>你就可以在 <a href="http://127.0.0.1:4000/" target="_blank" rel="noopener">http://127.0.0.1:4000/</a> 看到你的博客，你对本地博客的修改都会在这个地址进行显示，这大大提高了对博客的配置效率。</p>
<p>使用<code>ctrl+c</code>就可以停止 <strong>serve</strong></p>
<h1 id="Star"><a href="#Star" class="headerlink" title="Star"></a>Star</h1><p>若本教程顺利帮你搭建了自己的个人博客，请不要 <strong>害羞</strong>，给我的 <a href="https://github.com/qiubaiying/qiubaiying.github.io" target="_blank" rel="noopener">github仓库</a> 点个 <strong>star</strong> 吧！</p>
<p>因为最近发现 Fork 将近破百，加上直接 Clone 仓库的，保守估计已经帮助上百人成功的搭建了自己的博客，<del>可是 Star 却仅仅只有 <strong>12</strong>！可能还是做的不够好吧！</del>现在已经破百了，感谢大家的Star！</p>
<h3 id="别无他求，点个-Star-吧！"><a href="#别无他求，点个-Star-吧！" class="headerlink" title="别无他求，点个 Star 吧！"></a><strong>别无他求，点个 <a href="https://github.com/qiubaiying/qiubaiying.github.io" target="_blank" rel="noopener">Star</a> 吧</strong>！</h3><p><img src="http://upload-images.jianshu.io/upload_images/2178672-768a38ee9fb0df28.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>心满意足！</strong></p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h4 id="修改网站的-icon"><a href="#修改网站的-icon" class="headerlink" title="修改网站的 icon"></a>修改网站的 <strong>icon</strong></h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flgh6k23ppj30ad00uq2t.jpg" alt=""></p>
<p>要修改如图所示的网站 <strong>icon</strong>：</p>
<p>在博客 <code>img</code> 目录下找到并替换 <code>favicon.ico</code> 这个图标即可，图标尺寸为<code>32x32</code>。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1flghahch1oj30gu09y419.jpg" alt=""></p>
<h4 id="修改主页的座右铭"><a href="#修改主页的座右铭" class="headerlink" title="修改主页的座右铭"></a>修改主页的座右铭</h4><p>最近有不少小伙伴私信我：<strong>如何修改主页的座右铭？</strong></p>
<p>就是这个：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-31dc0068f256aca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>很简单，找到博客目录下的 <strong>index.html</strong> 文件，修改这句话就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9e4785654523bf07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="如何在博客文章中上插入图片"><a href="#如何在博客文章中上插入图片" class="headerlink" title="如何在博客文章中上插入图片"></a>如何在博客文章中上插入图片</h4><p>博客的文章用的是 MarkDown 格式，如果没用过 MarkDown 真的 强烈推荐 <a href="http://sspai.com/25137" target="_blank" rel="noopener">花半个小时学习一下</a>。</p>
<p>MarkDown 中添加图片的形式是 :<code>![](图片的URL)</code></p>
<p>例如：</p>
<p><code>![MarkDown示例图片](http://upload-images.jianshu.io/upload_images/2178672-eb2effd6b942a500.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</code>就会显示下面这张图片</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-98965f66db8f5856.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="MarkDown示例图片"></p>
<p><code>https://ws3.sinaimg.cn/large/006tNc79gy1fj9xhjzobbj30yg0my75z.jpg</code>就是这张图片的URL，我们可以在浏览器输入这个URL找到或下载这张图片。</p>
<p>所以，要在 MacDown 中插入图片，这张图片就需要上传到图床（网上），然后在引<br>用这张图片的URL。</p>
<h5 id="将图片上传到图床"><a href="#将图片上传到图床" class="headerlink" title="将图片上传到图床"></a>将图片上传到图床</h5><p>Mac 上的图床神器：iPic  </p>
<p>直接在App Store上下载，谁用谁知道！</p>
<p>使用方法很简单，直接拖动图片到 P 图标上，或者选中图片按快捷键 <code>⌘+U</code>，就能请示上传。</p>
<p>上传成功就能直接粘贴图片的URL。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-7399aeaced6f1e29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iPic"></p>
<p>用 iPic 上传图片后，获取URL插入文章中就可以了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-4be76fb02708de5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iPic上传图片"></p>
<h4 id="推荐几个好用软件"><a href="#推荐几个好用软件" class="headerlink" title="推荐几个好用软件"></a>推荐几个好用软件</h4><h5 id="MarkDown编辑器"><a href="#MarkDown编辑器" class="headerlink" title="MarkDown编辑器"></a>MarkDown编辑器</h5><p><a href="https://macdown.uranusjr.com/" target="_blank" rel="noopener">MacDown</a>：可能是Mac上最好的MacDown编辑器了  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-2226239a63278302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h5 id="图片压缩工具"><a href="#图片压缩工具" class="headerlink" title="图片压缩工具"></a>图片压缩工具</h5><p><a href="https://imageoptim.com/" target="_blank" rel="noopener">ImageOptim</a></p>
<p>对于我们的博客来说，图片越大，加载速度越慢。</p>
<p>不信你用手机打开你的博客试试~</p>
<p>所以有必要对我们上传到博客网站中的图片：指的是你的头像，首页背景图片，文章背景图片等。对于博客文章中插入的图片，其实也可以压缩了再上传。</p>
<p>对博客中的所有图片进行压缩：</p>
<p>看看压缩结果，最高的一张压缩了78.7%，这简直是太可怕了！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-0f8e643fa1da8674.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ImageOptim压缩图片"></p>
<p>好了，现在个人博客的加载速度估计要起飞了~</p>
<h1 id="最后要说个事情"><a href="#最后要说个事情" class="headerlink" title="最后要说个事情"></a>最后要说个事情</h1><p>我在博客中的文章，你们可以保留，让更多需要帮助人的看到，当然也可以删除。</p>
<p>但是，我发现居然有人把文章的作者改成了自己，然后当成自己的文章放在自己的博客上，这就令人感到气愤了。</p>
<p>比如说向我请教问题的这位：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-ed45ebafec7f5d34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>我在博客中的每篇文章都是我一字一句敲出来的，转载的文章我也注明了出处，表示对原作者的尊重。同时也希望大家都能尊重我的付出。</p>
<p>谢谢~</p>
]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 快速调出终端</title>
    <url>/folder/2017/02/06/2017-2-9-Mac%E5%BF%AB%E9%80%9F%E8%B0%83%E5%87%BA%E7%BB%88%E7%AB%AF/</url>
    <content><![CDATA[<blockquote>
<p>在Mac下快速调出终端的方法是：为终端添加一个快捷键打开方式</p>
</blockquote>
<h2 id="为终端添加一个快捷键打开方式"><a href="#为终端添加一个快捷键打开方式" class="headerlink" title="为终端添加一个快捷键打开方式"></a>为终端添加一个快捷键打开方式</h2><p>打开Mac下自带的软件 <strong>Automator</strong></p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fckb184f74j319v0q01kx.jpg" alt=""></p>
<p>新建文稿</p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fckb6zzo28j30mo0fvgn7.jpg" alt=""></p>
<p>创建一个服务</p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fckb93qmy5j30g00fh0vq.jpg" alt=""></p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fckbfe8o0zj30t10lb0wv.jpg" alt=""></p>
<p><img src="https://ww1.sinaimg.cn/large/006tKfTcgy1fckbff4e7pj30t10lbwis.jpg" alt=""></p>
<p>修改框内的脚本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on run &#123;input, parameters&#125;	tell application &quot;Terminal&quot;		reopen		activate	end tellend run</span><br></pre></td></tr></table></figure>

<p>运行：<code>command + R</code>，如果没有问题，则会打开终端</p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fckaqdd2m1j30t10lb42a.jpg" alt=""></p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fckaq4nn9hj30iy0daaan.jpg" alt=""></p>
<p>保存：<code>Command + S</code>，将其命名为<code>打开终端</code>或你想要的名字</p>
<p>设置快捷键</p>
<p>在 <strong>系统偏好设置</strong> -&gt; <strong>键盘设置</strong> -&gt; <strong>快捷键</strong> -&gt; <strong>服务</strong></p>
<p>选择我们创建好的 ‘<strong>打开终端</strong>‘，设置你想要的快捷键，比我我设置了<code>⌘+空格</code></p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fckbvaixhnj30kw0ihq67.jpg" alt=""></p>
<p>到此，设置完成。</p>
<p>聪明的你也许会发现，这个技巧能为所有的程序设置快捷启动。</p>
<p>将脚本中的 <code>Terminal</code> 替换成 其他程序就可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">on run &#123;input, parameters&#125;</span><br><span class="line">    tell application &quot;Terminal&quot;</span><br><span class="line">        reopen</span><br><span class="line">        activate</span><br><span class="line">    end tell</span><br><span class="line">end run</span><br></pre></td></tr></table></figure>

<h2 id="黑技能"><a href="#黑技能" class="headerlink" title="黑技能"></a>黑技能</h2><p>既然学了 <code>Automator</code> ，那就在附上一个黑技能吧。为你的代码排序。在 <strong>Xcode8</strong>以前，有个插件能为代码快速排序，不过时过境迁~ 对于没用的插件而且又有患有强迫症的的小伙伴，只能手动排序了（😂）.</p>
<p>首先还是创建一个服务</p>
<p>创建一个<code>Shell</code>脚本，</p>
<p>勾选:<code>用输出内容替换所选文本</code></p>
<p>输入：<code>sort|uniq</code> </p>
<p>保存： 存为<code>Sort &amp; Uniq</code></p>
<p><img src="https://ww4.sinaimg.cn/large/006tKfTcgy1fckd40rgwmj30rt0ildiy.jpg" alt=""></p>
<p><strong>选中你的代代码</strong> -&gt; <strong>鼠标右键</strong> -&gt; <strong>Servies</strong> -&gt; <strong>Sort&amp;Uniq</strong></p>
<p><img src="https://ww2.sinaimg.cn/large/006tKfTcgy1fckd6tx1dzj30h90b7mzm.jpg" alt=""></p>
<p>排序后的代码：</p>
<p><img src="https://ww3.sinaimg.cn/large/006tKfTcgy1fckd6lak55j309j05y3yo.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>开发技巧</tag>
        <tag>Mac</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title>BYPhoneNumTF</title>
    <url>/folder/2017/02/04/2016-10-26-BYPhoneNumTF/</url>
    <content><![CDATA[<blockquote>
<p><strong>BYPhoneNumTF</strong> 一个电话号码格式的文本框</p>
</blockquote>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>当在<code>TextField</code>输入数字时，会自动分隔为：137 9922 2299 或 137-9922-2299</p>
<p>限制文本输入个数</p>
<p>限制只能输入数字</p>
<h1 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h1><p><img src="http://ww2.sinaimg.cn/large/7853084cgw1fa3cqnu8s2g207i0dc4qp.gif" alt=""></p>
<h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><p>要实现电话号码格式的输入看似简单，但是实现起来坑非常多，至于坑是什么只有各位动手写了才能体会~</p>
<p>下面我们来实现该功能：</p>
<p>首先要遵守协议<code>&lt;UITextFieldDelegate&gt;</code></p>
<p>然后在<code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string</code> 方法中实现我们的逻辑</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;LoginVC.h&quot;</span><br><span class="line"></span><br><span class="line">#define placeholder @&quot; &quot;</span><br><span class="line"></span><br><span class="line">@interface LoginVC () &lt;UITextFieldDelegate&gt;</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *phoneNumberTF;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123;</span><br><span class="line"></span><br><span class="line">    NSString *phStr = placeholder;</span><br><span class="line">    unichar phChar = &apos; &apos;;</span><br><span class="line">    if (phStr.length) &#123;</span><br><span class="line">        phChar = [phStr characterAtIndex:0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (textField) &#123;</span><br><span class="line">        NSString* text = textField.text;</span><br><span class="line">        //删除</span><br><span class="line">        if([string isEqualToString:@&quot;&quot;])&#123;</span><br><span class="line">            </span><br><span class="line">            //删除一位</span><br><span class="line">            if(range.length == 1)&#123;</span><br><span class="line">                //最后一位,遇到空格则多删除一次</span><br><span class="line">                if (range.location == text.length - 1 ) &#123;</span><br><span class="line">                    if ([text characterAtIndex:text.length - 1] == phChar) &#123;</span><br><span class="line">                        [textField deleteBackward];</span><br><span class="line">                    &#125;</span><br><span class="line">                    return YES;</span><br><span class="line">                &#125;</span><br><span class="line">                //从中间删除</span><br><span class="line">                else&#123;</span><br><span class="line">                    NSInteger offset = range.location;</span><br><span class="line">                    </span><br><span class="line">                    if (range.location &lt; text.length &amp;&amp; [text characterAtIndex:range.location] == phChar &amp;&amp; [textField.selectedTextRange isEmpty]) &#123;</span><br><span class="line">                        [textField deleteBackward];</span><br><span class="line">                        offset --;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [textField deleteBackward];</span><br><span class="line">                    textField.text = [self _parseString:textField.text];</span><br><span class="line">                    UITextPosition *newPos = [textField positionFromPosition:textField.beginningOfDocument offset:offset];</span><br><span class="line">                    textField.selectedTextRange = [textField textRangeFromPosition:newPos toPosition:newPos];</span><br><span class="line">                    return NO;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (range.length &gt; 1) &#123;</span><br><span class="line">                BOOL isLast = NO;</span><br><span class="line">                //如果是从最后一位开始</span><br><span class="line">                if(range.location + range.length == textField.text.length )&#123;</span><br><span class="line">                    isLast = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                [textField deleteBackward];</span><br><span class="line">                textField.text = [self _parseString:textField.text];</span><br><span class="line">                </span><br><span class="line">                NSInteger offset = range.location;</span><br><span class="line">                if (range.location == 3 || range.location  == 8) &#123;</span><br><span class="line">                    offset ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isLast) &#123;</span><br><span class="line">                    //光标直接在最后一位了</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    UITextPosition *newPos = [textField positionFromPosition:textField.beginningOfDocument offset:offset];</span><br><span class="line">                    textField.selectedTextRange = [textField textRangeFromPosition:newPos toPosition:newPos];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            else&#123;</span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else if(string.length &gt;0)&#123;</span><br><span class="line">            </span><br><span class="line">            //限制输入字符个数</span><br><span class="line">            if (([self _noneSpaseString:textField.text].length + string.length - range.length &gt; 11) ) &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //判断是否是纯数字(搜狗，百度输入法，数字键盘居然可以输入其他字符)</span><br><span class="line">            if(![self _isNum:string])&#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            [textField insertText:string];</span><br><span class="line">            textField.text = [self _parseString:textField.text];</span><br><span class="line">            </span><br><span class="line">            NSInteger offset = range.location + string.length;</span><br><span class="line">            if (range.location == 3 || range.location  == 8) &#123;</span><br><span class="line">                offset ++;</span><br><span class="line">            &#125;</span><br><span class="line">            UITextPosition *newPos = [textField positionFromPosition:textField.beginningOfDocument offset:offset];</span><br><span class="line">            textField.selectedTextRange = [textField textRangeFromPosition:newPos toPosition:newPos];</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString*)_parseString:(NSString*)string&#123;</span><br><span class="line">    </span><br><span class="line">    if (!string) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableString* mStr = [NSMutableString stringWithString:[string stringByReplacingOccurrencesOfString:placeholder withString:@&quot;&quot;]];</span><br><span class="line">    if (mStr.length &gt;3) &#123;</span><br><span class="line">        [mStr insertString:placeholder atIndex:3];</span><br><span class="line">    &#125;if (mStr.length &gt; 8) &#123;</span><br><span class="line">        [mStr insertString:placeholder atIndex:8];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return  mStr;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 获取正常电话号码（去掉空格） */</span><br><span class="line">- (NSString*)_noneSpaseString:(NSString*)string&#123;</span><br><span class="line">    </span><br><span class="line">    return [string stringByReplacingOccurrencesOfString:placeholder withString:@&quot;&quot;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)_isNum:(NSString *)checkedNumString &#123;</span><br><span class="line">    </span><br><span class="line">    if (!checkedNumString) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    checkedNumString = [checkedNumString stringByTrimmingCharactersInSet:[NSCharacterSet decimalDigitCharacterSet]];</span><br><span class="line">    </span><br><span class="line">    if(checkedNumString.length &gt; 0) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>###封装方法</p>
<p>需要实现的代码就是要这么多，但这些代码写在ViewController显得太臃肿了，所以我对代码进行了封装:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  BYPhoneNumTF.h</span><br><span class="line">//</span><br><span class="line">//  Created by BY on 16/12/2.</span><br><span class="line">//  Copyright © 2016年 BY. All rights reserved.</span><br><span class="line">//  电话号码类型的文本输入框，且只能输入数字</span><br><span class="line">//  输入显示：137 9922 1234 或 137-9922-1234</span><br><span class="line">//  使用方法：在XIB中的TextField继承该类即可</span><br><span class="line">//  修改占位符placeholder即可改变样式</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">// @&quot; &quot; or @&quot;-&quot;</span><br><span class="line">#define placeholder @&quot; &quot;</span><br><span class="line"></span><br><span class="line">@interface BYPhoneNumTF : UITextField</span><br><span class="line"></span><br><span class="line">/** 去掉格式的电话号码 */</span><br><span class="line">@property (nonatomic, strong) NSString *plainPhoneNum;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//</span><br><span class="line">//  BYPhoneNumTF.m</span><br><span class="line">//  dev-Jack</span><br><span class="line">//</span><br><span class="line">//  Created by BY on 16/12/2.</span><br><span class="line">//  Copyright © 2016年 Jack. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;BYPhoneNumTF.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface BYPhoneNumTF ()&lt;UITextFieldDelegate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation BYPhoneNumTF</span><br><span class="line"></span><br><span class="line">- (NSString *)plainPhoneNum &#123;</span><br><span class="line">    return [self _noneSpaseString:self.text];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)awakeFromNib &#123;</span><br><span class="line">    [super awakeFromNib];</span><br><span class="line">    self.delegate = self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123;</span><br><span class="line"></span><br><span class="line">    NSString *phStr = placeholder;</span><br><span class="line">    unichar phChar = &apos; &apos;;</span><br><span class="line">    if (phStr.length) &#123;</span><br><span class="line">        phChar = [phStr characterAtIndex:0];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if (textField) &#123;</span><br><span class="line">        NSString* text = textField.text;</span><br><span class="line">        //删除</span><br><span class="line">        if([string isEqualToString:@&quot;&quot;])&#123;</span><br><span class="line">            </span><br><span class="line">            //删除一位</span><br><span class="line">            if(range.length == 1)&#123;</span><br><span class="line">                //最后一位,遇到空格则多删除一次</span><br><span class="line">                if (range.location == text.length - 1 ) &#123;</span><br><span class="line">                    if ([text characterAtIndex:text.length - 1] == phChar) &#123;</span><br><span class="line">                        [textField deleteBackward];</span><br><span class="line">                    &#125;</span><br><span class="line">                    return YES;</span><br><span class="line">                &#125;</span><br><span class="line">                //从中间删除</span><br><span class="line">                else&#123;</span><br><span class="line">                    NSInteger offset = range.location;</span><br><span class="line">                    </span><br><span class="line">                    if (range.location &lt; text.length &amp;&amp; [text characterAtIndex:range.location] == phChar &amp;&amp; [textField.selectedTextRange isEmpty]) &#123;</span><br><span class="line">                        [textField deleteBackward];</span><br><span class="line">                        offset --;</span><br><span class="line">                    &#125;</span><br><span class="line">                    [textField deleteBackward];</span><br><span class="line">                    textField.text = [self _parseString:textField.text];</span><br><span class="line">                    UITextPosition *newPos = [textField positionFromPosition:textField.beginningOfDocument offset:offset];</span><br><span class="line">                    textField.selectedTextRange = [textField textRangeFromPosition:newPos toPosition:newPos];</span><br><span class="line">                    return NO;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (range.length &gt; 1) &#123;</span><br><span class="line">                BOOL isLast = NO;</span><br><span class="line">                //如果是从最后一位开始</span><br><span class="line">                if(range.location + range.length == textField.text.length )&#123;</span><br><span class="line">                    isLast = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                [textField deleteBackward];</span><br><span class="line">                textField.text = [self _parseString:textField.text];</span><br><span class="line">                </span><br><span class="line">                NSInteger offset = range.location;</span><br><span class="line">                if (range.location == 3 || range.location  == 8) &#123;</span><br><span class="line">                    offset ++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (isLast) &#123;</span><br><span class="line">                    //光标直接在最后一位了</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    UITextPosition *newPos = [textField positionFromPosition:textField.beginningOfDocument offset:offset];</span><br><span class="line">                    textField.selectedTextRange = [textField textRangeFromPosition:newPos toPosition:newPos];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            else&#123;</span><br><span class="line">                return YES;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        else if(string.length &gt;0)&#123;</span><br><span class="line">            </span><br><span class="line">            //限制输入字符个数</span><br><span class="line">            if (([self _noneSpaseString:textField.text].length + string.length - range.length &gt; 11) ) &#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            //判断是否是纯数字(搜狗，百度输入法，数字键盘居然可以输入其他字符)</span><br><span class="line">            if(![self _isNum:string])&#123;</span><br><span class="line">                return NO;</span><br><span class="line">            &#125;</span><br><span class="line">            [textField insertText:string];</span><br><span class="line">            textField.text = [self _parseString:textField.text];</span><br><span class="line">            </span><br><span class="line">            NSInteger offset = range.location + string.length;</span><br><span class="line">            if (range.location == 3 || range.location  == 8) &#123;</span><br><span class="line">                offset ++;</span><br><span class="line">            &#125;</span><br><span class="line">            UITextPosition *newPos = [textField positionFromPosition:textField.beginningOfDocument offset:offset];</span><br><span class="line">            textField.selectedTextRange = [textField textRangeFromPosition:newPos toPosition:newPos];</span><br><span class="line">            return NO;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return YES;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString*)_parseString:(NSString*)string&#123;</span><br><span class="line">    </span><br><span class="line">    if (!string) &#123;</span><br><span class="line">        return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    NSMutableString* mStr = [NSMutableString stringWithString:[string stringByReplacingOccurrencesOfString:placeholder withString:@&quot;&quot;]];</span><br><span class="line">    if (mStr.length &gt;3) &#123;</span><br><span class="line">        [mStr insertString:placeholder atIndex:3];</span><br><span class="line">    &#125;if (mStr.length &gt; 8) &#123;</span><br><span class="line">        [mStr insertString:placeholder atIndex:8];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return  mStr;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 获取正常电话号码（去掉空格） */</span><br><span class="line">- (NSString*)_noneSpaseString:(NSString*)string&#123;</span><br><span class="line">    </span><br><span class="line">    return [string stringByReplacingOccurrencesOfString:placeholder withString:@&quot;&quot;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)_isNum:(NSString *)checkedNumString &#123;</span><br><span class="line">    </span><br><span class="line">    if (!checkedNumString) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    checkedNumString = [checkedNumString stringByTrimmingCharactersInSet:[NSCharacterSet decimalDigitCharacterSet]];</span><br><span class="line">    </span><br><span class="line">    if(checkedNumString.length &gt; 0) &#123;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return YES;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>在storyboard中的<code>TextField</code>控件的Calss类型选择该类<code>BYPhoneNumTF</code>即可。</p>
<p>代码及Demo下载地址：<a href="https://github.com/qiubaiying/BYPhoneNumTF" target="_blank" rel="noopener">BYPhoneNumTF</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>轮子</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello 2017</title>
    <url>/folder/2017/02/04/2017-02-04-Hello-2017/</url>
    <content><![CDATA[<blockquote>
<p>“🙉🙉🙉 ”</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>BY 的 Blog 就这么开通了。</p>
<p>本来打算在年前完成 Blog 的搭建，不曾料想踩了很多坑。。。</p>
<p><a href="#build">跳过废话，直接看技术实现 </a> </p>
<p>2017 年，BY Blog 总算是搭建好了。</p>
<p>最开始写博客是在<a href="www.jianshu.com">简书</a>这个平台上，简书确实不错，支持markdown在线编辑。</p>
<p>在一次偶然间，听到我的好基友 <strong>阳阳</strong> 想搭建个人主页，觉得作为一个程序员，是应该倒腾倒腾自己的Blog，于是乎就开始了撸起袖子干了。</p>
<p id = "build"></p>
---

<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>接下来说说搭建这个博客的技术细节。  </p>
<p>正好之前就有关注过 <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> + <a href="http://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a> 快速 Building Blog 的技术方案，非常轻松时尚。</p>
<p>其优点非常明显：</p>
<ul>
<li><strong>Markdown</strong> 带来的优雅写作体验</li>
<li>非常熟悉的 Git workflow ，<strong>Git Commit 即 Blog Post</strong></li>
<li>利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机<ul>
<li>如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了 </li>
</ul>
</li>
<li>Jekyll 的自定制非常容易，基本就是个模版引擎</li>
</ul>
<hr>
<p>主题我直接 Downlosd 了 <a href="https://huangxuan.me/" target="_blank" rel="noopener">Hux的博客主题</a> 的进行修改，简单粗暴，不过遇到了很多坑😂，好在都填完了。。。</p>
<p>本地调试环境需要 <code>gem install jekyll</code>，结果 rubygem 的源居然被墙了，<del>后来手动改成了我大淘宝的镜像源才成功</del>，淘宝的源已经<a href="https://gems.ruby-china.org/" target="_blank" rel="noopener">停止维护</a>，换成了OSChina的源 <code>https://gems.ruby-china.org/</code>。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>最后，感谢 Hux 提供的的 <a href="https://github.com/Huxpro/huxpro.github.io" target="_blank" rel="noopener">Blog 主题</a></p>
<p>如果你恰好逛到了这里，希望你也能喜欢这个博客主题，感兴趣的话可以自己动手搭建一个。</p>
<p>—— BY 后记于 2017.2</p>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa 进阶</title>
    <url>/folder/2017/01/06/2016-01-06-ReactiveCocoa-%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>在<a href="http://qiubaiying.github.io/2016/12/26/ReactiveCocoa-基础/" target="_blank" rel="noopener">上篇文章</a>中介绍了<strong>ReactiveCocoa</strong>的基础知识,接下来我们来深入介绍<strong>ReactiveCocoa</strong>及其在<strong>MVVM</strong>中的用法。</p>
</blockquote>
<p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fbgye3re5xj30je0iomz8.jpg" alt="ReactiveCocoa进阶思维导图"></p>
<h1 id="常见操作方法介绍"><a href="#常见操作方法介绍" class="headerlink" title="常见操作方法介绍"></a>常见操作方法介绍</h1><h4 id="操作须知"><a href="#操作须知" class="headerlink" title="操作须知"></a>操作须知</h4><p>所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，因此只要继承RACStream就有了操作处理方法。</p>
<h4 id="操作思想"><a href="#操作思想" class="headerlink" title="操作思想"></a>操作思想</h4><p>运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术.</p>
<p>Hook用处：截获API调用的技术。</p>
<p>有关Hook的知识可以看我的这篇博客<a href="http://www.jianshu.com/p/ff114e69cc0a" target="_blank" rel="noopener">《Objective-C Runtime 的一些基本使用》</a>中的 <em>更换代码的实现方法</em> 一节,</p>
<p>Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。</p>
<h4 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h4><h4 id="bind（绑定）-ReactiveCocoa核心方法"><a href="#bind（绑定）-ReactiveCocoa核心方法" class="headerlink" title="bind（绑定）- ReactiveCocoa核心方法"></a><strong>bind</strong>（绑定）- ReactiveCocoa核心方法</h4><p><strong>ReactiveCocoa</strong> 操作的核心方法是 <strong>bind</strong>（绑定）,而且也是RAC中核心开发方式。之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。</p>
<p>列如，把数据展示到控件上，之前都是重写控件的 <code>setModel</code> 方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。</p>
<ul>
<li><p><strong>作用</strong></p>
<p>  RAC底层都是调用<strong>bind</strong>， 在开发中很少直接使用 <strong>bind</strong> 方法，<strong>bind</strong>属于RAC中的底层方法，我们只需要调用封装好的方法，<strong>bind</strong>用作了解即可.</p>
</li>
<li><p><strong>bind方法使用步骤</strong></p>
<ol>
<li><p>传入一个返回值 <code>RACStreamBindBlock</code> 的 block。</p>
</li>
<li><p>描述一个 <code>RACStreamBindBlock</code> 类型的 <code>bindBlock</code>作为block的返回值。</p>
</li>
<li><p>描述一个返回结果的信号，作为 <code>bindBlock</code> 的返回值。</p>
<p>注意：在bindBlock中做信号结果的处理。</p>
</li>
</ol>
</li>
<li><p><strong>bind方法参数</strong></p>
<p><strong>RACStreamBindBlock</strong>:<br><code>typedef RACStream * (^RACStreamBindBlock)(id value, BOOL *stop);</code></p>
<p><code>参数一(value)</code>:表示接收到信号的原始值，还没做处理</p>
<p><code>参数二(*stop)</code>:用来控制绑定Block，如果*stop = yes,那么就会结束绑定。</p>
<p><code>返回值</code>：信号，做好处理，在通过这个信号返回出去，一般使用 <code>RACReturnSignal</code>,需要手动导入头文件<code>RACReturnSignal.h</code></p>
</li>
<li><p><strong>使用</strong></p>
<p>  假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：”</p>
<ul>
<li><p>使用封装好的方法：在返回结果后，拼接。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[_textField.rac_textSignal subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">	// 在返回结果后，拼接 输出：</span><br><span class="line">	NSLog(@&quot;输出:%@&quot;,x);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<pre><code>- 方式二:，使用RAC中 `bind` 方法做处理，在返回结果前，拼接。

    这里需要手动导入`#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;`，才能使用`RACReturnSignal`

    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123;</span><br><span class="line">   // 什么时候调用:</span><br><span class="line">   // block作用:表示绑定了一个信号.</span><br><span class="line"></span><br><span class="line">   return ^RACStream *(id value, BOOL *stop)&#123;</span><br><span class="line"></span><br><span class="line">       // 什么时候调用block:当信号有新的值发出，就会来到这个block。</span><br><span class="line"></span><br><span class="line">       // block作用:做返回值的处理</span><br><span class="line"></span><br><span class="line">       // 做好处理，在返回结果前，拼接 输出:</span><br><span class="line">       return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]];</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">&#125;] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p><strong>底层实现</strong></p>
<ol>
<li><p>源信号调用bind,会重新创建一个绑定信号。</p>
</li>
<li><p>当绑定信号被订阅，就会调用绑定信号中的 <code>didSubscribe</code> ，生成一个 <code>bindingBlock</code> 。</p>
</li>
<li><p>当源信号有内容发出，就会把内容传递到 <code>bindingBlock</code> 处理，调用<code>bindingBlock(value,stop)</code></p>
</li>
<li><p>调用<code>bindingBlock(value,stop)</code>，会返回一个内容处理完成的信号<code>RACReturnSignal</code>。</p>
</li>
<li><p>订阅<code>RACReturnSignal</code>，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。</p>
<p>注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。</p>
</li>
</ol>
</li>
</ul>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p>映射主要用这两个方法实现：<strong>flattenMap</strong>,<strong>Map</strong>,用于把源信号内容映射成新的内容。</p>
<h6 id="flattenMap"><a href="#flattenMap" class="headerlink" title="flattenMap"></a>flattenMap</h6><ul>
<li><p><strong>作用</strong></p>
<p>  把源信号的内容映射成一个新的信号，信号可以是任意类型</p>
</li>
<li><p><strong>使用步骤</strong></p>
<ol>
<li>传入一个block，block类型是返回值<code>RACStream</code>，参数value</li>
<li>参数value就是源信号的内容，拿到源信号的内容做处理</li>
<li>包装成<code>RACReturnSignal</code>信号，返回出去。</li>
</ol>
</li>
</ul>
<ul>
<li><p><strong>使用</strong></p>
<p>  监听文本框的内容改变，把结构重新映射成一个新值.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123;</span><br><span class="line">       </span><br><span class="line">       // block调用时机：信号源发出的时候</span><br><span class="line">       </span><br><span class="line">       // block作用：改变信号的内容</span><br><span class="line">       </span><br><span class="line">       // 返回RACReturnSignal</span><br><span class="line">       return [RACReturnSignal return:[NSString stringWithFormat:@&quot;信号内容：%@&quot;, value]];</span><br><span class="line">       </span><br><span class="line">   &#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></li>
<li><p><strong>底层实现</strong></p>
<ol start="0">
<li><strong>flattenMap</strong>内部调用 <code>bind</code> 方法实现的,<strong>flattenMap</strong>中block的返回值，会作为bind中bindBlock的返回值。</li>
<li>当订阅绑定信号，就会生成 <code>bindBlock</code>。</li>
<li>当源信号发送内容，就会调用<code>bindBlock(value, *stop)</code></li>
<li>调用<code>bindBlock</code>，内部就会调用 <strong>flattenMap</strong> 的 bloc k，<strong>flattenMap</strong> 的block作用：就是把处理好的数据包装成信号。</li>
<li>返回的信号最终会作为 <code>bindBlock</code> 中的返回信号，当做 <code>bindBlock</code> 的返回信号。</li>
<li>订阅 <code>bindBlock</code> 的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。</li>
</ol>
</li>
</ul>
<h6 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h6><ul>
<li><p><strong>作用</strong></p>
<p>  把源信号的值映射成一个新的值</p>
</li>
</ul>
<ul>
<li><p><strong>使用步骤</strong></p>
<ol>
<li>传入一个block,类型是返回对象，参数是 <code>value</code></li>
<li><code>value</code>就是源信号的内容，直接拿到源信号的内容做处理</li>
<li>把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。</li>
</ol>
</li>
<li><p><strong>使用</strong></p>
<p>  监听文本框的内容改变，把结构重新映射成一个新值.</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[_textField.rac_textSignal map:^id(id value) &#123;</span><br><span class="line">      </span><br><span class="line">      // 拼接完后，返回对象</span><br><span class="line">       return [NSString stringWithFormat:@&quot;信号内容: %@&quot;, value];</span><br><span class="line">       </span><br><span class="line">   &#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></li>
<li><p><strong>底层实现</strong>:</p>
<ol start="0">
<li>Map底层其实是调用 <code>flatternMa</code>p,<code>Map</code> 中block中的返回的值会作为 <code>flatternMap</code> 中block中的值</li>
<li>当订阅绑定信号，就会生成 <code>bindBlock</code> </li>
<li>当源信号发送内容，就会调用 <code>bindBlock(value, *stop)</code></li>
<li>调用 <code>bindBlock</code> ，内部就会调用 <code>flattenMap的block</code></li>
<li><code>flattenMap的block</code> 内部会调用 <code>Map</code> 中的block，把 <code>Map</code> 中的block返回的内容包装成返回的信号</li>
<li>返回的信号最终会作为 <code>bindBlock</code> 中的返回信号，当做 <code>bindBlock</code> 的返回信号</li>
<li>订阅 <code>bindBlock</code> 的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。</li>
</ol>
</li>
</ul>
<h6 id="FlatternMap-和-Map-的区别"><a href="#FlatternMap-和-Map-的区别" class="headerlink" title="FlatternMap 和 Map 的区别"></a>FlatternMap 和 Map 的区别</h6><ul>
<li><strong>FlatternMap</strong> 中的Block <strong>返回信号</strong>。 </li>
</ul>
<ol start="2">
<li><strong>Map</strong> 中的Block <strong>返回对象</strong>。</li>
<li>开发中，如果信号发出的值 <strong>不是信号</strong> ，映射一般使用 <code>Map</code></li>
<li>如果信号发出的值 <strong>是信号</strong>，映射一般使用 <code>FlatternMap</code>。</li>
</ol>
<ul>
<li><p><code>signalOfsignals</code>用 <strong>FlatternMap</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建信号中的信号</span><br><span class="line">RACSubject *signalOfsignals = [RACSubject subject];</span><br><span class="line">RACSubject *signal = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">[[signalOfsignals flattenMap:^RACStream *(id value) &#123;</span><br><span class="line"></span><br><span class="line"> // 当signalOfsignals的signals发出信号才会调用</span><br><span class="line"></span><br><span class="line">    return value;</span><br><span class="line"></span><br><span class="line">&#125;] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">    // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。</span><br><span class="line">    // 也就是flattenMap返回的信号发出内容，才会调用。</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;signalOfsignals：%@&quot;,x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 信号的信号发送信号</span><br><span class="line">[signalOfsignals sendNext:signal];</span><br><span class="line"></span><br><span class="line">// 信号发送内容</span><br><span class="line">[signal sendNext:@&quot;hi&quot;];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><p>组合就是将多个信号按照某种规则进行拼接，合成新的信号。</p>
<h6 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h6><ul>
<li><p><strong>作用</strong> </p>
<p>  按<strong>顺序拼接</strong>信号，当多个信号发出的时候，有顺序的接收信号。</p>
</li>
<li><p><strong>底层实现</strong></p>
<ol>
<li>当拼接信号被订阅，就会调用拼接信号的didSubscribe</li>
<li>didSubscribe中，会先订阅第一个源信号（signalA）</li>
<li>会执行第一个源信号（signalA）的didSubscribe</li>
<li>第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来.</li>
<li>第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。</li>
<li>订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe</li>
<li>第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来.</li>
</ol>
</li>
<li><p><strong>使用步骤</strong></p>
<ol>
<li>使用<code>concat:</code>拼接信号</li>
<li>订阅拼接信号，内部会自动按拼接顺序订阅信号</li>
</ol>
</li>
<li><p><strong>使用</strong></p>
<p>  拼接信号 <code>signalA</code>、 <code>signalB</code>、 <code>signalC</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;Hello&quot;];</span><br><span class="line">       </span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;World&quot;];</span><br><span class="line">       </span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   RACSignal *signalC = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;!&quot;];</span><br><span class="line">       </span><br><span class="line">       [subscriber sendCompleted];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // 拼接 A B, 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。</span><br><span class="line">   RACSignal *concatSignalAB = [signalA concat:signalB];</span><br><span class="line">   </span><br><span class="line">   // A B + C</span><br><span class="line">   RACSignal *concatSignalABC = [concatSignalAB concat:signalC];</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   // 订阅拼接的信号, 内部会按顺序订阅 A-&gt;B-&gt;C</span><br><span class="line">   // 注意：第一个信号必须发送完成，第二个信号才会被激活...</span><br><span class="line">   [concatSignalABC subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="then"><a href="#then" class="headerlink" title="then"></a>then</h6><ul>
<li><p><strong>作用</strong> </p>
<p>  用于连接两个信号，当第一个信号完成，才会连接then返回的信号。</p>
</li>
<li><p><strong>底层实现</strong></p>
<ol>
<li>先过滤掉之前的信号发出的值</li>
<li>使用concat连接then返回的信号</li>
</ol>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">   </span><br><span class="line">   [subscriber sendNext:@1];</span><br><span class="line">   </span><br><span class="line">   [subscriber sendCompleted];</span><br><span class="line">   </span><br><span class="line">   return nil;</span><br><span class="line">   </span><br><span class="line"> &#125;] then:^RACSignal *&#123;</span><br><span class="line">   </span><br><span class="line">   	return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@2];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line"> &#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">   // 只能接收到第二个信号的值，也就是then返回信号的值</span><br><span class="line">   NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   </span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> ///</span><br><span class="line"> 输出：2</span><br></pre></td></tr></table></figure></li>
<li><p><strong>注意</strong></p>
<p>  注意使用<code>then</code>，之前信号的值会被忽略掉.</p>
</li>
</ul>
<h6 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h6><ul>
<li><p><strong>作用</strong> </p>
<p>  合并信号,任何一个信号发送数据，都能监听到.</p>
</li>
<li><p><strong>底层实现</strong></p>
<ol>
<li>合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。</li>
<li>每发出一个信号，这个信号就会被订阅</li>
<li>也就是合并信号一被订阅，就会订阅里面所有的信号。</li>
<li>只要有一个信号被发出就会被监听。</li>
</ol>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;A&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;B&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   // 合并信号, 任何一个信号发送数据，都能监听到</span><br><span class="line">   RACSignal *mergeSianl = [signalA merge:signalB];</span><br><span class="line"></span><br><span class="line">   [mergeSianl subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // 输出</span><br><span class="line">2017-01-03 13:29:08.013 ReactiveCocoa进阶[3627:718315] A</span><br><span class="line">2017-01-03 13:29:08.014 ReactiveCocoa进阶[3627:718315] B</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h6><ul>
<li><p><strong>作用</strong> </p>
<p>  把两个信号压缩成一个信号，只有当两个信号 <strong>同时</strong> 发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。</p>
</li>
<li><p><strong>底层实现</strong></p>
<ol>
<li>定义压缩信号，内部就会自动订阅signalA，signalB</li>
<li>每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把每个信号 第一次 发出的值包装成元组发出</li>
</ol>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;A1&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;A2&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;B1&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;B2&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;B3&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   RACSignal *zipSignal = [signalA zipWith:signalB];</span><br><span class="line">   </span><br><span class="line">   [zipSignal subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">2017-01-03 13:48:09.234 ReactiveCocoa进阶[3997:789720] zipWith: &lt;RACTuple: 0x600000004df0&gt; (</span><br><span class="line">   A1,</span><br><span class="line">   B1</span><br><span class="line">)</span><br><span class="line">2017-01-03 13:48:09.234 ReactiveCocoa进阶[3997:789720] zipWith: &lt;RACTuple: 0x608000003410&gt; (</span><br><span class="line">   A2,</span><br><span class="line">   B2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h6 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h6><ul>
<li><p><strong>作用</strong> </p>
<p>  将多个信号合并起来，并且拿到各个信号最后一个值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</p>
</li>
<li><p><strong>底层实现</strong></p>
<ol>
<li>当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。</li>
<li>并且把两个信号的 最后一次 发送的值组合成元组发出。</li>
</ol>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;A1&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;A2&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;B1&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;B2&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;B3&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   RACSignal *combineSianal = [signalA combineLatestWith:signalB];</span><br><span class="line">   </span><br><span class="line">   [combineSianal subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;combineLatest:%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">2017-01-03 13:48:09.235 ReactiveCocoa进阶[3997:789720] combineLatest:&lt;RACTuple: 0x60800000e150&gt; (</span><br><span class="line">   A2,</span><br><span class="line">   B1</span><br><span class="line">)</span><br><span class="line">2017-01-03 13:48:09.235 ReactiveCocoa进阶[3997:789720] combineLatest:&lt;RACTuple: 0x600000004db0&gt; (</span><br><span class="line">   A2,</span><br><span class="line">   B2</span><br><span class="line">)</span><br><span class="line">2017-01-03 13:48:09.236 ReactiveCocoa进阶[3997:789720] combineLatest:&lt;RACTuple: 0x60800000e180&gt; (</span><br><span class="line">   A2,</span><br><span class="line">   B3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意</strong></p>
<p>  <strong>combineLatest</strong>与<strong>zip</strong>用法相似，必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。</p>
<p>  区别看下图：</p>
<p>  <img src="https://ww2.sinaimg.cn/large/006y8lVagw1fbdf6cyez6j30id0kkabf.jpg" alt=""></p>
</li>
</ul>
<h6 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h6><ul>
<li><p><strong>作用</strong> </p>
<p>  把信号发出元组的值聚合成一个值</p>
</li>
<li><p><strong>底层实现</strong></p>
<ol>
<li>订阅聚合信号，</li>
<li>每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。</li>
</ol>
</li>
<li><p><strong>使用</strong></p>
<p>   常见的用法，（先组合在聚合）<code>combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock</code></p>
<p>   reduce中的block简介:</p>
<p>   reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容<br>   reduceblcok的返回值：聚合信号之后的内容。</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;A1&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;A2&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;B1&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;B2&quot;];</span><br><span class="line">       [subscriber sendNext:@&quot;B3&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA, signalB] reduce:^id(NSString *str1, NSString *str2)&#123;</span><br><span class="line">       </span><br><span class="line">       return [NSString stringWithFormat:@&quot;%@ %@&quot;, str1, str2];</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   [reduceSignal subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // 输出</span><br><span class="line">   2017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B1</span><br><span class="line">2017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B2</span><br><span class="line">2017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B3</span><br></pre></td></tr></table></figure></code></pre><h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>过滤就是过滤信号中的 特定值 ，或者过滤指定 发送次数 的信号。</p>
<h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><ul>
<li><p><strong>作用</strong></p>
<p>  过滤信号，使用它可以获取满足条件的信号.</p>
<p>  block的返回值是Bool值，返回<code>NO</code>则过滤该信号</p>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 过滤:</span><br><span class="line">// 每次信号发出，会先执行过滤条件判断.</span><br><span class="line">[[_textField.rac_textSignal filter:^BOOL(NSString *value) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;原信号: %@&quot;, value);</span><br><span class="line"></span><br><span class="line">       // 过滤 长度 &lt;= 3 的信号</span><br><span class="line">       return value.length &gt; 3;</span><br><span class="line">       </span><br><span class="line">   &#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;长度大于3的信号：%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // 在_textField中输出12345</span><br><span class="line">// 输出</span><br><span class="line">2017-01-03 16:36:54.938 ReactiveCocoa进阶[4714:1552910] 原信号: 1</span><br><span class="line">2017-01-03 16:36:55.383 ReactiveCocoa进阶[4714:1552910] 原信号: 12</span><br><span class="line">2017-01-03 16:36:55.706 ReactiveCocoa进阶[4714:1552910] 原信号: 123</span><br><span class="line">2017-01-03 16:36:56.842 ReactiveCocoa进阶[4714:1552910] 原信号: 1234</span><br><span class="line">2017-01-03 16:36:56.842 ReactiveCocoa进阶[4714:1552910] 长度大于3的信号：1234</span><br><span class="line">2017-01-03 16:36:58.350 ReactiveCocoa进阶[4714:1552910] 原信号: 12345</span><br><span class="line">2017-01-03 16:36:58.351 ReactiveCocoa进阶[4714:1552910] 长度大于3的信号：12345</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="ignore"><a href="#ignore" class="headerlink" title="ignore"></a>ignore</h6><ul>
<li><p><strong>作用</strong></p>
<p>  忽略某些信号.</p>
</li>
<li><p><strong>使用</strong></p>
</li>
<li><p><strong>作用</strong></p>
<p>  忽略某些值的信号.</p>
<p>  底层调用了 <code>filter</code> 与 过滤值进行比较，若相等返回则 <code>NO</code></p>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  	// 内部调用filter过滤，忽略掉字符为 @“1”的值</span><br><span class="line">[[_textField.rac_textSignal ignore:@&quot;1&quot;] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line"> 	 NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h6><ul>
<li><p><strong>作用</strong></p>
<p>  当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。</p>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;,x);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h6><ul>
<li><p><strong>作用</strong></p>
<p>  跳过 <strong>第N次</strong> 的发送的信号.</p>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 表示输入第一次，不会被监听到，跳过第一次发出的信号</span><br><span class="line">[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">   NSLog(@&quot;%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><ul>
<li><p><strong>作用</strong></p>
<p>  取 <strong>前N次</strong> 的发送的信号.</p>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject] ;</span><br><span class="line">   </span><br><span class="line">   // 取 前两次 发送的信号</span><br><span class="line">   [[subject take:2] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   [subject sendNext:@1];</span><br><span class="line">   [subject sendNext:@2];</span><br><span class="line">   [subject sendNext:@3];</span><br><span class="line">   </span><br><span class="line">   // 输出</span><br><span class="line">2017-01-03 17:35:54.566 ReactiveCocoa进阶[4969:1677908] 1</span><br><span class="line">2017-01-03 17:35:54.567 ReactiveCocoa进阶[4969:1677908] 2</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast"></a>takeLast</h6><ul>
<li><p><strong>作用</strong></p>
<p>  取 <strong>最后N次</strong> 的发送的信号</p>
<p>  前提条件，订阅者必须调用完成 <code>sendCompleted</code>，因为只有完成，就知道总共有多少信号.</p>
</li>
<li><p><strong>使用</strong>    </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject] ;</span><br><span class="line">   </span><br><span class="line">   // 取 后两次 发送的信号</span><br><span class="line">   [[subject takeLast:2] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   [subject sendNext:@1];</span><br><span class="line">   [subject sendNext:@2];</span><br><span class="line">   [subject sendNext:@3];</span><br><span class="line">   </span><br><span class="line">   // 必须 跳用完成</span><br><span class="line">   [subject sendCompleted];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil"></a>takeUntil</h6><ul>
<li><p><strong>作用</strong></p>
<p>  获取信号直到某个信号执行完成</p>
</li>
<li><p><strong>使用</strong>    </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	// 监听文本框的改变直到当前对象被销毁</span><br><span class="line">[_textField.rac_textSignal takeUntil:self.rac_willDeallocSignal];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest"></a>switchToLatest</h6><ul>
<li><p><strong>作用</strong></p>
<p>  用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。</p>
</li>
<li><p><strong>注意</strong></p>
<p>  switchToLatest：只能用于信号中的信号</p>
</li>
<li><p><strong>使用</strong>    </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSubject *signalOfSignals = [RACSubject subject];</span><br><span class="line">   RACSubject *signal = [RACSubject subject];</span><br><span class="line">   </span><br><span class="line">   // 获取信号中信号最近发出信号，订阅最近发出的信号。</span><br><span class="line">   [signalOfSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   [signalOfSignals sendNext:signal];</span><br><span class="line">   [signal sendNext:@1];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="秩序"><a href="#秩序" class="headerlink" title="秩序"></a>秩序</h4><p>秩序包括 <code>doNext</code> 和 <code>doCompleted</code> 这两个方法，主要是在 执行<code>sendNext</code> 或者 <code>sendCompleted</code>之前，先执行这些方法中Block。</p>
<h6 id="doNext"><a href="#doNext" class="headerlink" title="doNext"></a>doNext</h6><p>执行<code>sendNext</code>之前，会先执行这个<code>doNext</code>的 Block</p>
<h6 id="doCompleted"><a href="#doCompleted" class="headerlink" title="doCompleted"></a>doCompleted</h6><p>执行<code>sendCompleted</code>之前，会先执行这<code>doCompleted</code>的<code>Block</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    </span><br><span class="line">    [subscriber sendNext:@&quot;hi&quot;];</span><br><span class="line">    </span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">    </span><br><span class="line">&#125;] doNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    // 执行 [subscriber sendNext:@&quot;hi&quot;] 之前会调用这个 Block</span><br><span class="line">    NSLog(@&quot;doNext&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;] doCompleted:^&#123;</span><br><span class="line">    </span><br><span class="line">    // 执行 [subscriber sendCompleted] 之前会调用这 Block</span><br><span class="line">    NSLog(@&quot;doCompleted&quot;);</span><br><span class="line">&#125;] subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p><strong>ReactiveCocoa</strong> 中的线程操作 包括 <code>deliverOn</code> 和 <code>subscribeOn</code>这两种，将 <em>传递的内容</em> 或 创建信号时 <em>block中的代码</em> 切换到指定的线程中执行。</p>
<h6 id="deliverOn"><a href="#deliverOn" class="headerlink" title="deliverOn"></a>deliverOn</h6><ul>
<li><p><strong>作用</strong></p>
<p>  内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。</p>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	// 在子线程中执行</span><br><span class="line">	dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">            </span><br><span class="line">            [subscriber sendNext:@123];</span><br><span class="line">            </span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            </span><br><span class="line">            return nil;</span><br><span class="line">        &#125;]</span><br><span class="line">          deliverOn:[RACScheduler mainThreadScheduler]]</span><br><span class="line">          </span><br><span class="line">         subscribeNext:^(id x) &#123;</span><br><span class="line">         </span><br><span class="line">             NSLog(@&quot;%@&quot;, x);</span><br><span class="line">             </span><br><span class="line">             NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">         &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    // 输出</span><br><span class="line">2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224535] &lt;NSThread: 0x608000270f00&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224482] 123</span><br><span class="line">2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224482] &lt;NSThread: 0x600000079bc0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>  可以看到<code>副作用</code>在 <em>子线程</em> 中执行，而 <code>传递的内容</code> 在 <em>主线程</em> 中接收</p>
</li>
</ul>
<h6 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn"></a>subscribeOn</h6><ul>
<li><p><strong>作用</strong></p>
<p>  <strong>subscribeOn</strong>则是将 <code>内容传递</code> 和 <code>副作用</code> 都会切换到指定线程中</p>
</li>
<li><p><strong>使用</strong></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        </span><br><span class="line">        [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">            NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">            </span><br><span class="line">            [subscriber sendNext:@123];</span><br><span class="line">            </span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            </span><br><span class="line">            return nil;</span><br><span class="line">        &#125;]</span><br><span class="line">          subscribeOn:[RACScheduler mainThreadScheduler]] //传递的内容到主线程中</span><br><span class="line">         subscribeNext:^(id x) &#123;</span><br><span class="line">         </span><br><span class="line">             NSLog(@&quot;%@&quot;, x);</span><br><span class="line">             </span><br><span class="line">             NSLog(@&quot;%@&quot;, [NSThread currentThread]);</span><br><span class="line">         &#125;];</span><br><span class="line">    &#125;);	</span><br><span class="line">	//</span><br><span class="line">2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] &lt;NSThread: 0x608000077640&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] 123</span><br><span class="line">2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] &lt;NSThread: 0x608000077640&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure>

<p>  <code>内容传递</code> 和 <code>副作用</code> 都切换到了 <em>主线程</em> 执行</p>
</li>
</ul>
<h4 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h4><p>时间操作就会设置信号超时，定时和延时。</p>
<h6 id="interval-定时"><a href="#interval-定时" class="headerlink" title="interval 定时"></a>interval 定时</h6><ul>
<li><p><strong>作用</strong></p>
<p>  定时：每隔一段时间发出信号</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 每隔1秒发送信号，指定当前线程执行</span><br><span class="line">[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;定时:%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">// 输出</span><br><span class="line">2017-01-04 13:48:55.196 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:55 +0000</span><br><span class="line">2017-01-04 13:48:56.195 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:56 +0000</span><br><span class="line">2017-01-04 13:48:57.196 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:57 +0000</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h6 id="timeout-超时"><a href="#timeout-超时" class="headerlink" title="timeout 超时"></a>timeout 超时</h6><ul>
<li><p><strong>作用</strong></p>
<p>  超时，可以让一个信号在一定的时间后，自动报错。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       // 不发送信号，模拟超时状态</span><br><span class="line">       // [subscriber sendNext:@&quot;hello&quot;];</span><br><span class="line">       //[subscriber sendCompleted];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;] timeout:1 onScheduler:[RACScheduler currentScheduler]];// 设置1秒超时</span><br><span class="line">   </span><br><span class="line">   [signal subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125; error:^(NSError *error) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, error);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // 执行代码 1秒后 输出：</span><br><span class="line">   2017-01-04 13:48:55.195 ReactiveCocoa进阶[1980:492724] Error Domain=RACSignalErrorDomain Code=1 &quot;(null)&quot;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="delay-延时"><a href="#delay-延时" class="headerlink" title="delay 延时"></a>delay 延时</h6><ul>
<li><p><strong>作用</strong></p>
<p>  延时，延迟一段时间后发送信号</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signal2 = [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">       </span><br><span class="line">       [subscriber sendNext:@&quot;延迟输出&quot;];</span><br><span class="line">       </span><br><span class="line">       return nil;</span><br><span class="line">   &#125;] delay:2] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   // 执行代码 2秒后 输出</span><br><span class="line">   2017-01-04 13:55:23.751 ReactiveCocoa进阶[2030:525038] 延迟输出</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h4><h6 id="retry"><a href="#retry" class="headerlink" title="retry"></a>retry</h6><ul>
<li><p><strong>作用</strong></p>
<p>  重试：只要 发送错误 <code>sendError:</code>,就会 重新执行 创建信号的Block 直到成功</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	__block int i = 0;</span><br><span class="line">    </span><br><span class="line">    [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        if (i == 5) &#123;</span><br><span class="line">            </span><br><span class="line">            [subscriber sendNext:@&quot;Hello&quot;];</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">            // 发送错误</span><br><span class="line">            NSLog(@&quot;收到错误:%d&quot;, i);</span><br><span class="line">            [subscriber sendError:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">        </span><br><span class="line">    &#125;] retry] subscribeNext:^(id x) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@&quot;, x);</span><br><span class="line">        </span><br><span class="line">    &#125; error:^(NSError *error) &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;%@&quot;, error);</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">	// 输出</span><br><span class="line">2017-01-04 14:36:51.594 ReactiveCocoa进阶[2443:667226] 收到错误信息:0</span><br><span class="line">2017-01-04 14:36:51.595 ReactiveCocoa进阶[2443:667226] 收到错误信息:1</span><br><span class="line">2017-01-04 14:36:51.595 ReactiveCocoa进阶[2443:667226] 收到错误信息:2</span><br><span class="line">2017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] 收到错误信息:3</span><br><span class="line">2017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] 收到错误信息:4</span><br><span class="line">2017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] Hello</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h6><ul>
<li><p><strong>作用</strong></p>
<p>  重放：当一个信号被多次订阅,反复播放内容</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line">        [subscriber sendNext:@2];</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;] replay];</span><br><span class="line">    </span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [signal subscribeNext:^(id x) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 输出</span><br><span class="line">2017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 1</span><br><span class="line">2017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 2</span><br><span class="line">2017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 1</span><br><span class="line">2017-01-04 14:51:01.935 ReactiveCocoa进阶[2544:706740] 2</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h6 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h6><ul>
<li><p><strong>作用</strong></p>
<p>  节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">   </span><br><span class="line">   // 节流1秒，1秒后接收最后一个发送的信号</span><br><span class="line">   [[subject throttle:1] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">       NSLog(@&quot;%@&quot;, x);</span><br><span class="line">   &#125;];</span><br><span class="line">   </span><br><span class="line">   [subject sendNext:@1];</span><br><span class="line">   [subject sendNext:@2];</span><br><span class="line">   [subject sendNext:@3];</span><br><span class="line">   </span><br><span class="line">   // 输出</span><br><span class="line">   2017-01-04 15:02:37.543 ReactiveCocoa进阶[2731:758193] 3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="MVVM架构思想"><a href="#MVVM架构思想" class="headerlink" title="MVVM架构思想"></a>MVVM架构思想</h1><hr>
<p>程序为什么要有架构？便于程序开发与维护.</p>
<h4 id="常见的架构"><a href="#常见的架构" class="headerlink" title="常见的架构"></a>常见的架构</h4><ul>
<li><p><strong>MVC</strong></p>
<p>  M:模型 V:视图 C:控制器</p>
</li>
<li><p><strong>MVVM</strong></p>
<p>  M:模型 V:视图+控制器 VM:视图模型</p>
</li>
<li><p><strong>MVCS</strong></p>
<p>   M:模型 V:视图 C:控制器 C:服务类</p>
</li>
<li><p><a href="http://www.cocoachina.com/ios/20140703/9016.html" target="_blank" rel="noopener"><strong>VIPER</strong></a></p>
<p>  V:视图 I:交互器 P:展示器 E:实体 R:路由</p>
</li>
</ul>
<h4 id="MVVM介绍"><a href="#MVVM介绍" class="headerlink" title="MVVM介绍"></a>MVVM介绍</h4><ul>
<li><p>模型(M):保存视图数据。</p>
</li>
<li><p>视图+控制器(V):展示内容 + 如何展示</p>
</li>
<li><p>视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。</p>
</li>
</ul>
<h1 id="实战一：登录界面"><a href="#实战一：登录界面" class="headerlink" title="实战一：登录界面"></a>实战一：登录界面</h1><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><ol>
<li>监听两个文本框的内容</li>
<li>有内容登录按键才允许按钮点击</li>
<li>返回登录结果</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ol>
<li>界面的所有业务逻辑都交给控制器做处理</li>
<li>在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型.</li>
</ol>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li>创建LoginViewModel类，处理登录界面业务逻辑.</li>
<li>这个类里面应该保存着账号的信息，创建一个账号Account模型</li>
<li>LoginViewModel应该保存着账号信息Account模型。</li>
<li>需要时刻监听Account模型中的账号和密码的改变，怎么监听？</li>
<li>在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。</li>
<li>每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号.</li>
<li>这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号.</li>
<li>监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑.</li>
<li>执行命令，把数据包装成信号传递出去</li>
<li>监听命令中信号的数据传递</li>
<li>监听命令的执行时刻</li>
</ol>
<h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p><img src="https://ww3.sinaimg.cn/large/006y8lVagw1fbgvoh8yu6j30bj0l43yz.jpg" alt="登录界面"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><code>MyViewController.m</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;MyViewController.h&quot;</span><br><span class="line">#import &quot;LoginViewModel.h&quot;</span><br><span class="line"></span><br><span class="line">@interface MyViewController ()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) LoginViewModel *loginViewModel;</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *accountField;</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UITextField *pwdField;</span><br><span class="line"></span><br><span class="line">@property (weak, nonatomic) IBOutlet UIButton *loginBtn;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self bindModel];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)didReceiveMemoryWarning &#123;</span><br><span class="line">    [super didReceiveMemoryWarning];</span><br><span class="line">    // Dispose of any resources that can be recreated.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 视图模型绑定</span><br><span class="line">- (void)bindModel &#123;</span><br><span class="line"></span><br><span class="line">    // 给模型的属性绑定信号</span><br><span class="line">    //</span><br><span class="line">    RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal;</span><br><span class="line">    RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal;</span><br><span class="line">    </span><br><span class="line">    RAC(self.loginBtn, enabled) = self.loginViewModel.enableLoginSignal;</span><br><span class="line">    </span><br><span class="line">    // 监听登录点击</span><br><span class="line">    [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</span><br><span class="line">        </span><br><span class="line">        [self.loginViewModel.LoginCommand execute:nil];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (IBAction)btnTap:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - lazyLoad</span><br><span class="line"></span><br><span class="line">- (LoginViewModel *)loginViewModel &#123;</span><br><span class="line">    </span><br><span class="line">    if (nil == _loginViewModel) &#123;</span><br><span class="line">        _loginViewModel = [[LoginViewModel alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return _loginViewModel;</span><br><span class="line">&#125;</span><br><span class="line">```	</span><br><span class="line">		</span><br><span class="line">`LoginViewModel.h`</span><br></pre></td></tr></table></figure>
<p>#import &lt;UIKit/UIKit.h&gt;</p>
<p>@interface Account : NSObject</p>
<p>@property (nonatomic, strong) NSString *account;<br>@property (nonatomic, strong) NSString *pwd;</p>
<p>@end</p>
<p>@interface LoginViewModel : UIViewController</p>
<p>@property (nonatomic, strong) Account *account;</p>
<p>// 是否允许登录的信号<br>@property (nonatomic, strong, readonly) RACSignal *enableLoginSignal;</p>
<p>@property (nonatomic, strong, readonly) RACCommand *LoginCommand;</p>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`LoginViewModel.m`</span><br></pre></td></tr></table></figure>
<p>#import “LoginViewModel.h”</p>
<p>@implementation Account</p>
<p>@end</p>
<p>@interface LoginViewModel ()</p>
<p>@end</p>
<p>@implementation LoginViewModel</p>
<ul>
<li><p>(instancetype)init {</p>
<p>  if (self = [super init]) {</p>
<pre><code>[self initialBind];</code></pre><p>  }<br>  return self;<br>}</p>
</li>
<li><p>(void)initialBind {</p>
<p>  // 监听账号属性改变， 把他们合成一个信号<br>  _enableLoginSignal = [RACSubject combineLatest:@[RACObserve(self.account, account), RACObserve(self.account, pwd)] reduce:^id(NSString *accout, NSString *pwd){</p>
<pre><code>return @(accout.length &amp;&amp; pwd.length);</code></pre><p>  }];</p>
<p>  // 处理业务逻辑<br>  _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {</p>
<pre><code>NSLog(@&quot;点击了登录&quot;);
return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

    // 模仿网络延迟

    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{

        // 返回登录成功 发送成功信号
        [subscriber sendNext:@&quot;登录成功&quot;];
    });

    return nil;
}];</code></pre><p>  }];</p>
</li>
</ul>
<pre><code>// 监听登录产生的数据
[_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) {

    if ([x isEqualToString:@&quot;登录成功&quot;]) {
        NSLog(@&quot;登录成功&quot;);
    }

}];

[[_LoginCommand.executing skip:1] subscribeNext:^(id x) {

    if ([x isEqualToNumber:@(YES)]) {

        NSLog(@&quot;正在登陆...&quot;);
    } else {

    // 登录成功
    NSLog(@&quot;登陆成功&quot;);

    }

}];</code></pre><p>}</p>
<p>#pragma mark - lazyLoad</p>
<ul>
<li><p>(Account *)account<br>{<br>  if (_account == nil) {</p>
<pre><code>_account = [[Account alloc] init];</code></pre><p>  }<br>  return _account;<br>}</p>
</li>
<li><p>(void)viewDidLoad {<br>  [super viewDidLoad];</p>
</li>
</ul>
<p>}</p>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 实战二：网络请求数据</span><br><span class="line"></span><br><span class="line">#### 需求</span><br><span class="line">1. 请求一段网络数据，将请求到的数据在`tableView`上展示</span><br><span class="line">2. 该数据为豆瓣图书的搜索返回结果，URL：url:https://api.douban.com/v2/book/search?q=悟空传</span><br><span class="line"></span><br><span class="line">#### 分析</span><br><span class="line">1. 界面的所有业务逻辑都交给**控制器**做处理</span><br><span class="line">2. 网络请求交给**MV**模型处理</span><br><span class="line"></span><br><span class="line">#### 步骤</span><br><span class="line"></span><br><span class="line">1. 控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑</span><br><span class="line">2. VM提供一个命令，处理请求业务逻辑</span><br><span class="line">3. 在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。</span><br><span class="line">4. 请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。</span><br><span class="line"></span><br><span class="line">#### 其他</span><br><span class="line"></span><br><span class="line">网络请求与图片缓存用到了[AFNetworking](https://github.com/AFNetworking/AFNetworking) 和 [SDWebImage](https://github.com/rs/SDWebImage),自行在Pods中导入。</span><br></pre></td></tr></table></figure>
<p>platform :ios, ‘8.0’</p>
<p>target ‘ReactiveCocoa进阶’ do</p>
<p>use_frameworks!<br>pod ‘ReactiveCocoa’, ‘~&gt; 2.5’<br>pod ‘AFNetworking’<br>pod ‘SDWebImage’<br>end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 运行效果</span><br><span class="line"></span><br><span class="line">![](https://ww3.sinaimg.cn/large/006y8lVagw1fbgw1xnz74j30bj0l4408.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 代码</span><br><span class="line"></span><br><span class="line">`SearchViewController.m`</span><br></pre></td></tr></table></figure>
<p>#import “SearchViewController.h”<br>#import “RequestViewModel.h”</p>
<p>@interface SearchViewController ()<UITableViewDataSource></p>
<p>@property (nonatomic, strong) UITableView *tableView;</p>
<p>@property (nonatomic, strong) RequestViewModel *requesViewModel;</p>
<p>@end</p>
<p>@implementation SearchViewController</p>
<ul>
<li><p>(RequestViewModel *)requesViewModel<br>{<br>  if (_requesViewModel == nil) {</p>
<pre><code>_requesViewModel = [[RequestViewModel alloc] init];</code></pre><p>  }<br>  return _requesViewModel;<br>}</p>
</li>
<li><p>(void)viewDidLoad {<br>  [super viewDidLoad];</p>
</li>
</ul>
<pre><code>self.tableView = [[UITableView alloc] initWithFrame:self.view.frame];

self.tableView.dataSource = self;

[self.view addSubview:self.tableView];

//
RACSignal *requesSiganl = [self.requesViewModel.reuqesCommand execute:nil];

[requesSiganl subscribeNext:^(NSArray *x) {

    self.requesViewModel.models = x;

    [self.tableView reloadData];
}];</code></pre><p>}</p>
<ul>
<li><p>(void)didReceiveMemoryWarning {<br>  [super didReceiveMemoryWarning];<br>  // Dispose of any resources that can be recreated.<br>}</p>
</li>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section<br>{<br>  return self.requesViewModel.models.count;<br>}</p>
</li>
<li><p>(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath<br>{<br>  static NSString *ID = @”cell”;<br>  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID];<br>  if (cell == nil) {</p>
<pre><code>cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID];</code></pre><p>  }</p>
<p>  Book *book = self.requesViewModel.models[indexPath.row];<br>  cell.detailTextLabel.text = book.subtitle;<br>  cell.textLabel.text = book.title;</p>
<p>  [cell.imageView sd_setImageWithURL:[NSURL URLWithString:book.image] placeholderImage:[UIImage imageNamed:@”cellImage”]];</p>
</li>
</ul>
<pre><code>return cell;</code></pre><p>}<br>@end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`RequestViewModel.h`</span><br></pre></td></tr></table></figure>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>@interface Book : NSObject</p>
<p>@property (nonatomic, copy) NSString *subtitle;<br>@property (nonatomic, copy) NSString *title;<br>@property (nonatomic, copy) NSString *image;</p>
<p>@end</p>
<p>@interface RequestViewModel : NSObject</p>
<p>// 请求命令<br>@property (nonatomic, strong, readonly) RACCommand *reuqesCommand;</p>
<p>//模型数组<br>@property (nonatomic, strong) NSArray *models;</p>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">`RequestViewModel.m`</span><br></pre></td></tr></table></figure>
<p>#import “RequestViewModel.h”</p>
<p>@implementation Book</p>
<ul>
<li><p>(instancetype)initWithValue:(NSDictionary *)value {</p>
<p>  if (self = [super init]) {</p>
<pre><code>self.title = value[@&quot;title&quot;];
self.subtitle = value[@&quot;subtitle&quot;];
self.image = value[@&quot;image&quot;];</code></pre><p>  }<br>  return self;<br>}</p>
</li>
</ul>
<ul>
<li><p>(Book *)bookWithDict:(NSDictionary *)value {</p>
<p>  return [[self alloc] initWithValue:value];<br>}</p>
</li>
</ul>
<p>@end</p>
<p>@implementation RequestViewModel</p>
<ul>
<li><p>(instancetype)init<br>{<br>  if (self = [super init]) {</p>
<pre><code>[self initialBind];</code></pre><p>  }<br>  return self;<br>}</p>
</li>
</ul>
<ul>
<li><p>(void)initialBind<br>{<br>  _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) {</p>
<pre><code>RACSignal *requestSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) {

    NSMutableDictionary *parameters = [NSMutableDictionary dictionary];
    parameters[@&quot;q&quot;] = @&quot;悟空传&quot;;

    //
    [[AFHTTPSessionManager manager] GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) {

        NSLog(@&quot;downloadProgress: %@&quot;, downloadProgress);
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {

        // 数据请求成功就讲数据发送出去
        NSLog(@&quot;responseObject:%@&quot;, responseObject);

        [subscriber sendNext:responseObject];

        [subscriber sendCompleted];

    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {

        NSLog(@&quot;error: %@&quot;, error);
    }];</code></pre></li>
</ul>
<pre><code>     return nil;
  }];

    // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去
    return [requestSiganl map:^id(NSDictionary *value) {

        NSMutableArray *dictArr = value[@&quot;books&quot;];

        NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) {

            return [Book bookWithDict:value];

        }] array];

        return modelArr;

    }];

}];</code></pre><p>}</p>
<p>@end</p>
<pre><code>
&gt;最后附上GitHub：&lt;https://github.com/qiubaiying/ReactiveCocoa_Demo&gt;</code></pre>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>ReactiveCocoa</tag>
        <tag>函数式编程</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactiveCocoa 基础</title>
    <url>/folder/2016/12/26/2016-12-26-ReactiveCocoa-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="ReactiveCocoa基础"><a href="#ReactiveCocoa基础" class="headerlink" title="ReactiveCocoa基础"></a>ReactiveCocoa基础</h1><blockquote>
<p>本文修改自<a href="http://www.jianshu.com/p/87ef6720a096" target="_blank" rel="noopener">最快让你上手ReactiveCocoa之基础篇</a></p>
<p>有关对 <strong>ReactiveCocoa</strong> 的看法可以看一下唐巧的这篇<a href="https://gold.xitu.io/entry/568bd2ae60b2e57ba2cd2c7b" target="_blank" rel="noopener">ReactiveCocoa 讨论会</a></p>
</blockquote>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVagw1fb7g0gukk8j30m90rl78j.jpg" alt="ReactiveCocoa思维导图"></p>
<h1 id="ReactiveCocoa简介"><a href="#ReactiveCocoa简介" class="headerlink" title="ReactiveCocoa简介"></a>ReactiveCocoa简介</h1><p><a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener"><img src="http://ww1.sinaimg.cn/large/006y8lVagw1fb7g6on3iwj30c2029q2z.jpg" alt=""></a></p>
<p>ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。</p>
<p>在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。</p>
<p>比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。其实这些事件，都可以通过RAC处理</p>
<p>ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。</p>
<p>非常符合我们开发中高聚合，低耦合的思想。</p>
<h1 id="ReactiveCocoa编程思想"><a href="#ReactiveCocoa编程思想" class="headerlink" title="ReactiveCocoa编程思想"></a>ReactiveCocoa编程思想</h1><p>在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的 <code>Three20</code> 框架，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的编程思想。</p>
<p>先简单介绍下目前咱们已知的编程思想:</p>
<h4 id="响应式编程思想"><a href="#响应式编程思想" class="headerlink" title="响应式编程思想"></a>响应式编程思想</h4><p><strong>响应式编程思想</strong>：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。</p>
<p><code>代表</code>：KVO</p>
<h4 id="链式编程思想"><a href="#链式编程思想" class="headerlink" title="链式编程思想"></a>链式编程思想</h4><p><strong>链式编程</strong> 是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make.add(1).add(2).sub(5).muilt(-4).divide(4);</span><br></pre></td></tr></table></figure>

<p><code>特点</code>：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值）</p>
<p><code>代表</code>：masonry框架。</p>
<p><code>实现</code>：模仿masonry，写一个加法计算器，练习链式编程思想。</p>
<p>NSObject+Caculator.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@class CaculatorMaker;</span><br><span class="line"></span><br><span class="line">@interface NSObject (Caculator)</span><br><span class="line"></span><br><span class="line">// 计算</span><br><span class="line">+ (int)makeCaculators:(void (^)(CaculatorMaker *))block;</span><br><span class="line">                       </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>NSObject+Caculator.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@implementation NSObject (Caculator)</span><br><span class="line"></span><br><span class="line">+ (int)makeCaculators:(void (^)(CaculatorMaker *))block &#123;</span><br><span class="line">    </span><br><span class="line">    CaculatorMaker *mgr = [[CaculatorMaker alloc] init];</span><br><span class="line">    </span><br><span class="line">    block(mgr);</span><br><span class="line">    </span><br><span class="line">    return (mgr.result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>CaculatorMaker.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@class CaculatorMaker;</span><br><span class="line"></span><br><span class="line">typedef CaculatorMaker *(^CasulatorBlock)(int);</span><br><span class="line"></span><br><span class="line">@interface CaculatorMaker : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int result;</span><br><span class="line"></span><br><span class="line">// 算数方法</span><br><span class="line">- (CaculatorMaker *(^)(int))add;</span><br><span class="line">- (CasulatorBlock)sub;</span><br><span class="line">- (CasulatorBlock)muilt;</span><br><span class="line">- (CasulatorBlock)divide;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>CaculatorMaker.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># import &quot;CaculatorMaker.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation CaculatorMaker</span><br><span class="line"></span><br><span class="line">- (CaculatorMaker *(^)(int))add &#123;</span><br><span class="line"></span><br><span class="line">    return ^CaculatorMaker *(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        _result += value;</span><br><span class="line">        </span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CasulatorBlock)sub &#123;</span><br><span class="line">    </span><br><span class="line">    return ^CaculatorMaker *(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        _result -= value;</span><br><span class="line">        </span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CasulatorBlock)muilt &#123;</span><br><span class="line"></span><br><span class="line">    return ^CaculatorMaker *(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        _result *= value;</span><br><span class="line">        </span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CasulatorBlock)divide &#123;</span><br><span class="line">    </span><br><span class="line">    return ^CaculatorMaker *(int value) &#123;</span><br><span class="line">        </span><br><span class="line">        _result /= value;</span><br><span class="line">        </span><br><span class="line">        return self;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int result = [NSObject makeCaculators:^(CaculatorMaker *make) &#123;</span><br><span class="line">        </span><br><span class="line">        // ( 1 + 2 - 5 ) * (-4) / 4</span><br><span class="line">        make.add(1).add(2).sub(5).muilt(-4).divide(4);</span><br><span class="line"></span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%d&quot;, result);</span><br></pre></td></tr></table></figure>




<h4 id="函数式编程思想"><a href="#函数式编程思想" class="headerlink" title="函数式编程思想"></a>函数式编程思想</h4><p><strong>函数式编程思想</strong>：是把操作尽量写成一系列嵌套的函数或者方法调用。</p>
<p><code>特点</code>：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果）</p>
<p><code>代表</code>：<strong>ReactiveCocoa</strong></p>
<p><code>实现</code>：用函数式编程实现，写一个加法计算器,并且加法计算器自带判断是否等于某个值.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Calculator *caculator = [[Calculator alloc] init];</span><br><span class="line"></span><br><span class="line">BOOL isqule = [[[caculator caculator:^int(int result) &#123;</span><br><span class="line">    </span><br><span class="line">    result += 2;</span><br><span class="line">    result *= 5;</span><br><span class="line">    return result;</span><br><span class="line">    </span><br><span class="line">&#125;] equle:^BOOL(int result) &#123;</span><br><span class="line">    </span><br><span class="line">    return result == 10;</span><br><span class="line">    </span><br><span class="line">&#125;] isEqule];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%d&quot;, isqule);</span><br></pre></td></tr></table></figure>

<p>Calculator.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface Calculator : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) BOOL isEqule;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, assign) int result;</span><br><span class="line"></span><br><span class="line">- (Calculator *)caculator:(int (^)(int result))caculator;</span><br><span class="line"></span><br><span class="line">- (Calculator *)equle:(BOOL (^)(int result))operation;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>Calculator.m</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;Calculator.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Calculator</span><br><span class="line"></span><br><span class="line">- (Calculator *)caculator:(int (^)(int))caculator &#123;</span><br><span class="line"></span><br><span class="line">    _result = caculator(_result);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (Calculator *)equle:(BOOL (^)(int))operation &#123;</span><br><span class="line"></span><br><span class="line">    _isEqule = operation(_result);</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>ReactiveCocoa</strong> 结合了这两种种编程风格：</p>
<ul>
<li><p><strong>函数式编程</strong>（Functional Programming）</p>
</li>
<li><p><strong>响应式编程</strong>（Reactive Programming）</p>
</li>
</ul>
<p>所以，你可能听说过 <strong>ReactiveCocoa</strong> 被描述为函数响应式编程（FRP）框架。</p>
<p>以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。</p>
<h1 id="导入ReactiveCocoa"><a href="#导入ReactiveCocoa" class="headerlink" title="导入ReactiveCocoa"></a>导入ReactiveCocoa</h1><hr>
<blockquote>
<p>ReactiveCocoa的<a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">GitHub地址</a></p>
</blockquote>
<h4 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h4><p><strong>ReactiveCocoa 2.5</strong>版本以后改用了<strong>Swift</strong>，所以<strong>Objective-C</strong>项目需要导入<strong>2.5版本</strong></p>
<p><code>CocoaPods</code>集成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;YouProjectName&apos; do</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line">pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 2.5&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>PS:新版本的<code>CocoaPods</code>需要加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">target &apos;YouProjectName&apos; do </span><br><span class="line">... </span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这句话来限定项目，否则导入失败。</p>
<h4 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h4><p><strong>Swift</strong>项目导入2.5后的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform :ios, &apos;8.0&apos;</span><br><span class="line"></span><br><span class="line">target &apos;YouProjectName&apos; do</span><br><span class="line"></span><br><span class="line">use_frameworks!</span><br><span class="line">pod &apos;ReactiveCocoa&apos;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>使用时在<a href="http://www.jianshu.com/p/587b83b6665c" target="_blank" rel="noopener">全局头文件</a>导入头文件即可</p>
<p><code>PrefixHeader.pch</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef PrefixHeader_pch</span><br><span class="line">#define PrefixHeader_pch</span><br><span class="line"></span><br><span class="line">#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<h1 id="ReactiveCocoa常见类"><a href="#ReactiveCocoa常见类" class="headerlink" title="ReactiveCocoa常见类"></a>ReactiveCocoa常见类</h1><h4 id="RACSiganl-信号类"><a href="#RACSiganl-信号类" class="headerlink" title="RACSiganl 信号类"></a>RACSiganl 信号类</h4><blockquote>
<p>信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。</p>
</blockquote>
<p>注意：</p>
<ul>
<li>信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。</li>
<li>默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。</li>
<li>如何订阅信号：调用信号RACSignal的subscribeNext就能订阅</li>
</ul>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// RACSignal使用步骤：</span><br><span class="line">    // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe</span><br><span class="line">    // 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span><br><span class="line">    // 3.发送信号 - (void)sendNext:(id)value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // RACSignal底层实现：</span><br><span class="line">    // 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。</span><br><span class="line">    // 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock</span><br><span class="line">    // 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。</span><br><span class="line">    // 2.1 subscribeNext内部会调用siganl的didSubscribe</span><br><span class="line">    // 3.siganl的didSubscribe中调用[subscriber sendNext:@1];</span><br><span class="line">    // 3.1 sendNext底层其实就是执行subscriber的nextBlock</span><br><span class="line"></span><br><span class="line">    // 1.创建信号</span><br><span class="line">    RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"></span><br><span class="line">        // block调用时刻：每当有订阅者订阅信号，就会调用block。</span><br><span class="line"></span><br><span class="line">        // 2.发送信号</span><br><span class="line">        [subscriber sendNext:@1];</span><br><span class="line"></span><br><span class="line">        // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">        return [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">            // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。</span><br><span class="line"></span><br><span class="line">            // 执行完Block后，当前信号就不在被订阅了。</span><br><span class="line"></span><br><span class="line">            NSLog(@&quot;信号被销毁&quot;);</span><br><span class="line"></span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 3.订阅信号,才会激活信号.</span><br><span class="line">    [siganl subscribeNext:^(id x) &#123;</span><br><span class="line">        // block调用时刻：每当有信号发出数据，就会调用block.</span><br><span class="line">        NSLog(@&quot;接收到数据:%@&quot;,x);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<h4 id="RACSubscriber"><a href="#RACSubscriber" class="headerlink" title="RACSubscriber"></a>RACSubscriber</h4><blockquote>
<p>表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。</p>
</blockquote>
<h4 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h4><blockquote>
<p>用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。</p>
</blockquote>
<p><strong>使用场景</strong>：不想监听某个信号时，可以通过它主动取消订阅信号。</p>
<h4 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h4><blockquote>
<p>RACSubject:信号提供者，自己可以充当信号，又能发送信号。</p>
</blockquote>
<p><strong>使用场景</strong>:通常用来代替代理，有了它，就不必要定义代理了。</p>
<h4 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a><strong>RACReplaySubject</strong></h4><blockquote>
<p>重复提供信号类，RACSubject的子类。</p>
</blockquote>
<p><code>RACReplaySubject</code>与<code>RACSubject</code>区别:</p>
<p> <code>RACReplaySubject</code>可以先发送信号，在订阅信号，<code>RACSubject</code>就不可以。</p>
<p> <strong>使用场景一</strong>:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。</p>
<p> <strong>使用场景二</strong>:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。</p>
<p> <strong>ACSubject</strong> 和 <strong>RACReplaySubject</strong> 简单使用：</p>
<p> <strong>ACSubject</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // RACSubject使用步骤</span><br><span class="line">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span><br><span class="line">// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span><br><span class="line">// 3.发送信号 sendNext:(id)value</span><br><span class="line"></span><br><span class="line">// RACSubject:底层实现和RACSignal不一样。</span><br><span class="line">// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。</span><br><span class="line">// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 1. 创建信号</span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">// 2.订阅信号</span><br><span class="line">[subject subscribeNext:^(id x) &#123;</span><br><span class="line">   </span><br><span class="line">    // block调用时机：当信号发出新值，就会调用</span><br><span class="line">    NSLog(@&quot;收到信号&quot;);</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.发送信号</span><br><span class="line">NSLog(@&quot;发送信号&quot;);</span><br><span class="line">[subject sendNext:@&quot;1&quot;];</span><br></pre></td></tr></table></figure>

 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> // RACReplaySubject使用步骤:</span><br><span class="line">// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。</span><br><span class="line">// 2.可以先订阅信号，也可以先发送信号。</span><br><span class="line">// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</span><br><span class="line">// 2.2 发送信号 sendNext:(id)value</span><br><span class="line"></span><br><span class="line">// RACReplaySubject:底层实现和RACSubject不一样。</span><br><span class="line">// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。</span><br><span class="line">// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock</span><br><span class="line"></span><br><span class="line">// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。</span><br><span class="line">// 也就是先保存值，在订阅值。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 1.创建信号</span><br><span class="line">RACReplaySubject *replaySubject = [RACReplaySubject subject];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 3.先订阅信号</span><br><span class="line">[replaySubject subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;第一个订阅者接受到的数据%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 2.发送信号</span><br><span class="line">[replaySubject sendNext:@1];</span><br><span class="line">[replaySubject sendNext:@2];</span><br><span class="line"></span><br><span class="line">// 后订阅信号</span><br><span class="line">[replaySubject subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p><strong>RACSubject</strong>替换代理（与block类似）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 需求:</span><br><span class="line">    // 1.给当前控制器添加一个按钮，modal到另一个控制器界面</span><br><span class="line">    // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器</span><br><span class="line"></span><br><span class="line">步骤一：在第二个控制器.h，添加一个RACSubject代替代理。</span><br><span class="line">@interface TwoViewController : UIViewController</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) RACSubject *delegateSignal;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">步骤二：监听第二个控制器按钮点击</span><br><span class="line">@implementation TwoViewController</span><br><span class="line">- (IBAction)notice:(id)sender &#123;</span><br><span class="line">    // 通知第一个控制器，告诉它，按钮被点了</span><br><span class="line"></span><br><span class="line">     // 通知代理</span><br><span class="line">     // 判断代理信号是否有值</span><br><span class="line">    if (self.delegateSignal) &#123;</span><br><span class="line">        // 有值，才需要通知</span><br><span class="line">        [self.delegateSignal sendNext:nil];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.</span><br><span class="line">@implementation OneViewController </span><br><span class="line">- (IBAction)btnClick:(id)sender &#123;</span><br><span class="line"></span><br><span class="line">    // 创建第二个控制器</span><br><span class="line">    TwoViewController *twoVc = [[TwoViewController alloc] init];</span><br><span class="line"></span><br><span class="line">    // 设置代理信号</span><br><span class="line">    twoVc.delegateSignal = [RACSubject subject];</span><br><span class="line"></span><br><span class="line">    // 订阅代理信号</span><br><span class="line">    [twoVc.delegateSignal subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">        NSLog(@&quot;点击了通知按钮 %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 跳转到第二个控制器</span><br><span class="line">    [self presentViewController:twoVc animated:YES completion:@&quot;hi&quot;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<h4 id="RACTuple"><a href="#RACTuple" class="headerlink" title="RACTuple"></a>RACTuple</h4><blockquote>
<p>元组类,类似NSArray,用来包装值.(<code>@[key, value]</code>)</p>
</blockquote>
<h4 id="RACSequence"><a href="#RACSequence" class="headerlink" title="RACSequence"></a>RACSequence</h4><blockquote>
<p>RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。</p>
</blockquote>
<p>使用场景：字典转模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1.遍历数组</span><br><span class="line">NSArray *numbers = @[@1,@2,@3,@4];</span><br><span class="line"></span><br><span class="line">// 这里其实是三步</span><br><span class="line">// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence</span><br><span class="line">// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal</span><br><span class="line">// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。</span><br><span class="line"></span><br><span class="line">[numbers.rac_sequence.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;%@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 2.遍历字典,遍历出来的键值对 都会包装成 RACTuple(元组对象) @[key, value]</span><br><span class="line">NSDictionary *dic = @&#123;@&quot;name&quot;: @&quot;BYqiu&quot;, @&quot;age&quot;: @18&#125;;</span><br><span class="line"></span><br><span class="line">[dic.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123;</span><br><span class="line">    </span><br><span class="line">    // 解元组包，会把元组的值，按顺序给参数里的变量赋值</span><br><span class="line">    // 写法相当与</span><br><span class="line">    // NSString *key = x[0];</span><br><span class="line">    // NSString *value = x[1];</span><br><span class="line">    RACTupleUnpack(NSString *key, NSString *value) = x;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;key:%@, value:%@&quot;, key, value);</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 3.字典转模型</span><br><span class="line"></span><br><span class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];</span><br><span class="line"></span><br><span class="line">NSArray *dicArray = [NSArray arrayWithContentsOfFile:filePath];</span><br><span class="line"></span><br><span class="line">NSMutableArray *items = [NSMutableArray array];</span><br><span class="line"></span><br><span class="line">// OC写法</span><br><span class="line">for (NSDictionary *dic in dicArray) &#123;</span><br><span class="line">    </span><br><span class="line">    //FlagItem *item = [FlagItem flagWithDict:dict];</span><br><span class="line">    //[items addObject:item];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// RAC写法</span><br><span class="line">[dicArray.rac_sequence.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    // 利用RAC遍历， x：字典</span><br><span class="line">    </span><br><span class="line">    //FlagItem *item = [FlagItem flagWithDict:x];</span><br><span class="line">    //[items addObject:item];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// RAC高级用法（函数式编程）</span><br><span class="line">NSArray *flags = [[dicArray.rac_sequence map:^id(id value) &#123;</span><br><span class="line">    </span><br><span class="line">    return  [FlagItem flagWithDict:value];</span><br><span class="line">    </span><br><span class="line">&#125;] array];</span><br></pre></td></tr></table></figure>

<h4 id="RACCommand"><a href="#RACCommand" class="headerlink" title="RACCommand"></a>RACCommand</h4><blockquote>
<p>RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。</p>
</blockquote>
<p> 一、RACCommand使用步骤:</p>
<ol>
<li><p>创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock</p>
</li>
<li><p>在signalBlock中，创建RACSignal，并且作为signalBlock的返回值</p>
</li>
<li><p>执行命令 - (RACSignal *)execute:(id)input</p>
<p>二、RACCommand使用注意:</p>
</li>
<li><p>signalBlock必须要返回一个信号，不能传nil.</p>
</li>
<li><p>如果不想要传递信号，直接创建空的信号[RACSignal empty];</p>
</li>
<li><p>RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。</p>
</li>
<li><p>RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。</p>
<p>三、RACCommand设计思想：</p>
<p>内部signalBlock为什么要返回一个信号，这个信号有什么用。</p>
</li>
<li><p>在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。</p>
</li>
<li><p>当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。</p>
<p>四、如何拿到RACCommand中返回信号发出的数据。</p>
</li>
<li><p>RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。</p>
</li>
<li><p>订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。</p>
<p>五、监听当前命令是否正在执行executing</p>
<p>六、使用场景,监听按钮点击，网络请求</p>
</li>
</ol>
<p>使用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 1.创建命令</span><br><span class="line">    RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123;</span><br><span class="line">        NSLog(@&quot;执行命令&quot;);</span><br><span class="line">        </span><br><span class="line">        // 返回空信号</span><br><span class="line">        //return [RACSignal empty];</span><br><span class="line">        </span><br><span class="line">        // 2.创建信号 传递数据</span><br><span class="line">        return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">            </span><br><span class="line">            [subscriber sendNext:@&quot;请求数据&quot;];</span><br><span class="line">            </span><br><span class="line">            // 注意：数据传递完，最好调用sendCompleted,这时命令才执行完毕</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">            </span><br><span class="line">            return nil;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 强引用命令，不要被销毁，否则接收不到数据</span><br><span class="line">    _command = command;</span><br><span class="line">    </span><br><span class="line">    // 3.订阅RACCommand的信号</span><br><span class="line">    [command.executionSignals subscribeNext:^(id x) &#123;</span><br><span class="line">        [x subscribeNext:^(id x) &#123;</span><br><span class="line">            </span><br><span class="line">            NSLog(@&quot;订阅RACCommand的信号: %@&quot;, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // RAC高级用法</span><br><span class="line">    // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号</span><br><span class="line">    [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">        NSLog(@&quot;RAC高级用法: %@&quot;, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。</span><br><span class="line">    [[command.executing skip:1] subscribeNext:^(id x) &#123;</span><br><span class="line">       </span><br><span class="line">        if ([x boolValue] == YES) &#123;</span><br><span class="line">            </span><br><span class="line">            // 正在执行</span><br><span class="line">            NSLog(@&quot;正在执行&quot;);</span><br><span class="line">            </span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            </span><br><span class="line">            // 执行完毕</span><br><span class="line">            NSLog(@&quot;执行完成&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    // 5.执行命名</span><br><span class="line">    [self.command execute:@1];</span><br></pre></td></tr></table></figure>

<h4 id="RACMulticastConnection"><a href="#RACMulticastConnection" class="headerlink" title="RACMulticastConnection"></a>RACMulticastConnection</h4><blockquote>
<p>用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。</p>
</blockquote>
<p>注意：RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建.</p>
<p>RACMulticastConnection使用步骤:</p>
<ol>
<li>创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id<RACSubscriber> subscriber))didSubscribe</li>
<li>创建连接 RACMulticastConnection *connect = [signal publish];</li>
<li>订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock]</li>
<li>连接 [connect connect]</li>
</ol>
<p>RACMulticastConnection底层原理:</p>
<ol>
<li>创建connect，connect.sourceSignal -&gt; RACSignal(原始信号)  connect.signal -&gt; RACSubject</li>
<li>订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。</li>
<li>[connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject<ol>
<li>订阅原始信号，就会调用原始信号中的didSubscribe</li>
<li>didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext</li>
</ol>
</li>
<li>RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。<ul>
<li>因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock</li>
</ul>
</li>
</ol>
<p>需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。</p>
<p>解决：使用RACMulticastConnection就能解决.</p>
<p>问题：每次订阅一次都会发送请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建请求信号</span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;发送请求&quot;);</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 订阅信号</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;接受数据: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 再次订阅信号，会再次执行发送请求，也就是每次订阅都会发送一次请求</span><br><span class="line">[signal subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;接受数据: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-28 11:37:04.397 ReactiveCacoa[1505:340573] 发送请求</span><br><span class="line">2016-12-28 11:37:04.398 ReactiveCacoa[1505:340573] 接受数据: 1</span><br><span class="line">2016-12-28 11:37:04.398 ReactiveCacoa[1505:340573] 发送请求</span><br><span class="line">2016-12-28 11:37:04.398 ReactiveCacoa[1505:340573] 接受数据: 1</span><br></pre></td></tr></table></figure>
<p>可以发现每次订阅都会重新发送请求.</p>
<p>下面我们使用RACMulticastConnection：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;发送请求&quot;);</span><br><span class="line">    [subscriber sendNext:@1];</span><br><span class="line">    </span><br><span class="line">    return nil;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 创建连接</span><br><span class="line">RACMulticastConnection *connect = [signal publish];</span><br><span class="line"></span><br><span class="line">// 订阅信号</span><br><span class="line">// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接，当调用连接，就会一次性调用所有订阅者的SendNext</span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;订阅者1信号: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[connect.signal subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;订阅者2信号: %@&quot;, x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 连接、激活信号</span><br><span class="line">[connect connect];</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-28 11:37:04.399 ReactiveCacoa[1505:340573] 发送请求</span><br><span class="line">2016-12-28 11:37:04.399 ReactiveCacoa[1505:340573] 订阅者1信号: 1</span><br><span class="line">2016-12-28 11:37:04.399 ReactiveCacoa[1505:340573] 订阅者2信号: 1</span><br></pre></td></tr></table></figure>
<h4 id="RACScheduler"><a href="#RACScheduler" class="headerlink" title="RACScheduler"></a>RACScheduler</h4><blockquote>
<p>RAC中的队列，用GCD封装的。</p>
</blockquote>
<h4 id="RACUnit"><a href="#RACUnit" class="headerlink" title="RACUnit"></a>RACUnit</h4><blockquote>
<p>表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil.</p>
</blockquote>
<h4 id="RACEven"><a href="#RACEven" class="headerlink" title="RACEven"></a>RACEven</h4><blockquote>
<p>把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。</p>
</blockquote>
<h1 id="ReactiveCocoa开发中常见用法"><a href="#ReactiveCocoa开发中常见用法" class="headerlink" title="ReactiveCocoa开发中常见用法"></a>ReactiveCocoa开发中常见用法</h1><ol>
<li>替换代理            </li>
<li>替换KVO</li>
<li>监听事件</li>
<li>替换通知</li>
<li>监听文本框文字改变</li>
<li>统一处理多个网络请求</li>
</ol>
<h4 id="替换代理："><a href="#替换代理：" class="headerlink" title="替换代理："></a>替换代理：</h4><p><strong>rac_signalForSelector:</strong></p>
<p><code>rac_signalForSelector:</code> 直接监听 <code>Selector</code> 事件的调用</p>
<p>应用场景：监听 <code>RedViewController</code> 中按钮的点击事件 <code>btnTap:</code></p>
<p>跳转到<code>RedViewController</code>前，先使用<code>rac_signalForSelector</code>订阅rvc中的 <code>btnTap:</code> 点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 使用segue跳转</span><br><span class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</span><br><span class="line">- </span><br><span class="line">    if ([segue.identifier isEqualToString:@&quot;goRedVC&quot;]) &#123;</span><br><span class="line">        </span><br><span class="line">        RedViewController *rvc = segue.destinationViewController;</span><br><span class="line">        </span><br><span class="line">        // 订阅rvc中的 btnTap: 点击事件</span><br><span class="line">        [[rvc rac_signalForSelector:@selector(btnTap:)] subscribeNext:^(id x) &#123;</span><br><span class="line">        </span><br><span class="line">            NSLog(@&quot;RedVC btnTap！&quot;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RedViewController.m</code> 中的按钮事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (IBAction)btnTap:(id)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="替换KVO"><a href="#替换KVO" class="headerlink" title="替换KVO"></a>替换KVO</h4><p><strong>rac_valuesForKeyPath:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// KVO</span><br><span class="line">// 监听 slider 的 value 变化</span><br><span class="line">[[self.slider rac_valuesForKeyPath:@&quot;value&quot; observer:nil] subscribeNext:^(id x) &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;slider value Change：%@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="替换通知"><a href="#替换通知" class="headerlink" title="替换通知"></a>替换通知</h4><p><strong>rac_addObserverForName</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 原生的订阅通知</span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                                         selector:@selector(userDidChange:)</span><br><span class="line">                                             name:kTTCurrentUserLoggedOffNotification</span><br><span class="line">                                           object:nil];</span><br><span class="line">                                           </span><br><span class="line">// 使用RAC订阅通知 ，takeUntil限定信号的声明周期                                  </span><br><span class="line">[[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil]</span><br><span class="line">  takeUntil:[self rac_willDeallocSignal]]</span><br><span class="line">  subscribeNext:^(id x) &#123;</span><br><span class="line">     NSLog(@&quot;Notification received&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p><strong>rac_signalForControlEvents:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 监听 btn 的 UIControlEventTouchUpInside 点击事件</span><br><span class="line">[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;btnTap&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>


<h4 id="监听-textField-文字变化"><a href="#监听-textField-文字变化" class="headerlink" title="监听 textField 文字变化"></a>监听 textField 文字变化</h4><p><strong>rac_textSignal</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[self.textField rac_textSignal] subscribeNext:^(id x) &#123;</span><br><span class="line">        </span><br><span class="line">	NSLog(@&quot;textField change: %@&quot;, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="统一处理多个网络请求"><a href="#统一处理多个网络请求" class="headerlink" title="统一处理多个网络请求"></a>统一处理多个网络请求</h4><p><strong>rac_liftSelector:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">	// 处理多个请求都返回结果的时候，统一处理</span><br><span class="line">    // 如同时进行多个网络请求，每个请求都正确返回时，再去刷新页面</span><br><span class="line">    </span><br><span class="line">    RACSignal *signalOne = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        // 网络请求1</span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        // 返回成功</span><br><span class="line">        [subscriber sendNext:@&quot;网络请求1 data&quot;];</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        </span><br><span class="line">        // 网络请求2</span><br><span class="line">        // ...</span><br><span class="line">        </span><br><span class="line">        // 返回成功</span><br><span class="line">        [subscriber sendNext:@&quot;网络请求2 data&quot;];</span><br><span class="line">        </span><br><span class="line">        return nil;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [self rac_liftSelector:@selector(updateWithR1:R2:) withSignalsFromArray:@[signalOne, signalTwo]];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 更新界面</span><br><span class="line">- (void)updateWithR1:(id)r1 R2:(id)r2 &#123;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;R1:%@, R2：%@ 完成！&quot;, r1, r2);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意</strong>：</h4><ul>
<li><p><code>替换KVO</code>和 <code>监听文本框文字改变</code> 方法在创建监听方法时就会执行一次。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-28 16:53:50.746 ReactiveCacoa[4956:1246592] slider value Change：0.5</span><br><span class="line">2016-12-28 16:53:50.748 ReactiveCacoa[4956:1246592] textField change:</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>rac_liftSelector</code>时 <code>@selector(updateWithR1:R2:)</code>中的方 <strong>参数个数</strong> 要与 <strong>signal个数</strong> 相同，否则会被断言Crash！</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>ReactiveCocoa</tag>
        <tag>函数式编程</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C：Category</title>
    <url>/folder/2016/12/21/2016-12-21-Objective-C-Category/</url>
    <content><![CDATA[<blockquote>
<p>本文转载自美图点评技术团队的：<a href="http://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="noopener">深入理解Objective-C：Category</a>，略有修改。</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>无论一个类设计的多么完美，在未来的需求演进中，都有可能会碰到一些无法预测的情况。那怎么扩展已有的类呢？一般而言，继承和组合是不错的选择。但是在Objective-C 2.0中，又提供了category这个语言特性，可以动态地为已有类添加新行为。如今category已经遍布于Objective-C代码的各个角落，从Apple官方的framework到各个开源框架，从功能繁复的大型APP到简单的应用，catagory无处不在。本文对category做了比较全面的整理，希望对读者有所裨益。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>本文系学习Objective-C的runtime源码时整理所成，主要剖析了category在runtime层的实现原理以及和category相关的方方面面，内容包括：</p>
<ul>
<li>初入宝地 category简介</li>
<li>连类比事 category和extension</li>
<li>挑灯细览 category真面目</li>
<li>追本溯源 category如何加载</li>
<li>旁枝末叶 category和+load方法</li>
<li>触类旁通 category和方法覆盖</li>
<li>更上一层 category和关联对象</li>
</ul>
<h2 id="初入宝地-Category简介"><a href="#初入宝地-Category简介" class="headerlink" title="初入宝地 Category简介"></a>初入宝地 Category简介</h2><p>Category是Objective-C 2.0之后添加的语言特性，Category的主要作用是为已经存在的类添加方法。除此之外，apple还推荐了Category的另外两个使用场景,详见<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html" target="_blank" rel="noopener">Apple Category文档</a>。</p>
<ul>
<li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处，<ul>
<li>可以减少单个文件的体积 b)可以把不同的功能组织到不同的category里 </li>
<li>可以由多个开发者共同完成一个类 </li>
<li>可以按需加载想要的 Category 等等。</li>
</ul>
</li>
<li>声明私有方法</li>
</ul>
<p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>
<ul>
<li>模拟多继承</li>
<li>把framework的私有方法公开</li>
</ul>
<p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p>
<h2 id="连类比事-Category和Extension"><a href="#连类比事-Category和Extension" class="headerlink" title="连类比事 Category和Extension"></a>连类比事 Category和Extension</h2><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。(详见<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html" target="_blank" rel="noopener">Apple文档</a>)</p>
<h2 id="挑灯细览-category真面目"><a href="#挑灯细览-category真面目" class="headerlink" title="挑灯细览 category真面目"></a>挑灯细览 category真面目</h2><p>我们知道，所有的OC类和对象，在runtime层都是用struct表示的，category也不例外，在runtime层，category用结构体category_t（在objc-runtime-new.h中可以找到此定义），它包含了</p>
<ol>
<li>类的名字（name）</li>
</ol>
<ul>
<li>类（cls）</li>
<li>category中所有给类添加的实例方法的列表（instanceMethods）</li>
<li>category中所有添加的类方法的列表（classMethods）</li>
<li>category实现的所有协议的列表（protocols）</li>
<li>category中添加的所有属性（instanceProperties）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct category_t &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    classref_t cls;</span><br><span class="line">    struct method_list_t *instanceMethods;</span><br><span class="line">    struct method_list_t *classMethods;</span><br><span class="line">    struct protocol_list_t *protocols;</span><br><span class="line">    struct property_list_t *instanceProperties;</span><br><span class="line">&#125; category_t;</span><br></pre></td></tr></table></figure>
<p>从category的定义也可以看出category的可为（可以添加实例方法，类方法，甚至可以实现协议，添加属性）和不可为（无法添加实例变量）。<br>ok，我们先去写一个category看一下category到底为何物：</p>
<p>MyClass.h：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">- (void)printName;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface MyClass(MyAddition)</span><br><span class="line"></span><br><span class="line">@property(nonatomic, copy) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)printName;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>MyClass.m：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;MyClass.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,@&quot;MyClass&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass(MyAddition)</span><br><span class="line"></span><br><span class="line">- (void)printName</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,@&quot;MyAddition&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>我们使用clang的命令去看看category到底会变成什么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clang -rewrite-objc MyClass.m</span><br></pre></td></tr></table></figure>
<p>好吧，我们得到了一个3M大小，10w多行的.cpp文件（这绝对是Apple值得吐槽的一点），我们忽略掉所有和我们无关的东西，在文件的最后，我们找到了如下代码片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static struct /*_method_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _objc_method)</span><br><span class="line">unsigned int method_count;</span><br><span class="line">struct _objc_method method_list[1];</span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_objc_method),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;(struct objc_selector *)&quot;printName&quot;, &quot;v16@0:8&quot;, (void *)_I_MyClass_MyAddition_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct /*_prop_list_t*/ &#123;</span><br><span class="line">unsigned int entsize;  // sizeof(struct _prop_t)</span><br><span class="line">unsigned int count_of_properties;</span><br><span class="line">struct _prop_t prop_list[1];</span><br><span class="line">&#125; _OBJC_$_PROP_LIST_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) = &#123;</span><br><span class="line">sizeof(_prop_t),</span><br><span class="line">1,</span><br><span class="line">&#123;&#123;&quot;name&quot;,&quot;T@\&quot;NSString\&quot;,C,N&quot;&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __declspec(dllexport) struct _class_t OBJC_CLASS_$_MyClass;</span><br><span class="line"></span><br><span class="line">static struct _category_t _OBJC_$_CATEGORY_MyClass_$_MyAddition __attribute__ ((used, section (&quot;__DATA,__objc_const&quot;))) =</span><br><span class="line">&#123;</span><br><span class="line">&quot;MyClass&quot;,</span><br><span class="line">0, // &amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">(const struct _method_list_t *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_MyClass_$_MyAddition,</span><br><span class="line">0,</span><br><span class="line">0,</span><br><span class="line">(const struct _prop_list_t *)&amp;_OBJC_$_PROP_LIST_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line">static void OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition(void ) &#123;</span><br><span class="line">_OBJC_$_CATEGORY_MyClass_$_MyAddition.cls = &amp;OBJC_CLASS_$_MyClass;</span><br><span class="line">&#125;</span><br><span class="line">#pragma section(&quot;.objc_inithooks$B&quot;, long, read, write)</span><br><span class="line">__declspec(allocate(&quot;.objc_inithooks$B&quot;)) static void *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">(void *)&amp;OBJC_CATEGORY_SETUP_$_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *L_OBJC_LABEL_CLASS_$ [1] __attribute__((used, section (&quot;__DATA, __objc_classlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _class_t *_OBJC_LABEL_NONLAZY_CLASS_$[] = &#123;</span><br><span class="line">&amp;OBJC_CLASS_$_MyClass,</span><br><span class="line">&#125;;</span><br><span class="line">static struct _category_t *L_OBJC_LABEL_CATEGORY_$ [1] __attribute__((used, section (&quot;__DATA, __objc_catlist,regular,no_dead_strip&quot;)))= &#123;</span><br><span class="line">&amp;_OBJC_$_CATEGORY_MyClass_$_MyAddition,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，</p>
<ol>
<li>首先编译器生成了实例方法列表OBJC$_CATEGORY_INSTANCE_METHODSMyClass$_MyAddition和属性列表OBJC$_PROP_LISTMyClass$_MyAddition，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在MyAddition这个category里面写的方法printName，而属性列表里面填充的也正是我们在MyAddition里添加的name属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</li>
</ol>
<ul>
<li>其次，编译器生成了category本身OBJC$_CATEGORYMyClass$_MyAddition，并用前面生成的列表来初始化category本身。</li>
<li>最后，编译器在DATA段下的objc_catlist section里保存了一个大小为1的category_t的数组L_OBJC_LABELCATEGORY$（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。<br>到这里，编译器的工作就接近尾声了，对于category在运行期怎么加载，我们下节揭晓。</li>
</ul>
<h2 id="追本溯源-category如何加载"><a href="#追本溯源-category如何加载" class="headerlink" title="追本溯源 category如何加载"></a>追本溯源 category如何加载</h2><p>我们知道，Objective-C的运行是依赖OC的runtime的，而OC的runtime和其他系统库一样，是OS X和iOS通过dyld动态加载的。<br>想了解更多dyld地同学可以移步<a href="https://www.mikeash.com/pyblog/friday-qa-2012-11-09-dyld-dynamic-linking-on-os-x.html" target="_blank" rel="noopener">这里</a>。</p>
<p>对于OC运行时，入口方法如下（在objc-os.mm文件中）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _objc_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    static bool initialized = false;</span><br><span class="line">    if (initialized) return;</span><br><span class="line">    initialized = true;</span><br><span class="line"></span><br><span class="line">    // fixme defer initialization until an objc-using image is found?</span><br><span class="line">    environ_init();</span><br><span class="line">    tls_init();</span><br><span class="line">    lock_init();</span><br><span class="line">    exception_init();</span><br><span class="line"></span><br><span class="line">    // Register for unmap first, in case some +load unmaps something</span><br><span class="line">    _dyld_register_func_for_remove_image(&amp;unmap_image);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_bound,</span><br><span class="line">                                             1/*batch*/, &amp;map_images);</span><br><span class="line">    dyld_register_image_state_change_handler(dyld_image_state_dependents_initialized, 0/*not batch*/, &amp;load_images);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>category被附加到类上面是在map_images的时候发生的，在new-ABI的标准下，_objc_init里面的调用的map_images最终会调用objc-runtime-new.mm里面的_read_images方法，而在_read_images方法的结尾，有以下的代码片段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Discover categories. </span><br><span class="line">    for (EACH_HEADER) &#123;</span><br><span class="line">        category_t **catlist =</span><br><span class="line">            _getObjc2CategoryList(hi, &amp;count);</span><br><span class="line">        for (i = 0; i &lt; count; i++) &#123;</span><br><span class="line">            category_t *cat = catlist[i];</span><br><span class="line">            class_t *cls = remapClass(cat-&gt;cls);</span><br><span class="line"></span><br><span class="line">            if (!cls) &#123;</span><br><span class="line">                // Category&apos;s target class is missing (probably weak-linked).</span><br><span class="line">                // Disavow any knowledge of this category.</span><br><span class="line">                catlist[i] = NULL;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: IGNORING category \?\?\?(%s) %p with &quot;</span><br><span class="line">                                 &quot;missing weak-linked target class&quot;,</span><br><span class="line">                                 cat-&gt;name, cat);</span><br><span class="line">                &#125;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Process this category. </span><br><span class="line">            // First, register the category with its target class. </span><br><span class="line">            // Then, rebuild the class&apos;s method lists (etc) if </span><br><span class="line">            // the class is realized. </span><br><span class="line">            BOOL classExists = NO;</span><br><span class="line">            if (cat-&gt;instanceMethods ||  cat-&gt;protocols </span><br><span class="line">                ||  cat-&gt;instanceProperties)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls, hi);</span><br><span class="line">                if (isRealized(cls)) &#123;</span><br><span class="line">                    remethodizeClass(cls);</span><br><span class="line">                    classExists = YES;</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category -%s(%s) %s&quot;,</span><br><span class="line">                                 getName(cls), cat-&gt;name,</span><br><span class="line">                                 classExists ? &quot;on existing class&quot; : &quot;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (cat-&gt;classMethods  ||  cat-&gt;protocols </span><br><span class="line">                /* ||  cat-&gt;classProperties */)</span><br><span class="line">            &#123;</span><br><span class="line">                addUnattachedCategoryForClass(cat, cls-&gt;isa, hi);</span><br><span class="line">                if (isRealized(cls-&gt;isa)) &#123;</span><br><span class="line">                    remethodizeClass(cls-&gt;isa);</span><br><span class="line">                &#125;</span><br><span class="line">                if (PrintConnecting) &#123;</span><br><span class="line">                    _objc_inform(&quot;CLASS: found category +%s(%s)&quot;,</span><br><span class="line">                                 getName(cls), cat-&gt;name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们拿到的catlist就是上节中讲到的编译器为我们准备的category_t数组，关于是如何加载catlist本身的，我们暂且不表，这和category本身的关系也不大，有兴趣的同学可以去研究以下Apple的二进制格式和load机制。</p>
<p>略去PrintConnecting这个用于log的东西，这段代码很容易理解：</p>
<ol>
<li>把category的实例方法、协议以及属性添加到类上</li>
<li>把category的类方法和协议添加到类的metaclass上</li>
</ol>
<p>值得注意的是，在代码中有一小段注释 <code>/ || cat-&gt;classProperties /</code>，看来苹果有过给类添加属性的计划啊。<br>ok，我们接着往里看，category的各种列表是怎么最终添加到类上的，就拿实例方法列表来说吧：<br>在上述的代码片段里，addUnattachedCategoryForClass只是把类和category做一个关联映射，而remethodizeClass才是真正去处理添加事宜的功臣。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void remethodizeClass(class_t *cls)</span><br><span class="line">&#123;</span><br><span class="line">    category_list *cats;</span><br><span class="line">    BOOL isMeta;</span><br><span class="line"></span><br><span class="line">    rwlock_assert_writing(&amp;runtimeLock);</span><br><span class="line"></span><br><span class="line">    isMeta = isMetaClass(cls);</span><br><span class="line"></span><br><span class="line">    // Re-methodizing: check for more categories</span><br><span class="line">    if ((cats = unattachedCategoriesForClass(cls))) &#123;</span><br><span class="line">        chained_property_list *newproperties;</span><br><span class="line">        const protocol_list_t **newprotos;</span><br><span class="line"></span><br><span class="line">        if (PrintConnecting) &#123;</span><br><span class="line">            _objc_inform(&quot;CLASS: attaching categories to class &apos;%s&apos; %s&quot;,</span><br><span class="line">                         getName(cls), isMeta ? &quot;(meta)&quot; : &quot;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Update methods, properties, protocols</span><br><span class="line"></span><br><span class="line">        BOOL vtableAffected = NO;</span><br><span class="line">        attachCategoryMethods(cls, cats, &amp;vtableAffected);</span><br><span class="line"></span><br><span class="line">        newproperties = buildPropertyList(NULL, cats, isMeta);</span><br><span class="line">        if (newproperties) &#123;</span><br><span class="line">            newproperties-&gt;next = cls-&gt;data()-&gt;properties;</span><br><span class="line">            cls-&gt;data()-&gt;properties = newproperties;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        newprotos = buildProtocolList(cats, NULL, cls-&gt;data()-&gt;protocols);</span><br><span class="line">        if (cls-&gt;data()-&gt;protocols  &amp;&amp;  cls-&gt;data()-&gt;protocols != newprotos) &#123;</span><br><span class="line">            _free_internal(cls-&gt;data()-&gt;protocols);</span><br><span class="line">        &#125;</span><br><span class="line">        cls-&gt;data()-&gt;protocols = newprotos;</span><br><span class="line"></span><br><span class="line">        _free_internal(cats);</span><br><span class="line"></span><br><span class="line">        // Update method caches and vtables</span><br><span class="line">        flushCaches(cls);</span><br><span class="line">        if (vtableAffected) flushVtables(cls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于添加类的实例方法而言，又会去调用attachCategoryMethods这个方法，我们去看下attachCategoryMethods：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void </span><br><span class="line">attachCategoryMethods(class_t *cls, category_list *cats,</span><br><span class="line">                      BOOL *inoutVtablesAffected)</span><br><span class="line">&#123;</span><br><span class="line">    if (!cats) return;</span><br><span class="line">    if (PrintReplacedMethods) printReplacements(cls, cats);</span><br><span class="line"></span><br><span class="line">    BOOL isMeta = isMetaClass(cls);</span><br><span class="line">    method_list_t **mlists = (method_list_t **)</span><br><span class="line">        _malloc_internal(cats-&gt;count * sizeof(*mlists));</span><br><span class="line"></span><br><span class="line">    // Count backwards through cats to get newest categories first</span><br><span class="line">    int mcount = 0;</span><br><span class="line">    int i = cats-&gt;count;</span><br><span class="line">    BOOL fromBundle = NO;</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">        method_list_t *mlist = cat_method_list(cats-&gt;list[i].cat, isMeta);</span><br><span class="line">        if (mlist) &#123;</span><br><span class="line">            mlists[mcount++] = mlist;</span><br><span class="line">            fromBundle |= cats-&gt;list[i].fromBundle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    attachMethodLists(cls, mlists, mcount, NO, fromBundle, inoutVtablesAffected);</span><br><span class="line"></span><br><span class="line">    _free_internal(mlists);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>attachCategoryMethods做的工作相对比较简单，它只是把所有category的实例方法列表拼成了一个大的实例方法列表，然后转交给了attachMethodLists方法（我发誓，这是本节我们看的最后一段代码了^_^），这个方法有点长，我们只看一小段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (uint32_t m = 0;</span><br><span class="line">             (scanForCustomRR || scanForCustomAWZ)  &amp;&amp;  m &lt; mlist-&gt;count;</span><br><span class="line">             m++)</span><br><span class="line">        &#123;</span><br><span class="line">            SEL sel = method_list_nth(mlist, m)-&gt;name;</span><br><span class="line">            if (scanForCustomRR  &amp;&amp;  isRRSelector(sel)) &#123;</span><br><span class="line">                cls-&gt;setHasCustomRR();</span><br><span class="line">                scanForCustomRR = false;</span><br><span class="line">            &#125; else if (scanForCustomAWZ  &amp;&amp;  isAWZSelector(sel)) &#123;</span><br><span class="line">                cls-&gt;setHasCustomAWZ();</span><br><span class="line">                scanForCustomAWZ = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Fill method list array</span><br><span class="line">        newLists[newCount++] = mlist;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line"></span><br><span class="line">    // Copy old methods to the method list array</span><br><span class="line">    for (i = 0; i &lt; oldCount; i++) &#123;</span><br><span class="line">        newLists[newCount++] = oldLists[i];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的有两点：</p>
<ol>
<li>category的方法没有“完全替换掉”原来类已经有的方法，也就是说如果category和原来类都有methodA，那么category附加完成之后，类的方法列表里会有两个methodA</li>
<li>category的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，这也就是我们平常所说的category的方法会“覆盖”掉原来类的同名方法，这是因为运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休^_^，殊不知后面可能还有一样名字的方法。</li>
</ol>
<h2 id="旁枝末叶-category-和-load-方法"><a href="#旁枝末叶-category-和-load-方法" class="headerlink" title="旁枝末叶 category 和 +load 方法"></a>旁枝末叶 category 和 +load 方法</h2><p>我们知道，在类和category中都可以有+load方法，那么有两个问题：</p>
<ol>
<li>在类的+load方法调用的时候，我们可以调用category中声明的方法么？</li>
<li>这么些个+load方法，调用顺序是咋样的呢？</li>
</ol>
<p>鉴于上述几节我们看的代码太多了，对于这两个问题我们先来看一点直观的：</p>
<p><img src="http://tech.meituan.com/img/diveintocategory/project.png" alt=""></p>
<p>我们的代码里有MyClass和MyClass的两个category （Category1和Category2），MyClass和两个category都添加了+load方法，并且Category1和Category2都写了MyClass的printName方法。<br>在Xcode中点击Edit Scheme，添加如下两个环境变量（可以在执行load方法以及加载category的时候打印log信息，更多的环境变量选项可参见objc-private.h）:<br><img src="http://tech.meituan.com/img/diveintocategory/environment_vars.png" alt=""></p>
<p>运行项目，我们会看到控制台打印很多东西出来，我们只找到我们想要的信息，顺序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category1</span><br><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category2</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: +[MyClass load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category1) load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category2) load]</span><br></pre></td></tr></table></figure>

<p>所以，对于上面两个问题，答案是很明显的：</p>
<ol>
<li>可以调用，因为附加category到类的工作会先于+load方法的执行</li>
</ol>
<ul>
<li>+load的执行顺序是先类，后category，而category的+load执行顺序是根据编译顺序决定的。<br>目前的编译顺序是这样的：</li>
</ul>
<p><img src="http://tech.meituan.com/img/diveintocategory/compile1.png" alt=""></p>
<p>我们调整一个Category1和Category2的编译顺序，run。ok，我们可以看到控制台的输出顺序变了：</p>
<p><img src="http://tech.meituan.com/img/diveintocategory/compile2.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category2</span><br><span class="line">objc[1187]: REPLACED: -[MyClass printName] by category Category1</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: class &apos;MyClass&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category2)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: category &apos;MyClass(Category1)&apos; scheduled for +load</span><br><span class="line">objc[1187]: LOAD: +[MyClass load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category2) load]</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">objc[1187]: LOAD: +[MyClass(Category1) load]</span><br></pre></td></tr></table></figure>

<p>虽然对于+load的执行顺序是这样，但是对于“覆盖”掉的方法，则会先找到最后一个编译的category里的对应方法。</p>
<p>这一节我们只是用很直观的方式得到了问题的答案，有兴趣的同学可以继续去研究一下OC的运行时代码。</p>
<h2 id="触类旁通-category-和方法覆盖"><a href="#触类旁通-category-和方法覆盖" class="headerlink" title="触类旁通 category 和方法覆盖"></a>触类旁通 category 和方法覆盖</h2><p>鉴于上面几节我们已经把原理都讲了，这一节只有一个问题:</p>
<p>怎么调用到原来类中被category覆盖掉的方法？</p>
<p>对于这个问题，我们已经知道category其实并不是完全替换掉原来类的同名方法，只是category在方法列表的前面而已，所以我们只要顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class currentClass = [MyClass class];</span><br><span class="line">MyClass *my = [[MyClass alloc] init];</span><br><span class="line"></span><br><span class="line">if (currentClass) &#123;</span><br><span class="line">    unsigned int methodCount;</span><br><span class="line">    Method *methodList = class_copyMethodList(currentClass, &amp;methodCount);</span><br><span class="line">    IMP lastImp = NULL;</span><br><span class="line">    SEL lastSel = NULL;</span><br><span class="line">    for (NSInteger i = 0; i &lt; methodCount; i++) &#123;</span><br><span class="line">        Method method = methodList[i];</span><br><span class="line">        NSString *methodName = [NSString stringWithCString:sel_getName(method_getName(method)) </span><br><span class="line">                                        encoding:NSUTF8StringEncoding];</span><br><span class="line">        if ([@&quot;printName&quot; isEqualToString:methodName]) &#123;</span><br><span class="line">            lastImp = method_getImplementation(method);</span><br><span class="line">            lastSel = method_getName(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    typedef void (*fn)(id,SEL);</span><br><span class="line"></span><br><span class="line">    if (lastImp != NULL) &#123;</span><br><span class="line">        fn f = (fn)lastImp;</span><br><span class="line">        f(my,lastSel);</span><br><span class="line">    &#125;</span><br><span class="line">    free(methodList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更上一层-category-和关联对象"><a href="#更上一层-category-和关联对象" class="headerlink" title="更上一层 category 和关联对象"></a>更上一层 category 和关联对象</h2><p>如上所见，我们知道在category里面是无法为category添加实例变量的。但是我们很多时候需要在category中添加和对象关联的值，这个时候可以求助关联对象来实现。</p>
<p>MyClass+Category1.h:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;MyClass.h&quot;</span><br><span class="line"></span><br><span class="line">@interface MyClass (Category1)</span><br><span class="line"></span><br><span class="line">@property(nonatomic,copy) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>MyClass+Category1.m:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;MyClass+Category1.h&quot;</span><br><span class="line">#import &lt;objc/runtime.h&gt;</span><br><span class="line"></span><br><span class="line">@implementation MyClass (Category1)</span><br><span class="line"></span><br><span class="line">+ (void)load</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;%@&quot;,@&quot;load in Category1&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setName:(NSString *)name</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(self,</span><br><span class="line">                             &quot;name&quot;,</span><br><span class="line">                             name,</span><br><span class="line">                             OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString*)name</span><br><span class="line">&#123;</span><br><span class="line">    NSString *nameObject = objc_getAssociatedObject(self, &quot;name&quot;);</span><br><span class="line">    return nameObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>但是关联对象又是存在什么地方呢？ 如何存储？ 对象销毁时候如何处理关联对象呢？<br>我们去翻一下runtime的源码，在objc-references.mm文件中有个方法_object_set_associative_reference：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123;</span><br><span class="line">    // retain the new value (if any) outside the lock.</span><br><span class="line">    ObjcAssociation old_association(0, nil);</span><br><span class="line">    id new_value = value ? acquireValue(value, policy) : nil;</span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;</span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());</span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);</span><br><span class="line">        if (new_value) &#123;</span><br><span class="line">            // break any existing association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i != associations.end()) &#123;</span><br><span class="line">                // secondary table exists</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // create the new association (first time).</span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                _class_setInstancesHaveAssociatedObjects(_object_getClass(object));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // setting the association to nil breaks the association.</span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            if (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                if (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // release the old value (outside of the lock).</span><br><span class="line">    if (old_association.hasValue()) ReleaseValue()(old_association);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到所有的关联对象都由AssociationsManager管理，而AssociationsManager定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class AssociationsManager &#123;</span><br><span class="line">    static OSSpinLock _lock;</span><br><span class="line">    static AssociationsHashMap *_map;               // associative references:  object pointer -&gt; PtrPtrHashMap.</span><br><span class="line">public:</span><br><span class="line">    AssociationsManager()   &#123; OSSpinLockLock(&amp;_lock); &#125;</span><br><span class="line">    ~AssociationsManager()  &#123; OSSpinLockUnlock(&amp;_lock); &#125;</span><br><span class="line"></span><br><span class="line">    AssociationsHashMap &amp;associations() &#123;</span><br><span class="line">        if (_map == NULL)</span><br><span class="line">            _map = new AssociationsHashMap();</span><br><span class="line">        return *_map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的kv对。<br>而在对象的销毁逻辑里面，见objc-runtime-new.mm:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *objc_destructInstance(id obj) </span><br><span class="line">&#123;</span><br><span class="line">    if (obj) &#123;</span><br><span class="line">        Class isa_gen = _object_getClass(obj);</span><br><span class="line">        class_t *isa = newcls(isa_gen);</span><br><span class="line"></span><br><span class="line">        // Read all of the flags at once for performance.</span><br><span class="line">        bool cxx = hasCxxStructors(isa);</span><br><span class="line">        bool assoc = !UseGC &amp;&amp; _class_instancesHaveAssociatedObjects(isa_gen);</span><br><span class="line"></span><br><span class="line">        // This order is important.</span><br><span class="line">        if (cxx) object_cxxDestruct(obj);</span><br><span class="line">        if (assoc) _object_remove_assocations(obj);</span><br><span class="line"></span><br><span class="line">        if (!UseGC) objc_clear_deallocating(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>正如侯捷先生所讲-“源码面前，了无秘密”，Apple的Cocoa Touch框架虽然并不开源，但是Objective-C的runtime和Core Foundation却是完全开放源码的(在<a href="http://www.opensource.apple.com/tarballs/" target="_blank" rel="noopener">http://www.opensource.apple.com/tarballs/</a>可以下载到全部的开源代码)。<br>本系列runtime源码学习将会持续更新，意犹未尽的同学可以自行到上述网站下载源码学习。行笔简陋，如有错误，望指正。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Category</tag>
        <tag>ObjC</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器 你真的会使用吗？</title>
    <url>/folder/2016/12/13/2016-12-13-%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>定时器的使用是软件开发基础技能，用于延时执行或重复执行某些方法。</p>
<p>我相信大部分人接触iOS的定时器都是从这段代码开始的:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(action:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>]</span><br></pre></td></tr></table></figure>

<p>但是你真的会用吗？</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="iOS定时器"><a href="#iOS定时器" class="headerlink" title="iOS定时器"></a>iOS定时器</h2><p>首先来介绍iOS中的定时器</p>
<p>iOS中的定时器大致分为这几类：</p>
<ul>
<li><strong>NSTimer</strong></li>
<li><strong>CADisplayLink</strong></li>
<li><strong>GCD定时器</strong></li>
</ul>
<h3 id="NSTimer"><a href="#NSTimer" class="headerlink" title="NSTimer"></a>NSTimer</h3><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p><strong>NSTime</strong>定时器是我们比较常使用的定时器，比较常使用的方法有两种：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="built_in">NSTimer</span> *)timerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSTimer</span> *)scheduledTimerWithTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti target:(<span class="keyword">id</span>)aTarget selector:(SEL)aSelector userInfo:(<span class="keyword">nullable</span> <span class="keyword">id</span>)userInfo repeats:(<span class="built_in">BOOL</span>)yesOrNo;</span><br></pre></td></tr></table></figure>
<p>这两种方法都是创建一个定时器，区别是用<code>timerWithTimeInterval:</code>方法创建的定时器需要手动加入RunLoop中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建NSTimer对象</span><br><span class="line">NSTimer *timer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];</span><br><span class="line">// 加入RunLoop中</span><br><span class="line">[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>

<p>需要<strong>注意</strong>的是： <code>UIScrollView</code> 滑动时执行的是 <code>UITrackingRunLoopMode</code>，<code>NSDefaultRunLoopMode</code>被挂起，会导致定时器失效，等恢复为<strong>滑动结束</strong>时才恢复定时器。其原因可以查看我这篇<a href="http://www.jianshu.com/p/c4f552ceda63" target="_blank" rel="noopener">《Objective-C RunLoop 详解》</a>中的 “RunLoop 的 Mode“章节，有详细的介绍。</p>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)startTimer&#123;</span><br><span class="line">    NSTimer *UIScrollView = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(action:) userInfo:nil repeats:YES];</span><br><span class="line">    [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)action:(NSTimer *)sender &#123;</span><br><span class="line">    static int i = 0;</span><br><span class="line">    NSLog(@&quot;NSTimer: %d&quot;,i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将<code>timer</code>添加到<strong>NSDefaultRunLoopMode</strong>中，没0.5秒打印一次，然后滑动<code>UIScrollView</code>.</p>
<p>打印台输出：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2178672-9de097ecc618b498.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>可以看出在滑动<code>UIScrollView</code>时，定时器被暂停了。</p>
<p>所以如果需要定时器在 <code>UIScrollView</code> 拖动时也不影响的话，有两种解决方法</p>
<ol>
<li><strong>timer</strong>分别添加到 <code>UITrackingRunLoopMode</code> 和 <code>NSDefaultRunLoopMode</code>中</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode: <span class="built_in">UITrackingRunLoopMode</span>];</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>直接将<strong>timer</strong>添加到<code>NSRunLoopCommonModes</code> 中：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:timer forMode: <span class="built_in">NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>

<p>但并不是都<strong>timer</strong>所有的需要在滑动<code>UIScrollView</code>时继续执行，比如使用<strong>NSTimer</strong>完成的帧动画，滑动<code>UIScrollView</code>时就可以停止帧动画，保证滑动的流程性。</p>
<p>若没有特殊要求的话，一般使用第二种方法创建完<strong>timer</strong>，会自动添加到<code>NSDefaultRunLoopMode</code>中去执行，也是平时最常用的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(action:) userInfo:nil repeats:YES];</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<p><code>TimeInterval</code>：延时时间</p>
<p><code>target</code>:目标对象，一般就是<code>self</code>本身</p>
<p><code>selector</code>:执行方法</p>
<p><code>userInfo</code>:传入信息</p>
<p><code>repeats</code>:是否重复执行</p>
<p>以上创建的定时器，若<code>repeats</code>参数设为<code>NO</code>，执行一次后就会被释放掉;</p>
<p>若<code>repeats</code>参数设为<code>YES</code>重复执行时，必须手动关闭，否则定时器不会释放(停止）。</p>
<p>释放方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 停止定时器</span><br><span class="line">[timer invalidate];</span><br></pre></td></tr></table></figure>

<p>实际开发中，我们会将<code>NSTimer</code>对象设置为属性，这样方便释放。</p>
<p><strong>iOS10.0</strong> 推出了两个新的API，与上面的方法相比，<code>selector</code>换成Block回调以、减少传入的参数(那几个参数真是鸡肋)。不过开发中一般需要适配低版本，还是尽量使用上面的方法吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br><span class="line">+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br></pre></td></tr></table></figure>

<p>###特点</p>
<ul>
<li><p><strong>必须加入Runloop</strong></p>
<p>  上面不管使用哪种方法，实际最后都会加入RunLoop中执行，区别就在于是否手动加入而已。</p>
</li>
<li><p><strong>存在延迟</strong></p>
<p>  不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行，这个延迟时间大概为50-100毫秒.</p>
<p>  所以NSTimer不是绝对准确的,而且中间耗时或阻塞错过下一个点,那么下一个点就pass过去了.</p>
</li>
<li><p><strong>UIScrollView滑动会暂停计时</strong></p>
<p>  添加到<code>NSDefaultRunLoopMode</code>的 <code>timer</code> 在 <code>UIScrollView</code>滑动时会暂停，若不想被<code>UIScrollView</code>滑动影响，需要将 <code>timer</code> 添加再到 <code>UITrackingRunLoopMode</code> 或 直接添加到<code>NSRunLoopCommonModes</code> 中</p>
</li>
</ul>
<p>##CADisplayLink</p>
<p>CADisplayLink官方介绍：</p>
<blockquote>
<p>A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display</p>
</blockquote>
<p><strong>CADisplayLink</strong>对象是一个和屏幕刷新率同步的定时器对象。每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的<code>target</code>发送一次指定的<code>selector</code>消息， CADisplayLink类对应的 <code>selector</code> 就会被调用一次。</p>
<p>从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染，或者做动画。<br>###使用方法</p>
<p>创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) CADisplayLink *displayLink;</span><br><span class="line"></span><br><span class="line">self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)];  </span><br><span class="line"></span><br><span class="line">// 每隔1帧调用一次</span><br><span class="line">self.displayLink.frameInterval = 1;  </span><br><span class="line"></span><br><span class="line">[self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];</span><br></pre></td></tr></table></figure>
<p>释放方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[self.displayLink invalidate];  </span><br><span class="line"></span><br><span class="line">self.displayLink = nil;</span><br><span class="line">```      </span><br><span class="line">当把**CADisplayLink**对象添加到runloop中后，`selector`就能被周期性调用，类似于重复的NSTimer被启动了；执行`invalidate`操作时，CADisplayLink对象就会从runloop中移除，`selector`调用也随即停止，类似于NSTimer的`invalidate`方法。</span><br><span class="line"></span><br><span class="line">**CADisplayLink**中有两个重要的属性：</span><br><span class="line"></span><br><span class="line">- **frameInterval**</span><br><span class="line"></span><br><span class="line">	NSInteger类型的值，用来设置间隔多少帧调用一次`selector`方法，默认值是1，即每帧都调用一次。</span><br><span class="line">    </span><br><span class="line">- **duration**</span><br><span class="line"></span><br><span class="line">	`CFTimeInterval`值为`readOnly`，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在`targe`t的`selector`被首次调用以后才会被赋值。`selector`的调用间隔时间计算方式是：**调用间隔时间 = duration × frameInterval**。</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">###特点</span><br><span class="line"></span><br><span class="line">- **刷新频率固定**</span><br><span class="line">	</span><br><span class="line">	正常情况iOS设备的屏幕刷新频率是固定**60Hz**,如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。</span><br><span class="line">- **屏幕刷新时调用**</span><br><span class="line"></span><br><span class="line">	CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会	</span><br><span class="line"></span><br><span class="line">- **适合做界面渲染**</span><br><span class="line"></span><br><span class="line">	CADisplayLink可以确保系统渲染每一帧的时候我们的方法都被调用，从而保证了动画的流畅性。</span><br><span class="line"></span><br><span class="line">##GCD定时器</span><br><span class="line"></span><br><span class="line">**GCD定时器**和NSTimer是不一样的，NSTimer受RunLoop影响，但是GCD的定时器不受影响，因为通过源码可知RunLoop也是基于GCD的实现的，所以GCD定时器有非常高的精度。关于GCD的使用可一看看[这篇博客](http://www.cnblogs.com/pure/archive/2013/03/31/2977420.html)。</span><br><span class="line"></span><br><span class="line">###使用方法</span><br><span class="line">创建GCD定时器定时器的方法稍微比较复杂，看下面的代码：</span><br><span class="line"></span><br><span class="line">####单次的延时调用</span><br><span class="line">NSObject中的`performSelector:withObject:afterDelay:`以及 `performSelector:withObject:afterDelay:inModes:` 这两个方法在调用的时候会设置当前 runloop 中 `timer` ，前者设置的 `timer` 在 `NSDefaultRunLoopMode` 运行，后者则可以指定 **NSRunLoop** 的 `mode` 来执行。我们上面介绍过 runloop 中 `timer` 在 `UITrackingRunLoopMode` 被挂起，就导致了代码就会一直等待 `timer` 的调度,解决办法在上面也有说明。</span><br><span class="line"></span><br><span class="line">不过我们可以用另一套方案来解决这个问题，就是使用GCD中的 `dispatch_after` 来实现单次的延时调用：</span><br></pre></td></tr></table></figure>
<p>double delayInSeconds = 2.0;<br>    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));<br>    dispatch_after(popTime, dispatch_get_main_queue(), ^(void){<br>        [self someMethod];<br>    });</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">####循环调用</span><br></pre></td></tr></table></figure>
<p>// 创建GCD定时器<br>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<p>dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</p>
<p>dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0); //每秒执行</p>
<p>// 事件回调<br>dispatch_source_set_event_handler(_timer, ^{</p>
<pre><code>dispatch_async(dispatch_get_main_queue(), ^{
    // 在主线程中实现需要的功能

}</code></pre><p>}</p>
<p>});</p>
<p>// 开启定时器<br>dispatch_resume(_timer);</p>
<p>// 挂起定时器（dispatch_suspend 之后的 Timer，是不能被释放的！会引起崩溃）<br>dispatch_suspend(_timer);</p>
<p>// 关闭定时器<br>dispatch_source_cancel(_timer);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">上面代码中要注意的是：</span><br><span class="line"></span><br><span class="line">1. `dispatch_source_set_event_handler()`中的任务实在子线程中执行的，若需要回到主线程，要调用`dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;`.</span><br><span class="line">- `dispatch_source_set_timer` 中第二个参数，当我们使用 `dispatch_time` 或者 `DISPATCH_TIME_NOW` 时，系统会使用默认时钟来进行计时。然而当系统休眠的时候，默认时钟是不走的，也就会导致计时器停止。使用 `dispatch_walltime ` 可以让计时器按照真实时间间隔进行计时.</span><br><span class="line">- 第三个参数， ` 1.0 * NSEC_PER_SEC` 为每秒执行一次，对应的还有毫秒，分秒，纳秒可以选择.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- `dispatch_source_set_event_handler` 这个函数在执行完之后，block 会立马执行一遍，后面隔一定时间间隔再执行一次。而 `NSTimer` 第一次执行是到计时器触发之后。这也是和 `NSTimer` 之间的一个显著区别。</span><br><span class="line">- 挂起（暂停）定时器, `dispatch_suspend` 之后的 `Timer`，不能被释放的,会引起崩溃.</span><br><span class="line">- 创建的`timer`一定要有`dispatch_suspend(_timer)`或`dispatch_source_cancel(_timer)`这两句话来指定出口，否则定时器将不执行，若我们想无限循环可将 `dispatch_source_cancel(_timer)` 写在一句永不执行的`if`判断语句中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##使用场景</span><br><span class="line"></span><br><span class="line">介绍完iOS中的各种定时器，接下来我们来说说这几种定时器在开发中的几种用法。</span><br><span class="line">###短信重发倒计时</span><br><span class="line"></span><br><span class="line">短信倒计时使我们登录注册常用的功能，一般设置为60s，实现方法如下：</span><br></pre></td></tr></table></figure>
<p>// 计时时间<br>@property (nonatomic, assign) int timeout;</p>
<p>/** 开启倒计时 */</p>
<ul>
<li><p>(void)startCountdown {</p>
<p>  if (_timeout &gt; 0) {</p>
<pre><code>return;</code></pre><p>  }</p>
<p>  _timeout = 60;</p>
<p>  // GCD定时器<br>  dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<p>  dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</p>
<p>  dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0); //每秒执行</p>
<p>  dispatch_source_set_event_handler(_timer, ^{</p>
<pre><code>if(_timeout &lt;= 0 ){// 倒计时结束

    // 关闭定时器
    dispatch_source_cancel(_timer);

    dispatch_async(dispatch_get_main_queue(), ^{

        //设置界面的按钮显示 根据自己需求设置
        [self.sendMsgBtn setTitle:@&quot;发送&quot; forState:UIControlStateNormal];

        self.sendMsgBtn.enabled = YES;

    });

}else{// 倒计时中

    // 显示倒计时结果

    NSString *strTime = [NSString stringWithFormat:@&quot;重发(%.2d)&quot;, _timeout];

    dispatch_async(dispatch_get_main_queue(), ^{

        //设置界面的按钮显示 根据自己需求设置

        [self.sendMsgBtn setTitle:[NSString stringWithFormat:@&quot;%@&quot;,strTime] forState:UIControlStateNormal];

        self.sendMsgBtn.enabled = NO;

    });

    _timeout--;
}</code></pre><p>  });</p>
<p>  // 开启定时器<br>  dispatch_resume(_timer);</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在上面代码中，我们设置了一个60s循环倒计时，当我们向服务器获取短信验证码成功时 调用该方法开始倒计时。每秒刷新按钮的倒计时数，倒计时结束时再将按钮 `Title` 恢复为“发送”.</span><br><span class="line"></span><br><span class="line">有一点需要注意的是，按钮的样式要设置为 **UIButtonTypeCustom**,否则会出现刷新 `Title` 时闪烁.</span><br><span class="line"></span><br><span class="line">我们可以把这个方法封装一下，方便调用，否则在控制器中写这么一大段代码确实也不优雅。</span><br><span class="line"></span><br><span class="line">效果如下：</span><br><span class="line"></span><br><span class="line">![](http://upload-images.jianshu.io/upload_images/2178672-3d4d1353bcc36026.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">##### [代码链接](https://github.com/qiubaiying/BYTimer)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###每个几分钟向服务器发送数据</span><br><span class="line"></span><br><span class="line">在有定位服务的APP中，我们需要每个一段时间将定位数据发送到服务器，比如每5s定位一次每隔5分钟将再统一将数据发送服务器，这样会处理比较省电。</span><br><span class="line">一般程序进入后台时，定时器会停止，但是在定位APP中，需要持续进行定位，APP在后台时依旧可以运行，所以在后台定时器也是可以运行的。</span><br><span class="line"></span><br><span class="line">注：关于iOS后台常驻,可以查看[这篇博客](http://waitingyuan.blog.163.com/blog/static/2155781652014111133150534/)</span><br><span class="line"></span><br><span class="line">在使用GCD定时的时候发现GCD定时器也可以在后代运行，创建方法同上面的短信倒计时.</span><br><span class="line"></span><br><span class="line">这里我们使用**NSTimer**来创建一个每个5分钟执行一次的定时器.</span><br></pre></td></tr></table></figure>
<p>#import &lt;Foundation/Foundation.h&gt;</p>
<p>typedef void(^TimerBlock)();</p>
<p>@interface BYTimer : NSObject</p>
<ul>
<li><p>(void)startTimerWithBlock:(TimerBlock)timerBlock;</p>
</li>
<li><p>(void)stopTimer;</p>
</li>
</ul>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#import “BYTimer.h”</p>
<p>@interface BYTimer ()</p>
<p>@property (nonatomic, strong) NSTimer *timer;<br>@property (nonatomic, strong) TimerBlock timerBlock;</p>
<p>@end</p>
<p>@implementation BYTimer</p>
<ul>
<li><p>(void)startTimerWithBlock:(TimerBlock)timerBlock {</p>
<p>   self.timer = [NSTimer timerWithTimeInterval:300 target:self selector:@selector(_timerAction) userInfo:nil repeats:YES];</p>
<p>  [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes];<br>  _timerBlock = timerBlock;</p>
</li>
</ul>
<p>}</p>
<ul>
<li><p>(void)_timerAction {<br>  if (self.timerBlock) {</p>
<pre><code>self.timerBlock();</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)stopTimer {<br>  [self.timer invalidate];<br>}</p>
</li>
</ul>
<p>@end</p>
<pre><code>
该接口的实现很简单，就是 **NSTimer** 创建了一个300s执行一次的定时器，但是要注意定时器需要加入`NSRunLoopCommonModes`中。

要使定时器在后台能运行，app 就需要在 [后台常驻](http://waitingyuan.blog.163.com/blog/static/2155781652014111133150534/)。

# 结语

最后总结一下：

NSTimer 使用简单方便，但是应用条件有限。

CADisplayLink 刷新频率与屏幕帧数相同，用于绘制动画。具体使用可看我封装好的一个 [水波纹动画](https://github.com/qiubaiying/WaterRippleView)。

GCD定时器 精度高，可控性强，使用稍复杂。</code></pre>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>忽略 Xcode 8 中的注释警告</title>
    <url>/folder/2016/12/07/2016-12-07-%E5%BF%BD%E7%95%A5-Xcode8-%E4%B8%AD%E7%9A%84%E6%B3%A8%E9%87%8A%E8%AD%A6%E5%91%8A%E2%9A%A0%EF%B8%8F/</url>
    <content><![CDATA[<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>从Xcode8.0开始，引入了文档注释警告，虽然是件好事，可是各种三方库爆出了一大堆警告：</p>
<p><img src="http://ww2.sinaimg.cn/large/7853084cgw1fai8d9fu90j20ko0kpk21.jpg" alt=""></p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><p><code>Bulid Settings</code> -&gt; <code>Documentation Comments</code> -&gt; <strong><code>NO</code></strong></p>
<p><img src="http://ww1.sinaimg.cn/large/7853084cgw1fai8e613e5j20kk03cdga.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>快速添加圆角和描边</title>
    <url>/folder/2016/12/01/2016-12-01-%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E5%9C%86%E8%A7%92%E5%92%8C%E6%8F%8F%E8%BE%B9/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>对于习惯使用Storyboard的人来说，设置圆角、描边是一件比较蛋疼的事，因为苹果没有在xcode的Interface Builder上直接提供修改控件的圆角，边框设置。</p>
<p>我们来说说如何对某个控件进行圆角、描边处理：</p>
<h1 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h1><p>对于一个初学者来说，如果要进行某个控件的圆角、描边设置，就要从Storyboard关联出属性，然后再对属性进行代码处理。</p>
<p>如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.myButton.layer.cornerRadius = 20;</span><br><span class="line">self.myButton.layer.masksToBounds = YES;</span><br><span class="line">self.myButton.layer.borderWidth = 2;</span><br><span class="line">self.myButton.layer.borderColor = [UIColor blackColor].CGColor;</span><br></pre></td></tr></table></figure>
<p>这样不仅需要Storyboard关联出属性，还要写一堆代码对属性进行设置，不得不说实在麻烦~</p>
<h1 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h1><p>更聪明的做法是使用Storyboard提供的Runtime Attributes为控件添加圆角描边。</p>
<p>选中控件，然后在Runtime Attributes框中输入对应的<code>Key</code>与<code>Type</code>与<code>Value</code>,这样程序在运行时就会通过KVC为你的控件属性进行赋值。(不仅仅是圆角、描边~)</p>
<p>如下图</p>
<p><img src="http://ww4.sinaimg.cn/large/7853084cgw1fabg89aeqkj207b08j74y.jpg" alt=""></p>
<p>设置圆角、描边的Key为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layer.borderWidth</span><br><span class="line">layer.borderColorFromUIColor</span><br><span class="line">layer.cornerRadius</span><br><span class="line">clipsToBounds</span><br></pre></td></tr></table></figure>
<p>我这次在测试时，</p>
<p>这样做不用关联出属性，但是需要输入大串字符串，也是不够方便。</p>
<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1><p>创建UIView的分类，使用<code>IBInspectable</code>+ <code>IB_DESIGNABLE</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">IB_DESIGNABLE</span><br><span class="line"></span><br><span class="line">@interface UIView (Inspectable)</span><br><span class="line"></span><br><span class="line">@property(nonatomic,assign) IBInspectable CGFloat cornerRadius;</span><br><span class="line">@property(nonatomic,assign) IBInspectable CGFloat borderWidth;</span><br><span class="line">@property(nonatomic,assign) IBInspectable UIColor *borderColor;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;UIView+Inspectable.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation UIView (Inspectable)</span><br><span class="line"></span><br><span class="line">-(void)setCornerRadius:(CGFloat)cornerRadius&#123;</span><br><span class="line">    self.layer.masksToBounds = YES;</span><br><span class="line">    self.layer.cornerRadius = cornerRadius;</span><br><span class="line">&#125;</span><br><span class="line">-(void)setBorderColor:(UIColor *)borderColor&#123;</span><br><span class="line">    self.layer.borderColor = borderColor.CGColor;</span><br><span class="line">&#125;</span><br><span class="line">-(void)setBorderWidth:(CGFloat)borderWidth&#123;</span><br><span class="line">    self.layer.borderWidth = borderWidth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (CGFloat)cornerRadius&#123;</span><br><span class="line">    return self.layer.cornerRadius;</span><br><span class="line">&#125;</span><br><span class="line">- (CGFloat)borderWidth&#123;</span><br><span class="line">    return self.layer.borderWidth;</span><br><span class="line">&#125;</span><br><span class="line">- (UIColor *)borderColor&#123;</span><br><span class="line">    return [UIColor colorWithCGColor:self.layer.borderColor];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>附上：<a href="https://github.com/qiubaiying/CircularAndStroke.git" target="_blank" rel="noopener">GitHub地址</a></p>
<h4 id="直接使用"><a href="#直接使用" class="headerlink" title="直接使用"></a>直接使用</h4><p>直接将这两个文件拖入项目中即可使用，在右边栏将会显示圆角和描边的属性设置</p>
<p>如图：</p>
<p><img src="http://ww4.sinaimg.cn/large/7853084cgw1facfqugjtbj20mp07v401.jpg" alt=""></p>
<h4 id="动态显示设置效果"><a href="#动态显示设置效果" class="headerlink" title="动态显示设置效果"></a>动态显示设置效果</h4><p>直接使用的话只有在运行时才能看到效果，</p>
<p>例如要实时显示一个<code>UIBUtton</code>圆角、描边效果，需要创建一个类继承<code>UIButton</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;UIView+Inspectable.h&quot;</span><br><span class="line"></span><br><span class="line">@interface myButton : UIButton</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;myButton.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation myButton</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p>只要将button的Class选择该空白类即可</p>
<p>关于<code>IBInspectable</code>与<code>IB_DESIGNABLE</code>的使用详情可以参考这篇文章<a href="http://www.jianshu.com/p/a90e44ba1f2b" target="_blank" rel="noopener">《谈不完美的IBDesignable/IBInspectable可视化效果编程》</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Objective-C：RunLoop</title>
    <url>/folder/2016/11/28/2016-11-28-Objective-C-RunLoop/</url>
    <content><![CDATA[<h1 id="深入理解RunLoop"><a href="#深入理解RunLoop" class="headerlink" title="深入理解RunLoop"></a>深入理解RunLoop</h1><blockquote>
<p>本文转自：<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">《深入理解RunLoop》</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。之后会介绍一下在 iOS 中，苹果是如何利用 RunLoop 实现自动释放池、延迟回调、触摸事件、屏幕刷新等功能的。</p>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>RunLoop 的概念</li>
<li>RunLoop 与线程的关系</li>
<li>RunLoop 对外的接口</li>
<li>RunLoop 的 Mode</li>
<li>RunLoop 的内部逻辑</li>
<li>RunLoop 的底层实现</li>
<li>苹果用 RunLoop 实现的功能<ul>
<li>AutoreleasePool</li>
<li>事件响应</li>
<li>手势识别</li>
<li>界面更新</li>
<li>定时器</li>
<li>PerformSelecter</li>
<li>关于GCD</li>
<li>关于网络请求</li>
</ul>
</li>
<li>RunLoop 的实际应用举例<ul>
<li>AFNetworking</li>
<li>AsyncDisplayKit</li>
</ul>
</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    do &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; while (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种模型通常被称作 <a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event Loop</a>。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。</p>
<p>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</p>
<p>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>CFRunLoopRef 的代码是<a href="https://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="noopener">开源</a>的，你可以在<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">这里</a>下载到整个 CoreFoundation 的源码来查看。</p>
<p>(Update: Swift 开源后，苹果又维护了一个跨平台的 CoreFoundation 版本：<a href="https://github.com/apple/swift-corelibs-foundation/" target="_blank" rel="noopener">https://github.com/apple/swift-corelibs-foundation/</a>，这个版本的源码可能和现有 iOS 系统中的实现略不一样，但更容易编译，而且已经适配了 Linux/Windows。) </p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份<a href="http://www.fenestrated.net/~macman/mirrors/Apple%20Technotes%20(As%20of%202002)/tn/tn2028.html" target="_blank" rel="noopener">文档</a>标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 <code>pthread_main_thread_np()</code> 或 <code>[NSThread mainThread]</code> 来获取主线程；也可以通过 <code>pthread_self()</code> 或 <code>[NSThread currentThread]</code> 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span><br><span class="line">static CFMutableDictionaryRef loopsDic;</span><br><span class="line">/// 访问 loopsDic 时的锁</span><br><span class="line">static CFSpinLock_t loopsLock;</span><br><span class="line"> </span><br><span class="line">/// 获取一个 pthread 对应的 RunLoop。</span><br><span class="line">CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line">    </span><br><span class="line">    if (!loopsDic) &#123;</span><br><span class="line">        // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span><br><span class="line">        loopsDic = CFDictionaryCreateMutable();</span><br><span class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 直接从 Dictionary 里获取。</span><br><span class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</span><br><span class="line">    </span><br><span class="line">    if (!loop) &#123;</span><br><span class="line">        /// 取不到时，创建一个</span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        CFDictionarySetValue(loopsDic, thread, loop);</span><br><span class="line">        /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    return loop;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetMain() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">CFRunLoopRef CFRunLoopGetCurrent() &#123;</span><br><span class="line">    return _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="RunLoop 有5个类的关系"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef</strong> 是事件产生的地方。Source 有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 <code>CFRunLoopSourceSignal(source)</code>，将这个 Source 标记为待处理，然后手动调用 <code>CFRunLoopWakeUp(runloop)</code> 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong> 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</span><br><span class="line">    kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</span><br><span class="line">    kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</span><br><span class="line">    kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</span><br><span class="line">    kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</span><br><span class="line">    kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环</p>
<h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __CFRunLoopMode &#123;</span><br><span class="line">    CFStringRef _name;            // Mode Name, 例如 @&quot;kCFRunLoopDefaultMode&quot;</span><br><span class="line">    CFMutableSetRef _sources0;    // Set</span><br><span class="line">    CFMutableSetRef _sources1;    // Set</span><br><span class="line">    CFMutableArrayRef _observers; // Array</span><br><span class="line">    CFMutableArrayRef _timers;    // Array</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">struct __CFRunLoop &#123;</span><br><span class="line">    CFMutableSetRef _commonModes;     // Set</span><br><span class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</span><br><span class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</span><br><span class="line">    CFMutableSetRef _modes;           // Set</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</span><br><span class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</span><br></pre></td></tr></table></figure>

<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br><span class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</span><br><span class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</span><br></pre></td></tr></table></figure>

<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode <code>只能增加不能删除</code>。</p>
<p>苹果公开提供的 Mode 有两个：<code>kCFRunLoopDefaultMode (NSDefaultRunLoopMode)</code> 和 <code>UITrackingRunLoopMode</code>，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：<code>kCFRunLoopCommonModes (NSRunLoopCommonModes)</code>，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<p>RunLoop 的内部逻辑</p>
<p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt=""></p>
<p>其内部代码整理如下 （太长了不想看可以直接跳过去，后面会有说明）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 用DefaultMode启动</span><br><span class="line">void CFRunLoopRun(void) &#123;</span><br><span class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/// 用指定的Mode启动，允许设置RunLoop超时时间</span><br><span class="line">int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/// RunLoop的实现</span><br><span class="line">int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line">    </span><br><span class="line">    /// 首先根据modeName找到对应mode</span><br><span class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false);</span><br><span class="line">    /// 如果mode里没有source/timer/observer, 直接返回。</span><br><span class="line">    if (__CFRunLoopModeIsEmpty(currentMode)) return;</span><br><span class="line">    </span><br><span class="line">    /// 1. 通知 Observers: RunLoop 即将进入 loop。</span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">    </span><br><span class="line">    /// 内部函数，进入loop</span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">        </span><br><span class="line">        Boolean sourceHandledThisLoop = NO;</span><br><span class="line">        int retVal = 0;</span><br><span class="line">        do &#123;</span><br><span class="line"> </span><br><span class="line">            /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line">            /// 4. RunLoop 触发 Source0 (非port) 回调。</span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            /// 执行被加入的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">            /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span><br><span class="line">            if (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                if (hasMsg) goto handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span><br><span class="line">            if (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span><br><span class="line">            /// • 一个基于 port 的Source 的事件。</span><br><span class="line">            /// • 一个 Timer 到时间了</span><br><span class="line">            /// • RunLoop 自身的超时时间到了</span><br><span class="line">            /// • 被其他什么调用者手动唤醒</span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line">            </span><br><span class="line">            /// 收到消息，处理消息。</span><br><span class="line">            handle_msg:</span><br><span class="line"> </span><br><span class="line">            /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span><br><span class="line">            if (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            /// 9.2 如果有dispatch到main_queue的block，执行block。</span><br><span class="line">            else if (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125; </span><br><span class="line"> </span><br><span class="line">            /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span><br><span class="line">            else &#123;</span><br><span class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                if (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 执行加入到Loop的block</span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line">            </span><br><span class="line"> </span><br><span class="line">            if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                /// 进入loop时参数说处理完事件就返回。</span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; else if (timeout) &#123;</span><br><span class="line">                /// 超出传入参数标记的超时时间了</span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; else if (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                /// 被外部调用者强制停止了</span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                /// source/timer/observer一个都没有了</span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            /// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span><br><span class="line">        &#125; while (retVal == 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 10. 通知 Observers: RunLoop 即将退出。</span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 <code>CFRunLoopRun()</code> 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 <code>mach_msg()</code>。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。</p>
<p><img src="http://ww4.sinaimg.cn/large/7853084cjw1fa7xzae9dlj206203nwel.jpg" alt=""></p>
<p>苹果官方将整个系统大致划分为上述4个层次：</p>
<p>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。</p>
<p>应用框架层即开发人员接触到的 Cocoa 等框架。</p>
<p>核心框架层包括各种核心框架、OpenGL 等内容。</p>
<p>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 <a href="https://opensource.apple.com/" target="_blank" rel="noopener">opensource.apple.com</a> 里找到。</p>
<p>我们在深入看一下 Darwin 这个核心的架构：</p>
<p><img src="http://ww4.sinaimg.cn/large/7853084cjw1fa7xzt0n5wj2070060wel.jpg" alt=""></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 <code>IPC (进程间通信)</code> 的核心。</p>
<p>Mach 的消息定义是在 <code>&lt;mach/message.h&gt;</code> 头文件的，很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  mach_msg_header_t header;</span><br><span class="line">  mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line"> </span><br><span class="line">typedef struct &#123;</span><br><span class="line">  mach_msg_bits_t msgh_bits;</span><br><span class="line">  mach_msg_size_t msgh_size;</span><br><span class="line">  mach_port_t msgh_remote_port;</span><br><span class="line">  mach_port_t msgh_local_port;</span><br><span class="line">  mach_port_name_t msgh_voucher_port;</span><br><span class="line">  mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure>

<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 <code>local_port</code> 和目标端口 <code>remote_port</code>，</p>
<p>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">			mach_msg_header_t *msg,</span><br><span class="line">			mach_msg_option_t option,</span><br><span class="line">			mach_msg_size_t send_size,</span><br><span class="line">			mach_msg_size_t rcv_size,</span><br><span class="line">			mach_port_name_t rcv_name,</span><br><span class="line">			mach_msg_timeout_t timeout,</span><br><span class="line">			mach_port_name_t notify);</span><br></pre></td></tr></table></figure>

<p>为了实现消息的发送和接收，<code>mach_msg()</code> 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数 <code>mach_msg_trap()</code>，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 <code>mach_msg_trap()</code> 时会触发陷阱机制，切换到内核态；内核态中内核实现的 <code>mach_msg()</code> 函数会完成实际的工作，如下图：</p>
<p><img src="http://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_5.png" alt=""></p>
<p>这些概念可以参考维基百科: <a href="http://en.wikipedia.org/wiki/System_call" target="_blank" rel="noopener">System_call</a>、<a href="http://en.wikipedia.org/wiki/Trap_(computing)" target="_blank" rel="noopener">Trap_(computing)</a>。</p>
<p>RunLoop 的核心就是一个 <code>mach_msg()</code> (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 <code>mach_msg_trap()</code> 这个地方。</p>
<p>关于具体的如何利用 mach port 发送信息，可以看看 <a href="http://nshipster.com/inter-process-communication/" target="_blank" rel="noopener">NSHipster 这一篇文章</a>，或者<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="noopener">这里</a>的中文翻译 。</p>
<p>关于Mach的历史可以看看这篇很有趣的文章：<a href="http://www.programmer.com.cn/8121/" target="_blank" rel="noopener">Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian</a>。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">    current mode = kCFRunLoopDefaultMode</span><br><span class="line">    common modes = &#123;</span><br><span class="line">        UITrackingRunLoopMode</span><br><span class="line">        kCFRunLoopDefaultMode</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    common mode items = &#123;</span><br><span class="line"> </span><br><span class="line">        // source0 (manual)</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        // source1 (mach port)</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 17923&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 12039&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0,  &#123;port = 16647&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order =-1, &#123;</span><br><span class="line">            callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 2407,</span><br><span class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1c03,</span><br><span class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 0, &#123;port = 1b03,</span><br><span class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">        CFRunLoopSource &#123;order = 1, &#123;port = 1903,</span><br><span class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">        // Ovserver</span><br><span class="line">        CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 0, activities = 0x20,          // BeforeWaiting</span><br><span class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 1999000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _afterCACommitHandler&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2000000, activities = 0xa0,    // BeforeWaiting | Exit</span><br><span class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">        CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit</span><br><span class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">        // Timer</span><br><span class="line">        CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0,</span><br><span class="line">            next fire date = 453098071 (-4421.76019 @ 96223387169499),</span><br><span class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    modes ＝ &#123;</span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            sources1 =  &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            observers = &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">            timers =    &#123; /* same as &apos;common mode items&apos; */ &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = 0, &#123;</span><br><span class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = &#123;</span><br><span class="line">                CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000,</span><br><span class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">            )&#125;,</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line"> </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            sources1 = &#123;</span><br><span class="line">                CFRunLoopSource &#123;order = -1, &#123;</span><br><span class="line">                    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        CFRunLoopMode  &#123;</span><br><span class="line">            sources0 = (null),</span><br><span class="line">            sources1 = (null),</span><br><span class="line">            observers = (null),</span><br><span class="line">            timers = (null),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，系统默认注册了5个Mode:</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p>你可以在<a href="http://iphonedevwiki.net/index.php/CFRunLoop" target="_blank" rel="noopener">这里</a>看到更多的苹果内部的 Mode，但那些 Mode 在开发中就很难遇到了。</p>
<p>当 RunLoop 进行回调时，一般都是通过一个很长的函数调用出去 (call out), 当你在你的代码中下断点调试时，通常能在调用栈上看到这些函数。下面是这几个函数的整理版本，如果你在调用栈中看到这些长函数名，在这里查找一下就能定位到具体的调用地点了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    /// 1. 通知Observers，即将进入RunLoop</span><br><span class="line">    /// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopEntry);</span><br><span class="line">    do &#123;</span><br><span class="line"> </span><br><span class="line">        /// 2. 通知 Observers: 即将触发 Timer 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeTimers);</span><br><span class="line">        /// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeSources);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 4. 触发 Source0 (非基于port的) 回调。</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(source0);</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);</span><br><span class="line"> </span><br><span class="line">        /// 6. 通知Observers，即将进入休眠</span><br><span class="line">        /// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopBeforeWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 7. sleep to wait msg.</span><br><span class="line">        mach_msg() -&gt; mach_msg_trap();</span><br><span class="line">        </span><br><span class="line"> </span><br><span class="line">        /// 8. 通知Observers，线程被唤醒</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopAfterWaiting);</span><br><span class="line"> </span><br><span class="line">        /// 9. 如果是被Timer唤醒的，回调Timer</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(timer);</span><br><span class="line"> </span><br><span class="line">        /// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(dispatched_block);</span><br><span class="line"> </span><br><span class="line">        /// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br><span class="line">        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(source1);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &#125; while (...);</span><br><span class="line"> </span><br><span class="line">    /// 10. 通知Observers，即将退出RunLoop</span><br><span class="line">    /// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br><span class="line">    __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h4><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 <code>_wrapRunLoopWithAutoreleasePoolHandler()</code>。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 <code>_objc_autoreleasePoolPush()</code> 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用<code>_objc_autoreleasePoolPop()</code> 和 <code>_objc_autoreleasePoolPush()</code> 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 <code>_objc_autoreleasePoolPop()</code> 来释放自动释放池。这个 Observer 的 order 是 2147483647（<code>2^31-1</code><br>），优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h4 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h4><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code>。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="noopener">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 <code>_UIApplicationHandleEventQueue()</code> 进行应用内部的分发。</p>
<p><code>_UIApplicationHandleEventQueue()</code> 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h4 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h4><p>当上面的 <code>_UIApplicationHandleEventQueue()</code> 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h4 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h4><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView/CALayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p><strong>NSTimer</strong> 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p><strong>CADisplayLink</strong> 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h4 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h4><p>当调用 NSObject 的 <code>performSelecter:afterDelay:</code> 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 <code>performSelector:onThread:</code> 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h4 id="关于GCD"><a href="#关于GCD" class="headerlink" title="关于GCD"></a>关于GCD</h4><p>实际上 RunLoop 底层也会用到 GCD 的东西，<del>比如 RunLoop 是用 dispatch_source_t 实现的 Timer</del>（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p>
<p>当调用 <code>dispatch_async(dispatch_get_main_queue(), block)</code> 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <code>__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</code> 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p>
<h4 id="关于网络请求"><a href="#关于网络请求" class="headerlink" title="关于网络请求"></a>关于网络请求</h4><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure>

<ul>
<li>CFSocket 是最底层的接口，只负责 socket 通信。</li>
<li>CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。</li>
<li>NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。</li>
<li>NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 <code>com.apple.NSURLConnectionLoader</code> 线程)，AFNetworking2 和 Alamofire 工作于这一层。</li>
</ul>
<p>下面主要介绍下 NSURLConnection 的工作过程。</p>
<p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 <code>[connection start]</code> 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p>
<p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p>
<p><img src="http://ww3.sinaimg.cn/large/7853084cjw1fa7xj3vs8ij20hs0cdt9m.jpg" alt=""></p>
<p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p>
<h2 id="RunLoop-的实际应用举例"><a href="#RunLoop-的实际应用举例" class="headerlink" title="RunLoop 的实际应用举例"></a>RunLoop 的实际应用举例</h2><h4 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h4><p><a href="https://github.com/AFNetworking/AFNetworking" target="_blank" rel="noopener">AFURLConnectionOperation</a> 这个类是基于 NSURLConnection 构建的，其希望能在后台线程接收 Delegate 回调。为此 AFNetworking 单独创建了一个线程，并在这个线程中启动了一个 RunLoop：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        [[NSThread currentThread] setName:@&quot;AFNetworking&quot;];</span><br><span class="line">        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">+ (NSThread *)networkRequestThread &#123;</span><br><span class="line">    static NSThread *_networkRequestThread = nil;</span><br><span class="line">    static dispatch_once_t oncePredicate;</span><br><span class="line">    dispatch_once(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    return _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RunLoop 启动前内部必须要有至少一个 Timer/Observer/Source，所以 AFNetworking 在 [runLoop run] 之前先创建了一个新的 NSMachPort 添加进去了。通常情况下，调用者需要持有这个 NSMachPort (mach_port) 并在外部线程通过这个 port 发送消息到 loop 内；但此处添加 port 只是为了让 RunLoop 不至于退出，并没有用于实际的发送消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)start &#123;</span><br><span class="line">    [self.lock lock];</span><br><span class="line">    if ([self isCancelled]) &#123;</span><br><span class="line">        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125; else if ([self isReady]) &#123;</span><br><span class="line">        self.state = AFOperationExecutingState;</span><br><span class="line">        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    [self.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要这个后台线程执行任务时，AFNetworking 通过调用 [NSObject performSelector:onThread:..] 将这个任务扔到了后台线程的 RunLoop 中。</p>
<h4 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h4><p><a href="https://github.com/facebook/AsyncDisplayKit" target="_blank" rel="noopener">AsyncDisplayKit</a> 是 Facebook 推出的用于保持界面流畅性的框架，其原理大致如下：</p>
<p>UI 线程中一旦出现繁重的任务就会导致界面卡顿，这类任务通常分为3类：排版，绘制，UI对象操作。</p>
<p>排版通常包括计算视图大小、计算文本高度、重新计算子式图的排版等操作。</p>
<p>绘制一般有文本绘制 (例如 CoreText)、图片绘制 (例如预先解压)、元素绘制 (Quartz)等操作。</p>
<p>UI对象操作通常包括 UIView/CALayer 等 UI 对象的创建、设置属性和销毁。</p>
<p>其中前两类操作可以通过各种方法扔到后台线程执行，而最后一类操作只能在主线程完成，并且有时后面的操作需要依赖前面操作的结果 （例如TextView创建时可能需要提前计算出文本的大小）。ASDK 所做的，就是尽量将能放入后台的任务放入后台，不能的则尽量推迟 (例如视图的创建、属性的调整)。</p>
<p>为此，ASDK 创建了一个名为 ASDisplayNode 的对象，并在内部封装了 UIView/CALayer，它具有和 UIView/CALayer 相似的属性，例如 frame、backgroundColor等。所有这些属性都可以在后台线程更改，开发者可以只通过 Node 来操作其内部的 UIView/CALayer，这样就可以将排版和绘制放入了后台线程。但是无论怎么操作，这些属性总需要在某个时刻同步到主线程的 UIView/CALayer 去。</p>
<p>ASDK 仿照 QuartzCore/UIKit 框架的模式，实现了一套类似的界面更新的机制：即在主线程的 RunLoop 中添加一个 Observer，监听了 kCFRunLoopBeforeWaiting 和 kCFRunLoopExit 事件，在收到回调时，遍历所有之前放入队列的待处理的任务，然后一一执行。<br>具体的代码可以看这里<a href="https://github.com/facebook/AsyncDisplayKit/blob/master/AsyncDisplayKit%2FDetails%2FTransactions%2F_ASAsyncTransactionGroup.m" target="_blank" rel="noopener">_ASAsyncTransactionGroup</a>。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>RunLoop</tag>
        <tag>Obj-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS噪音计</title>
    <url>/folder/2016/11/15/2016-11-15-iOS%E5%99%AA%E9%9F%B3%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在办公室觉得有点吵，然后忽然想做一个噪音计测试一下噪音，在App Store下载了几款测噪音软件，使用原来都大同小异。于是决定自己实现测噪音的原理。</p>
<h2 id="分贝dB"><a href="#分贝dB" class="headerlink" title="分贝dB"></a>分贝dB</h2><p>首先要测量噪音，必须知道噪音的大小的参考的单位为分贝（dB），分贝的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SPL = 20lg[p(e)/p(ref)]</span><br></pre></td></tr></table></figure>
<p><code>p(e)</code>为待测的有效声压，<code>p(ref)</code>为参考声压，一般取2*10E-5帕，这是人耳能分辨的最小声压（1KHz）。</p>
<p>就是说噪音每增加20dB，声压增强了10倍。</p>
<h2 id="iOS测噪音原理"><a href="#iOS测噪音原理" class="headerlink" title="iOS测噪音原理"></a>iOS测噪音原理</h2><p>iOS设备测量噪音原理非常简单：调用系统麦克风，根据麦克风输入强度计算转化为对应的dB值。但是，实现的过程可是坑满满。</p>
<p>找到了一篇博客介绍iOS硬件的调用:<a href="http://www.cnblogs.com/kenshincui/p/4186022.html" target="_blank" rel="noopener">iOS开发系列–音频播放、录音、视频播放、拍照、视频录制</a></p>
<p>iOS的<code>AVFoundation</code>框架中有一个<code>AVAudioRecorder</code>类专门处理录音操作，详见<a href="https://developer.apple.com/reference/avfoundation/1668872-av_foundation_audio_settings_con" target="_blank" rel="noopener">Apple文档</a></p>
<p>在<code>AVAudioRecorder.h</code>中找到下列方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)updateMeters; /* call to refresh meter values */ 更新麦克风测量值</span><br><span class="line">- (float)peakPowerForChannel:(NSUInteger)channelNumber; /* returns peak power in decibels for a given channel */ 获取峰值</span><br><span class="line">- (float)averagePowerForChannel:(NSUInteger)channelNumber; /* returns average power in decibels for a given channel */ 获取平局值</span><br></pre></td></tr></table></figure>

<p><code>- (float)averagePowerForChannel:(NSUInteger)channelNumber;</code>文档中描述：</p>
<blockquote>
<p>Return Value</p>
</blockquote>
<blockquote>
<p>The current average power, in decibels, for the sound being recorded. A return value of 0 dB indicates full scale, or maximum power; a return value of -160 dB indicates minimum power (that is, near silence).</p>
</blockquote>
<blockquote>
<p>If the signal provided to the audio recorder exceeds ±full scale, then the return value may exceed 0 (that is, it may enter the positive range).</p>
</blockquote>
<blockquote>
<p>Discussion</p>
</blockquote>
<blockquote>
<p>To obtain a current average power value, you must call the updateMeters method before calling this method.</p>
</blockquote>
<p>也就是说获取的麦克风测量值返回值范围为 <code>-160dB ~ 0dB</code>,并且注意最后那句话返回值可能超过0。</p>
<h2 id="转化公式"><a href="#转化公式" class="headerlink" title="转化公式"></a>转化公式</h2><p>获取的的测量值为 <code>-160 ~ 0dB</code> ，如何转化为我们所要的噪音值呢？在网上找了很多资料都没有结果，于是就自己摸索转化公式。</p>
<p>刚开始想到的是利用分贝计算公式<code>SPL = 20lg[p(e)/p(ref)]</code>进行计算，后来直接放弃这个方案，因为这是一个对数运算，获取到的值非常稳定，几乎不会波动，与其他的测噪软件所得的分贝值出入太大。</p>
<p>然后发现有个App在麦克风没有输入时显示-55dB</p>
<p><img src="http://ww2.sinaimg.cn/large/7853084cgw1f9u0nu3xv3j205n0a0glq.jpg" alt=""></p>
<p>于是思路就有了。</p>
<p>其他测噪音软件的量程均为<code>0~110dB</code>,而我们获取的的测量值为 <code>-160 ~ 0dB</code>，两者之间差了<code>50dB</code>，也就是说以麦克风的测量值的<code>-160dB+50dB = -110dB</code>作为起点，<code>0dB</code>作为Max值,恰好量程为<code>0~110dB</code>.</p>
<p>问题看似结束，但是直接以<code>50dB</code>作为补偿测量结果会偏大。最后选择了分段进行处理，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-(void)audioPowerChange&#123;</span><br><span class="line">    </span><br><span class="line">    [self.audioRecorder updateMeters];//更新测量值</span><br><span class="line">    float power = [self.audioRecorder averagePowerForChannel:0];// 均值</span><br><span class="line">    float powerMax = [self.audioRecorder peakPowerForChannel:0];// 峰值</span><br><span class="line">    NSLog(@&quot;power = %f, powerMax = %f&quot;,power, powerMax);</span><br><span class="line">    </span><br><span class="line">    CGFloat progress = (1.0 / 160.0) * (power + 160.0);</span><br><span class="line">    </span><br><span class="line">    // 关键代码</span><br><span class="line">    power = power + 160  - 50;</span><br><span class="line">    </span><br><span class="line">    int dB = 0;</span><br><span class="line">    if (power &lt; 0.f) &#123;</span><br><span class="line">        dB = 0;</span><br><span class="line">    &#125; else if (power &lt; 40.f) &#123;</span><br><span class="line">        dB = (int)(power * 0.875);</span><br><span class="line">    &#125; else if (power &lt; 100.f) &#123;</span><br><span class="line">        dB = (int)(power - 15);</span><br><span class="line">    &#125; else if (power &lt; 110.f) &#123;</span><br><span class="line">        dB = (int)(power * 2.5 - 165);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        dB = 110;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;progress = %f, dB = %d&quot;, progress, dB);</span><br><span class="line">    self.powerLabel.text = [NSString stringWithFormat:@&quot;%ddB&quot;, dB];</span><br><span class="line">    [self.audioPowerProgress setProgress:progress];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>效果如下：</p>
<p><img src="http://ww4.sinaimg.cn/large/7853084cgw1f9u1gqgqieg20k00zk7d8.gif" alt=""></p>
<h1 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h1><p>Demo下载地址：<a href="https://github.com/qiubaiying/Noise-meter-Demo" target="_blank" rel="noopener">Noise-meter-Demo</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Demo</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON转模型 For YYModel</title>
    <url>/folder/2016/10/26/2016-10-26-JSON-%E8%BD%AC%E6%A8%A1%E5%9E%8B-For-YYModel/</url>
    <content><![CDATA[<blockquote>
<p>JSON转模型是我们做iOS开发的基础技能，本文将通过<a href="https://github.com/ibireme/YYModel" target="_blank" rel="noopener">YYModel</a>这个框架安全快速的完成JSON到模型的转换，其中还会介绍到一款好用的插件<a href="https://github.com/EnjoySR/ESJsonFormat-Xcode" target="_blank" rel="noopener">ESJsonFormat</a>。</p>
</blockquote>
<h1 id="1、首先创建模型类"><a href="#1、首先创建模型类" class="headerlink" title="1、首先创建模型类"></a>1、首先创建模型类</h1><p>创建模型类我们可以通过<a href="https://github.com/EnjoySR/ESJsonFormat-Xcode" target="_blank" rel="noopener">ESJsonFormat</a>这款插件快速完成。</p>
<p>使用方法：</p>
<p>将光标移动到代码行中 如下图的13行</p>
<p>然后点击<code>Window</code>-&gt;<code>ESJsonFormat</code>-&gt;<code>Input JSON Window</code>调出窗口</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1f95tr49ed7j30no0csdir.jpg" alt=""></p>
<p>在窗口中输入你要解析的JSON文本，如下图：</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1f97s13l4b9j30jv0e8dhp.jpg" alt=""></p>
<p>按<code>Enter</code>继续，然后神奇的一幕发生了</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVagw1f97s46k95tj30k30dydj9.jpg" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1f97s6yp9hmj30iw0b840m.jpg" alt=""></p>
<p>看到在.h中 所有的属性自动为你填上，而且帮你选好了类型</p>
<p>.m 也为你声明了<code>list</code>中成员的类型，不过这里需要稍作修改，因为我们需要用到YYModel进行解析，所以方法名改成<code>modelContainerPropertyGenericClass</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSDictionary *)modelContainerPropertyGenericClass &#123;</span><br><span class="line">    return @&#123;@&quot;list&quot; : [List class]&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有问题就是属性中出现关键字<code>id</code>，我们需要将id改为<code>teacherId</code></p>
<p>然后在.m的<code>implementation</code>中声明,将字典的的<code>id</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (NSDictionary *)modelCustomPropertyMapper &#123;</span><br><span class="line">    return @&#123;@&quot;teacherId&quot; : @&quot;id&quot;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，模型的创建就完成了，剩下的就是用YYModel进行解析了</p>
<h1 id="2、使用YYModel进行解析"><a href="#2、使用YYModel进行解析" class="headerlink" title="2、使用YYModel进行解析"></a>2、使用YYModel进行解析</h1><p>解析很简单，就只需要一句话</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:</span><br><span class="line">Model *model = [Model yy_modelWithJSON:json];</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">Model *model = [[Model alloc] init];</span><br><span class="line">[model yy_modelSetWithDictionary:json];</span><br></pre></td></tr></table></figure>

<p>到此，简便快速的完成了JSON到模型的转换。</p>
<p>最后，<a href="http://www.jianshu.com/p/25e678fa43d3" target="_blank" rel="noopener">这里附上一篇YYModel的使用</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode Debug 大全</title>
    <url>/folder/2016/10/18/2016-10-18-Xcode-Debug-%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>BUG,简单来说就是程序运行结果与预期的不同，下面来说说Xcode中的DEBUG方法</p>
<p><a href="http://www.cnblogs.com/daiweilai/p/4421340.html#quanjuduandian" target="_blank" rel="noopener">参考博文</a></p>
</blockquote>
<h1 id="断点调试"><a href="#断点调试" class="headerlink" title="断点调试"></a>断点调试</h1><ul>
<li>普通断点</li>
<li>全局断点</li>
<li>条件断点</li>
</ul>
<h4 id="1-普通断点"><a href="#1-普通断点" class="headerlink" title="1.普通断点"></a>1.普通断点</h4><p>看图</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f8rti38wlxj20ke0d3n0h.jpg" alt=""></p>
<p>当程序运行到断点处时会停下，然后进行单步调试<br><img src="http://images.cnitblog.com/blog2015/680363/201504/131002381048966.png" alt=""></p>
<h4 id="2-全局断点"><a href="#2-全局断点" class="headerlink" title="2.全局断点"></a>2.全局断点</h4><p>当程序运行出现崩溃时，就会自动断点到出现crash的代码行</p>
<p><img src="http://images.cnitblog.com/blog2015/680363/201504/130933043392329.png" alt=""></p>
<h4 id="3-条件断点"><a href="#3-条件断点" class="headerlink" title="3.条件断点"></a>3.条件断点</h4><p>我们如果在一个循环里面使用了断点，如果这个循环执行了100万次，那你的断点要执行那么多次，你不觉得蛋蛋都凉了的忧伤么？所以我们这么做：</p>
<p>编辑断点</p>
<p><img src="http://ww1.sinaimg.cn/large/65e4f1e6gw1f8rw64yys0j207i03laah.jpg" alt=""></p>
<p>添加条件Condition</p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f8rw52q1tjj20ct04lmxo.jpg" alt=""></p>
<p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f8rw44p4ykj20ln0g10vg.jpg" alt=""></p>
<p>还可以Action中在条件断点触发时执行事件</p>
<p><img src="http://ww3.sinaimg.cn/large/65e4f1e6gw1f8rwq16872j20cv07amyg.jpg" alt=""></p>
<p>如：输出信息</p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6gw1f8rwms50t3j20dj07bjso.jpg" alt=""></p>
<h4 id="4-方法断点"><a href="#4-方法断点" class="headerlink" title="4.方法断点"></a>4.方法断点</h4><h1 id="打印调试（NSLog）"><a href="#打印调试（NSLog）" class="headerlink" title="打印调试（NSLog）"></a>打印调试（NSLog）</h1><p>尽管ARC已经让内存管理变得简单、省时和高效，但是在object的life-cycles中跟踪一些重要事件依然十分重要。毕竟ARC并没有完全排除内存泄露的可能性，或者试图访问一个被release的对象。</p>
<ul>
<li>NSLog</li>
</ul>
<p>强化NSLog</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//A better version of NSLog</span><br><span class="line">#define NSLog(format, ...) do &#123; \</span><br><span class="line">fprintf(stderr, &quot;&lt;%s : %d&gt; %s\n&quot;, \</span><br><span class="line">[[[NSString stringWithUTF8String:__FILE__] lastPathComponent] UTF8String], \</span><br><span class="line">__LINE__, __func__); \</span><br><span class="line">(NSLog)((format), ##__VA_ARGS__); \</span><br><span class="line">fprintf(stderr, &quot;-------\n&quot;); \</span><br><span class="line">&#125; while (0)</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ViewController.m : 32&gt; -[ViewController viewDidLoad]</span><br><span class="line">2016-10-14 17:33:31.022 DEUBG[12852:1238167] Hello World！</span><br><span class="line">-------</span><br></pre></td></tr></table></figure>

<p>利用NSString输出多种类型</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6gw1f8rxvn6fqlj20nc05cgoh.jpg" alt=""></p>
<ul>
<li>开启僵尸对象</li>
</ul>
<p>Xcode可以把那些已经release掉得对象，变成“僵尸”，当我们访问一个Zombie对象时，Xcode可以告诉我们正在访问的对象是一个不应该存在的对象了。因为Xcode知道这个对象是什么，所以可以让我们知道这个对象在哪里，以及这是什么时候发生的。<br>所以Zombies是你的好基友！他可以让你输出的信息更具体！</p>
<p>具体这样做：(僵尸只能用在模拟器和OC语言)</p>
<p><img src="http://images.cnitblog.com/blog2015/680363/201504/130941016986159.png" alt=""></p>
<h1 id="控制台-lldb-命令"><a href="#控制台-lldb-命令" class="headerlink" title="控制台(lldb 命令)"></a>控制台(lldb 命令)</h1><p>LLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。(这里有一个关于调试器如何工作的总体的解释。)</p>
<p>你以前有可能已经使用过调试器，即使只是在 Xcode 的界面上加一些断点。但是通过一些小的技巧，你就可以做一些非常酷的事情。GDB to LLDB 参考是一个非常好的调试器可用命令的总览。你也可以安装 Chisel，它是一个开源的 LLDB 插件合辑，这会使调试变得更加有趣。</p>
<p>参考：</p>
<p><a href="http://objccn.io/issue-19-2/" target="_blank" rel="noopener">与调试器共舞 - LLDB 的华尔兹</a></p>
<p><a href="http://www.starfelix.com/blog/2014/03/17/lldbdiao-shi-ming-ling-chu-tan/" target="_blank" rel="noopener">LLDB调试命令初探</a></p>
<p><a href="https://developer.apple.com/library/content/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide/document/Introduction.html" target="_blank" rel="noopener">About LLDB and Xcode</a></p>
<p><a href="http://lldb.llvm.org/tutorial.html" target="_blank" rel="noopener">The LLDB Debugger</a></p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h6 id="help"><a href="#help" class="headerlink" title="help"></a><em>help</em></h6><p>在控制台输入<code>help</code>，显示控制台支持的lldb命令</p>
<h6 id="print"><a href="#print" class="headerlink" title="print"></a><em>print</em></h6><p>打印值</p>
<p>缩写<code>p</code> </p>
<p>print是 <code>expression --</code> 的缩写</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1f8vakv88vuj30b204s74x.jpg" alt=""></p>
<p>printk可以指定格式打印<br>如<br><code>默认 p</code></p>
<p><code>十六进制 p/x</code>、</p>
<p><code>二进制 p/t</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) p 16</span><br><span class="line">16</span><br><span class="line"></span><br><span class="line">(lldb) p/x 16</span><br><span class="line">0x10</span><br><span class="line"></span><br><span class="line">(lldb) p/t 16</span><br><span class="line">0b00000000000000000000000000010000</span><br><span class="line"></span><br><span class="line">(lldb) p/t (char)16</span><br><span class="line">0b00010000</span><br></pre></td></tr></table></figure>
<p>你也可以使用 p/c 打印字符，或者 p/s 打印以空终止的字符串  p/d打印ACRSII(译者注：以 ‘\0’ 结尾的字符串)。</p>
<p>完整清单<a href="https://sourceware.org/gdb/onlinedocs/gdb/Output-Formats.html" target="_blank" rel="noopener">点击查看</a></p>
<h6 id="po"><a href="#po" class="headerlink" title="po"></a><em>po</em></h6><p>打印对象，是 <code>e -o --</code>的缩写</p>
<h6 id="expression"><a href="#expression" class="headerlink" title="expression"></a><em>expression</em></h6><h4 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h4><p>当你通过 Xcode 的源码编辑器的侧边槽 (或者通过下面的方法) 插入一个断点，程序到达断点时会就会停止运行。</p>
<p>调试条上会出现四个你可以用来控制程序的执行流程的按钮。</p>
<p><img src="https://objccn.io/images/issues/issue-19/Image_2014-11-22_at_10.37.45_AM.png" alt=""></p>
<p>从左到右，四个按钮分别是：continue，step over，step into，step out。</p>
<p>第一个，continue 按钮，会取消程序的暂停，允许程序正常执行 (要么一直执行下去，要么到达下一个断点)。在 LLDB 中，你可以使用 process continue 命令来达到同样的效果，它的别名为 continue，或者也可以缩写为 c。</p>
<p>第二个，step over 按钮，会以黑盒的方式执行一行代码。如果所在这行代码是一个函数调用，那么就不会跳进这个函数，而是会执行这个函数，然后继续。LLDB 则可以使用 thread step-over，next，或者 n 命令。</p>
<p>如果你确实想跳进一个函数调用来调试或者检查程序的执行情况，那就用第三个按钮，step in，或者在LLDB中使用 thread step in，step，或者 s 命令。注意，当前行不是函数调用时，next 和 step 效果是一样的。</p>
<p>大多数人知道 c，n 和 s，但是其实还有第四个按钮，step out。如果你曾经不小心跳进一个函数，但实际上你想跳过它，常见的反应是重复的运行 n 直到函数返回。其实这种情况，step out 按钮是你的救世主。它会继续执行到下一个返回语句 (直到一个堆栈帧结束) 然后再次停止。</p>
<h6 id="frame-info"><a href="#frame-info" class="headerlink" title="frame info"></a>frame info</h6><p>会告诉你当前的行数和源码文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) frame info</span><br><span class="line">frame #0: 0x000000010a53bcd4 DebuggerDance`main + 68 at main.m:17</span><br></pre></td></tr></table></figure>

<h6 id="Thread-Return"><a href="#Thread-Return" class="headerlink" title="Thread Return"></a>Thread Return</h6><p>调试时，还有一个很棒的函数可以用来控制程序流程：thread return 。它有一个可选参数，在执行时它会把可选参数加载进返回寄存器里，然后立刻执行返回命令，跳出当前栈帧。这意味这函数剩余的部分不会被执行。这会给 ARC 的引用计数造成一些问题，或者会使函数内的清理部分失效。但是在函数的开头执行这个命令，是个非常好的隔离这个函数，伪造返回值的方式 。</p>
<p><code>(lldb) thread return NO</code></p>
<h4 id="不用断点调试"><a href="#不用断点调试" class="headerlink" title="不用断点调试"></a>不用断点调试</h4><p>在程序运行时，点击暂停按钮,即可进入调试状态，能对全局变量做操作</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1f8vd4vy66ej307300xjr8.jpg" alt=""></p>
<h1 id="工具调试-instruments"><a href="#工具调试-instruments" class="headerlink" title="工具调试(instruments)"></a>工具调试(instruments)</h1><p>instruments Xcode自带许多工具供大家使用，打开方式如下图：</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1f8ve05g45cj30qd0f276o.jpg" alt=""></p>
<p><strong>leaks</strong>内存泄漏检查工具</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1f8ve5wnnr6j30li0c1wgd.jpg" alt=""></p>
<p>运行后查看</p>
<p><img src="http://ww4.sinaimg.cn/large/006y8lVagw1f8vebiu6r5j30se0kdqcr.jpg" alt=""></p>
<h1 id="视图调试"><a href="#视图调试" class="headerlink" title="视图调试"></a>视图调试</h1><p>启用视图调试:运行app过程中，按下底部的Debug View Hierarchy 按钮，或者从菜单中选择Debug &gt; View Debugging &gt; Capture View Hierarchy 来启动视图调试。</p>
<p><img src="http://ww1.sinaimg.cn/large/006y8lVagw1f8vejy3rmgj30by01kmx8.jpg" alt=""></p>
<p>启动视图调试后，Xcode会对应用程序的视图层次拍一个快照并展示三维原型视图来探究用户界面的层级。该三维视图除了展示app的视图层次外，还展示每个视图的位置、顺序和视图尺寸，以及视图间的交互方式。</p>
<h1 id="模拟器调试"><a href="#模拟器调试" class="headerlink" title="模拟器调试"></a>模拟器调试</h1><p>编译并运行应用程序，选中模拟器，从 Debug菜单中选择Color Blended Layers选项。</p>
<p><img src="http://ww2.sinaimg.cn/large/006y8lVagw1f8vezdqlh1j3092075dgz.jpg" alt=""></p>
<p>然后会看到app的用户界面被红色和绿色覆盖，显示了哪些图层可以被叠加覆盖，以及哪些图层是透明的。混合层属于计算密集型视图，所以推荐尽可能地使用不透明的图层。</p>
<p><img src="http://ww3.sinaimg.cn/large/006y8lVagw1f8vf07u522j30ag0j1q36.jpg" alt=""></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>目前所知道的调试方法大概就是上面这几种了，若有什么有趣的方法，请和我分享哈！</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发技巧</tag>
        <tag>Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS手势与变形</title>
    <url>/folder/2016/10/10/2016-10-10-iOS-%E6%89%8B%E5%8A%BF%E4%B8%8E%E5%8F%98%E5%BD%A2/</url>
    <content><![CDATA[<blockquote>
<p>手势在用户交互中有着举足轻重的作用，这篇文字简单的介绍了iOS中的手势，并通过手势对控件进行变形处理。</p>
</blockquote>
<h1 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h1><p>iOS手势分为下面这几种：</p>
<ul>
<li>UITapGestureRecognizer（点按）</li>
<li>UIPanGestureRecognizer（拖动）</li>
<li>UIScreenEdgePanGestureRecognizer (边缘拖动)</li>
<li>UIPinchGestureRecognizer（捏合）</li>
<li>UIRotationGestureRecognizer（旋转）</li>
<li>UILongPressGestureRecognizer（长按）</li>
<li>​UISwipeGestureRecognizer（轻扫）</li>
</ul>
<p>这些手势大都继承于<strong>UIGestureRecognizer</strong>类，（<code>UIScreenEdgePanGestureRecognizer</code>继承于<code>UIPanGestureRecognizer</code>类）,</p>
<p>需要说明的是这些手势只有一个是<strong>离散型手势</strong>，那就是<code>UITapGestureRecognizer</code>，一旦识别就无法取消，而且只会调用一次手势操作事件。</p>
<p>换句话说其他手势是<strong>连续型手势</strong>，而连续型手势的特点就是：会多次调用手势操作事件，而且在连续手势识别后可以取消手势。</p>
<p>从下图可以看出两者调用操作事件的次数是不同的：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79gw1fb0neee6mlj30dw0aldgf.jpg" alt=""></p>
<p>这些手势类有着以下共同的方法:</p>
<p>创建方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (instancetype)initWithTarget:(nullable id)target action:(nullable SEL)action;</span><br></pre></td></tr></table></figure>

<p>移除方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)removeTarget:(nullable id)target action:(nullable SEL)action;</span><br></pre></td></tr></table></figure>

<p>添加事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (void)addTarget:(id)target action:(SEL)action;</span><br></pre></td></tr></table></figure>

<p>还有下面这些属性等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property(nonatomic,readonly) UIGestureRecognizerState state;// 手势状态</span><br><span class="line"></span><br><span class="line">typedef NS_ENUM(NSInteger, UIGestureRecognizerState) &#123;</span><br><span class="line">     UIGestureRecognizerStatePossible,   // 尚未识别是何种手势操作（但可能已经触发了触摸事件），默认状态</span><br><span class="line">     UIGestureRecognizerStateBegan,      // 手势已经开始，此时已经被识别，但是这个过程中可能发生变化，手势操作尚未完成</span><br><span class="line">     UIGestureRecognizerStateChanged,    // 手势状态发生转变</span><br><span class="line">     UIGestureRecognizerStateEnded,      // 手势识别操作完成（此时已经松开手指）</span><br><span class="line">     UIGestureRecognizerStateCancelled,  // 手势被取消，恢复到默认状态</span><br><span class="line">     UIGestureRecognizerStateFailed,     // 手势识别失败，恢复到默认状态</span><br><span class="line">     UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded // 手势识别完成，同UIGestureRecognizerStateEnded</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">@property(nullable,nonatomic,weak) id &lt;UIGestureRecognizerDelegate&gt; delegate; // 代理</span><br><span class="line"></span><br><span class="line">@property(nonatomic, getter=isEnabled) BOOL enabled;</span><br></pre></td></tr></table></figure>

<p>当然我们也可以自定义手势来实现特殊的需求，关于自定义手势可以看<a href="http://blog.csdn.net/mmoaay/article/details/47355709" target="_blank" rel="noopener">这篇博客</a>.</p>
<p>接下来我们来看看这些常用手势的用法.</p>
<h4 id="UITapGestureRecognizer（点按）"><a href="#UITapGestureRecognizer（点按）" class="headerlink" title="UITapGestureRecognizer（点按）"></a>UITapGestureRecognizer（点按）</h4><p>Tap手势有两个属性，</p>
<ul>
<li>numberOfTapsRequired</li>
<li>numberOfTouchesRequired：</li>
</ul>
<p><code>numberOfTapsRequired</code>为触发事件需要点击的次数，默认是1；</p>
<p><code>numberOfTouchesRequired</code>为触发事件需要的几个手指点按，默认是1；</p>
<p>若都设置为2，就需要<code>两个</code>手指同时点按<code>2次</code>才会触发事件。</p>
<p>Tap手势也是我们最常用的手势之一, 比如点击ImageView跳转到其他界面，或者双击图片放大缩小等。</p>
<p>创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tap:)];</span><br><span class="line">   tap.numberOfTapsRequired = 2;</span><br><span class="line">   tap.numberOfTouchesRequired = 1;</span><br><span class="line">   [self.imageView addGestureRecognizer:tap];</span><br></pre></td></tr></table></figure>

<h4 id="UIPanGestureRecognizer（拖动）"><a href="#UIPanGestureRecognizer（拖动）" class="headerlink" title="UIPanGestureRecognizer（拖动）"></a>UIPanGestureRecognizer（拖动）</h4><p>Pan手势的属性和方法：</p>
<ul>
<li>@property (nonatomic)          NSUInteger minimumNumberOfTouches __TVOS_PROHIBITED;</li>
<li>@property (nonatomic)          NSUInteger minimumNumberOfTouches __TVOS_PROHIBITED;</li>
<li>-(CGPoint)translationInView:(nullable UIView *)view;</li>
<li>-(void)setTranslation:(CGPoint)translation inView:(nullable UIView *)view;</li>
<li>-(CGPoint)velocityInView:(nullable UIView *)view; </li>
</ul>
<p><code>translationInView:</code>方法获取<code>View</code>的偏移量；</p>
<p><code>setTranslation:</code>方法设置手势的偏移量；</p>
<p><code>velocityInView:</code>方法获取速度；</p>
<p>所以手势的创建方法都类似，这里就不在一一列举了。</p>
<h4 id="UIScreenEdgePanGestureRecognizer-边缘拖动"><a href="#UIScreenEdgePanGestureRecognizer-边缘拖动" class="headerlink" title="UIScreenEdgePanGestureRecognizer (边缘拖动)"></a>UIScreenEdgePanGestureRecognizer (边缘拖动)</h4><p>ScreenEdgePan继承于<code>UIPanGestureRecognizer</code>，在屏幕边缘滑动才会触发</p>
<ul>
<li>@property (readwrite, nonatomic, assign) UIRectEdge edges;</li>
</ul>
<p><code>edges</code>为指定边缘拖动触发的边，是一个枚举：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef NS_OPTIONS(NSUInteger, UIRectEdge) &#123;</span><br><span class="line">    UIRectEdgeNone   = 0,</span><br><span class="line">    UIRectEdgeTop    = 1 &lt;&lt; 0,</span><br><span class="line">    UIRectEdgeLeft   = 1 &lt;&lt; 1,</span><br><span class="line">    UIRectEdgeBottom = 1 &lt;&lt; 2,</span><br><span class="line">    UIRectEdgeRight  = 1 &lt;&lt; 3,</span><br><span class="line">    UIRectEdgeAll    = UIRectEdgeTop | UIRectEdgeLeft | UIRectEdgeBottom | UIRectEdgeRight</span><br><span class="line">&#125; NS_ENUM_AVAILABLE_IOS(7_0);</span><br></pre></td></tr></table></figure>
<p>其他方法和Tap手势一致，主要用于像左右抽屉视图的变换等处理。</p>
<h4 id="UIPinchGestureRecognizer（捏合）"><a href="#UIPinchGestureRecognizer（捏合）" class="headerlink" title="UIPinchGestureRecognizer（捏合）"></a>UIPinchGestureRecognizer（捏合）</h4><p>Pinch手势有两个属性：</p>
<ul>
<li>@property (nonatomic)          CGFloat scale;              </li>
<li>@property (nonatomic,readonly) CGFloat velocity; </li>
</ul>
<p><code>scale</code>：捏合比例</p>
<p><code>velocity</code>:捏合速度 = <code>scale/second</code></p>
<h4 id="UIRotationGestureRecognizer（旋转）"><a href="#UIRotationGestureRecognizer（旋转）" class="headerlink" title="UIRotationGestureRecognizer（旋转）"></a>UIRotationGestureRecognizer（旋转）</h4><p>Rotation手势和Pinch手势类似，同样有两个手势：</p>
<ul>
<li>@property (nonatomic)          CGFloat rotation;            </li>
<li>@property (nonatomic,readonly) CGFloat velocity;</li>
</ul>
<p><code>rotation</code>:旋转弧度，注意，这里的单位是<strong>弧度</strong></p>
<p><code>velocity</code>:旋转速度</p>
<h4 id="UILongPressGestureRecognizer（长按）"><a href="#UILongPressGestureRecognizer（长按）" class="headerlink" title="UILongPressGestureRecognizer（长按）"></a>UILongPressGestureRecognizer（长按）</h4><p>LongPress的属性：</p>
<ul>
<li>@property (nonatomic) NSUInteger numberOfTapsRequired;      // Default is 0. </li>
<li>@property (nonatomic) NSUInteger numberOfTouchesRequired __TVOS_PROHIBITED;   // Default is 1. </li>
<li>@property (nonatomic) CFTimeInterval minimumPressDuration; </li>
<li>@property (nonatomic) CGFloat allowableMovement;</li>
</ul>
<p><code>numberOfTapsRequired</code>和<code>numberOfTouchesRequired</code>和Tap手势类似，都是指定触发需要的点击次数和手指数量，但是LongPress手势的<code>numberOfTapsRequired</code>是指定长按前需要点击的次数。</p>
<p><code>minimumPressDuration</code>:触发时间</p>
<p><code>allowableMovement</code>:允许长按时间触发前允许手指滑动的范围。若是你在长按时手指移动，该长按手势将会失败，<code>allowableMovement</code>设置你能容忍的滑动范围，默认是10.</p>
<h1 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h1><hr>
<p>iOS的变形指的是图片的旋转、平移和缩放。这些变形可以和上面介绍的手势结合，完成许多变形操作。</p>
<p>说变形前我们来看看<strong>CGAffineTransform</strong>，<strong>CGAffineTransform</strong>为一个结构体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct CGAffineTransform &#123;</span><br><span class="line">    CGFloat a, b, c, d;</span><br><span class="line">    CGFloat tx, ty;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们输出一个控件的<code>transform</code>看看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGAffineTransform(self.label.transform));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-22 17:01:19.211 手势[6489:1481987] [1, 0, 0, 1, 0, 0]</span><br></pre></td></tr></table></figure>

<p>我们可以看到输出了一个长度为6的数组：<code>[1, 0, 0, 1, 0, 0]</code>，并且我们可以猜测对应结构体中的<code>[a, b, c, d, tx, ty]</code>，并且默认的<code>transform</code>值就是<code>[1, 0, 0, 1, 0, 0]</code>。</p>
<p>想进一步了解可以看这篇<a href="http://blog.csdn.net/ashiyanshi/article/details/48160429" target="_blank" rel="noopener">《iOS CGAffineTransform详解》</a></p>
<p>对iOS控件进行变形实际就是对控件<code>transform</code>属性进行操作。</p>
<p>但是我们使用中，使用已经封装好的的API对控件进行变形处理。分别是：</p>
<ul>
<li>CGAffineTransformScale()</li>
<li>CGAffineTransformTranslate()</li>
<li>CGAffineTransformRotate()</li>
</ul>
<p>和：</p>
<ul>
<li>CGAffineTransformMakeScale（）</li>
<li>CGAffineTransformMakeTranslate()</li>
<li>CGAffineTransformMakeRotate()</li>
</ul>
<p>这些API都是对设置<code>CGAffineTransform</code>的一个封装，针对<code>[a, b, c, d, tx, ty]</code>中不同的位置进行操作。</p>
<p>下面我们在ViewController创建一个<code>UILabel</code>控件。然后对它进行变形操作。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79jw1fazplz4mvmj306x0cbt8m.jpg" alt=""></p>
<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4><p>首先来看一个缩放操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 缩放到90%（相对）</span><br><span class="line">self.label.transform = CGAffineTransformScale(self.label.transform, 0.9, 0.9);</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGAffineTransform( self.label.transform));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-22 17:26:25.074 手势[6526:1564064] [0.90000000000000002, 0, 0, 0.90000000000000002, 0, 0]</span><br><span class="line">2016-12-22 17:26:26.096 手势[6526:1564064] [0.81000000000000005, 0, 0, 0.81000000000000005, 0, 0]</span><br><span class="line">2016-12-22 17:26:26.963 手势[6526:1564064] [0.72900000000000009, 0, 0, 0.72900000000000009, 0, 0]</span><br><span class="line">2016-12-22 17:26:28.830 手势[6526:1564064] [0.65610000000000013, 0, 0, 0.65610000000000013, 0, 0]</span><br></pre></td></tr></table></figure>

<p>我们再看看另一个缩放：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.label.transform = CGAffineTransformMakeScale(0.9, 0.9);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGAffineTransform( self.label.transform));</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-22 17:32:32.972 手势[6581:1600236] [0.90000000000000002, 0, 0, 0.90000000000000002, 0, 0]</span><br><span class="line">2016-12-22 17:32:34.164 手势[6581:1600236] [0.90000000000000002, 0, 0, 0.90000000000000002, 0, 0]</span><br><span class="line">2016-12-22 17:32:35.246 手势[6581:1600236] [0.90000000000000002, 0, 0, 0.90000000000000002, 0, 0]</span><br></pre></td></tr></table></figure>

<p>对比可以发现<code>CGAffineTransformScale()</code>与<code>CGAffineTransformMakeScale()</code>的区别在于，<code>CGAffineTransformScale()</code>实在原理的基础上在进行缩放操作，而<code>CGAffineTransformMakeScale()</code>直接将缩放值设定为0.9不变了。</p>
<p>缩放操作变动的是构体中<code>[a, b, c, d, tx, ty]</code>的<code>a</code>和<code>d</code>，值和变形系数<code>Scale</code>是相对应的，大于1是放大，小于1是缩小。。</p>
<p><code>a</code>是横向缩放， <code>d</code>是纵向缩放。</p>
<h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>先来看一个平移操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.label.transform = CGAffineTransformTranslate(self.label.transform, 10, 10);</span><br><span class="line">    NSLog(@&quot;%@&quot;, NSStringFromCGAffineTransform( self.label.transform));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-22 17:40:38.568 手势[6608:1631232] [1, 0, 0, 1, 10, 10]</span><br><span class="line">2016-12-22 17:40:40.833 手势[6608:1631232] [1, 0, 0, 1, 20, 20]</span><br><span class="line">2016-12-22 17:40:41.834 手势[6608:1631232] [1, 0, 0, 1, 30, 30]</span><br><span class="line">2016-12-22 17:40:42.532 手势[6608:1631232] [1, 0, 0, 1, 40, 40]</span><br><span class="line">2016-12-22 17:40:43.162 手势[6608:1631232] [1, 0, 0, 1, 50, 50]</span><br></pre></td></tr></table></figure>

<p>我们可以看到label往右下角移动</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79jw1fazply7kkpj306v0ca0sp.jpg" alt=""></p>
<p>对应xy的正向坐标为右下角。</p>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.label.transform = CGAffineTransformRotate(self.label.transform, M_PI_2);</span><br><span class="line">NSLog(@&quot;%@&quot;, NSStringFromCGAffineTransform( self.label.transform));</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2016-12-22 17:59:43.680 手势[6667:1717130] [6.123233995736766e-17, 1, -1, 6.123233995736766e-17, 0, 0]</span><br></pre></td></tr></table></figure>

<p><img src="http://ww2.sinaimg.cn/large/006tNc79gw1fazq3j2ud5j306z0cfdft.jpg" alt=""></p>
<p>可以看到<code>label</code>顺时针旋转了<code>π/2</code>弧度（90°）。</p>
<h1 id="手势结合变形"><a href="#手势结合变形" class="headerlink" title="手势结合变形"></a>手势结合变形</h1><hr>
<p>手势结合变形就是通过手势对控件变形处理。</p>
<p>上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController ()&lt;UIGestureRecognizerDelegate&gt;</span><br><span class="line">@property (weak, nonatomic) IBOutlet UIImageView *imageView;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">//    CGAffineTransform *mytransform = self.imageView.transform;</span><br><span class="line">    self.imageView.userInteractionEnabled = YES;</span><br><span class="line">    //1双击 恢复</span><br><span class="line">    UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(tap:)];</span><br><span class="line">    tap.numberOfTapsRequired = 2;</span><br><span class="line">    tap.numberOfTouchesRequired = 1;</span><br><span class="line">    [self.imageView addGestureRecognizer:tap];</span><br><span class="line">    </span><br><span class="line">    //2拖拽</span><br><span class="line">    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(pan:)];</span><br><span class="line">//    pan.delegate = self;</span><br><span class="line">    [self.imageView addGestureRecognizer:pan];</span><br><span class="line">    </span><br><span class="line">    //3捏合</span><br><span class="line">    UIPinchGestureRecognizer *pinch = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(pinch:)];</span><br><span class="line">    pinch.delegate = self;</span><br><span class="line">    [self.imageView addGestureRecognizer:pinch];</span><br><span class="line">    </span><br><span class="line">    //4旋转</span><br><span class="line">    UIRotationGestureRecognizer *rotaion = [[UIRotationGestureRecognizer alloc]initWithTarget:self action:@selector(rotaion:)];</span><br><span class="line">//    pinch.delegate = self;</span><br><span class="line">    [self.imageView addGestureRecognizer:rotaion];</span><br><span class="line">    </span><br><span class="line">    // 长按</span><br><span class="line">    UILongPressGestureRecognizer *longPress = [[UILongPressGestureRecognizer alloc] initWithTarget:self action:@selector(longPress:)];</span><br><span class="line">    longPress.numberOfTapsRequired = 0;</span><br><span class="line">    longPress.minimumPressDuration = 1;</span><br><span class="line">//    longPress.allowableMovement = 3;</span><br><span class="line">    [self.imageView addGestureRecognizer:longPress];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (void)tap:(UITapGestureRecognizer *)sender&#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;tap！&quot;);</span><br><span class="line">    </span><br><span class="line">    //恢复</span><br><span class="line">    self.imageView.transform = CGAffineTransformIdentity;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">- (void)pan:(UIPanGestureRecognizer *)sender&#123;</span><br><span class="line">//    CGPoint center = self.imageView.center;</span><br><span class="line">//    if (center.x &lt; 0)&#123;</span><br><span class="line">//        center.x = 0;</span><br><span class="line">//    &#125;else&#123;</span><br><span class="line">//        center.x += [sender translationInView:self.view].x;</span><br><span class="line">//    &#125;</span><br><span class="line">//    </span><br><span class="line">//    center.y += [sender translationInView:self.view].y;</span><br><span class="line">//    self.imageView.center = center;</span><br><span class="line">    //将相对偏移量清零</span><br><span class="line">//    [sender setTranslation:CGPointMake(0, 0) inView:self.view];</span><br><span class="line">    </span><br><span class="line">    self.imageView.transform = CGAffineTransformTranslate(self.imageView.transform, [sender translationInView:self.imageView].x, [sender translationInView:self.imageView].y);</span><br><span class="line">    [sender setTranslation:CGPointZero inView:self.view];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)pinch:(UIPinchGestureRecognizer *)sender&#123;</span><br><span class="line">    </span><br><span class="line">    CGFloat  scale = sender.scale;</span><br><span class="line">    self.imageView.transform = CGAffineTransformScale(self.imageView.transform, scale, scale);</span><br><span class="line">    [sender setScale:1];</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)rotaion:(UIRotationGestureRecognizer *)sender&#123;</span><br><span class="line">    //获取旋转弧度</span><br><span class="line">    CGFloat rotation = sender.rotation;</span><br><span class="line">    self.imageView.transform = CGAffineTransformRotate(self.imageView.transform, rotation);</span><br><span class="line">    sender.rotation = 0;</span><br><span class="line">    </span><br><span class="line">//    self.imageView.transform = CGAffineTransformMakeRotation(sender.rotation);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)longPress:(UILongPressGestureRecognizer *)sender &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;longPress:%@&quot;, sender);</span><br><span class="line">    </span><br><span class="line">    // 判断长按事件触发</span><br><span class="line">    if (sender.state == UIGestureRecognizerStateBegan) &#123;</span><br><span class="line">        self.imageView.transform = CGAffineTransformMake(1, 0, 0, 1, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//希望两个手势共存</span><br><span class="line">//遵守 UIGestureRecognizerDelegate 协议</span><br><span class="line">//实现方法 -(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</span><br><span class="line">//将要同时实现的手势设置代理 pinch.delegate = self; pinch.delegate = self;</span><br><span class="line"></span><br><span class="line">-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有几点需要注意：</p>
<ul>
<li>给本身没有交互功能的控件（）imagView, UIlabel, View等）添加手势，要设置<code>userInteractionEnabled</code>为<strong>YES</strong>，否则识别不了手势</li>
<li>想要手势共存需要：<ul>
<li>遵守 <code>UIGestureRecognizerDelegate</code> 协议</li>
<li>实现<code>-(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</code>方法，返回<code>YES</code></li>
<li>将要同时实现的手势设置代理 <code>pinch.delegate = self</code>; <code>pinch.delegate = self</code></li>
</ul>
</li>
</ul>
<h1 id="在storyboard中添加手势"><a href="#在storyboard中添加手势" class="headerlink" title="在storyboard中添加手势"></a>在storyboard中添加手势</h1><p>在<code>storyboard</code>的控件栏中我们可以看到这些手势控件：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79gw1fb0j188yh1j30780evwfq.jpg" alt="storyboard中的手势控件"></p>
<h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><ol>
<li><p>直接将手势控件拖到要添加的视图上</p>
<p> <img src="http://ww3.sinaimg.cn/large/006tNc79gw1fb0ja1f8fnj30f206nwev.jpg" alt=""></p>
</li>
<li><p>关联手势事件</p>
<p> <img src="http://ww2.sinaimg.cn/large/006tNc79gw1fb0jaxllv6j30ol0be77b.jpg" alt=""></p>
</li>
<li><p>设置手势属性</p>
<p> <img src="http://ww2.sinaimg.cn/large/006tNc79gw1fb0jc5mon3j307c06ydgd.jpg" alt=""></p>
</li>
</ol>
<p>注意：若想同时识别多个手势，方法和上面相同，遵循协议，实现方法，设置代理，不过代理可以手动关联。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79gw1fb0jokip2vj30ej0aq3zz.jpg" alt=""></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>iOS开发基础</tag>
      </tags>
  </entry>
</search>
