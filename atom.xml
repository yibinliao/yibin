<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>天然呆</title>
  
  <subtitle>My exclusive</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-26T09:44:30.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>宜彬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之三：Nsight Eclipse Edition基础</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-tx-3/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-tx-3/</id>
    <published>2019-11-08T02:45:04.372Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li><li><strong>嵌入式系统：Ubuntu16.04</strong></li><li><strong>虚拟机系统：Ubuntu14.04</strong></li><li><strong>编者: WordZzzz</strong></li></ul><hr><p>&#160;&#160;&#160;&#160;Nsight Eclipse Edition是专为NVIDIA定制的Eclipse开发环境，主要区别是在菜单中加入了CUDA工程的建立、CUDAToolKit和NVIDIA的NVCC编译器等开发工具，方便开发者开发基于CUDA强大计算能力的各种工程项目。<br>&#160;&#160;&#160;&#160;根据上个教程安装完JetPcak3.0的各个功能模块之后，就可以在桌面的搜索框找出Nsight Eclipse Edition这个软件：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603170714026?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>&#160;&#160;&#160;&#160;本次教程以CUDA自带例程oceanFFT为例，介绍Nsight Eclips Edition的简单使用。</p><p>1.双击Nsight软件，弹出对话框，选择工作空间，即工作文件存放路径。确定后点击OK：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222057914?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>2.File-&gt;New-&gt;CUDA C/C++ Project，新建CUDA工程：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222149954?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>3.Project name：命名工程名称，Project type：提取CUDA例程，选定后点击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222210845?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600"></div><p></p><p>4.选取CUDA例程，这里我们选择oceanFFT，选定后点击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222405743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600"></div><p></p><p>5.基础设置默认即可，当然，对于TX1的PTX和GPU，标准的选择还是5.3，而不是2.0，选定后点击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222424384?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500"></div><p></p><p>6.选择链接，点击Management，创建新的链接，链接内容如第7步所示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222443915?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600"></div><p></p><p>7.输入IP和用户名，通过SSH登陆，填完后点击Finish：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222504197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500"></div><p></p><p>8.选择Project Path、Toolkit和CPU类型，选定后点击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222524428?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600"></div><p></p><p>9.编译版本默认即可，选定后点击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222544772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="600"></div><p></p><p>10.工程文件：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222611007?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="500"></div><p></p><p>11.Ctrl+B,构建：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603222627492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>12.在TX1上找到相应目录，运行相应二进制文件，运行效果如下：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170603224024916?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>&#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍Nsight进阶开发。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="TX1" scheme="http://yoursite.com/categories/TX1/"/>
    
    
      <category term="TX1" scheme="http://yoursite.com/tags/TX1/"/>
    
      <category term="Nsight" scheme="http://yoursite.com/tags/Nsight/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之二：刷机与开发前准备</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-tx-2/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-tx-2/</id>
    <published>2019-11-08T02:45:04.371Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li><li><strong>嵌入式系统：Ubuntu16.04</strong></li><li><strong>虚拟机系统：Ubuntu14.04</strong></li><li><strong>编者: WordZzzz</strong></li></ul><hr><p><strong><font color="black" size="5" face="仿宋">1.  JetPack3.0下载与安装</font></strong></p><p>本人PC端使用虚拟机安装Ubuntu14.04系统进行开发，需要有效联网。</p><p>1.首先在自己的home目录下创建Jetson文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~/Jetson</span><br><span class="line">$ cd ~/Jetson</span><br></pre></td></tr></table></figure><p>2.下载可执行文件到新建的Jetson文件夹下：<br><a href="https://developer.nvidia.com/embedded/downloads" target="_blank" rel="noopener">https://developer.nvidia.com/embedded/downloads</a></p><p>3.在虚拟机上运行安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x  ./JetPack-L4T-&lt;version&gt;-linux-x64.run</span><br><span class="line">$ ./JetPack-L4T-&lt;version&gt;-linux-x64.run</span><br></pre></td></tr></table></figure><p>之后出现如下图所示，单击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514162457089?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>之后会显示安装路径，单击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514163056458?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>4.接下来是开发板选型，这里我选TX1，单击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514163208366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>5.输入root用户密码：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514163407807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>6.联网获取安装包信息，此处必须联网，否则出不来安装信息，选完安装信息之后单击Next（ps：一般默认即可，只安装Jetpack不刷机的话就把下面的Target-Jetson TX1的Action一栏全部改为no action；由于我的已经安装完毕，所以Action一栏都是no action）：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514164423772?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>7.接受所选组件的许可协议，全部同意并单击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514164513150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>8.报错的话就按提示安装依赖库后再进行Jetpack安装：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514165036562?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>9.安装完成后如下图所示，单机Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514165440464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>10.点击Finish即可完成安装，最好不要勾选移除安装包：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514165617027?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p><strong><font color="black" size="5" face="仿宋">2.  刷机</font></strong><br>&#160;&#160;&#160;&#160;刷机过程需要重复上述1-5步，并且在第6步中Target-Jetson TX1的Action一栏改为需要的各个软件安装版本。所以刷机从第6步开始介绍.<br>6.联网获取安装包信息，此处必须联网，否则出不来安装信息，选完安装信息之后单击Next（一般默认即可）：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514170240735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>7.接受所选组件的许可协议，全部同意并单击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514164513150?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p>8.该组件管理器将继续安装。一旦主机的安装步骤完成后，单击下一步按钮继续安装目标组件。<p></p><div align="center"><img src="http://img.blog.csdn.net/20170514165440464?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>9.a.如果在6中取消选择Flash OS的组件管理器（即不烧写系统，只烧写某些组件），将需要输入IP地址，用户名和密码来建立ssh连接到目标设备：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514171202482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>9.b.如果在6中选择Flash OS的组件管理器，需要选择适合的特定环境中的网络布局：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514171121200?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p>10.a.如果选择了通过路由器/交换机设备访问互联网的布局，你会被要求选择哪个接口用于上网。<p></p><div align="center"><img src="http://img.blog.csdn.net/20170514171519491?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>10.b.如果您选择的设备通过主机IP获得通过指定DHCP服务器主机和访问互联网上的布局，您必须选择哪个接口是用于上网，并且将被用于目标接口。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514171554051?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>11.烧写确认，单击Next：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514173025649?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>12.之后会弹出POST窗口来引导你开启USB强制恢复模式：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170521110312924?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>&#160;&#160;&#160;&#160;TX1与主机使用usb连接，开启USB强制恢复模式（关机情况下，按一下POWER键，再长按REC键的同时点按RESET键，两秒后松开REC键）此时虚拟机会弹出NVIDIA设备：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514172001604?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>可以lsusb确认一下：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514172036136?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="200"></div><p></p><p>13.在POST窗口中回车，开始安装：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514172117995?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>14.系统安装完成后板子会重启。如果TX1重启后出现了Ubuntu的GUI界面，说明系统已经安装完成。重启完之后POST窗口会提示你输入IP地址，这里如果输入正确，等待十分钟左右就会进入下一个界面；如果失败，最好查看一下TX1现在的IP。接下来就需要安装CUDA、OpenCV等组件。在按Enter继续安装之前，需要确保TX1已经连网外网，如果校园网需要登录网关这样的，先将网关登录好再继续，因为安装组件的时候，需要安装一些依赖库，需要有外网的情况下才能进行。按Enter继续后，会出现提示信息，确定TX1的IP地址，手动输入TX1的IP地址后，按回车继续，稍等一会儿，会出现如下对话框（和9a里的一样，如果执行的9a而不是9b，这里就不会再出现确认信息）：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514171202482?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>15.一路NEXT，再次进入POST界面，此时使用SSH远程服务，无需下载线。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514172710005?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>16.安装完之后，程序自动关闭POST，回到如下界面，点击FINISH完成安装。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514172808920?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p><strong><font color="black" size="5" face="仿宋">3.  测试</font></strong><br>Jetpack自动编译所有例程，CUDA例程可以在以下目录中找到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;JetPack_Install_Dir&gt; / NVIDIA_CUDA- &lt;版本&gt; _samples</span><br></pre></td></tr></table></figure><p>可以通过重新编译运行示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMS=53 EXTRA_LDFLAGS=--unresolved-symbols=ignore-in-shared-libs TARGET_ARCH=aarch64 make</span><br></pre></td></tr></table></figure><p>运行：<br>CUDA的例程编译后的二进制文件目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/ubuntu/NVIDIA_CUDA-&lt;version&gt;_Samples/bin/aarch64/linux/release/</span><br></pre></td></tr></table></figure><p>命令行运行或双击运行：<br>例如，当您运行oceanFFT样品，将显示如下画面。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170514174244191?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p><strong><font color="black" size="5" face="仿宋">4.  开发前准备工作</font></strong></p><p><strong>更新源：</strong></p><p>&#160;&#160;&#160;&#160;因为默认源会找不到我们下述要用的一些依赖库和安装包，所以需要加入国内源，本例中采用的是中科大的源。值得注意的是，如果你之后回头来刷固件，一定还要把源换回来，否则有可能会安装失败。所以我们先做一下备份：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>在sources.list中将被#注释掉的源全部打开，随后在底部添加新的源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports trusty main universe restricted multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports trusty-security main universe restricted multiverse</span><br><span class="line">deb http://mirrors.ustc.edu.cn/ubuntu-ports trusty-updates main universe restricted multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty main universe restricted multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty-security main universe restricted multiverse</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/ubuntu-ports trusty-updates main universe restricted multiverse</span><br></pre></td></tr></table></figure><p>保存文件后，进行更新：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure><p><strong>浏览器安装：</strong></p><p>&#160;&#160;&#160;&#160;<font color="red">直接能上外网的请忽略此步骤。</font></p><p>&#160;&#160;&#160;&#160;由于身在校内，且实验室网络连接都是交换机模式，每一台设备连接外网时都需要登陆，所以就涉及到浏览器的安装。当然，大家也可以直接用PYTHON写个登陆脚本也是可以的。</p><p>&#160;&#160;&#160;&#160;NVIDIA Jetson TX1自带系统没有浏览器是个很尴尬的事情。我们尝试了两款浏览器，分别是Epiphany和Firefox。前者相对稳定，但是用一段时间之后就再也不能跳转至校园网登陆界面；后者经常闪退，但是至少还给我输入账号密码的机会。最后我们选择的是Firefox。</p><p>&#160;&#160;&#160;&#160;安装浏览器也需要联网，so，还得先用WiFi连接一下个人热点。</p><p>安装Epiphany：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install epiphany-browser</span><br></pre></td></tr></table></figure><p>安装Firefox：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install firefox-browser</span><br></pre></td></tr></table></figure><p><strong>输入法安装：</strong></p><p>&#160;&#160;&#160;&#160;命令行操作一般不需要使用输入法，但是如果我们想在GUI上进行一些操作，比如上网查资料等，输入法还是得有的。</p><p>安装google输入法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ibus-googlepinyin</span><br><span class="line">sudo reboot now</span><br></pre></td></tr></table></figure><p>&#160;&#160;&#160;&#160;安装完后重启系统，随后在GUI界面右上角找到文本输入设置(Text Entry Settings)，在里面将自己新下载的google输入法添加进去即可，操作和WINDOWS下添加输入法一样，故不在此赘述。</p><p><strong>lrzsz安装：</strong></p><p>&#160;&#160;&#160;&#160;NVIDIA Jetson TX1的SSH服务（端口号：22）已经配好，所以我们可以直接使用Xshell或者其他支持SSH远程登陆的客户端软件通过SSH服务来连接TX1，从而方便多人在WINDOWS上远程操控TX1。当然，Xshell是不支持图形界面的，如果想远程登录图形界面，可以配置一下vncserver，但是会消耗资源，个人不建议使用。</p><p>&#160;&#160;&#160;&#160;远程登录难免涉及到文件传输，文件传输有两种方法，大文件最好用FTP来传输，推荐使用File Zilla；小文件Xshell自己就可以搞定，需要在TX1上安装lrzsz。</p><p>安装lrzsz：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lrzsz</span><br></pre></td></tr></table></figure><p>sz发送TX1文件到本地：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sz filename</span><br></pre></td></tr></table></figure><p>rz发送本地文件到服务器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz</span><br></pre></td></tr></table></figure><p>&#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍如何使用Nsight进行程序开发。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="TX1" scheme="http://yoursite.com/categories/TX1/"/>
    
    
      <category term="TX1" scheme="http://yoursite.com/tags/TX1/"/>
    
      <category term="刷机" scheme="http://yoursite.com/tags/%E5%88%B7%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>NVIDIA Jetson TX1 系列开发教程之一：开箱测试</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-tx-1/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-tx-1/</id>
    <published>2019-11-08T02:45:04.368Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>嵌入式平台：NVIDIA Jetson TX1</strong></li><li><strong>嵌入式系统：Ubuntu16.04</strong></li><li><strong>编者: WordZzzz</strong></li></ul><hr><p><strong><font color="black" size="5" face="仿宋">1. 概述</font></strong></p><p>&#160;&#160;&#160;&#160;NVIDIA的Jetson TX1是嵌入式系统级模块（SoM），具有四核ARM Cortex-A57，4GB LPDDR4和集成的256核Maxwell GPU。 </p><p>&#160;&#160;&#160;&#160;对于部署计算机视觉和深度学习而言非常有用，Jetson TX1运行Linux(定制Ubuntu)，并提供1TFLOPS的FP16计算性能，功耗为10瓦。</p><p>&#160;&#160;&#160;&#160;Jetson TX1可作为模块，开发套件和兼容的生态系统产品。更多详细信息可以登录<a href="http://www.nvidia.cn/object/embedded-systems-dev-kits-modules-cn.html" target="_blank" rel="noopener">NVIDIA官网（此处有链接）</a>进行了解，也可通过<a href="http://elinux.org/Jetson_TX1" target="_blank" rel="noopener">Wikipedia（此处有链接）</a>进行TX1模组参数的快速预览。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170507174659130?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><hr><p><strong><font color="black" size="5" face="仿宋">2. 基本参数</font></strong></p><p><strong>处理组件：</strong></p><ul><li>四核ARM Cortex-A57</li><li>256核Maxwell GPU</li><li>4GB LPDDR4</li><li>16GB eMMC</li><li>H.264 / H.265编码器和解码器</li><li>双ISP（图像服务处理器）</li></ul><p><strong>端口和外设：</strong></p><ul><li>HDMI 2.0</li><li>802.11ac WiFi，蓝牙4.0</li><li>USB3，USB2</li><li>千兆以太网</li><li>12路MIPI CSI 2.0</li><li>4车道PCIe gen 2.0</li><li>SATA，2x SD卡</li><li>3x UART，3x SPI，4x I2C</li></ul><p><strong>构成因素：</strong></p><ul><li>400针Samtec板对板连接器</li><li>尺寸：50x87mm  （1.96“x 3.42”）</li><li>质量：45克</li><li>热转印板（TTP），-25C至85C工作温度</li><li>5.5-19.6VDC输入功率（消耗10-15W，典型负载下）</li></ul><p><strong>软件支持：</strong></p><ul><li>JetPack 2.3</li><li>Linux4Tegra R24.2 (L4T) for ARM (Ubuntu 16.04 aarch64)</li><li>CUDA Toolkit 8</li><li>cuDNN v5.1</li><li>TensorRT 1.0</li><li>VisionWorks 1.5</li><li>OpenCV4Tegra 2.4.13</li><li>OpenGL 4.4</li><li>OpenGL ES 3.1</li><li>Vulkan</li><li>V4L2 media controller support</li><li>gstreamer / OpenMAX</li><li>Tegra System Profiler (TSP)</li><li>Tegra Graphics Debugger</li><li>PerfKit 4.5.1</li></ul><p><strong><font color="black" size="5" face="仿宋">3. 开箱测试</font></strong></p><p>&#160;&#160;&#160;&#160;小五千大洋买回来的宝贝，拿到手还有点小激动（图片来自我的partner：Jack Cui）：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170507192357194?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>&#160;&#160;&#160;&#160;包装很高大上，下面来介绍一下开发套件的内容：TX1开发套件（含TX1模组）、一个19V电源适配器（尴尬的是没有插座线）、两个天线（用于TX1模组的WiFi和蓝牙）、Micro USB线和USB-OTG线。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170507192426987?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p>&#160;&#160;&#160;&#160;光有上面这些开发套件包含的东西是不能正常使用的，你还需要下面这些设备：</p><ul><li>电源适配器插头：</li></ul><p></p><div align="center"><img src="http://img.blog.csdn.net/20170507192456925?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><ul><li>2K显示屏：（开发套件原装系统默认分辨率为2K）。</li></ul><p>&#160;&#160;&#160;&#160;这里有点尴尬，除非你能保证你可以在没有显示器的情况下就能输入命令行修改分辨率（想办法调出命令行然后输入：xrandr -s 1208x720），否则还是找一块2K显示屏来吧。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170507175904716?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="400" height="400"></div><p></p><ul><li>鼠键套装：</li></ul><p></p><div align="center"><img src="http://img.blog.csdn.net/20170507180214767?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="600" height="400"></div><p></p><p><strong><font color="black" size="5" face="仿宋">4.调出桌面：</font></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/NVIDIA-INSTALL</span><br><span class="line">sudo ./install.sh</span><br><span class="line">sudo reboot now</span><br></pre></td></tr></table></figure><p>&#160;&#160;&#160;&#160;重启电脑之后，我们就可以看到ubuntu系统的桌面了。Jetson TX1出厂时默认的系统以及各依赖工具版本比较老旧，所以我们需要进行刷机来部署最新版本的JetPack。</p><p>&#160;&#160;&#160;&#160;下篇博文将以JetPack3.0为例，向大家介绍如何进行刷机。<br>&#160;&#160;&#160;&#160;下周日更新。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="TX1" scheme="http://yoursite.com/categories/TX1/"/>
    
    
      <category term="TX1" scheme="http://yoursite.com/tags/TX1/"/>
    
  </entry>
  
  <entry>
    <title>Sublime Text 3 搭建Python开发环境 码代码 美如画</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-py-7/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-py-7/</id>
    <published>2019-11-08T02:45:04.366Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：Sublime Text 3 Build 3143</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的 Vim ，浮肿沉重的 Eclipse ， VS ，即便体积轻巧迅速启动的 Editplus 、 Notepad++ ，在 Sublime Text 面前也略显失色，无疑这款性感无比的编辑器是 Coding 和 Writing 最佳的选择，没有之一。</p><p>&emsp;&emsp;Sublime Text 3 的功能实在是太强大了，搭配各种 package ，码代码、美如画。对于 Sublime Text 3 的介绍网上一大堆，博主就不再这里赘述了。本篇博文主要是记录一下博主如何在 Sublime Text 3 下优雅的编写、编译、运行 python 代码。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>&emsp;&emsp;WordZzzz使用的版本是 Sublime Text Build 3143 ，大家自行下载后直接安装即可，安装完之后需要 License 来激活我们的软件。</p><p>&emsp;&emsp;直接将下面的 License 复制过去就好，亲测可用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">—– BEGIN LICENSE —– </span><br><span class="line">TwitterInc </span><br><span class="line">200 User License </span><br><span class="line">EA7E-890007 </span><br><span class="line">1D77F72E 390CDD93 4DCBA022 FAF60790 </span><br><span class="line">61AA12C0 A37081C5 D0316412 4584D136 </span><br><span class="line">94D7F7D4 95BC8C1C 527DA828 560BB037 </span><br><span class="line">D1EDDD8C AE7B379F 50C9D69D B35179EF </span><br><span class="line">2FE898C4 8E4277A8 555CE714 E1FB0E43 </span><br><span class="line">D5D52613 C3D12E98 BC49967F 7652EED2 </span><br><span class="line">9D2D2E61 67610860 6D338B72 5CF95C69 </span><br><span class="line">E36B85CC 84991F19 7575D828 470A92AB </span><br><span class="line">—— END LICENSE ——</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="Package-Control"><a href="#Package-Control" class="headerlink" title="Package Control"></a>Package Control</h3><p>&emsp;&emsp;按 Ctrl+` 调出 console ，粘贴以下代码到底部命令行并回车：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import urllib.request,os,hashlib; h = &apos;6f4c264a24d933ce70df5dedcf1dcaee&apos; + &apos;ebe013ee18cced0ef93d5f746d80ef60&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;重启 Sublime Text 3。如果在 Perferences-&gt;package settings 中看到 package control 这一项，则安装成功。按下 Ctrl+Shift+P 调出命令面板输入 install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</p><p>&emsp;&emsp;下面介绍几个比较实用的 package 。</p><h3 id="SideBarEnhancements"><a href="#SideBarEnhancements" class="headerlink" title="SideBarEnhancements"></a>SideBarEnhancements</h3><p>&emsp;&emsp;SideBarEnhancements 扩展了侧边栏中菜单选项的数量，从而提升你的工作效率。诸如 “New file” 和 “Duplicate” 这样的选项对于 ST3 来说实在是太重要了，而且仅凭 “Delete” 这一个功能就让这个插件值得下载。这个功能将你会在你删除文件的时候把它放入回收站。虽然这个功能乍一看没什么用，但是当你没有使用这样的功能而彻底删除了一个文件的时候，除非你用了版本管理软件，否则你将很难恢复这个文件。</p><h3 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h3><p>&emsp;&emsp;Anaconda 是一个终极 Python 插件。它为 ST3 增添了多项 IDE 类似的功能，例如：</p><ul><li>Autocompletion 自动完成，该选项默认开启，同时提供多种配置选项。</li><li>Code linting 使用支持 pep8 标准的 PyLint 或者 PyFlakes。</li><li>McCabe code complexity checker 让你可以在特定的文件中使用 McCabe complexity checker. </li><li>Goto Definitions 能够在你的整个工程中查找并且显示任意一个变量，函数，或者类的定义。</li><li>Find Usage 能够快速的查找某个变量，函数或者类在某个特定文件中的什么地方被使用了。</li><li>Show Documentation： 能够显示一个函数或者类的说明性字符串(当然，是在定义了字符串的情况下)</li></ul><p>&emsp;&emsp;但是，刚安装完之后，打开一个 python 文档，所有代码都会被白色细线框中，如图所示；</p><p>&emsp;&emsp;强迫症的我看着好难受，决心要搞一搞这东西。后来发现在 Sublime &gt; Preferences &gt; Package Settings &gt; Anaconda &gt; Settings – Default 下修改 linting behaviour 选项即可，我这里改成了只有在保存的时候linting工作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    Sets the linting behaviour for anaconda:</span><br><span class="line"></span><br><span class="line">    &quot;always&quot; - Linting works always even while you are writing (in the background)</span><br><span class="line">    &quot;load-save&quot; - Linting works in file load and save only</span><br><span class="line">    &quot;save-only&quot; - Linting works in file save only</span><br><span class="line">*/</span><br><span class="line">&quot;anaconda_linting_behaviour&quot;: &quot;save-only&quot;,</span><br></pre></td></tr></table></figure><h3 id="SublimeREPL"><a href="#SublimeREPL" class="headerlink" title="SublimeREPL"></a>SublimeREPL</h3><p>&emsp;&emsp;这可能是对程序员来说最有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ，Python，Ruby， Scala 和 Haskell 等等）。</p><p>&emsp;&emsp;在 Sublime &gt; Tools &gt; SublimeREPL 下我们可以看到 SublimeREPL 支持运行的所有语言。</p><p>&emsp;&emsp;下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Default.sublime-commands 文件，从中我们可以看到 SublimeREPL 所支持的 python 的各种运行方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - PDB current file&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python_pdb&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python_run&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;command&quot;: &quot;python_virtualenv_repl&quot;,</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - virtualenv&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;caption&quot;: &quot;SublimeREPL: Python - IPython&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;id&quot;: &quot;repl_python_ipython&quot;,</span><br><span class="line">            &quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;接下来配置快捷键，打开 Sublime &gt; Preferences &gt; Key Building ，在右侧栏（ User 部分）添加下面的代码。下面的代码用 F5 来执行当前 Python 脚本，用 F4 来实现切换至 Python 命令行窗口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;&quot;keys&quot;:[&quot;f5&quot;],</span><br><span class="line">&quot;caption&quot;: &quot;SublimeREPL: Python - RUN current file&quot;,</span><br><span class="line">&quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">&#123;&quot;id&quot;: &quot;repl_python_run&quot;,</span><br><span class="line">&quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;</span><br><span class="line">,</span><br><span class="line">&#123;&quot;keys&quot;:[&quot;f4&quot;],</span><br><span class="line">&quot;caption&quot;: &quot;SublimeREPL: Python&quot;,</span><br><span class="line">&quot;command&quot;: &quot;run_existing_window_command&quot;, &quot;args&quot;:</span><br><span class="line">&#123;&quot;id&quot;: &quot;repl_python&quot;,</span><br><span class="line">&quot;file&quot;: &quot;config/Python/Main.sublime-menu&quot;&#125;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当然，如果你电脑里面安装了两个版本的 Python ，而你想指定使用某个版本，则需要修改下面的代码。下面的代码是在 AppData\Roaming\Sublime Text 3\Packages\SublimeREPL\config\Python 下的 Main.sublime-menu 文件，主要修改 “cmd” 后面跟着的 python 命令。比如我电脑里 python2.7 的执行程序命名是 python.exe ，而 python3.6 的执行程序命名为 python3.exe ，我想要使用 python3 ，所以把所有 “cmd” 后面跟着的命令都改为 “python3” 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     &#123;</span><br><span class="line">        &quot;id&quot;: &quot;tools&quot;,</span><br><span class="line">        &quot;children&quot;:</span><br><span class="line">        [&#123;</span><br><span class="line">            &quot;caption&quot;: &quot;SublimeREPL&quot;,</span><br><span class="line">            &quot;mnemonic&quot;: &quot;R&quot;,</span><br><span class="line">            &quot;id&quot;: &quot;SublimeREPL&quot;,</span><br><span class="line">            &quot;children&quot;:</span><br><span class="line">            [</span><br><span class="line">                &#123;&quot;caption&quot;: &quot;Python&quot;,</span><br><span class="line">                &quot;id&quot;: &quot;Python&quot;,</span><br><span class="line"></span><br><span class="line">                 &quot;children&quot;:[</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;P&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;],</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;python_virtualenv_repl&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;python_virtualenv_repl&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - virtualenv&quot;&#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - PDB current file&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python_pdb&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;D&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;cmd&quot;: [&quot;python3&quot;, &quot;-i&quot;, &quot;-u&quot;, &quot;-m&quot;, &quot;pdb&quot;, &quot;$file_basename&quot;],</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - RUN current file&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python_run&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;R&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;cmd&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$file_basename&quot;],</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;&quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;&#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;&quot;command&quot;: &quot;repl_open&quot;,</span><br><span class="line">                     &quot;caption&quot;: &quot;Python - IPython&quot;,</span><br><span class="line">                     &quot;id&quot;: &quot;repl_python_ipython&quot;,</span><br><span class="line">                     &quot;mnemonic&quot;: &quot;I&quot;,</span><br><span class="line">                     &quot;args&quot;: &#123;</span><br><span class="line">                        &quot;type&quot;: &quot;subprocess&quot;,</span><br><span class="line">                        &quot;encoding&quot;: &quot;utf8&quot;,</span><br><span class="line">                        &quot;autocomplete_server&quot;: true,</span><br><span class="line">                        &quot;cmd&quot;: &#123;</span><br><span class="line">                            &quot;osx&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;],</span><br><span class="line">                            &quot;linux&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;],</span><br><span class="line">                            &quot;windows&quot;: [&quot;python3&quot;, &quot;-u&quot;, &quot;$&#123;packages&#125;/SublimeREPL/config/Python/ipy_repl.py&quot;]</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &quot;cwd&quot;: &quot;$file_path&quot;,</span><br><span class="line">                        &quot;syntax&quot;: &quot;Packages/Python/Python.tmLanguage&quot;,</span><br><span class="line">                        &quot;external_id&quot;: &quot;python&quot;,</span><br><span class="line">                        &quot;extend_env&quot;: &#123;</span><br><span class="line">                            &quot;PYTHONIOENCODING&quot;: &quot;utf-8&quot;,</span><br><span class="line">                            &quot;SUBLIMEREPL_EDITOR&quot;: &quot;$editor&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]&#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;别忘了， Sublime Text 3 也有自己的 build 功能，即也支持 python 等语言的代码构建（ ctrl + b ）。同样的，我们如何添加不同的 python 版本到我们的构建系统呢？很简单，Sublime &gt; Tools &gt; Build System &gt; New Build System，分别添加如下代码之后，再分别保存为 python2.sublime-build 和 python3.sublime-build ，这样，当我们再次打开 Sublime &gt; Tools &gt; Build System 之后，就会发现我们新添加的 python2 和 python3 构建系统了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;cmd&quot;: [&quot;D:/Program Files/Python/Python27/python.exe&quot;, &quot;-u&quot;, &quot;$file&quot;],</span><br><span class="line">&quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line([0-9]*)&quot;,</span><br><span class="line">&quot;selector&quot;: &quot;source.python&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;cmd&quot;: [&quot;D:/Program Files/Python/Python36/python3.exe&quot;, &quot;-u&quot;, &quot;$file&quot;],</span><br><span class="line">&quot;file_regex&quot;: &quot;^[ ]*File \&quot;(...*?)\&quot;, line([0-9]*)&quot;,</span><br><span class="line">&quot;selector&quot;: &quot;source.python&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SublimeTmpl"><a href="#SublimeTmpl" class="headerlink" title="SublimeTmpl"></a>SublimeTmpl</h3><p>&emsp;&emsp;快速生成文件模板</p><p>&emsp;&emsp;，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。</p><p>&emsp;&emsp;SublimeTmpl默认的快捷键:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctrl+alt+h html</span><br><span class="line">ctrl+alt+j javascript</span><br><span class="line">ctrl+alt+c css</span><br><span class="line">ctrl+alt+p php</span><br><span class="line">ctrl+alt+r ruby</span><br><span class="line">ctrl+alt+shift+p python</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里我想修改一下python模板，所以就需要进行如下操作：Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl &gt; Settings – User 添加如下代码。然后 ctrl+alt+shift+p 来新建一个模板试试看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    &quot;disable_keymap_actions&quot;: false, // &quot;all&quot;; &quot;html,css&quot;  </span><br><span class="line">    &quot;date_format&quot; : &quot;%Y-%m-%d %H:%M:%S&quot;,  </span><br><span class="line">    &quot;attr&quot;: &#123;  </span><br><span class="line">        &quot;author&quot;: &quot;WordZzzz&quot;,  </span><br><span class="line">        &quot;email&quot;: &quot;wordzzzz@foxmail.com&quot;,  </span><br><span class="line">        &quot;link&quot;: &quot;http://blog.csdn.net/u011475210&quot;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;快捷键也是可以更改的，全部在 Sublime &gt; Preferences &gt; Package Settings &gt; SublimeTmpl 的设置中。</p><p>&emsp;&emsp;如果想要新建其他类型的文件模板的话，先自定义文件模板方在templates文件夹里，再分别打开Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings这四个文件照着里面的格式自定义想要新建的类型，这里就不详细介绍了，请各位自己折腾哈~</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><ul><li>跳转到任意内容 (“cmd+p”) 用来快速查找和打开文件。你仅仅只需要工程中文件的一部分路径或者文件名你就可以很容易的打开这个文件。这在一个大型的 Django 工程中显得非常方便。</li><li>跳转到指定行 (“ctrl+g”) 让你在当前文件中跳转到指定行数。</li><li>跳转到标志 (“cmd+r”) 可以列出当前文件中所有的函数或者类，让你更方便查找。你可以通过输入关键字来查找你所需要的函数或者类。</li><li>跳转到行首 (cmd+left-arrow-key) 与 跳转到行尾 (cmd+right-arrow-key)</li><li>删除当前行(ctrl+shift+k)</li><li>多重编辑 是我迄今为止最喜欢的快捷键<br>选定一个单词，点击 “cmd+d”来选择同样的单词，再次点击 “cmd+d”*继续选择下一个单词…<br>或者 “cmd+单击”来指定多个你想要同时修改的地方。</li><li>块编辑 (option+left-mouse-click) 用于选择一整块的内容。通常在整理 CSV 文件的时候用于删除空白内容。</li></ul><h2 id="自定义命令"><a href="#自定义命令" class="headerlink" title="自定义命令"></a>自定义命令</h2><p>&emsp;&emsp;你可以很容易地使用 Python 来编辑你自己的自定义命令和快捷键组合。例如：</p><ul><li>拷贝当前文件路径到剪贴板 – 链接</li><li>关闭除当前活动标签页以外的所有其他标签页 – 链接</li></ul><p>&emsp;&emsp;通过文件选项打开你的 Package 文件夹(Sublime &gt; Preferences &gt; Browse Packages)，然后打开 User 文件夹，接下来将上述的 Python 文件添加到 “/Sublime Text 3/Packages/User” 文件夹中。</p><p>&emsp;&emsp;最后请在 Key Bindings – User file (Sublime Text &gt; Preferences &gt; Package Settings &gt; AdvancedNewFile &gt; Key Bindings – User) 文件中完成快捷键绑定。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  // Copy file name</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;keys&quot;: [&quot;cmd+shift+c&quot;],</span><br><span class="line">     &quot;command&quot;: &quot;copy_path_to_clipboard&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  // Close all other tabs</span><br><span class="line">  &#123;  </span><br><span class="line">    &quot;keys&quot;: [&quot;cmd+alt+w&quot;],</span><br><span class="line">    &quot;command&quot;: &quot;close_tabs&quot;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://yoursite.com/categories/Python3/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="Sublime" scheme="http://yoursite.com/tags/Sublime/"/>
    
  </entry>
  
  <entry>
    <title>Python3：字典中的items()函数</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-py-6/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-py-6/</id>
    <published>2019-11-08T02:45:04.364Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：python-3.6.2-amd64</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p><strong><font color="black" size="5" face="仿宋">一、Python2.x中items()：</font></strong></p><p>&emsp;&emsp;和之前一样，本渣渣先贴出来python中help的帮助信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.items)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">items(...)</span><br><span class="line">    D.items() -&gt; list of D's (key, value) pairs, as 2-tuples</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.iteritems)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">iteritems(...)</span><br><span class="line">    D.iteritems() -&gt; an iterator over the (key, value) items of D</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.viewitems)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">viewitems(...)</span><br><span class="line">    D.viewitems() -&gt; a set-like object providing a view on D's items</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Python2.x中，items( )用于 返回一个字典的拷贝列表【Returns a copy of the list of all items (key/value pairs) in D】，占额外的内存。</p><p>&emsp;&emsp;iteritems() 用于返回本身字典列表操作后的迭代【Returns an iterator on all items(key/value pairs) in D】，不占用额外的内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="number">1</span>:<span class="string">'one'</span>,<span class="number">2</span>:<span class="string">'two'</span>,<span class="number">3</span>:<span class="string">'three'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.items())</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.iteritems())</span><br><span class="line">&lt;type <span class="string">'dictionary-itemiterator'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.viewitems())</span><br><span class="line">&lt;type <span class="string">'dict_items'</span>&gt;</span><br></pre></td></tr></table></figure><p><strong><font color="black" size="5" face="仿宋">二、Python3.x中items()：</font></strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(dict.items)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">items(...)</span><br><span class="line">    D.items() -&gt; a set-like object providing a view on D's items</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Python 3.x 里面，iteritems() 和 viewitems() 这两个方法都已经废除了，而 items() 得到的结果是和 2.x 里面 viewitems() 一致的。在3.x 里 用 items()替换iteritems() ，可以用于 for 来循环遍历。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d=&#123;<span class="number">1</span>:<span class="string">'one'</span>,<span class="number">2</span>:<span class="string">'two'</span>,<span class="number">3</span>:<span class="string">'three'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(d.items())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict_items</span>'&gt;</span></span><br></pre></td></tr></table></figure><p>简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = &#123; <span class="string">'Adam'</span>: <span class="number">95</span>, <span class="string">'Lisa'</span>: <span class="number">85</span>, <span class="string">'Bart'</span>: <span class="number">59</span>, <span class="string">'Paul'</span>: <span class="number">74</span> &#125;</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> d.items():</span><br><span class="line">sum = sum + value</span><br><span class="line">print(key, <span class="string">':'</span> ,value)</span><br><span class="line">print(<span class="string">'平均分为:'</span> ,sum /len(d))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D:\Users\WordZzzz\Desktop&gt;python3 test.py</span><br><span class="line">Adam : <span class="number">95</span></span><br><span class="line">Lisa : <span class="number">85</span></span><br><span class="line">Bart : <span class="number">59</span></span><br><span class="line">Paul : <span class="number">74</span></span><br><span class="line">平均分为: <span class="number">78.25</span></span><br></pre></td></tr></table></figure><p>关于python3.x中items具体的应用，可以通过下面的传送门到达机器学习实战中找到：</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://yoursite.com/categories/Python3/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="items" scheme="http://yoursite.com/tags/items/"/>
    
  </entry>
  
  <entry>
    <title>Python3：string中的split()函数</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-py-5/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-py-5/</id>
    <published>2019-11-08T02:45:04.363Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：python-3.6.2-amd64</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="Python2-x中split-函数："><a href="#Python2-x中split-函数：" class="headerlink" title="Python2.x中split()函数："></a>Python2.x中split()函数：</h2><p>&emsp;&emsp;老规矩，help！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(str.split)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">split(...)</span><br><span class="line">    S.split([sep [,maxsplit]]) -&gt; list of strings</span><br><span class="line"></span><br><span class="line">    Return a list of the words <span class="keyword">in</span> the string S, using sep <span class="keyword">as</span> the</span><br><span class="line">    delimiter string.  If maxsplit <span class="keyword">is</span> given, at most maxsplit</span><br><span class="line">    splits are done. If sep <span class="keyword">is</span> <span class="keyword">not</span> specified <span class="keyword">or</span> <span class="keyword">is</span> <span class="literal">None</span>, any</span><br><span class="line">    whitespace string <span class="keyword">is</span> a separator <span class="keyword">and</span> empty strings are removed</span><br><span class="line">    <span class="keyword">from</span> the result.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出，在Python2.x中，split()返回的是字符串列表。</p><h2 id="Python3-x中split-函数："><a href="#Python3-x中split-函数：" class="headerlink" title="Python3.x中split()函数："></a>Python3.x中split()函数：</h2><p>&emsp;&emsp;同样，help！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(str.split)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">split(...)</span><br><span class="line">    S.split(sep=None, maxsplit=-1) -&gt; list of strings</span><br><span class="line"></span><br><span class="line">    Return a list of the words <span class="keyword">in</span> S, using sep <span class="keyword">as</span> the</span><br><span class="line">    delimiter string.  If maxsplit <span class="keyword">is</span> given, at most maxsplit</span><br><span class="line">    splits are done. If sep <span class="keyword">is</span> <span class="keyword">not</span> specified <span class="keyword">or</span> <span class="keyword">is</span> <span class="literal">None</span>, any</span><br><span class="line">    whitespace string <span class="keyword">is</span> a separator <span class="keyword">and</span> empty strings are</span><br><span class="line">    removed <span class="keyword">from</span> the result.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;啊哦，在Python3.x中，split()返回的也是字符串列表。</p><h2 id="样例："><a href="#样例：" class="headerlink" title="样例："></a>样例：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">"this is string example....wow!!!"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (str.split( ))</span><br><span class="line">[<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'string'</span>, <span class="string">'example....wow!!!'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (str.split(<span class="string">'i'</span>,<span class="number">1</span>))</span><br><span class="line">[<span class="string">'th'</span>, <span class="string">'s is string example....wow!!!'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> (str.split(<span class="string">'w'</span>))</span><br><span class="line">[<span class="string">'this is string example....'</span>, <span class="string">'o'</span>, <span class="string">'!!!'</span>]</span><br></pre></td></tr></table></figure><p>加入正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySent=<span class="string">'This book is the best book on Python or M.L. I have ever laid eyes upon'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mySent.split()                                      <span class="comment">#不带参数切分</span></span><br><span class="line">[<span class="string">'This'</span>, <span class="string">'book'</span>, <span class="string">'is'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'on'</span>, <span class="string">'Python'</span>, <span class="string">'or'</span>, <span class="string">'M.L.'</span>, <span class="string">'I'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>regEx = re.compile(<span class="string">'\\W'</span>)                               <span class="comment">#正则表达式，定义分隔符是除单词、数字外的任意字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listOfTokens = regEx.split(mySent)                      <span class="comment">#根据正则表达式的规则进行切分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listOfTokens</span><br><span class="line">[<span class="string">'This'</span>, <span class="string">'book'</span>, <span class="string">'is'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'on'</span>, <span class="string">'Python'</span>, <span class="string">'or'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">''</span>, <span class="string">'I'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[tok <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">0</span>]           <span class="comment">#去掉空格</span></span><br><span class="line">[<span class="string">'This'</span>, <span class="string">'book'</span>, <span class="string">'is'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'on'</span>, <span class="string">'Python'</span>, <span class="string">'or'</span>, <span class="string">'M'</span>, <span class="string">'L'</span>, <span class="string">'I'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[tok.lower() <span class="keyword">for</span> tok <span class="keyword">in</span> listOfTokens <span class="keyword">if</span> len(tok) &gt; <span class="number">2</span>]   <span class="comment">#全部小写，去掉长度小于3的单词</span></span><br><span class="line">[<span class="string">'this'</span>, <span class="string">'book'</span>, <span class="string">'the'</span>, <span class="string">'best'</span>, <span class="string">'book'</span>, <span class="string">'python'</span>, <span class="string">'have'</span>, <span class="string">'ever'</span>, <span class="string">'laid'</span>, <span class="string">'eyes'</span>, <span class="string">'upon'</span>]</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://yoursite.com/categories/Python3/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="split" scheme="http://yoursite.com/tags/split/"/>
    
  </entry>
  
  <entry>
    <title>Python3：sorted()函数及列表中的sort()函数</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-py-4/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-py-4/</id>
    <published>2019-11-08T02:45:04.345Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：python-3.6.2-amd64</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p><strong><font color="black" size="5" face="仿宋">一、sort，sorted函数介绍：</font></strong></p><p>&emsp;&emsp;Sort函数是list列表中的函数，而sorted可以对list或者iterator进行排序。</p><p>&emsp;&emsp;下面我们使用help来查看他们的用法及功能：<br>sort：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(list.sort)</span><br><span class="line">Help on method_descriptor:</span><br><span class="line"></span><br><span class="line">sort(...)</span><br><span class="line">    L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*</span><br></pre></td></tr></table></figure><p>sorted：<br>Python3.x:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sorted)</span><br><span class="line">Help on built-<span class="keyword">in</span> function sorted <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">sorted(iterable, /, *, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br><span class="line">    Return a new list containing all items <span class="keyword">from</span> the iterable <span class="keyword">in</span> ascending order.</span><br><span class="line"></span><br><span class="line">    A custom key function can be supplied to customize the sort order, <span class="keyword">and</span> the</span><br><span class="line">    reverse flag can be set to request the result <span class="keyword">in</span> descending order.</span><br></pre></td></tr></table></figure><p>Python2.x:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(sorted)</span><br><span class="line">Help on built-<span class="keyword">in</span> function sorted <span class="keyword">in</span> module __builtin__:</span><br><span class="line"></span><br><span class="line">sorted(...)</span><br><span class="line">    sorted(iterable, cmp=None, key=None, reverse=False) --&gt; new sorted list</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;好吧，Python3.x和Python2.x的sorted函数有点不太一样，少了cmp参数。下面本渣渣主要基于Python2.x的sorted函数进行讲解，Python3.x直接忽略cmp这个参数即可，为了保证代码通用性，不建议大家在今后的编程中使用cmp参数。</p><p><strong><font color="black" size="5" face="仿宋">二、sort和sorted的比较：</font></strong></p><p>&emsp;&emsp;用sort函数对列表排序时会影响列表本身，而sorted不会。<br>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.sort()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;Python2.x的sorted函数：sorted(iterable，cmp，key，reverse）<br>参数：</p><ul><li>iterable可以是list或者iterator；</li><li>cmp是带两个参数的比较函数；</li><li>key 是带一个参数的函数；</li><li>reverse为False或者True；</li></ul><p>举例说明:<br>（1）用cmp函数排序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>,<span class="number">90</span>), (<span class="string">'sara'</span>,<span class="number">80</span>),(<span class="string">'lily'</span>,<span class="number">95</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,cmp = <span class="keyword">lambda</span> x,y: cmp(x[<span class="number">0</span>],y[<span class="number">0</span>]))</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,cmp = <span class="keyword">lambda</span> x,y: cmp(x[<span class="number">1</span>],y[<span class="number">1</span>]))</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>)]</span><br></pre></td></tr></table></figure><p>（2）用key函数排序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list1 = [(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>,<span class="number">90</span>), (<span class="string">'sara'</span>,<span class="number">80</span>),(<span class="string">'lily'</span>,<span class="number">95</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,key = <span class="keyword">lambda</span> list1: list1[<span class="number">0</span>])</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,key = <span class="keyword">lambda</span> list1: list1[<span class="number">1</span>])</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>)]</span><br></pre></td></tr></table></figure><p>（3）用reverse排序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1,reverse = <span class="literal">True</span>)</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'david'</span>, <span class="number">90</span>)]</span><br></pre></td></tr></table></figure><p>（4）用operator.itemgetter函数排序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> itemgetter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=itemgetter(<span class="number">1</span>))</span><br><span class="line">[(<span class="string">'sara'</span>, <span class="number">80</span>), (<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=itemgetter(<span class="number">0</span>))</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;介绍operator.itemgetter函数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = operator.itemgetter(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(a)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;operator.itemgetter函数获取的不是值，而是定义了一个函数。</p><p>（5）多级排序:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(list1, key=itemgetter(<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">[(<span class="string">'david'</span>, <span class="number">90</span>), (<span class="string">'lily'</span>, <span class="number">95</span>), (<span class="string">'mary'</span>, <span class="number">90</span>), (<span class="string">'sara'</span>, <span class="number">80</span>)]</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://yoursite.com/categories/Python3/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="sort" scheme="http://yoursite.com/tags/sort/"/>
    
      <category term="sorted" scheme="http://yoursite.com/tags/sorted/"/>
    
  </entry>
  
  <entry>
    <title>Python3：operator模块中的itemgetter()函数</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-py-3/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-py-3/</id>
    <published>2019-11-08T02:45:04.344Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：python-3.6.2-amd64</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>&emsp;&emsp;和之前一样，本渣渣先贴出来python中help的帮助信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> operator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(operator.itemgetter)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">itemgetter</span> <span class="title">in</span> <span class="title">module</span> <span class="title">operator</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">itemgetter</span><span class="params">(builtins.object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">itemgetter</span><span class="params">(item, ...)</span> --&gt; itemgetter object</span></span><br><span class="line"><span class="class"> |</span></span><br><span class="line"><span class="class"> |  Return a callable object that fetches the given item(s) from its operand.</span></span><br><span class="line"><span class="class"> |  After f = itemgetter(2), the call f(r) returns r[2].</span></span><br><span class="line"><span class="class"> |  After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3])</span></span><br><span class="line"><span class="class"> |</span></span><br><span class="line"><span class="class"> |  Methods defined here:</span></span><br><span class="line"> |</span><br><span class="line"> |  __call__(self, /, *args, **kwargs)</span><br><span class="line"> |      Call self <span class="keyword">as</span> a function.</span><br><span class="line"> |</span><br><span class="line"> |  __getattribute__(self, name, /)</span><br><span class="line"> |      Return getattr(self, name).</span><br><span class="line"> |</span><br><span class="line"> |  __new__(*args, **kwargs) <span class="keyword">from</span> builtins.type</span><br><span class="line"> |      Create <span class="keyword">and</span> <span class="keyword">return</span> a new object.  See help(type) <span class="keyword">for</span> accurate signature.</span><br><span class="line"> |</span><br><span class="line"> |  __reduce__(...)</span><br><span class="line"> |      Return state information <span class="keyword">for</span> pickling</span><br><span class="line"> |</span><br><span class="line"> |  __repr__(self, /)</span><br><span class="line"> |      Return repr(self).</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;operator.itemgetter函数<br>operator模块提供的itemgetter函数用于获取对象的哪些维的数据，参数为一些序号（即需要获取的数据在对象中的序号），下面看例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=operator.itemgetter(<span class="number">1</span>)      //定义函数b，获取对象的第<span class="number">1</span>个域的值</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(a) </span><br><span class="line"><span class="number">2</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=operator.itemgetter(<span class="number">1</span>,<span class="number">0</span>)   //定义函数b，获取对象的第<span class="number">1</span>个域和第<span class="number">0</span>个的值</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b(a) </span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;要注意，operator.itemgetter函数获取的不是值，而是定义了一个函数，通过该函数作用到对象上才能获取值。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://yoursite.com/categories/Python3/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="itemgetter" scheme="http://yoursite.com/tags/itemgetter/"/>
    
  </entry>
  
  <entry>
    <title>Python3：numpy模块中的argsort()函数</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-py-2/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-py-2/</id>
    <published>2019-11-08T02:45:04.342Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：python-3.6.2-amd64</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>&emsp;&emsp;argsort函数是Numpy模块中的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(numpy.argsort)</span><br><span class="line">Help on function argsort <span class="keyword">in</span> module numpy.core.fromnumeric:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">argsort(a, axis=<span class="number">-1</span>, kind=<span class="string">'quicksort'</span>, order=<span class="literal">None</span>)</span><br><span class="line">Returns the indices that would sort an array.</span><br><span class="line"></span><br><span class="line">Perform an indirect sort along the given axis using the algorithm specified</span><br><span class="line">by the `kind` keyword. It returns an array of indices of the same shape <span class="keyword">as</span></span><br><span class="line">`a` that index data along the given axis <span class="keyword">in</span> sorted order.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;从中可以看出argsort函数返回的是数组值从小到大的索引值</p><p>Examples：</p><p>One dimensional array:一维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>Two-dimensional array:二维数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([[<span class="number">0</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x, axis=<span class="number">0</span>) <span class="comment">#按列排序</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x, axis=<span class="number">1</span>) <span class="comment">#按行排序</span></span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>Examples：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(x) <span class="comment">#按升序排列</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.argsort(-x) <span class="comment">#按降序排列</span></span><br><span class="line">array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[np.argsort(x)] <span class="comment">#通过索引值排序后的数组</span></span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[np.argsort(-x)]</span><br><span class="line">array([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>另一种方式实现按降序排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = x[np.argsort(x)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[::<span class="number">-1</span>]</span><br><span class="line">array([<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://yoursite.com/categories/Python3/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="argsort" scheme="http://yoursite.com/tags/argsort/"/>
    
  </entry>
  
  <entry>
    <title>Python3：input()函数</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-py-1/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-py-1/</id>
    <published>2019-11-08T02:45:04.341Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：python-3.6.2-amd64</strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><h2 id="Python2-x中range-函数："><a href="#Python2-x中range-函数：" class="headerlink" title="Python2.x中range()函数："></a>Python2.x中range()函数：</h2><p>&emsp;&emsp;老规矩，help！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(range)</span><br><span class="line">Help on built-<span class="keyword">in</span> function range <span class="keyword">in</span> module __builtin__:</span><br><span class="line"></span><br><span class="line">range(...)</span><br><span class="line">    range(stop) -&gt; list of integers</span><br><span class="line">    range(start, stop[, step]) -&gt; list of integers</span><br><span class="line"></span><br><span class="line">    Return a list containing an arithmetic progression of integers.</span><br><span class="line">    range(i, j) returns [i, i+<span class="number">1</span>, i+<span class="number">2</span>, ..., j<span class="number">-1</span>]; start (!) defaults to <span class="number">0.</span></span><br><span class="line">    When step <span class="keyword">is</span> given, it specifies the increment (<span class="keyword">or</span> decrement).</span><br><span class="line">    For example, range(<span class="number">4</span>) returns [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].  The end point <span class="keyword">is</span> omitted!</span><br><span class="line">    These are exactly the valid indices <span class="keyword">for</span> a list of <span class="number">4</span> elements.</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;可以看出，在Python2.x中，range()返回的是可以用来迭代的列表。</p><h2 id="Python3-x中range-函数："><a href="#Python3-x中range-函数：" class="headerlink" title="Python3.x中range()函数："></a>Python3.x中range()函数：</h2><p>&emsp;&emsp;同样，help！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(range)</span><br><span class="line">Help on <span class="class"><span class="keyword">class</span> <span class="title">range</span> <span class="title">in</span> <span class="title">module</span> <span class="title">builtins</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">range</span><span class="params">(object)</span></span></span><br><span class="line"><span class="class"> |  <span class="title">range</span><span class="params">(stop)</span> -&gt; range object</span></span><br><span class="line"><span class="class"> |  range(start, stop[, step]) -&gt; range object</span></span><br><span class="line"><span class="class"> |</span></span><br><span class="line"><span class="class"> |  Return an object that produces a sequence of integers from start (inclusive)</span></span><br><span class="line"><span class="class"> |  to stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.</span></span><br><span class="line"><span class="class"> |  start defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.</span></span><br><span class="line"><span class="class"> |  These are exactly the valid indices for a list of 4 elements.</span></span><br><span class="line"><span class="class"> |  When step is given, it specifies the increment (or decrement).</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;啊哦，在Python3.x中，range()返回的是一个range对象。</p><h2 id="样例对比："><a href="#样例对比：" class="headerlink" title="样例对比："></a>样例对比：</h2><p>Python2.x：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>Python3.x：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>range(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(range(<span class="number">1</span>,<span class="number">10</span>))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;通过list强制类型转换，可以在Python3.x中实现Python2.x中的range函数一样的效果。</p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="Python3" scheme="http://yoursite.com/categories/Python3/"/>
    
    
      <category term="Python3" scheme="http://yoursite.com/tags/Python3/"/>
    
      <category term="input" scheme="http://yoursite.com/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>CVPR2014 Objectness BING 源码编译</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-bing-3/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-bing-3/</id>
    <published>2019-11-08T02:45:04.340Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：VS2013+OpenCV2.4.13</strong></li><li><strong>编者: WordZzzz</strong></li></ul><hr><h2 id="一、资源"><a href="#一、资源" class="headerlink" title="一、资源"></a>一、资源</h2><p>1.论文作者主页：<a href="http://mmcheng.net/zh/bing/" target="_blank" rel="noopener">http://mmcheng.net/zh/bing/</a><br>2.代码下载地址：<a href="http://mmcheng.net/zh/code-data/" target="_blank" rel="noopener">http://mmcheng.net/zh/code-data/</a><br>3.数据集下载地址：<a href="http://mmcheng.net/zh/bing/" target="_blank" rel="noopener">http://mmcheng.net/zh/bing/</a></p><h2 id="二、环境配置"><a href="#二、环境配置" class="headerlink" title="二、环境配置"></a>二、环境配置</h2><p>&emsp;&emsp;如果你用的是Visual Studio 2012，正好电脑也支持X64平台，那么你只需要配置一下VS2012下的OpenCV（版本要求2.4.8以上），下载的程序就可以直接用了。<br>&emsp;&emsp;我做了一些排雷的动作，尝试了Visual Studio 2013中Release、Debug中的x64和win32版本，即：Release+x64、Debug+x64、Release+win32、Debug+win32.但是因为本渣渣能力有限，最终没能把Visual Studio 2013中的Debug+win32版本跑出来。</p><p>1.解压下载的源码：<br>&emsp;&emsp;解压后文件夹内容如图所示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903110934676?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>2.解压VOC2007数据集：<br>&emsp;&emsp;在上图的源码文件中我们也可以看到有个VOC2007文件夹，里面只有ImageSets一个文件夹（里面是训练时会用到的文本文档）。在这一步，我们要把下载好的800多MB的数据集解压到源码的VOC2007文件夹下。（注意在解压过程中当出现是否覆盖的选项时，一律选择跳过,虽然覆盖了也不是很影响效果。）</p><p>3.用VS2013打开解决方案，提示升级VC++编译器和库，直接点击确定就好：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111124791?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>4.X64-&gt;WIN32:</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111218240?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111248523?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111311467?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>添加win32配置管理器，注意一定要从x64继承下来其他东西。</p><p>5.配置LibLinear：</p><ul><li>右键LibLinear，选为启动项目；</li><li>在linear.cpp文件中，修改print_string_stdout函数为：extern “C” static void print_string_stdout(const char *s)</li><li>静态库配置：</li></ul><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111729176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>6.LibLinear代码生成：<br>&emsp;&emsp;最重要的就是这一块的东西了，我直接把四种配置的截图贴在这里，注意，MT对应Release，MTD对应Debug，但是作者的Debug版本用的是DLL(/MDd)，所以本渣渣在Debug版本中也没做更改：</p><p>Release+x64：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111535986?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>Debug+x64：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111413318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>Release+win32：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111515044?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>Debug+win32（失败）：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903111445504?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>&emsp;&emsp;ctrl+F5之后在相应目录下生成LibLinear.lib静态库，记下这个地址。<br>7.配置Objectness：<br>&emsp;&emsp;以Debug+win32的配置为例进行介绍（虽然配置失败，但是这些属性设置是通用的，所以没有更新截图）</p><ul><li><p>右键Objectness，选为启动项目；</p></li><li><p>打开Debug属性，链接器-&gt;附加库目录，添加LibLinear.lib的目录；（注意:链接库依赖项 要设为是（yes））</p></li><li><p>用_popcnt函数实现_popcnt64函数功能：需要自己动手在INT64类型基础上写函数。要加头文件#include&lt;intrin.h&gt;在stdafx.h中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">inline</span> <span class="selector-tag">INT64</span> __<span class="selector-tag">popcnt64</span>(<span class="selector-tag">INT64</span> <span class="selector-tag">x</span>)</span><br><span class="line">&#123;</span><br><span class="line">       return __popcnt((unsigned int)(x )) +__popcnt((unsigned int)(x&gt;&gt; 32));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>8.配置opencv：<br>&emsp;&emsp;这里大家可以参考浅墨的博客进行配置，当然本渣渣要是有时间了也会写一篇博客并在此更新链接。浅墨opencv配置链接：<br><a href="http://blog.csdn.net/poem_qianmo/article/details/19809337" target="_blank" rel="noopener">http://blog.csdn.net/poem_qianmo/article/details/19809337</a></p><p>&emsp;&emsp;这里我只贴出一些需要填写路径的截图：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903150731185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903150751508?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903150810256?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903150831273?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903150858382?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>&emsp;&emsp;<strong><font color="red" size="3" face="仿宋">需要注意的是上图部分，Debug版本就用d结尾的库，Release版本就用不带d结尾的库，千万不要像浅墨那样两个版本都塞进去，否则会莫名其妙报错。</font></strong></p><p>9.再次配置Objectness的代码生成，和第6步是一样的。</p><p>&emsp;&emsp;ctrl+F5之后，运行成功。</p><p>10.效果展示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903151152107?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170903151223762?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>11.其他：<br>&emsp;&emsp;如果想优化代码，可以打开openmp，并且设置一下优化等级，本渣渣在这里只是为了看处理效果，所以就没做优化的配置。关于优化配置可参考链接（有些情况不一定好使）：<a href="http://www.cnblogs.com/larch18/p/4560690.html" target="_blank" rel="noopener">http://www.cnblogs.com/larch18/p/4560690.html</a></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="BING" scheme="http://yoursite.com/categories/BING/"/>
    
    
      <category term="BING" scheme="http://yoursite.com/tags/BING/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>CVPR2014 Objectness BING 源码详解</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-bing-2/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-bing-2/</id>
    <published>2019-11-08T02:45:04.338Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>操作系统：WINDOWS 10</strong></li><li><strong>软件版本：VS2013+OpenCV2.4.13</strong></li><li><strong>编者: WordZzzz</strong></li></ul><hr><h2 id="一、样本生成："><a href="#一、样本生成：" class="headerlink" title="一、样本生成："></a>一、样本生成：</h2><h3 id="1-正样本"><a href="#1-正样本" class="headerlink" title="1.正样本"></a>1.正样本</h3><p>&emsp;&emsp;算法首先对每张图像上可能的所有标注框采样,生成不同尺度（该尺度在一定经验值范围内）的样本位置，并计算新生成的正样本与原始样本重叠率，保留重叠率超过50%的，重新归一化到8 * 8大小，计算新生成的有效正样本的梯度特征，并在水平方向翻转，最终保存新生成样本8 * 8的梯度特征与该特征的水平翻转特征作为xP.</p><h3 id="2-负样本"><a href="#2-负样本" class="headerlink" title="2.负样本"></a>2.负样本</h3><p>&emsp;&emsp;固定100次随机产生100个备选的负样本窗口，筛选出与每张图片中，与所有目标的重叠率都小于50%的负样本窗，并将该窗口内保存图像作为负样本。</p><h3 id="3-尺度处理"><a href="#3-尺度处理" class="headerlink" title="3.尺度处理"></a>3.尺度处理</h3><p>&emsp;&emsp;在筛选有效正样本时，同时保存了水平，垂直尺度系数，但是实际保存的尺度是归一化映射后的值，即(h - min) * num + w - min + 1,其中h,w表示筛选出的有效正样本相对原始目标的垂直，水平尺度系数，实际上，还是保存的尺度系数，只是在数据结构上，采用哈希映射存储罢了。</p><h3 id="4-判定有效样本"><a href="#4-判定有效样本" class="headerlink" title="4.判定有效样本"></a>4.判定有效样本</h3><p>&emsp;&emsp;程序下一步，会在上面采样生成的所有有效正样本，进行直方图统计，统计出每个尺度下的样本数。例如有2500多个图像文件，计算所有正样本数，统计每个尺度下的正样本数。根据统计结果，剔除掉正样本数少于50的尺度。保存剩下的尺度统计结果，接着，对所有正负样本，统一分配到一个二维矩阵，垂直表示样本数，水平表示样本的8<em>8梯度特征值，直接保存。<br>以上，属于该算法的第一个亮点。<br>&emsp;&emsp;算法主要是用来加速传统的滑动窗口对象检测，通过训练通用的对象估计方法来产生候选对象窗口。作者观察到一般对象都会有定义完好的封闭轮廓，而且通过将相关图像窗口重置为固定大小，就可以通过梯度幅值进行区分。基于以上的观察以及复杂度的考虑，为了明确训练方法，将窗口固定为8</em>8的，并将梯度幅值转化为一个简单的64维的特征来描述这个窗口。这就相当于我们看路上走的人一样，在很远的地方即使我们没看清楚脸，只是看到一个轮廓也能识别出是不是我们认识的人，反而，如果脸贴着脸去看一个人可能会认不出来。<br>&emsp;&emsp;也就是作者发现，在固定窗口的大小下，物体与背景的梯度模式有所不同。如下图所示。图（a）中绿框代表背景，红框代表物体。如果把这些框都resize成固定大小，比如8X8，然后求出8X8这些块中每个点的梯度（Normed Gradient，简称NG特征，叫赋范梯度特征，就是计算梯度范数，即<code>!$\sqrt{(g_x^2 + g_y^2)}$</code>,实际就是该点的L2范数梯度，但是作者实现时，采用-1,0,1方式计算gx或者gy,因此，用|gx| + |gy|近似代替梯度的L2范数），可以明显看到物体与背景的梯度模式的差别，如图1（c）所示，物体的梯度分布呈现出较为杂乱的模式，而背景的较为单一和清楚。其实这个道理很浅显，就是图像中背景区域往往呈现出homogeneous的特性，早期的图像区域分割方法就是依靠这种特性来做的。然后我个人觉得这里不一定要用梯度，用其他一些统计特征甚至是图像特征都有可能得到类似的结果。<br>&emsp;&emsp;所以，作者首先将所有的标注样本，用不同尺度缩放采样，将采样出的有效正样本统一缩放到8 * 8，计算NG特征，也就是下面图中a生成c在过程。这样，通过SVM训练这些NG特征，得到目标和背景的第一次区分模型。<br>&emsp;&emsp;下面是原文的解释<br>&emsp;&emsp;对象一般是具有很好定义封闭轮廓和中心的。重置窗口的时候，就相当于将现实中的对象缩小到一个固定大小，因为在封闭的轮廓中，图像梯度变化很小，所以它是一个很好的可区分特征，就像是图1中，轮船和人在颜色，形状，纹理，光照等方面都有很大的不同，他们在梯度空间都存在共性。为了有效地利用观察结果，我们首先将输入图像重置为不同尺度的，在不同的尺度下计算梯度。然后再重置为取8 * 8大小的框，作为一个对应图像的64维的NG特征。<br>我们采用的NG特征，是一个密集的且紧凑的objectness特性，有以下几点优势：首先，由于归一化了支持域，所以无论对象窗口如何改变位置，尺度以及纵横比，它对应的NG特征基本不会改变。也就是说，NG特征是对于位置，尺度，纵横比是不敏感的，这一点是对于任意类别对象检测是很有用的。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823181219294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700"></div><p></p><p>&emsp;&emsp;图1 尽管对象（红色）和背景（绿色），在图像空间（a）呈现出了很大的不同，通过一个适当的尺度和纵横比，我们将其分别重置为固定大小(b)，他们对应的NG特征(c)表现出很大的共性,基于NG特征，我们学习了一个简单的64D线性模型（d），用来筛选对象窗口。<br>这种不敏感的特性是一个好的对象检测方法应该具备的。第二，NG特征的紧凑性，使得计算和核实更加有效率，而且能够很好的应用在实时应用程序中。<br>NG特征的缺点就是识别能力不够。但一般而言，会采用检测器来最终缺点结果的误报率。</p><h2 id="二、两级SVM训练："><a href="#二、两级SVM训练：" class="headerlink" title="二、两级SVM训练："></a>二、两级SVM训练：</h2><h3 id="1-SVM第一级训练"><a href="#1-SVM第一级训练" class="headerlink" title="1.SVM第一级训练"></a>1.SVM第一级训练</h3><p>&emsp;&emsp;首先，算法传递进入第一级SVM的样本总数，在超过SVM默认参数值时，采用SVM默认训练总样本数。用所有正样本以及剩下的数量采用随机从原负样本中抽取。即，负样本在这种情况下，不是全部参加SVM第一级训练。而是随机抽取一部分，保证总样本数达到SVM默认训练总样本数。<br>&emsp;&emsp;算法做一些SVM的初始化，涉及到样本标签Y，实际上，正样本默认都为有标签，以及SVM参数初始化等。<br>&emsp;&emsp;通过第一级SVM训练后，算法生成第一级SVM模型，转换成8 * 8，并归一化到1~255，保存。该模型w是用来下文中投票打分的，为第二级SVM学习做准备。</p><h3 id="2-二值化模型参数w"><a href="#2-二值化模型参数w" class="headerlink" title="2.二值化模型参数w"></a>2.二值化模型参数w</h3><p>&emsp;&emsp;首先通过上面的训练，我们可以得到分类的模型线性w，第一个要二值化的目标就是它，二值化的思想可以简单想象成找若干个基向量，并用这些基向量的线性组合来记表示w， 而且这些基向量的每一维只能取1或者-1（二值嘛）。那么假设我们用了Nw个基向量，每个基向量为aj, j = 1,…,Nw，那么就有<code>!$ w ≈  \sum_{j=1}^{N_w} \beta_j \alpha_j$</code>。具体模型的二值化近似可以按如下算法1的步骤进行：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823184337349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400"></div><p></p><p>&emsp;&emsp;算法1的步骤也很明确，每一个都生成一个基向量，此基向量每一维都是由当前残差的符号决定，然后用当前残差减去残差在这基向量的投影（相当于去掉模型在这一维上的分量）。但在计算中因为二进制位只能为0或者1，所以为了处理方便，取：$\alpha_j^+∈{ 0,1 }^{64}$,那么就可以将基向量表示为$\alpha_j = \alpha_j^+ - \overline{\alpha_j^+}$。即基向量二进制与该二进制表示的补。<br>&emsp;&emsp;也就是说，αj表示基向量{-1,1}，βj表示校准系数，同时，将每个基向量，映射到一个64位类型的数据中。<br>这里，实际上采用Gram-Schmidt正交化，只取了包含大部分信息的前Nw个正交向量作为输出，目的也是为了降低计算量。二值化的目的在于后期位运算，后面还会把NG特征也二值化。直接采用硬件指令大幅度地提升速度。<br>&emsp;&emsp;代码中，Nw取2，也就是SVM生成的W 是8 * 8矩阵，矩阵元素任意值，通过这个二值化过程，生成2个基向量，每个基向量完全覆盖了W中每个元素，但是此时在基向量中，每个元素对应的取值变成0或者1，因此，原w的64个元素，拼接成了一个64位的单个数据，即基向量。同时，对应该基向量的校准系数，算法为了后期加速，只近似处理高4位的数据，因此，校准系数只有保存4个，且都是一样的值，但是由于后期位移运算，这里就把校准值放置到了对应bit位。于是，2个基向量，生成8个校准系数，2个64位的数据。</p><h3 id="3-打分窗口"><a href="#3-打分窗口" class="headerlink" title="3.打分窗口"></a>3.打分窗口</h3><p>&emsp;&emsp;为了找到图像中的一般对象，对每张训练图像（注意，这里是原图像，不是标注框），进行上文生成正样本时得到所有尺度的量化，扫描每个尺度定义好的量化窗口（依据尺度或者是纵横比，也就是说，这里只是对原图像依据之前尺度系数做缩放，不是缩放到8 * 8,因此，才有下文的I）。每一个窗口通过上文得到模型w获得得分</p><p>$$<br>s_l = &lt; w,g_l &gt;(1)<br>$$</p><p>$$<br>l = &lt; i,x,y &gt;(2)<br>$$<br>&emsp;&emsp;$s_l$ 代表过滤器得分，  $g_l$ 代表NG特征，  $l$表示坐标，  $i$表示尺度，  $(x,y)$表示窗口位置。运用非最大抑制(NMS)，我们为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 * 100），一些尺度（例如:10 * 500）的窗口包含对象的可能性是很小的。因此我们定义对象状态得分（校准过滤器得分）：</p><p>$$<br>o_l = v_i · s_l + t_i  (3)<br>$$</p><p>&emsp;&emsp;只需要按位与和字节统计操作.下面解释如何得到b.<br>因此，为了实现（1）的快速计算，作者先用上面的算法，二值化了w,现在开始二值化NG，即gl参数，得到上面的b.</p><p>&emsp;&emsp;接下来我们还要对NG特征进行二值化，还记得我们刚才将NG归一化到[0,255]之间吧，那么8 * 8窗口上的每个点的NG特征值就可以用一个byte来存储，也就是每个值我们都可以用一个8位的二进制串来表示。那么我们就有一个8X8X8的三维矩阵，前两维是窗口位置（行，列），第三维是在二进制串中的位置（页）。举个例子，比如窗口中第1行，第2列的NG特征值是192，换成二进制就是1100 0000，那么矩阵的元素（1,2,1） = （1,2,2）= 1，（1,2,3），…,（1,2,8）= 0;那么我们一页一页地将矩阵元素取出来，再将每页8X8的矩阵元素排成一个64位的二进制串并存进一个int64里。既然思路已经有了，做法也就很简单了：对于每一页，将每一行每个元素取出来，不断加入int64中并左移1位，最后得到那个int64每一位对应的元素坐标排列就应该是（1,1）（1,2）（1,3）…(8,8)。然后作者在这里又玩了一个trick，他说你这样每次移动一位不是要循环64次嘛，如果先将8个拼成一组（就是刚才那样左移1次），那么只需要移动8组就好了啊！而且，这样在相邻的窗口中还能重用重叠的部分（在VS2010 的Debug模式下我试了下，1个数“每次左移1位，移动1万次”和“每次左移100位，移动100次”两种情况，的确是后者速度快）。<br>最后，为了进一步节省存储空间，还可以只取NG值的高位来作二值化。因为比如192和193、194，它们的二进制表达分别是1100 0000， 1100 0001和 1100 0010，要是我只看前面4位，后面4位忽略（取0）的话，那么它们的取值都是192。也就是我们可以用192来约等于193和194，这样我们就不需要用到8位那么多了！写成公式就是下面的式（2）这样，其中Ng 是我们要用的高位的位数（也就是前面说的三维矩阵的页）,bk,l就是对应三维矩阵中的第k页（二值）。</p><p>最后将二值化模型w和二值化NG，结合起来对窗口打分的操作由卷积运算变成了大部分是位运算操作，</p><p>&emsp;&emsp;一个图像窗口对应的BING特征  $b_{k,l}$ 的过滤器得分,见式(1),可以表示为：</p><p>$$<br>s_l≈ \sum_{j=1}^{N_w}\beta_j\sum_{k=1}^{N_g}C_{j,k}<br>$$</p><p>&emsp;&emsp;其中，  $C_{j,k} = 2^{8-k}(2&lt; \alpha_j^+,b_{k,l}&gt;-|b_{k,l}|)$可以通过一些快速的按位操作以及SSE指令操作计算得到。</p><p>&emsp;&emsp;然后，运用非最大抑制(NMS)，做下滤波。</p><p>&emsp;&emsp;总结一下：首先，根据第一级SVM得到模型参数w,对每张训练图像，进行所有尺度变换（不是固定8*8大小），然后计算NG特征，接着根据上文的打分系统，计算每个尺度下的sl（实际上，二值化w和二值化NG特征，就是BING特征）.并重新排序，利用NMS消除掉高分点附近领域内的打分值。这里只选择指定阈值以上的高分点。然后，在原始图像，找到对应打分点对应的方框大小，并保存。这样，针对每张图像，我们计算了不同尺度i下的打分项以及相对应的可能目标匡。然后，针对所有可能的目标匡，我们将其与原始图像中所有有效正样本做重叠率比对，只要有一个正样本框与该可能目标匡重叠与大于0.5，则该可能目标匡作为正样本，否则为负样本。在传入第二级SVM时，作者将可能目标框的打分值，重新根据尺度整合，即不同尺度下下，所有的打分值，作为正负样本。在第二级训练时，针对每个尺度，训练一次。</p><h3 id="4-第二级SVM训练"><a href="#4-第二级SVM训练" class="headerlink" title="4.第二级SVM训练"></a>4.第二级SVM训练</h3><p>&emsp;&emsp;作者针对每种尺度下的打分值，训练SVM，每种尺度下样本总数不超过10W。超过，则随机在正负样本中抽取。确保先读取正样本，后需剩余的位置随即用负样本填满。训练结束后，生成新的权值vi,ti.</p><h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>&emsp;&emsp;在读入测试图片后，计算图像的BING特征，跟二级SVM训练预处理一样，对图像进行不同尺度的缩放，计算NG，打分统计得到sl（用的还是第一级模型的w）</p><p>&emsp;&emsp;然后，为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 * 100），一些尺度（例如:10 * 500）的窗口包含对象的可能性是很小的。<br>&emsp;&emsp;针对不同尺度i的窗口，得到不同的独立学习系数。使用校准函数(3)是非常快的，通常只需要在最终的建议窗口重排。<br>这里，打分用的权值是二级模型训练出的，即上文的vi,ti.得到ol重新排序。整个过程，计算时间，给出每个检测图象的平均测试时间。并保存打分结果与对应的目标框。</p><p>&emsp;&emsp;打分越高，越接近目标。实际上，算法生成的就是打分窗口，也就是所为的对象状态。下面测试的时候，根据打分窗口与标注的测试窗口重叠率大于0.5就认为检测到了。<br>接着，作者开始绘制结果，根据检测出的候选框与每个测试标注框计算重叠率，大于0.5，就认为检测到了，否则score为0未检到。之后，计算平均重叠率和平均检测率。</p><p>这里解释下重叠率：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823185011109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700"></div><p></p><p>&emsp;&emsp;上面的精度曲线称为DR-#WIN curves，源自TPAMI 2012的一篇论文：Measuring the objectness of image windows。原文还提出了将窗口数量比如[[0,5000]归一化到[0,1]之间，用曲线下的面积作为目标检测的度量结果，并称之为the area under the curve(AUC)，这样AUC的范围就在[0,1]之间了。</p><p>&emsp;&emsp;DR的计算是参考The PASCAL Visual Object Classes (VOC) Challenge，目标检测任务中DR的计算的是true/false positive精度，将算法检测目标结果放到groud truth中，将“预测目标区域与groud truth区域的交集”除以“预测目标区域与groud truth区域的并集”作为DR：</p><p>&emsp;&emsp;DR自少在50%以上才算目标检测正确，其实，50%已经是很低的了，几乎不能做为检测结果。</p><p>&emsp;&emsp;自己在程序中加了单张图片测试的显示部分，如果有同学需要可以私信我。</p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="BING" scheme="http://yoursite.com/categories/BING/"/>
    
    
      <category term="BING" scheme="http://yoursite.com/tags/BING/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>BING: Binarized Normed Gradients for Objectness Estimation at 300fps</title>
    <link href="http://yoursite.com/2019/11/08/2017-10-01-bing-1/"/>
    <id>http://yoursite.com/2019/11/08/2017-10-01-bing-1/</id>
    <published>2019-11-08T02:45:04.337Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><div align="center"><font color="black" size="6" face="仿宋">BING: Binarized Normed Gradients for Objectness Estimation at 300fps</font></div></strong><br><strong><div align="center"><font color="black" size="6" face="仿宋">基于二值化赋范梯度特征的一般对象估计</font></div></strong></p><p><strong><font color="black" size="5" face="仿宋">摘要：</font></strong></p><p>&emsp;&emsp;训练通用对象度量来生成一小组候选对象窗口，已经显示出加速了经典的滑动窗口对象检测范式。我们观察到，通过观察梯度的标准，可以通过将其对应的图像窗口适当地调整到小的固定尺寸来区分具有良好定义的闭合边界的通用对象。基于这个观察和计算复杂度，我们建议将窗口大小调整为8*8并使用赋范梯度作为简单的64D特征来描述，用于明确地训练通用的对象度量。</p><p>&emsp;&emsp;我们进一步展示了这种特征的二值化版本，即二值化赋范梯度（BING），它可以用于高效的对象估计，这只需要少量的原子操作（例如加法，按位移动等）。对有挑战性的PASCAL VOC 2007数据集的实验表明，我们的方法有效生成一小组类别无关的高质量对象窗口（单个笔记本电脑CPU上的300fps），通过使用1,000个建议窗口，产生96.2％的对象检测率（DR）。通过增加建议窗口和颜色空间的数量来计算BING特征，我们的性能可以进一步提高到99.5％的DR。</p><p>&emsp;&emsp;作为计算机视觉中最重要的领域之一，近年来，对象检测取得了长足的进步。然而，大多数最先进的检测器仍然需要每个类别的特定分类器以滑动窗口方式评估许多图像窗口[17,25]。为了减少每个分类器需要考虑的窗口数量，训练类别通用的对象度量最近变得流行[2,3,21,22,48,49,57]。对象通常表示为反映图像窗口覆盖任何类别的对象的可能性的值[3]。通用对象度量在预过滤过程中具有很大的潜力，可以显着改善：i）通过减少搜索空间来提高计算效率，以及ii）通过允许在测试期间使用强分类器来提高检测精度。然而，设计好的通用对象度量方法是困难的，需要：</p><ul><li>具备很好的检测率，找到所有前景对象；</li><li>提出少量建议，用于减少对象检测的计算时间；</li><li>达到很高的计算效率，很容易拓展到其他实时以及大规模的应用程序中；</li><li>具备很好的通用性，方便用于各个类别的检测器中，这样可以减少计算量</li></ul><p>&emsp;&emsp;据我们所知，暂时还没有任何方法可以同时满足以上全部要求。</p><p>&emsp;&emsp;认知心理学[47,54]和神经生物学[20,38]的研究表明，人们在识别物体之前具有很强的感知对象能力。 基于观察到的人类反应时间和估计的生物信号传播时间，人类注意理论假设人类视觉系统仅处理图像的一部分，而对图像的其余部分几乎视而不见。这进一步表明，在识别对象之前，在人类视觉系统中有简单的机制来选择可能的对象位置。</p><p>&emsp;&emsp;在本文中，我们提出了一个非常简单而又强大的特征“BING”，通过使用对象状态分数来帮助搜索对象。我们的工作动机是基于物体是具有明确的封闭边界和中心的独立事物[3，26，32]的事实。我们观察到，当查看赋范梯度（见图1和图3）时，将其相应的图像窗口大小调整为小的固定大小（例如8 * 8）后，具有明确定义的闭合边界的通用对象具有惊人的强相关性）。因此，为了有效地量化图像窗口的目标，我们将其大小调整为8 * 8，并使用梯度的范数作为一个简单的64D特征，用于在级联SVM框架中学习通用对象度量。我们进一步展示了NG功能的二值化版本，即二值化规范梯度（BING）功能，可以用于图像窗口的有效对象估计，只需要几个原子CPU操作（即加法，按位移动等） ）。 大部分现存的先进方法，一般采用复杂的分类特征，而且需要采用加速方法以至于计算时间是可控的，相对于此，BING特征是简单朴素的。</p><p>&emsp;&emsp;我们已经在PASCAL VOC2007数据集上，广义的评价了我们的方法。实验结果表明，我们的方法有效（在单个笔记本电脑CPU上为300fps）生成一小组数据驱动，类别无关，高品质的对象窗口，通过使用1000个窗口（约为整个滑动窗口的0.2%），产生96.2％的检测率（DR）。将目标窗口数量增加到5000个，估计3个不同颜色空间的对象，我们的方法可以达到99.5％的DR。在[3,22,48]之后，我们也验证了我们的方法的泛化能力。当我们对6个物体类别的对象度量进行训练时，对其他14个不可见的类别进行测试，我们观察到与标准设置类似的高性能（见图3）。与大多数流行的替代方案相比[3,22,48]，BING功能使我们能够使用较小的提议来实现更好的DR，而且能够预测不可见的类别，更简单，更快1000倍。这满足了良好的目标检测器的上述要求。我们的源代码将与论文一起发布。</p><p><strong><font color="black" size="5" face="仿宋">2.相关工作</font></strong></p><p>&emsp;&emsp;能够在识别物体之前感知物体与自下而上的视觉注意（显着性）密切相关。根据显著性定义，我们将相关研究大致分为三类：固定点预测、显著性对象检测，对象提案生成。</p><p>&emsp;&emsp;固定点预测：该模型旨在预测人眼运动的显着性[4,37]。 灵感来自神经生物学研究关于早期灵长类动物视觉系统，Itti等人[36]提出了显着检测的第一个计算模型之一，其估计了多尺度图像特征中的中心包围的差异。Ma和Zhang[42]提出了一种模糊增长模型来分析局部对比度显着性。Harel等人[29]提出了将中心包围的特征图归一化以突出显眼部分。虽然固定点预测模型已经取得了显着的发展，但预测结果倾向于突出边缘和角落而不是整个对象。因此，这些模型不适合生成用于检测目的的对象提案。</p><p>&emsp;&emsp;显著性对象检测：该模型尝试检测场景中最引人注意的对象，然后对该对象的整个范围进行细分[5,40]。Liu等人[41]将CRF框架中的局部，区域和全局显着性检测结合起来。 Achanta等人[1]使用频率调节方法的局部显着区域。 Cheng等[11,14]提出了一种基于区域对比分析和迭代图分割的显著性对象检测和分割方法。最近的研究还试图在基于滤波的框架[46]中生成高质量的显着性图，使用有效的数据表示[12]或考虑分层结构[55]。对于简单图像的这种显著性物体分割在图像场景分析[15,58]，内容感知图像编辑[13,56,60]中取得了巨大的成功，并且可以用作处理大量互联网图像或构建的便宜工具通过自动选择好的结果[10,11]，可以很好的应用[7,8,16,31,34,35]。然而，这些方法不太可能用于呈现许多对象的复杂图像，并且它们很少占主导地位（例如VOC[23]）。</p><p>&emsp;&emsp;对象提案生成：该方法通过提出少量（例如1,000个）类别无关的提案，并不作出决定，将覆盖图像中的所有对象[3,22,48]。生成粗略分割[6,21]作为对象提案已被证明是减少针对特定分类器的搜索空间的有效方法，同时允许使用强分类器来提高准确性。然而，这两种方法在计算上是昂贵的，每个图像需要2-7分钟。 Alexe等人[3]提出了一种提示集成方法，以更有效地获得更好的预测性能。张等人[57]提出了一种具有定向梯度特征的级联排序SVM方法，用于有效的提案生成。 Uijlings等人[48]提出了一种选择性搜索方法来获得更高的预测性能。我们提出一种简单而直观的方法，通常可以比其他方法更好地实现检测性能，并且比最流行的替代品快了1000倍[3,22,48]（见第4节）。</p><p>&emsp;&emsp;另外，对于一个有效的滑动窗口对象检测方法，保证计算量可控是非常重要的[43,51]。Lampert等人[39]提出了一个优雅的分支定界方法用于检测。但是，这些方法只能用于加速分类器，而且是用户已经提供了一个好的边框。一些其他有效的分类器[17]和近似核方法[43,51]也已经被提出。这些方法旨在减小估计单个窗口的计算量，自然也能结合对象性建议进而减小损失。</p><p><strong><font color="black" size="5" face="仿宋">3.方法</font></strong></p><p>&emsp;&emsp;灵感来自人类视觉系统的能力，在识别物体之前有效地感知对象[20,38,47,54]，我们引入了梯度（NG）特征（第3.1节）的简单64D范数，以及其二进制近似 ，即二值化赋范梯度（BING）特征（第3.3节），以有效捕获图像窗口的对象性。</p><p>&emsp;&emsp;为了找到图像中的一般对象，我们扫描一个定义好的量化窗口（依据尺度或者是纵横比）。每一个窗口通过一个线性模型  $w ∈ R64$ 获得得分</p><p>$$<br>s_l = &lt; w,g_l &gt;(1)<br>$$</p><p>$$<br>l = &lt; i,x,y &gt;(2)<br>$$</p><p>    $s_l$ 代表过滤器得分，  $g_l$ 代表NG特征，  $l$ 表示坐标，  $i$ 表示尺度，  $(x,y)$ 表示窗口位置。运用非最大抑制(NMS)，我们为每个尺度提供一些建议窗口。相对于其他窗口（例如：100 * 100），一些尺度（例如:10 * 500）的窗口包含对象的可能性是很小的。因此我们定义对象状态得分（校准过滤器得分）：</p><p>$$<br>o_l = v_i · s_l + t_i  (3)<br>$$</p><p>  其中  $v_i，t_i∈ R$ ，针对不同尺度  $i$ 的窗口，得到不同的独立学习系数。使用校准函数（3）是非常快的，通常只需要在最终的建议窗口重排之后进行。</p><p>3.1 梯度幅值（NG）和对象状态</p><p>  对象是具有明确界限的边界和中心的独立事物[3,26,32]。当将与现实世界对象相对应的窗口大小调整为小的固定大小（例如8 * 8，由于计算原因而选择，将在第3.3节中进行说明）时，相应图像梯度的范数（即幅度）将成为良好的辨别特征，因为封闭边界在这种抽象视图中可能存在的小变化。如图1所示，虽然游轮和人在颜色，形状，质地，照明等方面有很大的差异，但它们在赋范梯度空间中具有明显的相关性。为了有效地预测对象实例的存在，利用这一观察，我们首先将输入图像的大小调整为不同的量化尺寸，并计算出每个调整大小的图像的规范梯度。这些调整大小的规范梯度图的8 * 8个区域的值被定义为其对应窗口的64D规范梯度（NG）特征。</p><p>  我们的NG特征，作为图像窗口的密集和紧凑的对象特征，具有以下几个优点。 首先，无论物体的位置，尺度和纵横比如何变化，由于该特征的归一化支持区域，其对应的NG特征将保持大致不变。 换句话说，NG特征对于位置，比例和纵横比的变化不敏感，这对于检测任意类别的对象非常有用。而这些不敏感的属性就是一个很好的对象建议生成方法。 其次，NG特征的密集紧凑表示使得计算和验证非常有效，因此具有很大的实际应用潜力。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823181219294?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700"></div><p></p>Figure 1 尽管对象（红色）和背景（绿色），在图像空间（a）呈现出了很大的不同，通过一个适当的尺度和纵横比，我们将其分别重置为固定大小(b)，他们对应的NG特征(c)表现出很大的共性,基于NG特征，我们学习了一个简单的64D线性模型（d），用来筛选对象窗口。"    将这种优势引入NG特征的成本是丧失描述能力。 幸运的是，所产生的误报将由后续的类别特定检测器处理。 在第4节，我们显示我们的方法产生了一小组高质量的提案，涵盖了具有挑战性的VOC2007数据集中的96.2％的真实对象窗口。<p>3.2 objectness度量</p><p>  为了学习图像窗口的对象度量，我们遵循两级SVM的总体思路[57]。</p><ul><li><p>使用线性SVM学习式（1）中的单个模型w [24]。 真实对象窗口和随机采样背景窗口的NG特征分别用作正和负训练样本。</p></li><li><p>在（3）中使用线性SVM学习  $v_i$ 和  $t_i$ [24]，我们评估（1）在尺寸  $i$ 上训练图像，并将所选择的（NMS）提案作为训练样本，将它们的过滤分数作为1D特征，并使用训练图像注释检查其标签（有关评估标准，请参阅第4节）。</p></li><li><p>讨论：如图1d所示，学习的线性模型w（参见实验设置的第4节）看起来类似于假设为灵长类动物的生物似然结构的多尺寸中心包围模式[27,38,54]。 沿着边界的大的权重有利于将物体（中心）与其背景（包围）分开的边界。 与手动设计的中心环绕模式[36]相比，我们学到的w捕获更复杂更自然的前景。 比如，低层面的对象相对于高层面的部分要更加阻塞。也就表示模型w中会给予低层次的对象更低的置信度。</p></li></ul><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823184337349?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400"></div><p></p><p>3.3 二值化梯度幅值(BING)</p><p>  为了能够利用二值化近似模型[28,59]中的优点，我们提出了一个NG特征的加速版，二值化赋范梯度，加速特征提取和测试过程。我们学习的线性模型w∈R64可以通过算法1近似表示为一系列基向量的组合  $ w ≈  \sum_{j=1}^{N_w} \beta_j \alpha_j$ 。</p><p>  其中  $N_w$ 表示基向量的个数，  $\alpha_j∈{ -1,1 }^{64}$ 表示基向量，  $\beta_j∈R$ 表示校准系数。  $\alpha_j$ 可以进一步表示为二值向量和它的补：  $\alpha_j = \alpha_j^+ - \overline{\alpha_j^+}$ , 其中  $\alpha_j^+∈{ 0,1 }^{64}$ ,由  $α$ 二值化之后得到的  $b$ 可以被直接用于测试，而且只需要按位与和字节统计操作[28]</p><p>$$<br>&lt; w,b &gt; ≈ \sum_{j=1}^{N_w}\beta_j(2&lt; \alpha_j^+,b&gt;-|b|)  (4)<br>$$</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823184540642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400"></div><p></p><p>  关键过程就是如何二值化以及有效的计算NG特征。我们近似采用梯度幅值（以及转化为01字节）的前Ng位来作二值化。因此，64维 NG特征  $g_l$ 值可以通过前Ng位二值化梯度幅值(BING)近似表示为：</p><p>$$<br>g_l≈ \sum_{k=1}^{N_g}2^{8-k}b_{k,l}  (5)<br>$$</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823184656137?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="400"></div><p></p>Figure 2 变量说明：BING特征  $b_{x,y}$ ,它的最后一行是  $r_{x,y}$ ，最后一个元素  $b_{x,y}$ 。注意出现在式(2)和式(5)中的下标  $i, x, y, l, k,$ 这些是定位整个向量而不是向量元素的索引。我们可以用一个简单的原子变量(INT64和BYTE)表示BING特征和它的最后一行，这样能够更有效的进行特征计算。<p>  注意：这些BING特征拥有不同的权重，依据它原本不同的字节位。获取8 * 8的BING特征一般需要遍历64位，依据8 * 8 BING特征的两个特征，我们提出了一个快速的特征计算方法，能够只使用一些简单的原子操作（按位或和按位移动）避免循环计算。</p><p>  第一，BING特征  $b_{x,y}$ 以及它的最后一行  $r_{x,y}$ 可以存储在一个简单的INT64和一个BYTE变量中；第二，相邻的BING特征以及他们的行之间拥有一个简单的累积关系。如图2，将  $r_{x-1,y}$ 按位移动1位，这1位将自动进位到  $r_{x,y}$ ，插入  $b_{x,y}$ 的过程可以用按位或来实现。同样，将  $b_{x-1,y}$ 按位移动8位，这8位将自动进位到  $b_{x,y}$ ，自动插入  $r_{x,y}$ 。</p><p>  我们的BING特征有效的利用了整体图像之间的累积性质[52]。与之前的方法在任意矩形范围内计算一些值不同的是，我们采用一些原子操作在一个固定8 * 8大小范围内计算一系列二进制模式。</p><p>  一个图像窗口对应的BING特征  $b_{k,l}$ 的过滤器得分,见式(1),可以表示为：</p><p>$$<br>s_l≈ \sum_{j=1}^{N_w}\beta_j\sum_{k=1}^{N_g}C_{j,k}  (6)<br>$$</p><p>  其中，  $C_{j,k} = 2^{8-k}(2&lt; \alpha_j^+,b_{k,l}&gt;-|b_{k,l}|)$ 可以通过一些快速的按位操作以及SSE指令操作计算得到。</p><p>  实现细节：我们使用一维的标识[-1,0,1]，来定义水平方向和垂直方向上的图像梯度  $g_x$ 和  $g_y$ ，当计算梯度幅值是采用  $min(|g_x|+|g_y|,255)$ ,然后将其存入一个BYTE中。</p><p><strong><font color="black" size="5" face="仿宋">4.实验评估</font></strong></p><p>  我们在VOC2007数据集上实验评估了我们的方法，使用的是DR和WIN的评估标准，与3个现存最先进的方法建议质量、通用性以及效率上做了对比。正如[3,48]，一系列高检测率的粗糙集对于有效对象检测是足够了的，，而且它允许使用复杂的特征和补充线索来得到比传统方法更好的质量和更高的效率。在对比试验中，我们采用的对应作者公布的实现方式和建议的参数设置。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823185011109?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700"></div><p></p>Figure 3 不同方法关于#WIN和DR的权衡曲线。我们的方法使用1000建议窗口，达到了96.2%DR，使用5000个建议窗口可以达到99.5DR.其他三个方法我们采用了相同的评估标准，可以看出来优于一些其他的方法[6,21,25,30,50]，显著性测量[33，36]，特征点检测[44]以及HOG检测[17].<p>  建议质量对比：参照[3,48,57]，我们在数据集VOC2007上采用DR-WIN评估测试集，该数据集包含4952张20个类别的带有边框注释图像。数量巨大，种类繁多，视角、尺度、位置、阻塞、光照等都有不同，这些特点非常符合我们识别所有对象的要求。图3展示了数据统计对比，对比的方法有：OBN[3]，SEL[48]，以及CSVM[57]。正如[48]，通过收集不同参数设置下的结果，可以增加建议窗口的离散度，也能提高检测率DR，当然也需要提高建议窗口的数量（#WIN）。SEL[48]组合了80个不同参数设置的结果，达到了99.1%的DR和使用了10000多个建议窗口。我们的方法达到99.5%的DR，但只需要5000个建议窗口，而且仅仅收集了3个颜色空间的结果（RGB，HSV，GRAY）。如同DR-#WIN数据分析展示的那样，我们简单的方法在总体上达到了更好的效果，速率上比最流行的的方法[3,22,48]提升了3个数量级（见表格1），我们举例阐述了一些不同复杂度下的结果，如图4.</p><p>  通用性测试：参照[3]，为了证明我们的方法具有通用性，采用包含未训练类别的对象图像进行测试。我们采用6个类别的对象训练我们的方法，通过剩下的14个类别进行测试。图3中，训练和测试是通过BING和BING-generic表示的。正如我们看到了那样，两个曲线基本一致，证明了我们方法的通用性。</p><p>  最近的工作[18]能够在20秒内检测100000对象类别，主要采用的是减低传统多类别计算复杂度从O(LC)到O(L),L表示推荐窗口的数量，C表示分类器的数量。我们的方法可以得到任意类别（训练过的以及未训练的）的高质量的推荐窗口，可以通过减小L来显著减少计算复杂度。</p><p>  计算时间：见表1，我们的方法可以在300fps的视频中，提供高效率的提供高质量的对象窗口，其他的方法对一张图片都需要几秒。这些方法通常是作为现存最先进的算法，而且很难大幅度的提升速度。我们在2501张图片上的训练需要很少的时间（包括加载XML文件，总共20S），而现有的先进的方法[6,21]测试一张图片通常需要多于2分钟.</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823185136104?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="200"></div><p></p>Table 1 在VOC2007上的平均计算时间<p>  如表2，通过采用二进制近似的方法学习线性过滤器和BING特征提取，计算每个图像窗口的得分只需要一些原子操作。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823185234675?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="300"></div><p></p>Table 2 用于计算不同阶段每个图像窗口的对象的平均原子操作数：计算规范梯度，提取BING特征，并获得对象分数。<p>  在每个标准化的尺度和纵横比下，定位的数量相当于O（N），N代表图像中的像素数.因此，在所有尺寸和纵横比的图像中，计算得分的复杂度也是O(N)。在每一个潜在的位置上，提取BING特征和计算得分可以利用它邻近的2个位置(例如：左和上)。这意味着空间复杂度也是O(N)。我们在同一个Intel i7-3940XM CPU上，对比其他基准方法[3,2，，48,57]的运行时间。</p><p>  如表3，我们可以进一步意识到，不同的近似对结果质量的影响，通过对比我们在其他试验中采用Nw=2，Ng=4.</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20170823185400065?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="250"></div><p></p>Table 3 在不同近似层下的，平均检测结果（DR，使用1000个建议窗口），控制（Nw和Ng），N/A表示没有近似。<p></p><div align="center"><img src="http://img.blog.csdn.net/20170823185822979?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" width="800" height="700"></div><p></p>Figure 4 在VOC2007上的真实的测试样例。<p><strong><font color="black" size="5" face="仿宋">5.结论以及将来的工作</font></strong></p><p>  我们呈现了一个非常简单，快速而且高质量的objectness方法，通过采用BING特征，计算任意尺度和纵横比的图像窗口中，我们仅仅需要一些原子操作（加，按位等）。通过最广泛的基准（VOC2007）和DR-#WIN评估标准进行结果评价，结果表明，与其他现存先进方法[3,22,48]相比，我们的方法不仅表现突出，而且速度上提升了3个数量级。</p><p>  局限性： 与其他objectness方法[3,57]和滑动窗口[17,25]一样，我们都预测了一系列的对象矩形边框，因此，也有相似的局限性，对于一些类别的对象，一个矩形框并不能很好的集中实体，以便用来进行区域分割[6,21,33,45]，例如蛇。</p><p>  进一步的工作：由于我们的方法具备高质量以及高效率的特性，所以它很适合实时多类别的对象检测和大规模图像收集应用程序（如：ImageNet[19]）。由于使用的简单的二进制操作，而且空间效率高，使得我们的方法可以在普通的设备上运行[28,59]。</p><p>  我们的加速策略主要是减少窗口数量，这个可以通过其他的加速技术（通常旨在减少分类时间）来实现。将我们的方法和[18]的方法的进行组合将是很有趣的这样能够在一个机器上实时检测数以千计类别的对象。我们的方法解决了基于对象检测方法[53]的效率屏障，使得能够进行实时的高质量的对象检测。</p><p>  通过使用简单的BING特征，我们能够使用一小部分（1000）的建议窗口得到涵盖几乎（96.2%）所有的对象区域。引入新的线索进一步降低建议窗口的数量，以便维持高效率的对象检测，以及在更多的应用程序[9]上使用BING特征，将是很值得研究的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;div align=&quot;center&quot;&gt;&lt;font color=&quot;black&quot; size=&quot;6&quot; face=&quot;仿宋&quot;&gt;BING: Binarized Normed Gradients for Objectness Estimation at 300fps&lt;/
      
    
    </summary>
    
    
      <category term="BING" scheme="http://yoursite.com/categories/BING/"/>
    
    
      <category term="BING" scheme="http://yoursite.com/tags/BING/"/>
    
  </entry>
  
  <entry>
    <title>我的个人博客之旅：从jekyll到hexo</title>
    <link href="http://yoursite.com/2019/11/08/2018-01-10-HEXO/"/>
    <id>http://yoursite.com/2019/11/08/2018-01-10-HEXO/</id>
    <published>2019-11-08T02:45:04.334Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>[toc]</p><hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;喜欢写Blog的人，会经历三个阶段。</p><ul><li>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。</li><li>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</li><li>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</li></ul><p>引自<a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">阮一峰</a></p><p>&emsp;&emsp;第一阶段我已经经历过了，目前在CSDN的文章仍然在更新。但是作为一个免费空间，一个技术博客的聚集地，其管理和运营虽说正在变得越来越好，但是恶心人的事件也时有发生，比如对新手不友好的审核机制、近期改版造成的各种不兼容问题。</p><p>&emsp;&emsp;于是，就想着挣脱枷锁，向第二第三阶段发展。</p><p>&emsp;&emsp;我这人吧凡事都考虑的比较详尽，，我感觉我如果再去经历第二阶段的话既浪费精力又消耗时间，而且自己也过了玩网站、玩博客的年纪，如果申请个域名再搞个网站，我不知道这股热度会持续多久。</p><p>&emsp;&emsp;所以，我就直接跳到了第三个阶段，开始在github上搭建自己的博客。由于自己对前端一无所知，即使使用现成的博客框架，刚开始玩的时候特别费劲。但是经过不断摸索，我的博客已经基本成型，传送门开启：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a> <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于gitee</a>。</p><p>&emsp;&emsp;本篇博文并不打算长篇大论的介绍基于GitHub Pages或者Gitee Pages搭建博客的步骤，因为这类的文章实在是太多了，青菜萝卜又各有所爱，不如给出资源，让大家自己折腾。所以我只是在此有序贴出我在搭建博客的过程中用到的各种有用资源，以及搭建博客的大致流程，也算是对我这段时间的一个告别仪式吧。</p><h2 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h2><p>&emsp;&emsp;我想在GitHub Pages推出之前，由于技术门槛的存在，第三个阶段应该会很少有人涉足。所以在开始一切之前，我们先来看看什么是<a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a>。</p><p>&emsp;&emsp;Github Pages 是面向用户、组织和项目开放的公共静态页面搭建托管服 务，站点可以被免费托管在 Github 上，你可以选择使用 Github Pages 默 认提供的域名 github.io 或者自定义域名来发布站点。Github Pages 支持 自动利用 Jekyll 生成站点，也同样支持纯 HTML 文档，将你的 Jekyll 站 点托管在 Github Pages 上是一个不错的选择。</p><p>&emsp;&emsp;网站首页就是搭建GitHub Pages的过程其中第一步之后，选择不同的git客户端选项，会出现相应的初始化步骤，很人性化。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110111003603?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>&emsp;&emsp;大家可以跟着上面的链接先在自己的github新建仓库，仓库名称为username.github.io，其中username要替换成你github的名称，比如我的github名称为wordzzzz，所以我新建的仓库就应该是wordzzzz.github.io。那么等我以后搭建好了我的博客，我就可以通过<a href="https://wordzzzz.github.io来访问我的主页了。" target="_blank" rel="noopener">https://wordzzzz.github.io来访问我的主页了。</a></p><p>&emsp;&emsp;到现在为止，只是搭建博客的准备工作。搭建博客的下一步是选择合适的静态博客框架。</p><h2 id="jekyll-or-hexo"><a href="#jekyll-or-hexo" class="headerlink" title="jekyll or hexo"></a>jekyll or hexo</h2><p>&emsp;&emsp;目前有两大静态博客主流框架：<a href="http://jekyllcn.com/" target="_blank" rel="noopener">jekyll</a>和<a href="https://hexo.io/" target="_blank" rel="noopener">hexo</a>。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110111311091?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110111420247?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>&emsp;&emsp;我一开始用的是jekyll，这是中文社区翻译出来的<a href="http://jekyllcn.com/" target="_blank" rel="noopener">中文开发文档</a>。我使用的主题是<a href="https://mmistakes.github.io/minimal-mistakes/" target="_blank" rel="noopener">Minimal Mistakes</a>，开发文档很详细。但是后来由于jekyll体验不是很好（中文资料少，我英语比较差我会说嘛），依赖环境总是出问题（需要安装ruby），markdown采用的是Kramdown（Kramdown对我之前的一些博客格式支持的不是很好，我自己写文档用的都是小书匠，然后发表到CSDN，所以并不想花时间在改格式上面），而且我使用的这个主题是个人维护的，种种原因导致最后做出来的博客很难符合我的胃口，最后被我扔进了停尸房<a href="https://github.com/WordZzzz/jekyll_mysite" target="_blank" rel="noopener">jekyll_mysite</a>。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110111512090?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110111533728?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>&emsp;&emsp;就在我将要放弃之时，hexo拯救了我。对，没错，它有<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">中文开发文档</a>。而在hexo界，使用最多的主题就是<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next</a>了。光是看到这两份资料，我就已经激动的不行了，这种扁平化设计的网站，不就正是我需要的么。加上详尽的开发文档和丰富的第三方接口，让我对它爱不释手。最终定稿了自己的个人博客，存储在github<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于github</a>和gitee<a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">wordzzzz的个人博客-托管于gitee</a>上。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110142732584?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110142739639?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><h2 id="next主题"><a href="#next主题" class="headerlink" title="next主题"></a>next主题</h2><p>&emsp;&emsp;next主题支持三种外观显示，支持多国语言，5套代码高亮主题，可以深度定制。在其<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Github</a>上，更是有三个主题的代表作，其中我最喜欢的莫过于基于Muse scheme的<a href="https://notes.wanghao.work/" target="_blank" rel="noopener">wanghao的博客</a>。于是，我就在wanghao的博客的基础上进行了相应的更改，形成了我现在的博客，主题文件全部在我的<a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">github</a>上，欢迎大家fork、star、follow。</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180110114341558?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></div><p></p><p>&emsp;&emsp;其实先按照hexo配置开发环境，再按照next文档配置站点文件，完全可以轻松搭建起自己的博客。但是还是藏不住内心那颗年轻的心啊，终究还是搜罗了一些好玩的东西放到了自己的博客上，比如音乐播放器。</p><p>&emsp;&emsp;下面我先简单介绍一下基于github平台、hexo框架的next主题博客开发步骤：</p><ul><li><a href>Github上新建username.github.io仓库并初始化</a></li><li><a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">PC端安装hexo及其依赖项并熟悉开发流程</a></li><li><a href="https://github.com/WordZzzz/hexo-next" target="_blank" rel="noopener">下载我的主题文件</a>或者<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">下载next主题文件</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">按照next官方教程验证主题</a></li><li><a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="noopener">按照next官方教程配置站点文件和主题文件</a></li><li><a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">按照next官方教程集成第三方服务</a></li><li><a href="https://hexo.io/zh-cn/docs/generating.html" target="_blank" rel="noopener">生成静态文件</a></li><li><a href="https://hexo.io/zh-cn/docs/server.html" target="_blank" rel="noopener">开启本地服务查看站点效果</a></li><li><a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">部署至Github</a></li></ul><p>&emsp;&emsp;文档都非常详细，下面我主要就第三方服务做一些说明。我提到的大部分三方服务在<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>都提及到了，所以具体配置大家跟着官方文档走就行，我只是为每一类服务选择哪个做一下建议。</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>&emsp;&emsp;我用的韩国的<a href="https://livere.com/" target="_blank" rel="noopener">livere</a>，从国内到国外，支持几乎全部社交账号登陆，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><p>&emsp;&emsp;<a href="https://tongji.baidu.com/web/welcome/login" target="_blank" rel="noopener">百度统计</a>和<a href="https://www.google.com/intl/zh-CN/analytics/" target="_blank" rel="noopener">google分析</a>我都加上了，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="阅读量统计"><a href="#阅读量统计" class="headerlink" title="阅读量统计"></a>阅读量统计</h3><p>&emsp;&emsp;我用的<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>，具体操作步骤请直接跳转至<a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener"> 为NexT主题添加文章阅读量统计功能</a>。</p><h3 id="内容分享服务"><a href="#内容分享服务" class="headerlink" title="内容分享服务"></a>内容分享服务</h3><p>&emsp;&emsp;我采用的是<a href="https://github.com/revir/need-more-share2" target="_blank" rel="noopener">need-more-share2</a>，直接在主题配置文件里面打开就行。</p><h3 id="搜索服务"><a href="#搜索服务" class="headerlink" title="搜索服务"></a>搜索服务</h3><p>&emsp;&emsp;我采用的是<a href="https://swiftype.com/" target="_blank" rel="noopener">Swiftype</a>，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。</p><h3 id="网站收录"><a href="#网站收录" class="headerlink" title="网站收录"></a>网站收录</h3><p>&emsp;&emsp;<a href="https://www.google.com/webmasters/tools/" target="_blank" rel="noopener">Google Webmaster tools</a>收录特别快，具体步骤请按照<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="noopener">next的官方文档</a>操作。但是<a href="http://ziyuan.baidu.com/?castk=LTE%3D" target="_blank" rel="noopener">百度站长</a>收录的就很慢了，我的到现在还没被收录。</p><h3 id="其他服务"><a href="#其他服务" class="headerlink" title="其他服务"></a>其他服务</h3><p>&emsp;&emsp;NexT 借助于 MathJax 来显示数学公式，此选项默认关闭，如果博客中有公式，那么一定要打开这个选项。</p><h2 id="next进阶"><a href="#next进阶" class="headerlink" title="next进阶"></a>next进阶</h2><p>&emsp;&emsp;最后想说一下其他一些配置，比如添加背景图片、侧边栏头像旋转、侧边栏鼠标滑入显示、背景音乐等等，此处大部分参考<a href="http://mashirosorata.vicp.io/HEXO-NEXT%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE.html" target="_blank" rel="noopener">这个博客</a>。</p><p>&emsp;&emsp;next人性化的为用户提供了custom接口，我们可以在不影响主题文件的基础上进行个性化定制。</p><h3 id="给页面添加背景图片"><a href="#给页面添加背景图片" class="headerlink" title="给页面添加背景图片"></a>给页面添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  background: url(/images/blogbk.jpg) no-repeat;</span><br><span class="line">  <span class="comment">/* 背景图垂直、水平均居中 */</span></span><br><span class="line">  <span class="attribute">background-position</span>: center center;</span><br><span class="line">  <span class="comment">/* 当内容高度大于图片高度时，背景图像的位置相对于viewport固定 */</span></span><br><span class="line">  <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">  <span class="comment">/* 让背景图基于容器大小伸缩 */</span></span><br><span class="line">  <span class="attribute">background-size</span>: cover;</span><br><span class="line">  <span class="comment">/* 设置背景颜色，背景图加载过程中会显示背景色 */</span></span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中的css样式属性都可以根据你的自定义图片来更改，以达到最佳的效果。</p><h3 id="给侧边栏添加背景图片"><a href="#给侧边栏添加背景图片" class="headerlink" title="给侧边栏添加背景图片"></a>给侧边栏添加背景图片</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">            background:url(/images/sidebar.jpg);</span><br><span class="line">            <span class="attribute">background-size</span>: cover;</span><br><span class="line">            <span class="attribute">background-position</span>:center;</span><br><span class="line">            <span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line">            <span class="selector-tag">p</span>,<span class="selector-tag">span</span>,<span class="selector-tag">a</span> &#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文字背景色以及半透明的设置"><a href="#文字背景色以及半透明的设置" class="headerlink" title="文字背景色以及半透明的设置"></a>文字背景色以及半透明的设置</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">            <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">            <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;其中border-radius是给文章背景设置圆角，margin-top是设置文章到顶部的距离，其中属性可根据自己的需要进行调整。</p><h3 id="评论-来必力-添加背景色"><a href="#评论-来必力-添加背景色" class="headerlink" title="评论(来必力)添加背景色"></a>评论(来必力)添加背景色</h3><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#lv-container</span> &#123;</span><br><span class="line">       <span class="attribute">border-radius</span>: <span class="number">20px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">60px</span> <span class="number">30px</span> <span class="number">60px</span>;</span><br><span class="line">       <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.8</span>) none repeat scroll !important;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;和上面一样，背景色和圆角可自己调整更改。</p><h3 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h3><p>&emsp;&emsp;在网址输入如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://7u2ss1.com1.z0.glb.clouddn.com/love.js</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后将里面的代码copy一下，新建love.js文件并且将代码复制进去，然后保存。将love.js文件放到路径/themes/next/source/js/src里面，然后打开\themes\next\layout_layout.swig文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面点击小红心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/js/src/love.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="侧边栏头像旋转"><a href="#侧边栏头像旋转" class="headerlink" title="侧边栏头像旋转"></a>侧边栏头像旋转</h3><p>&emsp;&emsp;打开\themes\next\source\css_common\components\sidebar\sidebar-author.styl，在里面添加如下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.site-author-image</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">$site</span>-author-image-padding;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="variable">$site</span>-author-image-width;</span><br><span class="line">  <span class="attribute">height</span>: <span class="variable">$site</span>-author-image-height;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$site</span>-author-image-border-width solid <span class="variable">$site</span>-author-image-border-color;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* start*/</span></span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span></span><br><span class="line">  webkit-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  moz-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  ms-<span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">1.4s</span> all;</span><br><span class="line">  <span class="comment">/* end */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start */</span></span><br><span class="line"><span class="selector-class">.site-author-image</span>:hover &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#55DAE1</span>;</span><br><span class="line">  webkit-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  moz-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  ms-<span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">  <span class="attribute">transform</span>: rotate(<span class="number">360deg</span>) scale(<span class="number">1.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* end */</span></span><br></pre></td></tr></table></figure><h3 id="设置鼠标划入侧边栏才显示站点信息："><a href="#设置鼠标划入侧边栏才显示站点信息：" class="headerlink" title="设置鼠标划入侧边栏才显示站点信息："></a>设置鼠标划入侧边栏才显示站点信息：</h3><h4 id="设置自定义div"><a href="#设置自定义div" class="headerlink" title="设置自定义div"></a>设置自定义div</h4><p>&emsp;&emsp;在theme/next/layout/_macro文件夹下打开sidebar.swig文件，找到以下代码行的位置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">"site-state motion-element"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在其上添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.0/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.5.0/velocity.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">  $(<span class="string">"#sidebar"</span>).hover(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#mydivshow"</span>).velocity(<span class="string">'stop'</span>).velocity(&#123;<span class="attr">opacity</span>: <span class="number">1</span>&#125;);</span></span><br><span class="line"><span class="actionscript">  &#125;,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#mydivshow"</span>).velocity(<span class="string">'stop'</span>).velocity(&#123;<span class="attr">opacity</span>: <span class="number">0</span>&#125;);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mydivshow"</span> <span class="attr">class</span>=<span class="string">"mydivshow"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;然后找到代码行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在此的上方添加一个，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--my custom code begin--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--my custom code end--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">&#123;% if display_toc and toc(page.content).length &gt; 1 %&#125;</span><br><span class="line"><span class="comment">&lt;!--noindex--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">"post-toc-wrap motion-element sidebar-panel sidebar-panel-active"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"post-toc"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="自定义区域的初始化设置"><a href="#自定义区域的初始化设置" class="headerlink" title="自定义区域的初始化设置"></a>自定义区域的初始化设置</h4><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，向里面增添下列代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#mydivshow&#123;<span class="attribute">opacity</span>: <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p>注：具体代码添加位置以及代码里的section.site-overview可以自己修改，<div id="mydivshow" class="mydivshow">和末尾的</div>是控制显示区域，section.site-overview则是用户鼠标滑入划出时的触发事件区域。</p><h3 id="自定义音乐播放器"><a href="#自定义音乐播放器" class="headerlink" title="自定义音乐播放器"></a>自定义音乐播放器</h3><p>&emsp;&emsp;描述：本站所用的音乐播放器是由DIYgod所制作的APlayer，其详细资料可参见<a href="https://aplayer.js.org/docs/#/" target="_blank" rel="noopener">这里</a>。</p><h4 id="安装APlayer插件"><a href="#安装APlayer插件" class="headerlink" title="安装APlayer插件"></a>安装APlayer插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install aplayer --save</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;安装完后在node_modules目录下找到APlayer.min.js文件，将其复制到theme/next/source/js/src/目录下。</p><h4 id="生成音乐播放器"><a href="#生成音乐播放器" class="headerlink" title="生成音乐播放器"></a>生成音乐播放器</h4><p>&emsp;&emsp;在你想要加入音乐播放器的地方插入以下代码，本站把他放在了侧边栏里，具体操作如下。</p><p>&emsp;&emsp;打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"player1"</span> <span class="attr">class</span>=<span class="string">"aplayer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> ap = <span class="keyword">new</span> APlayer(&#123;</span></span><br><span class="line"><span class="javascript">    element: <span class="built_in">document</span>.getElementById(<span class="string">'player1'</span>),                       <span class="comment">// Optional, player element</span></span></span><br><span class="line"><span class="actionscript">    narrow: <span class="literal">false</span>,                                                     <span class="comment">// Optional, narrow style</span></span></span><br><span class="line"><span class="actionscript">    autoplay: <span class="literal">false</span>,                                                    <span class="comment">// Optional, autoplay song(s), not supported by mobile browsers</span></span></span><br><span class="line"><span class="actionscript">    showlrc: <span class="number">0</span>,                                                        <span class="comment">// Optional, show lrc, can be 0, 1, 2, see: ###With lrc</span></span></span><br><span class="line"><span class="actionscript">    mutex: <span class="literal">true</span>,                                                       <span class="comment">// Optional, pause other players when this player playing</span></span></span><br><span class="line"><span class="actionscript">    theme: <span class="string">'#e6d0b2'</span>,                                                  <span class="comment">// Optional, theme color, default: #b7daff</span></span></span><br><span class="line"><span class="actionscript">    mode: <span class="string">'random'</span>,                                                    <span class="comment">// Optional, play mode, can be `random` `single` `circulation`(loop) `order`(no loop), default: `circulation`</span></span></span><br><span class="line"><span class="actionscript">    preload: <span class="string">'metadata'</span>,                                               <span class="comment">// Optional, the way to load music, can be 'none' 'metadata' 'auto', default: 'auto'</span></span></span><br><span class="line"><span class="actionscript">    listmaxheight: <span class="string">'513px'</span>,                                             <span class="comment">// Optional, max height of play list</span></span></span><br><span class="line"><span class="actionscript">    music: &#123;                                                           <span class="comment">// Required, music info, see: ###With playlist</span></span></span><br><span class="line"><span class="actionscript">        title: <span class="string">'你曾是少年'</span>,                                          <span class="comment">// Required, music title</span></span></span><br><span class="line"><span class="actionscript">        author: <span class="string">'cover'</span>,                                              <span class="comment">// Required, music author</span></span></span><br><span class="line"><span class="actionscript">        url: <span class="string">'http://mp3.qqmusic.cc/yq/102426570.mp3'</span>,                <span class="comment">// Required, music url</span></span></span><br><span class="line"><span class="actionscript">        pic: <span class="string">'/images/visitor.jpg'</span>,                                   <span class="comment">// Optional, music picture</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这里的歌曲url必须是在线音乐，当时现在大部分播放器都不会曝露出真实的歌曲播放地址，找资源很是费劲。这里给大家推荐一个<a href="http://www.qqmusic.cc/" target="_blank" rel="noopener">解析平台</a>，大部分的qq音乐还是可以解析出来或者直接在该平台上找到播放链接的。大家可以写多个music结构，以此来添加多个音乐。</p><p>&emsp;&emsp;当然，我们还可以通过添加网易云音乐外链的方式在我们的博客中添加音乐。打开theme/next/layout/_custom/文件夹下的sidebar.swig文件，向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"music163player"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">330</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=458789090&amp;auto=0&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;替换上述代码中的iframe标签之间的内容，就可以替换不同的音乐进行播放了。网易云音乐的歌单也可以生成外链，前提是歌单里的歌曲都有版权哦~</p><h4 id="自定义播放器样式"><a href="#自定义播放器样式" class="headerlink" title="自定义播放器样式"></a>自定义播放器样式</h4><p>&emsp;&emsp;包含颜色更改，列表歌曲信息的排版修改。</p><p>&emsp;&emsp;在theme/next/source/css/_custom文件夹下打开custom.styl文件，往里面添加以下代码：</p><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span>:hover &#123;   <span class="comment">/*列表悬停颜色*/</span></span><br><span class="line">                  <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list</span> <span class="selector-tag">ol</span> <span class="selector-tag">li</span> &#123;   <span class="comment">/*列表底色*/</span></span><br><span class="line">                        <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;</span><br><span class="line"><span class="selector-class">.aplayer-list-light</span> &#123;   <span class="comment">/*列表播放歌曲颜色*/</span></span><br><span class="line">                      <span class="attribute">background</span>:rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>) none repeat scroll !important;&#125;</span><br><span class="line"><span class="selector-id">#player1</span> &#123;    <span class="comment">/*边框样式*/</span></span><br><span class="line">          <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">          <span class="selector-tag">div</span>,<span class="selector-tag">ol</span> &#123;<span class="attribute">border-radius</span>: <span class="number">6px</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="selector-id">#player1</span> *&#123;<span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">1</span>);&#125;    <span class="comment">/*字体颜色*/</span></span><br><span class="line"><span class="comment">/*列表歌曲信息的排版*/</span></span><br><span class="line">.aplayer-list-index&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-title&#123;<span class="attribute">float</span>:left;&#125;</span><br><span class="line">.aplayer-list-author&#123;<span class="attribute">float</span>:right;&#125;</span><br></pre></td></tr></table></figure><h3 id="自定义萌萌哒音乐播放控制边栏"><a href="#自定义萌萌哒音乐播放控制边栏" class="headerlink" title="自定义萌萌哒音乐播放控制边栏"></a>自定义萌萌哒音乐播放控制边栏</h3><p>&emsp;&emsp;这一步要在自定义音乐播放器的配置完成之后才能进行，因为aplayer-controler依赖于aplayer来实现播放功能。</p><h4 id="安装aplayer-controler插件"><a href="#安装aplayer-controler插件" class="headerlink" title="安装aplayer-controler插件"></a>安装aplayer-controler插件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install aplayer-controler --save</span><br></pre></td></tr></table></figure><h4 id="添加js代码"><a href="#添加js代码" class="headerlink" title="添加js代码"></a>添加js代码</h4><p>&emsp;&emsp;安装APlayer-Controler的js文件：<a href="https://github.com/Mashiro-Sorata/APlayer-Controler/blob/master/demo/src/Aplayer-Controler.js" target="_blank" rel="noopener">APlayer-Controler.js</a></p><p>&emsp;&emsp;将其放入theme/next/source/js/src下。</p><h4 id="创建按钮区域"><a href="#创建按钮区域" class="headerlink" title="创建按钮区域"></a>创建按钮区域</h4><p>&emsp;&emsp;在theme/next/layout/_custom/文件夹下新建一个myapcontroler.swig的文件。向其中添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/js/src/Aplayer-Controler.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"AP-controler"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript"><span class="keyword">var</span> myapc=<span class="keyword">new</span> APlayer_Controler(&#123;</span></span><br><span class="line"><span class="javascript">APC_dom:$(<span class="string">'#AP-controler'</span>),</span></span><br><span class="line"><span class="actionscript">aplayer:ap, <span class="comment">//此为绑定的aplayer对象</span></span></span><br><span class="line"><span class="actionscript">attach_right:<span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">position:&#123;top:<span class="string">'300px'</span>,bottom:<span class="string">''</span>&#125;,</span></span><br><span class="line"><span class="actionscript">fixed:<span class="literal">true</span>,</span></span><br><span class="line">btn_width:100,</span><br><span class="line">btn_height:120,</span><br><span class="line"><span class="actionscript">img_src:[<span class="string">'http://oty1v077k.bkt.clouddn.com/bukagirl.jpg'</span>,</span></span><br><span class="line"><span class="actionscript"><span class="string">'http://oty1v077k.bkt.clouddn.com/jumpgirl.jpg'</span>,</span></span><br><span class="line"><span class="actionscript"><span class="string">'http://oty1v077k.bkt.clouddn.com/pentigirl.jpg'</span>,</span></span><br><span class="line"><span class="actionscript"><span class="string">'http://oty1v077k.bkt.clouddn.com/%E8%90%8C1.gif'</span>],</span></span><br><span class="line"><span class="actionscript">img_style:&#123;repeat:<span class="string">'no-repeat'</span>,position:<span class="string">'center'</span>,size:<span class="string">'contain'</span>&#125;,</span></span><br><span class="line"><span class="actionscript">ctrls_color:<span class="string">'rgba(173,255,47,0.8)'</span>,</span></span><br><span class="line"><span class="actionscript">ctrls_hover_color:<span class="string">'rgba(255,140,0,0.7)'</span>,</span></span><br><span class="line"><span class="actionscript">tips_on:<span class="literal">true</span>,</span></span><br><span class="line">tips_width:140,</span><br><span class="line">tips_height:25,</span><br><span class="line"><span class="actionscript">tips_color:<span class="string">'rgba(255,255,255,0.6)'</span>,</span></span><br><span class="line">tips_content:&#123;&#125;,</span><br><span class="line">timeout:30</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="将控制按钮加入body页面"><a href="#将控制按钮加入body页面" class="headerlink" title="将控制按钮加入body页面"></a>将控制按钮加入body页面</h4><p>&emsp;&emsp;在theme/next/layout文件夹下打开_layout.swig文件，在<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":null,"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"display":null,"superSample":2,"width":150,"height":300,"position":"right","hOffset":0,"vOffset":-20,"mobile":null,"show":false,"react":null,"opacityDefault":0.5,"opacityOnHover":0,"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script>前添加以下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include '_custom/myapcontroler.swig' %&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;到此，自定义音乐播放控制边栏就基本完成，完成整个配置需要根据自己的主题背景进一步修改完善。</p><hr><p><strong><font color="red" size="3" face="仿宋">本教程到此结束，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;喜欢写Blog的人，会经历三个阶段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶
      
    
    </summary>
    
    
      <category term="博客搭建" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    
      <category term="jekyll" scheme="http://yoursite.com/tags/jekyll/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="gitee" scheme="http://yoursite.com/tags/gitee/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序综述</title>
    <link href="http://yoursite.com/2019/11/08/2018-01-09-DS/"/>
    <id>http://yoursite.com/2019/11/08/2018-01-09-DS/</id>
    <published>2019-11-08T02:45:04.332Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS&amp;A/sort</a></strong></li><li><strong>编&emsp;&emsp;者：WordZzzz</strong></li></ul><hr><p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;剑指offer刷完了，是时候总结一波数据结构与算法了。本系列文章暂定包括数据结构中树和图的各种操作，以及查找、排序等基本算法和动态规划等高级算法。本系列文章只是作为总结性的文献，为自己日后的面试做准备。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;直接引自维基百科：<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">排序算法</a>。总结性强。</p><p>&emsp;&emsp;在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p><ul><li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li><li>输出结果是原输入的一种排列、或是重组</li></ul><p>&emsp;&emsp;虽然排序算法是一个简单的问题，但是从计算机科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。（例子：图书馆排序在2004年被发表）</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>&emsp;&emsp;在计算机科学所使用的排序算法通常被分类为：</p><ul><li>计算的时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，坏的性能是O(n2)。对于一个排序理想的性能是O(n)，但平均而言不可能达到。基于比较的排序算法对大多数输入而言至少需要O(n log n)。</li><li>内存使用量（以及其他电脑资源的使用）</li><li>稳定性：稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。</li><li>依据排序的方法：插入、交换、选择、合并等等。</li></ul><h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>&emsp;&emsp;当相等的元素是无法分辨的，比如像是整数，稳定性并不是一个问题。然而，假设以下的数对将要以他们的第一个数字来排序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(4, 1)  (3, 1)  (3, 7)（5, 6）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这个状况下，有可能产生两种不同的结果，一个是让相等键值的纪录维持相对的次序，而另外一个则没有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(3, 1)  (3, 7)  (4, 1)  (5, 6)  （维持次序）</span><br><span class="line">(3, 7)  (3, 1)  (4, 1)  (5, 6)  （次序被改变）</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此。不稳定排序算法可以被特别地实现为稳定。实现的一个方式是人工扩充键值的比较（比如上面的比较中加入第二个标准：第二个键值的大小），从而在键值相同的两个对象之间进行比较时，使用在原先数据次序中的条目。然而，要记录这种次序通常牵涉到额外的空间负担。</p><h3 id="排序算法列表"><a href="#排序算法列表" class="headerlink" title="排序算法列表"></a>排序算法列表</h3><p>&emsp;&emsp;在这个表格中，n是要被排序的纪录数量以及k是不同键值的数量。</p><h4 id="稳定的排序"><a href="#稳定的排序" class="headerlink" title="稳定的排序"></a>稳定的排序</h4><ul><li>冒泡排序（bubble sort）— O(n2)</li><li>插入排序（insertion sort）— O(n2)</li><li>鸡尾酒排序（cocktail sort）— O(n2)</li><li>桶排序（bucket sort）— O(n)；需要O(k)额外空间</li><li>计数排序（counting sort）— O(n+k)；需要O(n+k)额外空间</li><li>归并排序（merge sort）— O(n log n)；需要O(n)额外空间</li><li>原地归并排序 — O(n log2 n)如果使用最佳的现在版本</li><li>二叉排序树排序（binary tree sort）— O(n log n)期望时间；O(n2)最坏时间；需要O(n)额外空间</li><li>鸽巢排序（pigeonhole sort）— O(n+k)；需要O(k)额外空间</li><li>基数排序（radix sort）— O(n·k)；需要O(n)额外空间</li><li>侏儒排序（gnome sort）— O(n2)</li><li>图书馆排序（library sort）— O(n log n)期望时间；O(n2)最坏时间；需要(1+ε)n额外空间</li><li>块排序（block sort）— O(n log n)</li></ul><h4 id="不稳定的排序"><a href="#不稳定的排序" class="headerlink" title="不稳定的排序"></a>不稳定的排序</h4><ul><li>选择排序（selection sort）— O(n2)</li><li>希尔排序（shell sort）— O(n log2 n)如果使用最佳的现在版本</li><li>Clover排序算法（Clover sort）— O(n)期望时间，O(n2)最坏情况</li><li>梳排序 — O(n log n)</li><li>堆排序（heap sort）— O(n log n)</li><li>平滑排序（smooth sort）— O(n log n)</li><li>快速排序（quick sort）— O(n log n)期望时间，O(n2)最坏情况；对于大的、随机数列表一般相信是最快的已知排序</li><li>内省排序（introsort）—O (n log n)</li><li>耐心排序（patience sort）— O(n log n + k)最坏情况时间，需要额外的O(n + k)空间，也需要找到最长的递增子序列（longest increasing subsequence）</li></ul><h4 id="不实用的排序"><a href="#不实用的排序" class="headerlink" title="不实用的排序"></a>不实用的排序</h4><ul><li>Bogo排序 — O(n × n!)，最坏的情况下期望时间为无穷</li><li>Stupid排序 — O(n3);递归版本需要O(n2)额外内存</li><li>珠排序（bead sort）— O(n) or O(√n),但需要特别的硬件</li><li>煎饼排序 — O(n),但需要特别的硬件</li><li>臭皮匠排序（stooge sort）算法简单，但需要约n^2.7的时间</li></ul><hr><p>==概述到此结束，下面分八篇文章依次对典型的八种排序进行图文并茂的讲解和c++实现。==</p><hr><p>&emsp;&emsp;先贴一下八大排序的性能概括图：</p><p>&emsp;&emsp;再贴出来以后要用到的main函数和头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="comment">//double arr[] = &#123;4.5, 2.3,6.7, 3.5, 1.1&#125;;</span></span><br><span class="line"><span class="comment">//const int len = sizeof(arr) / sizeof(arr[0]);</span></span><br><span class="line"><span class="comment">//BubbleSort(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort1(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort2(arr, len);</span></span><br><span class="line"><span class="comment">//BubbleSort3(arr, len);</span></span><br><span class="line"><span class="comment">//InsertSort(arr, len);</span></span><br><span class="line"><span class="comment">//ShellSort(arr, len);</span></span><br><span class="line"><span class="comment">//QuickSort(arr, len);</span></span><br><span class="line"><span class="comment">//QuickSortIteration(arr, len);</span></span><br><span class="line"><span class="comment">//SelectSort(arr, len);</span></span><br><span class="line"><span class="comment">//HeapSort(arr, len);</span></span><br><span class="line"><span class="comment">//MergeSort(arr, len); </span></span><br><span class="line">MergeSortIteration(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v : arr)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125; <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后就要打开传送门了：</p><p>csdn告诉我今天上传博客的次数到达上限了，然而我还有两个没有上传，那我只好先引流到我的个人博客了。</p><ul><li><a href="https://wordzzzz.github.io/2018/01/01/DS/" target="_blank" rel="noopener">插入排序</a>：（有序区，无序区）。把无序区的第一个元素插入到有序区的合适的位置。对数组：比较得少，换得多。</li><li><a href="https://wordzzzz.github.io/2018/01/02/DS/" target="_blank" rel="noopener">希尔排序</a>：每一轮按照事先决定的间隔进行插入排序，间隔会依次缩小，最后一次一定要是1。</li><li><a href="https://wordzzzz.github.io/2018/01/03/DS/" target="_blank" rel="noopener">选择排序</a>：（有序区，无序区）。在无序区里找一个最小的元素跟在有序区的后面。对数组：比较得多，换得少。</li><li><a href="https://wordzzzz.github.io/2018/01/04/DS/" target="_blank" rel="noopener">堆排序</a>：（最大堆，有序区）。<br>从堆顶把根卸出来放在有序区之前，再恢复堆。</li><li><a href="https://wordzzzz.github.io/2018/01/05/DS/" target="_blank" rel="noopener">冒泡排序</a>：（无序区，有序区）。从无序区通过交换找出最大元素放到有序区前端。</li><li><a href="https://wordzzzz.github.io/2018/01/06/DS/" target="_blank" rel="noopener">快速排序</a>：（小数，基准元素，大数）。<br>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。</li><li><a href="https://wordzzzz.github.io/2018/01/07/DS/" target="_blank" rel="noopener">归并排序</a>：把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。<br>可从上到下或从下到上进行。</li><li><a href="https://wordzzzz.github.io/2018/01/08/DS/" target="_blank" rel="noopener">基数排序</a>：一种多关键字的排序算法，可用桶排序实现。</li></ul><p>参考链接：<br><a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科</a><br><a href="https://visualgo.net/en/sorting" target="_blank" rel="noopener">数据结构与算法可视化可视化</a><br><a href="http://www.cnblogs.com/skywang12345/category/508186.html" target="_blank" rel="noopener">数据结构与算法</a><br><a href="http://www.open-open.com/lib/view/open1404781467544.html" target="_blank" rel="noopener">排序算法可视化</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" target="_blank" rel="noopener">经典排序算法总结与实现</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之基数排序</title>
    <link href="http://yoursite.com/2019/11/08/2018-01-08-DS/"/>
    <id>http://yoursite.com/2019/11/08/2018-01-08-DS/</id>
    <published>2019-11-08T02:45:04.331Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机（Tabulation Machine）上的贡献。</p><p>&emsp;&emsp;基数排序法会使用到桶 (Bucket)，顾名思义，通过将要比较的位（个位、十位、百位…），将要排序的元素分配至 0~9 个桶中，借以达到排序的作用，在某些时候，基数排序法的效率高于其它的比较性排序法。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;它是这样实现的：</p><ul><li>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。</li><li>然后，从最低位开始，依次进行一次排序。</li><li>这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</li></ul><p>&emsp;&emsp;基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180109153959062?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="radixsort from wordzzzz"></div><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取数组a中最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_max</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i, max;</span><br><span class="line"></span><br><span class="line">max = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; length; i++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; max)</span><br><span class="line">max = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对数组按照"某个位数"进行排序(桶排序)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length, <span class="keyword">int</span> <span class="built_in">exp</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T* output = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (output == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i, buckets[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">// 将数据出现的次数存储在buckets[]中</span></span><br><span class="line">buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)<span class="comment">// 更改buckets[i]。目的是让更改后的buckets[i]的值，是该数据在output[]中的位置。</span></span><br><span class="line">buckets[i] += buckets[i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)<span class="comment">// 将数据存储到临时数组output[]中，这里的对应关系一定要捋清楚</span></span><br><span class="line">output[--buckets[(<span class="built_in">array</span>[i] / <span class="built_in">exp</span>) % <span class="number">10</span>]] = <span class="built_in">array</span>[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">// 将排序好的数据赋值给array[]</span></span><br><span class="line"><span class="built_in">array</span>[i] = output[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RadixSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span>;<span class="comment">// 指数。当对数组按各位进行排序时，exp=1；按十位进行排序时，exp=10；...</span></span><br><span class="line"><span class="keyword">int</span> max = get_max(<span class="built_in">array</span>, length);<span class="comment">// 数组array中的最大值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">exp</span> = <span class="number">1</span>; max / <span class="built_in">exp</span> &gt; <span class="number">0</span>; <span class="built_in">exp</span> *= <span class="number">10</span>)<span class="comment">// 从个位开始，对数组array按"指数"进行排序</span></span><br><span class="line">count_sort(<span class="built_in">array</span>, length, <span class="built_in">exp</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>平均时间复杂度 $O(d*(n+r))$</li><li>最好情况 $O(d*(n+r))$</li><li>最坏情况 $O(d*(n+r))$</li><li>空间复杂度 $O(n+r)$</li></ul><p>&emsp;&emsp;其中，d 为位数，r 为基数，n 为原数组个数。在基数排序中，因为没有比较操作，所以在复杂上，最好的情况与最坏的情况在时间上是一致的，均为 O(d*(n + r))。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;如果捋不清上述代码中的数组对应关系，可以参考一下下面这两张图的讲解，来源：<a href="http://www.cnblogs.com/skywang12345/p/3603669.html。" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3603669.html。</a></p><ul><li>个位的数值范围是[0,10)。因此，参见桶数组buckets[]，将数组按照个位数值添加到桶中。</li></ul><p></p><div align="center"><img src="http://img.blog.csdn.net/20180109154616722?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step1"></div><p></p><ul><li>接着是根据桶数组buckets[]来进行排序。假设将排序后的数组存在output[]中；找出output[]和buckets[]之间的联系就可以对数据进行排序了。</li></ul><p></p><div align="center"><img src="http://img.blog.csdn.net/20180109154657318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="step2"></div><p></p><p>&emsp;&emsp;基数排序不改变相同元素之间的相对顺序，因此它是稳定的排序算法。</p><p>&emsp;&emsp;基数排序 vs 计数排序 vs 桶排序</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="基数排序" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之归并排序</title>
    <link href="http://yoursite.com/2019/11/08/2018-01-07-DS/"/>
    <id>http://yoursite.com/2019/11/08/2018-01-07-DS/</id>
    <published>2019-11-08T02:45:04.330Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;归并排序（英语：Merge sort，或mergesort），是创建在归并操作上的一种有效的排序算法，效率为 ${\displaystyle O(n\log n)}$ 。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;归并操作（merge），也叫归并算法，指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。</p><p>递归法（Bottom-up）<br>原理如下（假设序列共有 ${\displaystyle n}$ 个元素）：</p><ul><li>将序列每相邻两个数字进行归并操作，形成 ${\displaystyle ceil(n/2)}$ 个序列，排序后每个序列包含两/一个元素。</li><li>若此时序列数不是1个则将上述序列再次归并，形成 ${\displaystyle ceil(n/4)}$个序列，每个序列包含四/三个元素。</li><li>重复步骤2，直到所有元素排序完毕，即序列数为1。</li></ul><p>迭代法（Top-down）</p><ul><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列。</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置。</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置。</li><li>重复步骤3直到某一指针到达序列尾。</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180109111825567?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="merge from wikipedia"></div><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180109111851701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line"><span class="keyword">int</span> k = left;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line"><span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, left, mid);<span class="comment">//左序列排序</span></span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);<span class="comment">//右序列排序</span></span><br><span class="line">Merge(<span class="built_in">array</span>, reg, left, mid, right);<span class="comment">//合并左右序列</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">MergeSortRecursive(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;<span class="comment">//步长，每次翻倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">regB[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//更新array</span></span><br><span class="line"><span class="built_in">array</span>[i] = regB[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>最优时间复杂度    ${\displaystyle O(n)}$ </li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    ${\displaystyle O(n)}$</li></ul><p>&emsp;&emsp;比较操作的次数介于 ${\displaystyle (n\log n)/2}$ 和 ${\displaystyle n\log n-n+1}$ 。 赋值操作的次数是 ${\displaystyle (2n\log n)}$ 。归并算法的空间复杂度为： ${\displaystyle \Theta (n)}$。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;对于归并排序有几点说明：</p><ul><li>和快速排序一样，归并排序在小数组上面的表现不如插入排序。</li><li>辅助数组是一个共用的数组。如果在每个归并的过程中都申请一个临时数组会造成比较大的时间开销。</li><li>归并的过程需要将元素复制到辅助数组，再从辅助数组排序复制回原数组，会拖慢排序速度。</li></ul><p>&emsp;&emsp;归并排序有以下几点优化方法：</p><ul><li>和快速排序一样，对于小数组可以使用插入排序或者选择排序，避免递归调用。（代码见下面的归并排序递归版优化）</li><li>在merge()调用之前，可以判断一下a[mid]是否小于等于a[mid+1]。如果是的话那么就不用归并了，数组已经是有序的。原因很简单，既然两个子数组已经有序了，那么a[mid]是第一个子数组的最大值，a[mid+1]是第二个子数组的最小值。当a[mid]&lt;=a[mid+1]时，数组整体有序。</li><li>为了节省将元素复制到辅助数组作用的时间，可以在递归调用的每个层次交换原始数组与辅助数组的角色。（代码见下面的归并排序迭代版优化）</li></ul><h4 id="递归版优化"><a href="#递归版优化" class="headerlink" title="递归版优化"></a>递归版优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 归并排序递归版合并函数</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left1 = left, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid + <span class="number">1</span>, right2 = right;</span><br><span class="line"><span class="keyword">int</span> k = left;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1 &amp;&amp; left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1] &lt; <span class="built_in">array</span>[left2] ? <span class="built_in">array</span>[left1++] : <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt;= right1)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt;= right2)</span><br><span class="line">reg[k++] = <span class="built_in">array</span>[left2++];</span><br><span class="line"><span class="keyword">for</span> (k = left; k &lt;= right; k++)</span><br><span class="line"><span class="built_in">array</span>[k] = reg[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序递归版递归函数优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursive1</span><span class="params">(T *<span class="built_in">array</span>, T *reg, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= M)<span class="comment">//序列长度小于阈值就采用插入排序</span></span><br><span class="line">InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, left, mid);<span class="comment">//左序列排序</span></span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, mid + <span class="number">1</span>, right);<span class="comment">//右序列排序</span></span><br><span class="line">Merge(<span class="built_in">array</span>, reg, left, mid, right);<span class="comment">//合并左右序列</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">T* reg = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (reg == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line">MergeSortRecursive1(<span class="built_in">array</span>, reg, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">delete</span>[] reg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版优化"><a href="#迭代版优化" class="headerlink" title="迭代版优化"></a>迭代版优化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 归并排序迭代版优化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortIteration1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">T* regA = <span class="built_in">array</span>;</span><br><span class="line">T* regB = (T*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * length);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (regB == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fputs</span>(<span class="string">"Error: out of memory\n"</span>, <span class="built_in">stderr</span>);</span><br><span class="line"><span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> seg = <span class="number">1</span>; seg &lt; length; seg += seg) &#123;<span class="comment">//步长，每次翻倍</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; length; left += seg + seg) &#123;</span><br><span class="line"><span class="keyword">int</span> low = left, mid = min(left + seg, length), high = min(left + seg + seg, length);<span class="comment">//因为可能会超出length</span></span><br><span class="line"><span class="keyword">int</span> k = low;</span><br><span class="line"><span class="keyword">int</span> left1 = low, right1 = mid;</span><br><span class="line"><span class="keyword">int</span> left2 = mid, right2 = high;</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1 &amp;&amp; left2 &lt; right2)<span class="comment">//这里的表达式没有等号，都是左闭右开区间</span></span><br><span class="line">regB[k++] = regA[left1] &lt; regA[left2] ? regA[left1++] : regA[left2++];</span><br><span class="line"><span class="keyword">while</span> (left1 &lt; right1)</span><br><span class="line">regB[k++] = regA[left1++];</span><br><span class="line"><span class="keyword">while</span> (left2 &lt; right2)</span><br><span class="line">regB[k++] = regA[left2++];</span><br><span class="line">&#125;</span><br><span class="line">T* temp = regA;<span class="comment">//优化：交换辅助数组与原始数组的角色</span></span><br><span class="line">regA = regB;</span><br><span class="line">regB = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (regA != <span class="built_in">array</span>) &#123;<span class="comment">//如果regA != array，则说明现在regA是辅助数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)<span class="comment">//所以需要拷贝数据到regB，也就是array。</span></span><br><span class="line">regB[i] = regA[i];</span><br><span class="line">regB = regA;<span class="comment">//regB重新指向辅助数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] regB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="归并排序" scheme="http://yoursite.com/tags/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之快速排序</title>
    <link href="http://yoursite.com/2019/11/08/2018-01-06-DS/"/>
    <id>http://yoursite.com/2019/11/08/2018-01-06-DS/</id>
    <published>2019-11-08T02:45:04.328Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 ${\displaystyle n}$ 个项目要 ${\displaystyle O(n\log n)}$ （大O符号）次比较。在最坏状况下则需要 ${\displaystyle O(n^{2})}$ 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 ${\displaystyle O(n\log n)}$ 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。</p><p>&emsp;&emsp;步骤为：</p><ul><li>从数列中挑出一个元素，称为”基准”（pivot）.</li><li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</li><li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li><li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li></ul><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180108223019362?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wikipedia"></div><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180108223101863?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="quicksort from wordzzzz"></div><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>&emsp;&emsp;先给出公用接口，之后的三个递归实现和一个迭代实现在代码中都有详细的说明，我就不再在此赘述。</p><h4 id="公用接口"><a href="#公用接口" class="headerlink" title="公用接口"></a>公用接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 快速排序主体函数（递归）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt; </span><br><span class="line">void QuickSort(T *array, const int length) &#123; </span><br><span class="line">if (array == NULL)</span><br><span class="line">throw invalid_argument(&quot;Array must not be empty&quot;); </span><br><span class="line">if (length &lt;= 0) </span><br><span class="line">return; </span><br><span class="line"></span><br><span class="line">Partion1(array, 0, length - 1);</span><br><span class="line">//  Partion2(array, 0, length - 1);</span><br><span class="line">//  Partion3(array, 0, length - 1);</span><br><span class="line">//PartionInsert(array, 0, length - 1);</span><br><span class="line">//PartionSecond(array, 0, length - 1);</span><br><span class="line">//PartionThird(array, 0, length - 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 快速排序1：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i=left(该索引之前的数比pivot小，初始值为left)，</span></span><br><span class="line"><span class="comment"> * j从left+1开始遍历数组，找到一个比pivot小的数，i+1，如果i和j序列号不等就交换（小值到前）。</span></span><br><span class="line"><span class="comment"> * j到最右端之后，for循环结束，再把pivot与i所指数据做交换，当前pivot就到达了它的最终位置。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = left + <span class="number">1</span>;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">for</span> (; j &lt;= right; ++j)&#123;<span class="comment">// 循环直至 j 扫描至 right</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; pivot)&#123;<span class="comment">// 如果遇到比基准小的数，i右移一位</span></span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (j != i)&#123;<span class="comment">// 如果i与j不重合，则交换他们指向的值</span></span><br><span class="line">swap(<span class="built_in">array</span>[j],<span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[i]);<span class="comment">// 基准值的位置确定</span></span><br><span class="line">Partion1(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion1(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序2：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，i = left+1从左向右遍历找到一个比pivot大的数停止，</span></span><br><span class="line"><span class="comment"> * 然后等待j从右往左遍历找到一个pivot小的数，两者交换，然后继续寻找直到i=j，for循环结束。</span></span><br><span class="line"><span class="comment"> * 之后我们需要做判断，如果pivot比i所指数据大就交换两者，否则i回退一步（因为开始忽略了首元素）。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)<span class="comment">// j向左遍历，直到找到比pivot小的值</span></span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)<span class="comment">// i向右遍历，直到找到比pivot大的值</span></span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)<span class="comment">// 如果i &lt; j，就交换刚才找到的那两个值</span></span><br><span class="line">swap(<span class="built_in">array</span>[j], <span class="built_in">array</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &lt;= <span class="built_in">array</span>[left])<span class="comment">// 这里一定要做判断再决定是否交换</span></span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span><span class="comment">// 如果不交换，说明left是最小，但i是不是第二小不确定，所以需要下次判断</span></span><br><span class="line">--i;</span><br><span class="line">Partion2(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion2(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序3：</span></span><br><span class="line"><span class="comment"> * 将第一个元素array[left]提出来作pivot，然后从j = right向前搜索第一个比pivot小的元素假设为array[k]，</span></span><br><span class="line"><span class="comment"> * 该元素放在array[left]的位置。因为array[left]已经保存pivot覆盖也没关系，于是array[k]又可以被覆盖了，</span></span><br><span class="line"><span class="comment"> * 从前往后搜索比pivot大的元素放到array[k]。一直进行下去直到i=j。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Partion3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j; </span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i; </span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">Partion3(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">Partion3(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 快速排序迭代实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; trace;</span><br><span class="line">trace.push(make_pair(<span class="number">0</span>, length - <span class="number">1</span>));<span class="comment">// 将数组首尾压栈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!trace.empty()) &#123;</span><br><span class="line"><span class="keyword">auto</span> top = trace.top();<span class="comment">// 将栈顶元素保存下来</span></span><br><span class="line">trace.pop();<span class="comment">// 弹出栈顶</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = top.first;<span class="comment">// 取出首尾地址</span></span><br><span class="line"><span class="keyword">int</span> j = top.second;</span><br><span class="line"></span><br><span class="line">T pivot = <span class="built_in">array</span>[i];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i &gt; top.first) trace.push(make_pair(top.first, i - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (j &lt; top.second) trace.push(make_pair(j + <span class="number">1</span>, top.second));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    不定</li><li>最坏时间复杂度    ${\displaystyle O(n^{2})}$ </li><li>最优时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    根据实现的方式不同而不同</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;快速排序是二叉查找树（二叉查找树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分区版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。</p><p>&emsp;&emsp;快速排序的最直接竞争者是堆排序（Heapsort）。堆排序通常比快速排序稍微慢，但是最坏情况的运行时间总是 ${\displaystyle O(n\log n)}$ 。快速排序是经常比较快，除了introsort变化版本外，仍然有最坏情况性能的机会。如果事先知道堆排序将会是需要使用的，那么直接地使用堆排序比等待introsort再切换到它还要快。堆排序也拥有重要的特点，仅使用固定额外的空间（堆排序是原地排序），而即使是最佳的快速排序变化版本也需要 ${\displaystyle O(\log n)}$ 的空间。然而，堆排序需要有效率的随机存取才能变成可行。</p><p>&emsp;&emsp;快速排序也与归并排序（Mergesort）竞争，这是另外一种递归排序算法，但有坏情况 ${\displaystyle O(n\log n)}$ 运行时间的优势。不像快速排序或堆排序，归并排序是一个稳定排序，且可以轻易地被采用在链表（linked list）和存储在慢速访问媒体上像是磁盘存储或网络连接存储的非常巨大数列。尽管快速排序可以被重新改写使用在链串列上，但是它通常会因为无法随机存取而导致差的基准选择。归并排序的主要缺点，是在最佳情况下需要 ${\displaystyle \Omega (n)}$ 额外的空间。</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>&emsp;&emsp;快排的优化、归并排序的优化一向是面试的考察重点，至于算法的优化，重点还是要知道现有算法的不足之处。</p><ul><li>当序列长度很小时，快排效率低，研究表明长度在5~25的数组，快排表现不如插入排序。</li><li>当pivot选择不当是，会导致树的不平衡，这样导致快排的时间复杂度为${\displaystyle O(n^{2})}$。</li><li>当数组中有大量重复的元素，快排效率将非常之低。</li></ul><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>&emsp;&emsp;针对上面提出的快排的局限性，我们依次做出优化策略：</p><ul><li>当当前序列长度小于特定值时，直接采用插入排序，或者不做处理，等到快排都执行完毕后（大致有序）在执行一次插入排序。</li><li>针对pivot的选择，不再选取固定值，而是采用其他选取策略，如随机、三值取中等。</li><li>如果数组中重复元素多，就采用三路划分算法：以某个数为基准将一个数组分成三部分：第一部分表示小于该pivot，第二部分等于pivot，第三部分大于pivot，要得到三部分得区间范围。</li></ul><p>&emsp;&emsp;下面的代码是对上述改进算法的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化1：</span></span><br><span class="line"><span class="comment">* 当排序的子序列小于预定的值M时，采用插入排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionInsert</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (right - left &lt;= M)</span><br><span class="line">InsertSort(<span class="built_in">array</span>, left, right);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">PartionInsert(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">PartionInsert(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产生随机数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Random</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> size = right - left + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> i = left + rand() % size;</span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[left]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取中位数移至left</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Median</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = left + ((right - left )&gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> minIndex = right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[mid])</span><br><span class="line">minIndex = mid;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[minIndex] &gt; <span class="built_in">array</span>[left])</span><br><span class="line">minIndex = left;</span><br><span class="line"><span class="keyword">if</span> (minIndex != right)<span class="comment">//三个判断，把最小值移到最右侧</span></span><br><span class="line">swap(<span class="built_in">array</span>[minIndex], <span class="built_in">array</span>[right]);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[mid] &lt; <span class="built_in">array</span>[left])<span class="comment">//那么剩下的两个数，最小的那个就是中位数了</span></span><br><span class="line">swap(<span class="built_in">array</span>[left], <span class="built_in">array</span>[mid]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化2：</span></span><br><span class="line"><span class="comment">* 取随机数或者三值取中作为基准值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionSecond</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Random(array, left, right);// 优化2-1：取随机数至最左端（基准值）</span></span><br><span class="line">Median(<span class="built_in">array</span>, left, right);<span class="comment">// 优化2-2：取中位数至最左端（基准值）</span></span><br><span class="line"><span class="keyword">int</span> i = left;</span><br><span class="line"><span class="keyword">int</span> j = right;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j)&#123;<span class="comment">// 循环直至 i,j 相遇</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[j] &gt;= pivot)</span><br><span class="line">--j;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[i++] = <span class="built_in">array</span>[j];<span class="comment">// 从右向左扫描，将比基准小的数填到左边</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; j &amp;&amp; <span class="built_in">array</span>[i] &lt; pivot)</span><br><span class="line">++i;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line"><span class="built_in">array</span>[j--] = <span class="built_in">array</span>[i];<span class="comment">// 从左向右扫描，将比基准大的数填到右边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[i] = pivot;<span class="comment">// 将基准数填回</span></span><br><span class="line">PartionSecond(<span class="built_in">array</span>, left, i - <span class="number">1</span>);</span><br><span class="line">PartionSecond(<span class="built_in">array</span>, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 快速排序3优化3：</span></span><br><span class="line"><span class="comment">* 重复数据比较多的话，可以分为小于等于大于三段</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartionThird</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> less = left;</span><br><span class="line"><span class="keyword">int</span> greater = right;</span><br><span class="line"><span class="keyword">int</span> it = left;</span><br><span class="line">T pivot = <span class="built_in">array</span>[left];<span class="comment">// 取第一个数为基准</span></span><br><span class="line"><span class="keyword">while</span> (it &lt;= greater)&#123;<span class="comment">// 循环直至it和greater相遇</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[it] == pivot)<span class="comment">// 如果等于pivot，it右移</span></span><br><span class="line">++it;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">array</span>[it] &lt; pivot)&#123;<span class="comment">// 如果小于pivot，扔左边，it和less右移</span></span><br><span class="line">swap(<span class="built_in">array</span>[less], <span class="built_in">array</span>[it]);</span><br><span class="line">++it;</span><br><span class="line">++less;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">// 如果大于pivot，扔右边，greater左移</span></span><br><span class="line">swap(<span class="built_in">array</span>[greater], <span class="built_in">array</span>[it]);</span><br><span class="line">--greater;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">PartionThird(<span class="built_in">array</span>, left, less - <span class="number">1</span>);</span><br><span class="line">PartionThird(<span class="built_in">array</span>, greater + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="快速排序" scheme="http://yoursite.com/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之冒泡排序</title>
    <link href="http://yoursite.com/2019/11/08/2018-01-05-DS/"/>
    <id>http://yoursite.com/2019/11/08/2018-01-05-DS/</id>
    <published>2019-11-08T02:45:04.327Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>&emsp;&emsp;冒泡排序对 ${\displaystyle n}$ 个项目需要${\displaystyle O(n)}$ )的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>冒泡排序算法的运作如下：</p><ul><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ul><p>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180108094645331?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wikipedia"></div><p></p><p>&emsp;&emsp;wordzzzz的小数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180108095446582?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 标准冒泡排序：嵌套循环比大小。</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n^{2})}$</li><li>最优时间复杂度    ${\displaystyle O(n)}$</li><li>平均时间复杂度    ${\displaystyle O(n^{2})}$</li><li>空间复杂度    总共 ${\displaystyle O(n)}$，需要辅助空间 ${\displaystyle O(1)}$</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 ${\displaystyle O(n^{2})}$次交换，而插入排序只要最多 ${\displaystyle O(n)}$ 交换。冒泡排序的实现（类似上面）通常会对已经排序好的数列拙劣地运行（ ${\displaystyle O(n^{2})}$ ），而插入排序在这个例子只需要 ${\displaystyle O(n)}$ 个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。</p><p>&emsp;&emsp;在面试中，一般都会涉及到算法的优化，重点考察的其实还是你对现有算法的理解，分析现有算法的缺点，就能找到优化的思路。</p><p>优化1：冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 ${\displaystyle O(n)}$ 。在这个情况，已经排序好的数列就无交换的需要。<br>优化2：可以记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。<br>优化3：若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。</p><p>优化代码如下：</p><p>优化1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 冒泡排序优化1：如果某次内循环没有改变任何数据，则结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort1</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123; </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>); </span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">flag = <span class="literal">false</span>;<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">flag = <span class="literal">true</span>;<span class="comment">//如果有交换，则标志位置1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span>;<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冒泡排序优化2：在优化1的基础上，记录上次排序结束位置，减少排序次数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> k = length;</span><br><span class="line"><span class="keyword">int</span> flag = k;<span class="comment">//设置标志位，用来判断内循环是否有数据交换</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; ++i)&#123;<span class="comment">//外循环，每次循环确定一个最大值</span></span><br><span class="line">k = flag;</span><br><span class="line">flag = <span class="number">0</span>;<span class="comment">//外循环第一步需要重置标志位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; ++j)&#123;<span class="comment">//内循环，用于交换数据，遍历次数递减</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &gt; <span class="built_in">array</span>[j + <span class="number">1</span>])&#123;<span class="comment">//如果当前数据比后面的数据大，则交换</span></span><br><span class="line">T tmp = <span class="built_in">array</span>[j + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j + <span class="number">1</span>] = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = tmp;</span><br><span class="line">flag = j + <span class="number">1</span>;<span class="comment">//如果有交换，更新交换位置的记录</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!flag) <span class="keyword">return</span>;<span class="comment">//如果本次循环没有数据交换，则结束排序</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化3：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *冒泡排序优化3：鸡尾酒排序，一个外循环内跑两个内循环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort3</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> high = length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (high &gt; low)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt; high; ++i)<span class="comment">//正向冒泡，确定最大值  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[i] &gt; <span class="built_in">array</span>[i + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">T temp = <span class="built_in">array</span>[i];</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="built_in">array</span>[i + <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[i + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">--high;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = high; j &gt; low; --j)<span class="comment">//反向冒泡，确定最小值  </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[j] &lt; <span class="built_in">array</span>[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">T temp = <span class="built_in">array</span>[j];</span><br><span class="line"><span class="built_in">array</span>[j] = <span class="built_in">array</span>[j - <span class="number">1</span>];</span><br><span class="line"><span class="built_in">array</span>[j - <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++low;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="冒泡排序" scheme="http://yoursite.com/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法系列之一：八大排序之堆排序</title>
    <link href="http://yoursite.com/2019/11/08/2018-01-04-DS/"/>
    <id>http://yoursite.com/2019/11/08/2018-01-04-DS/</id>
    <published>2019-11-08T02:45:04.325Z</published>
    <updated>2018-04-26T09:44:30.000Z</updated>
    
    <content type="html"><![CDATA[<hr><ul><li><strong>转载请注明作者和出处：<a href="http://blog.csdn.net/u011475210" target="_blank" rel="noopener">http://blog.csdn.net/u011475210</a></strong></li><li><strong>个人博客：<a href="https://wordzzzz.github.io/" target="_blank" rel="noopener">https://wordzzzz.github.io/</a> &amp;&amp; <a href="https://wordzzzz.gitee.io/" target="_blank" rel="noopener">https://wordzzzz.gitee.io/</a></strong></li><li><strong>代码地址：<a href="https://github.com/WordZzzz/Note/tree/master/DS-A" target="_blank" rel="noopener">https://github.com/WordZzzz/Note/tree/master/DS-A</a></strong></li><li><strong>博客作者：WordZzzz，一只热爱技术的文艺青年</strong></li></ul><hr><p>[toc]</p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;建议先看排序综述，传送门：<a href="http://blog.csdn.net/u011475210/article/details/79014021" target="_blank" rel="noopener">数据结构与算法系列之一：八大排序综述</a>。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>&emsp;&emsp;堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><p>&emsp;&emsp;通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：</p><ul><li>父节点i的左子节点在位置 ${\displaystyle (2i+1)}$。</li><li>父节点i的右子节点在位置 ${\displaystyle (2i+2)}$。</li><li>子节点i的父节点在位置 ${\displaystyle floor((i-1)/2)}$。</li></ul><p>&emsp;&emsp;在堆的数据结构中，堆中的最大值总是位于根节点(在优先队列中使用堆的话堆中的最小值位于根节点)。堆中定义以下几种操作：</p><ul><li>最大堆调整（Max_Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点。</li><li>创建最大堆（Build_Max_Heap）：将堆所有数据重新排序。</li><li>堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>&emsp;&emsp;基于以上堆相关的操作，我们可以很容易的定义堆排序。例如，假设我们已经读入一系列数据并创建了一个堆，一个最直观的算法就是反复的调用del_max()函数，因为该函数总是能够返回堆中最大的值，然后把它从堆中删除，从而对这一系列返回值的输出就得到了该序列的降序排列。真正的原地堆排序使用了另外一个小技巧。堆排序的过程是：</p><ul><li>创建一个堆 ${\displaystyle H[0..n-1]}$。</li><li>把堆首（最大值）和堆尾互换。</li><li>把堆的尺寸缩小1，并调用shift_down(0),目的是把新的数组顶端数据调整到相应位置。</li><li>重复步骤2，直到堆的尺寸为1。</li></ul><h3 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h3><p>&emsp;&emsp;wikipedia的大数据规模演示：</p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180108145757178?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="heapsort from wikipedia"></div><p></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序递归版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyRecursive</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sonl = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sonr = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> dad = i;</span><br><span class="line"><span class="keyword">if</span> (sonl &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonl]&gt;<span class="built_in">array</span>[i])&#123;<span class="comment">//如果左子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">dad = sonl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sonr &lt;= heapSize &amp;&amp; <span class="built_in">array</span>[sonr]&gt;<span class="built_in">array</span>[dad])&#123;<span class="comment">//如果右子结点大于父结点，则父结点指向子结点</span></span><br><span class="line">dad = sonr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dad != i)&#123;<span class="comment">//如果dad != i则说明父结点不是最大值，交换后递归执行MaxHeapifyRecursive</span></span><br><span class="line">swap(<span class="built_in">array</span>[i], <span class="built_in">array</span>[dad]);</span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, dad, heapSize);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="comment">//构建最大堆 </span></span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//MaxHeapifyIteration(array, i, length - 1);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line">MaxHeapifyRecursive(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//MaxHeapifyIteration(array, 0, i - 1);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 堆排序迭代版</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxHeapifyIteration</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line"><span class="comment">//建立父结点指针和子结点指针</span></span><br><span class="line"><span class="keyword">int</span> dad = left;</span><br><span class="line"><span class="keyword">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (son &lt;= right) &#123;<span class="comment">//若子结点指针在范围内才做比较</span></span><br><span class="line"><span class="keyword">if</span> (son + <span class="number">1</span> &lt;= right &amp;&amp; <span class="built_in">array</span>[son] &lt; <span class="built_in">array</span>[son + <span class="number">1</span>])<span class="comment">//先比较两个子结点的大小，选择最大的</span></span><br><span class="line">son++;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[dad] &gt; <span class="built_in">array</span>[son])<span class="comment">//如果父结点大于子结点代表调整完毕，直接跳出循环</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;<span class="comment">//否则交换父子内容在继续子结点和孙结点的比较</span></span><br><span class="line">swap(<span class="built_in">array</span>[dad], <span class="built_in">array</span>[son]);</span><br><span class="line">dad = son;</span><br><span class="line">son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(T *<span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span> == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">throw</span> invalid_argument(<span class="string">"Array must not be empty"</span>);</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line"><span class="comment">//构建最大堆 </span></span><br><span class="line"><span class="comment">//MaxHeapifyRecursive(array, i, length - 1);</span></span><br><span class="line">MaxHeapifyIteration(<span class="built_in">array</span>, i, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先将第一个元素和已经排好的元素前一位做交换，再从新调整（刚调整的元素之前的元素），直到排序完毕</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">swap(<span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[i]);</span><br><span class="line"><span class="comment">//MaxHeapifyRecursive(array, 0, i - 1);</span></span><br><span class="line">MaxHeapifyIteration(<span class="built_in">array</span>, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul><li>数据结构    数组</li><li>最坏时间复杂度    ${\displaystyle O(n\log n)}$</li><li>最优时间复杂度    ${\displaystyle O(n\log n)}$</li><li>平均时间复杂度    ${\displaystyle O(n\log n)}$ </li><li>空间复杂度    ${\displaystyle O(n)}$ total, ${\displaystyle O(1)}$ auxiliary</li></ul><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>&emsp;&emsp;原地堆排序已经是空间优化版本了，因为它不再需要申请额外的空间。</p><p>&emsp;&emsp;整个算法的过程分为建堆和排序两个过程，首先对现有数组建立最大堆，然后一边提取堆顶的最大值，一边减小堆的尺寸，最后堆尺寸为1时，排序也就完成了。如果大家对整个算法的执行过程不太了解，可以看一下下面这两张图，第一张是建堆的过程示意图，第二张是排序的过程示意图。图片来自：<a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank" rel="noopener">http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/</a></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180108145915265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><p></p><p></p><div align="center"><img src="http://img.blog.csdn.net/20180108145935165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTQ3NTIxMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="bubblesort from wordzzzz"></div><p></p><p><strong><font color="red" size="3" face="仿宋">系列教程持续发布中，欢迎订阅、关注、收藏、评论、点赞哦～～(￣▽￣～)～</font></strong></p><p><strong><font color="red" size="3" face="仿宋">完的汪(∪｡∪)｡｡｡zzz</font></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;转载请注明作者和出处：&lt;a href=&quot;http://blog.csdn.net/u011475210&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/u011475210&lt;/a
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="http://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="堆排序" scheme="http://yoursite.com/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
